<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Harry 的个人空间</title>
  
  
  <link href="https://harryzhang.cn/atom.xml" rel="self"/>
  
  <link href="https://harryzhang.cn/"/>
  <updated>2023-03-25T07:18:37.329Z</updated>
  <id>https://harryzhang.cn/</id>
  
  <author>
    <name>harry zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 连接错误问题解决</title>
    <link href="https://harryzhang.cn/2023/03/25/MySQL-%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://harryzhang.cn/2023/03/25/MySQL-%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2023-03-25T07:15:48.000Z</published>
    <updated>2023-03-25T07:18:37.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><ul><li>操作系统：Ubuntu16.04-server</li><li>MySQL版本：5.7.25</li></ul><h2 id="故障一"><a href="#故障一" class="headerlink" title="故障一"></a>故障一</h2><p>只能通过localhost登录MySQL</p><ol><li>报错如下<blockquote><p>$mysql -h172.16.0.1 -uroot -p123456<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>ERROR 1130 (HY000): Host ‘172.16.0.1’ is not allowed to connect to this MySQL server</p></blockquote></li><li>解决方法<br>此处参考自：<a href="https://stackoverflow.com/questions/19101243/error-1130-hy000-host-is-not-allowed-to-connect-to-this-mysql-server">https://stackoverflow.com/questions/19101243/error-1130-hy000-host-is-not-allowed-to-connect-to-this-mysql-server</a></li></ol><ul><li>首先查看你的root用户允许的主机ip<blockquote><p>mysql&gt;SELECT host FROM mysql.user WHERE User &#x3D; ‘root’;<br>+———–+<br>| host      |<br>+———–+<br>| localhost |<br>+———–+<br>1 row in set (0.24 sec)<br>一般结果中只有localhost或同时有localhost和127.0.0.1；</p></blockquote></li><li>然后如果你想指定允许某个ip可访问可执行如下命令<blockquote><p><code>CREATE USER &#39;root&#39;@&#39;ip_address&#39; IDENTIFIED BY &#39;some_pass&#39;;</code><br><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;ip_address&#39;;</code></p></blockquote></li><li>如果想要允许所有ip执行如下命令<blockquote><p><code>CREATE USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;some_pass&#39;;</code><br><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;;</code></p></blockquote></li><li>上面两种最后都要flush启用更改<blockquote><p><code> FLUSH PRIVILEGES;</code></p></blockquote></li><li>然后在执行一次查询会发现结果多了一行“%”，说明更改成功<br>+———–+<br>| host      |<br>+———–+<br>| %         |<br>+———–+<br>| localhost |<br>+———–+<br>1 row in set (0.24 sec)<br>再次登录如果仍旧失败，请看故障2</li></ul><h2 id="故障二"><a href="#故障二" class="headerlink" title="故障二"></a>故障二</h2><ol><li>报错如下<blockquote><p>$mysql -h172.16.0.1 -uroot -p123456<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>ERROR 2003 (HY000): Can’t connect to MySQL server on ‘172.16.0.1’ (111)</p></blockquote></li><li>解决方法</li></ol><ul><li>查看mysql的配置文件<blockquote><p>$vim &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</p></blockquote></li><li>将下面一行注释或者修改<blockquote><p><code>注释</code><br><code>#bind-address            = 127.0.0.1</code><br><code>修改</code><br><code>bind-address            = 0.0.0.0</code></p></blockquote></li><li>重启mysql启用更改<blockquote><p>$service mysql restart</p></blockquote></li></ul><p>再次尝试登录即可成功登录！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;软件环境&quot;&gt;&lt;a href=&quot;#软件环境&quot; class=&quot;headerlink&quot; title=&quot;软件环境&quot;&gt;&lt;/a&gt;软件环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;操作系统：Ubuntu16.04-server&lt;/li&gt;
&lt;li&gt;MySQL版本：5.7.25&lt;/li&gt;
&lt;/u</summary>
      
    
    
    
    <category term="数据库" scheme="https://harryzhang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://harryzhang.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL ORDER BY 如何实现排序的?</title>
    <link href="https://harryzhang.cn/2023/03/25/MySQL-ORDER-BY-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%9A%84/"/>
    <id>https://harryzhang.cn/2023/03/25/MySQL-ORDER-BY-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%9A%84/</id>
    <published>2023-03-25T07:12:42.000Z</published>
    <updated>2023-03-25T07:18:17.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL是如何进行排序的？"><a href="#MySQL是如何进行排序的？" class="headerlink" title="MySQL是如何进行排序的？"></a>MySQL是如何进行排序的？</h2><p>假设有一个表t结构如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/14151453-c7aec6166a2d984f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-c7aec6166a2d984f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>id为主键，type上建有索引，那么如果要查类型为1，val最小的1000行，那么SQL语句如下：<br><code>SELECT type, val, detail FROM t WHERE type = 1 ORDER BY val LIMIT 1000;</code></p><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>对上述查询执行explain结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/14151453-b14d9da637a8123d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-b14d9da637a8123d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>Using filesort表示需要排序，MySQL会给每个线程分配一块内存用来排序，称为sort buffer，具体的流程如下：</p><ol><li>初始化sort buffer，确定放入type，val，detail三个字段</li><li>从索引type中找到第一个满足type&#x3D;1条件的主键id</li><li>根据id回主键索引查询type和val的值存入sort buffer中，从索引type中继续取下一个id</li><li>重复3的操作直到type不满足条件</li><li>对sort buffer中的数据按照val字段做快速排序</li><li>按照排序结果取前1000行返回</li></ol><p>如果sort buffer够存下所有需要排序的记录，排序在内存中完成，如果内存放不下则需要借助磁盘临时文件进行外部排序。</p><h3 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h3><p>全字段排序过程里只对原表扫描的一遍，剩下的操作都是在sort buffer 和临时文件中执行的，但是如果要查询的字段比较多，sort buffer能存的行数就很少，需要分成多个临时文件进行外部排序，性能比较差，所以在单行数大的情况下这种方式明显不合适。</p><p>MySQL的参数<code>max_length_for_sort_data</code>表示如果单行记录长度超过这个值，就认为单行太大，要换一种排序算法，排序过程中只放要排序的列和主键id，执行流程如下：</p><ol><li>初始化sort buffer，放入val，id字段</li><li>从索引type中找到第一个满足type&#x3D;1条件的主键id</li><li>根据id回主键索引查询val的值，将val和id存入sort buffer中，从索引type中继续取下一个id</li><li>重复3的操作直到type不满足条件</li><li>对sort buffer中的数据按照val字段做快速排序</li><li>按照排序结果依次取1000行，并按照id值回表取出type，val，detail三个字段返回</li></ol><p>可以看到改流程与全字段排序的主要区别在于：</p><ul><li>第1步放入sort buffer的字段不同，rowid排序只放入排序字段和id，全字段排序放入查询的全部字段</li><li>第6步，rowid排序完成后要再回主键索引查一次全部数据返回，全字段排序因为所以要返回的字段内容都在sort buffer中了所以直接返回</li></ul><p><strong>说明</strong>：结果集只是一个逻辑概念，实际上MySQL从排序后的sort buffer中依次取出id，然后到原表查询所有字段的结果不需要在服务端再消耗内存保存，是直接返回的。</p><h3 id="联合索引避免排序"><a href="#联合索引避免排序" class="headerlink" title="联合索引避免排序"></a>联合索引避免排序</h3><p>上面两种方法都是需要建临时表进行排序的，对于MySQL来说都是成本比较高的操作。但并不是所有order by都是需要排序的，因为MySQL索引是天然有序的，如果在type和val字段创建一个联合索引idx_type_val，那么该查询就不需要排序了，这时执行过程就变成了如下流程：</p><ol><li>在索引idx_type_val上找到第一个满足type&#x3D;1条件记录</li><li>根据索引上的主键id回主键索引查询所有字段的值返回，在idx_type_val索引上继续取一下个值</li><li>重复2的操作直到不满足type&#x3D;1或者超过1000行结束。</li></ol><p>使用联合索引，首先不在需要建临时表做排序，其次也不需要扫描出满足type&#x3D;1条件的所有记录，因为索引有序直接扫描前1000行就结束了，大大减少了扫描的行数。</p><h2 id="优先队列排序"><a href="#优先队列排序" class="headerlink" title="优先队列排序"></a>优先队列排序</h2><p>对于MySQL来说并不是所有的排序都是用快速排序实现的，假如之前的查询变成了如下：<br><code>EXPLAIN SELECT type, val FROM t WHERE type = 1 ORDER BY val LIMIT 3;</code><br>假设type&#x3D;1的记录有1万条，只需要去前val最小的前三行。</p><p>对于这种情况，即使sort buffer不能放下1万行记录，会发现MySQL也没有使用到临时文件，这时因为选择了另一种算法：优先队列算法。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><ol><li>对于这10000准备排序的记录，先取前三行构造一个最大堆</li><li>取下一行Next记录跟当前堆顶记录Top比较，如果Next.val &lt; Top.val，就把堆顶记录弹出，将Next记录放入堆</li><li>重复2的操作直到取出所有10000行记录，最后堆中的三个记录就是最小的三个</li></ol><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>快速排序时间复杂度是<code>O(N*logN)</code>，优先队列排序时间复杂度为<code>O((N-K)*logK)</code>，K表示堆的大小，即返回记录的个数，对于该场景下为<code>(N-3)*log3</code>，基本可以看做线性时间复杂度，如果是limit 1的时候就相当于求最小值，该算法就是线性时间复杂度。<br>其次sort buffer中只需要维护堆，内存的消耗也大大减少，空间复杂度为<code>O(K)</code>。</p><h2 id="order-by-rand"><a href="#order-by-rand" class="headerlink" title="order by rand()"></a>order by rand()</h2><p>如果需要随机选1个数，SQL语句可能如下：<br><code>SELECT * FROM t ORDER BY RAND() LIMIT 1</code><br>需要注意到是这种方式会建临时表进行排序，临时表除了查询字段会多加一个排序字段存放rand()生成的值，即对每一行记录使用rand()函数生成一个随机数，然后根据这个数来排序。</p><p>这种写法的成本是比较高的，所以建议尽量避免这种写法，建议先随机一个0~N-1的值（N表示表总行数），然后去查数据库的某行，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rand1</span>():</span><br><span class="line">    N = mysql.query(<span class="string">&quot;select count(*) from t&quot;</span>)</span><br><span class="line">    res = mysql.query(<span class="string">&quot;select * from t limit N, 1&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【极客时间】<a href="https://time.geekbang.org/column/article/73479">MySQL实战45讲：16、17</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL是如何进行排序的？&quot;&gt;&lt;a href=&quot;#MySQL是如何进行排序的？&quot; class=&quot;headerlink&quot; title=&quot;MySQL是如何进行排序的？&quot;&gt;&lt;/a&gt;MySQL是如何进行排序的？&lt;/h2&gt;&lt;p&gt;假设有一个表t结构如下图所示：&lt;br&gt;&lt;im</summary>
      
    
    
    
    <category term="数据库" scheme="https://harryzhang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://harryzhang.cn/tags/MySQL/"/>
    
    <category term="排序" scheme="https://harryzhang.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 脏页刷盘</title>
    <link href="https://harryzhang.cn/2023/03/25/MySQL-%E8%84%8F%E9%A1%B5%E5%88%B7%E7%9B%98/"/>
    <id>https://harryzhang.cn/2023/03/25/MySQL-%E8%84%8F%E9%A1%B5%E5%88%B7%E7%9B%98/</id>
    <published>2023-03-25T07:12:03.000Z</published>
    <updated>2023-03-25T07:18:02.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是脏页？"><a href="#什么是脏页？" class="headerlink" title="什么是脏页？"></a>什么是脏页？</h2><p>InnoDB在处理更新语句时，先写内存再写redo log，并不会立即将数据页的更新落地到磁盘（WAL机制），这就会产生升内存数据页和磁盘数据页的数据不一致的情况，这种数据不一致的数据页称为<strong>脏页</strong>，当脏页写入到磁盘（这个操作称为flush）后，数据一致后称为干净页。</p><h2 id="什么时候会flush脏页？"><a href="#什么时候会flush脏页？" class="headerlink" title="什么时候会flush脏页？"></a>什么时候会flush脏页？</h2><ol><li><p>redo log写满<br>redo log大小是固定的，写完后会循环覆盖写入。当有新的内容要写入时，系统必须停止所有的更新操作，将checkpoint向前推进到新的位置，但是在推进之前必须将覆盖部分的所有脏页都flush到磁盘上。<br><img src="https://upload-images.jianshu.io/upload_images/14151453-05061327e5e6e8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-05061327e5e6e8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></li><li><p>内存不足需要淘汰数据页<br>当系统内存不足，又有新的数据页要更新，就需要淘汰一些数据页，如果淘汰的是脏页，就需要flush到磁盘（如果是干净页就直接释放出来复用）。</p></li><li><p>系统空闲的时候后台会定期flush适量的脏页到磁盘</p></li><li><p>MySQL正常关闭（shut down）时会把所有脏页都flush到磁盘</p></li></ol><h2 id="flush对系统性能的影响"><a href="#flush对系统性能的影响" class="headerlink" title="flush对系统性能的影响"></a>flush对系统性能的影响</h2><p>第3种是系统空闲不会有性能问题，第4种是要关闭了不考虑性能问题。第1和2的情况flush脏页会产生系统性能问题。</p><h3 id="redo-log写满"><a href="#redo-log写满" class="headerlink" title="redo log写满"></a>redo log写满</h3><p>此时整个系统不能再更新了，更新数会降为0，所以这种情况要尽量避免。</p><h3 id="内存不够"><a href="#内存不够" class="headerlink" title="内存不够"></a>内存不够</h3><p>InnoDB缓冲池（buffer pool）中的内存页有三种状态：</p><ul><li>未使用的空闲内存</li><li>使用了为脏页</li><li>使用了未干净页</li></ul><p>当一个SQL语句要淘汰的脏页数量太多，会导致语句执行的响应时间显著边长。</p><h2 id="flush速度控制策略"><a href="#flush速度控制策略" class="headerlink" title="flush速度控制策略"></a>flush速度控制策略</h2><p>InnoDB为了避免出现上述两种情况，需要有控制脏页比例的策略，控制的主要参考因素就是：脏页比例和redo log写盘速度。</p><h4 id="磁盘的IO能力"><a href="#磁盘的IO能力" class="headerlink" title="磁盘的IO能力"></a>磁盘的IO能力</h4><p>需要告诉InnoDB的磁盘读写能力（IOPS）让引擎全力flush脏页，磁盘的IOPS可以通过fio工具测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest </span><br></pre></td></tr></table></figure><p>如果<code>innodb_io_capacity</code>参数设置的不合理，比如远远低于磁盘实际的IOPS，InnoDB会认为IO性能低，刷脏页速度会很慢，甚至低于脏页的生成速度，导致脏页累计影响查询和更新性能。</p><h4 id="速度计算流程"><a href="#速度计算流程" class="headerlink" title="速度计算流程"></a>速度计算流程</h4><p>为了兼顾正常的业务请求，InnoDB引擎控制按照磁盘IOPS的百分比来刷脏页，具体流程如下：</p><ol><li>参数<code>innodb_max_dirty_pages_pct</code>控制脏页比例上限，默认75%。InnoDB根据当前脏页比例（设为M），计算出一个0~100的数字F1(M)，伪代码如下<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">F1</span>(<span class="params">M</span>):</span><br><span class="line">    <span class="keyword">if</span> M &gt;= innodb_max_dirty_pages_pct:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> * M / innodb_max_dirty_pages_pct</span><br></pre></td></tr></table></figure></li><li>InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的需要之间的差值设为N，根据N计算出一个0~100的数值F2(N)，N越大F2(N)越大</li><li>根据前两步计算出的两个值取较大值记为R，然后InnoDB会根据<code>innodb_io_capacity</code>设置的磁盘IOPS能力乘以R%来控制刷脏页的速度</li></ol><p>脏页比例计算:<br><code>Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total</code><br>SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_dirty&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_total&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@a</span><span class="operator">/</span><span class="variable">@b</span>;</span><br></pre></td></tr></table></figure><h2 id="连锁flush"><a href="#连锁flush" class="headerlink" title="连锁flush"></a>连锁flush</h2><p>在准备flush一个脏页时，如果相邻的数据页也是脏页，会把这个脏页一起flush，而且对这个新的脏页还可能有相邻的脏页导致连锁flush。<br>InnoDB使用<code>innodb_flush_neighbors</code>参数控制这个行为，值为1会产生上述连锁flush的情况，值为0则不会找相邻页。</p><p>找相邻页flush的机制虽然可以减少很多随机IO，但会增加一次flush时间，导致flush时的SQL语句执行时间变慢。</p><p>现在基本都使用的SSD这种IOPS比较高的硬盘，建议将<code>innodb_flush_neighbors</code>参数设为0，提高flush的速度。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>flush会占用IO资源影响了正在执行的SQL语句，本来正常情况下执行很快的一条语句，突然耗时大大增加，造成业务抖动。要尽量避免这种情况，需要合理的设置<code>innodb_io_capacity</code>的值，并且多关注脏页比例，不要让脏页比例经常接近75%。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【极客时间】<a href="https://time.geekbang.org/column/article/71806">MySQL实战45讲：第12节</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是脏页？&quot;&gt;&lt;a href=&quot;#什么是脏页？&quot; class=&quot;headerlink&quot; title=&quot;什么是脏页？&quot;&gt;&lt;/a&gt;什么是脏页？&lt;/h2&gt;&lt;p&gt;InnoDB在处理更新语句时，先写内存再写redo log，并不会立即将数据页的更新落地到磁盘（WAL机制）</summary>
      
    
    
    
    <category term="数据库" scheme="https://harryzhang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://harryzhang.cn/tags/MySQL/"/>
    
    <category term="脏页" scheme="https://harryzhang.cn/tags/%E8%84%8F%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 索引原理详解</title>
    <link href="https://harryzhang.cn/2023/03/25/MySQL-%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://harryzhang.cn/2023/03/25/MySQL-%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-03-25T07:11:48.000Z</published>
    <updated>2023-03-25T07:17:49.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引的底层实现"><a href="#索引的底层实现" class="headerlink" title="索引的底层实现"></a>索引的底层实现</h2><p>InnoDB存储引擎数据结构使用B+树</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+数据的基本结构如下图<br><img src="https://upload-images.jianshu.io/upload_images/14151453-8fa2fd1bbc4b7f13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-8fa2fd1bbc4b7f13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="为什么选用B-树"><a href="#为什么选用B-树" class="headerlink" title="为什么选用B+树"></a>为什么选用B+树</h3><p>MySQL为什么要选B+树作为存储结构呢，与B树相比有哪些优点？</p><p><strong>1. 减少磁盘访问，提高查询效率</strong><br>B+树非叶子节点上是不存数据的，仅存键值，而B树节点中不仅存储键值，也会存储数据。因为数据页的大小是固定的（InnoDB中页的默认大小是16KB），如果不存储数据，那么就会存储更多的键值，相应的树的阶数N就会更大，树高就会越低，这样查询数据进行磁盘IO的次数就会大大减少，数据查询的效率也会更快。<br>以InnoDB的一个整数字段索引为例，阶数N大概是1200，这棵树高是4的时候，就可以存1200^3（约17亿）个值，因为根节点总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。</p><p><strong>2. 提高范围查找效率</strong><br>因为B+树的所有数据均存储在叶子节点，而且是有序的，使得B+树范围查找，排序查找，分组查找以及去重查找变的简单，而B树的数据分散在各个节点上，实现起来比较困难。</p><h2 id="普通索引和唯一索引如何选择？"><a href="#普通索引和唯一索引如何选择？" class="headerlink" title="普通索引和唯一索引如何选择？"></a>普通索引和唯一索引如何选择？</h2><p>普通索引不需要保证一条记录的唯一性，查询和更新操作都不需要保证数据页已经读到内存中，相反唯一索引为了保证唯一性，更新时必须要保证数据页在内存中，需要检查是否满足唯一性</p><h3 id="查询操作的区别"><a href="#查询操作的区别" class="headerlink" title="查询操作的区别"></a>查询操作的区别</h3><ul><li>普通索引：查找到满足条件的第一个记录后，需要查找下一条记录，直到碰到不满足的记录</li><li>唯一索引：查找满足条件的第一个记录就会停止检索</li></ul><p>因为是innoDB的读写操作是以数据页为单位的，通常情况目标记录的下一个记录也会在内存中，对于普通索引来说，只是多了一次判断操作，这个CPU成本可以忽略不计，如果是目标记录恰好在某页的最后，下一条记录需要从磁盘中读取，这个I\O成本会大一些，但是这种情况出现的概率很低。<br>所以对于查询操作来说，唯一索引更快，但是性能差异非常小。</p><h3 id="更新操作的区别"><a href="#更新操作的区别" class="headerlink" title="更新操作的区别"></a>更新操作的区别</h3><h4 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h4><p>当更新一个数据页时，如果数据页在内存中就直接更新，如果数据页还没有在内存中，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存再change buffer中，这样就不用从磁盘中读入数据了，大大提高了更新操作的性能。InnoDB会在下次访问这个数据页的时候将数据页读入内存然后执行change buffer中与这个页有关的操作，保证数据的最终一致性。</p><p><strong>change buffer</strong>是可持久化的数据，也会被写到磁盘中，写入change buffer操作也会记录在redo log中。</p><p><strong>merge</strong>：将change buffer中的操作应用到原数据页的过程称为merge，merge除了在查询操作时会触发，系统后台有线程会定期merge，数据库正常关闭（shut down）时也会执行merge操作。</p><p><strong>优点</strong>：</p><ul><li>减少读磁盘，明显提升更新操作的速度</li><li>数据读入内存会占用buffer pool，可以减少内存使用，提高内存利用率</li></ul><p><strong>使用条件</strong>：</p><ul><li>唯一索引的更新操作需要判断唯一性约束，必须将数据读到内存中才能判断，因此唯一索引的更换不能使用</li><li>只有普通索引可使用</li><li>change buffer使用的是buffer pool中的内存，因此不能过大。</li></ul><p><strong>应用场景</strong>：</p><ul><li>写多读少的业务，如账单、日志类的系统</li></ul><p>如果业务更新后马上会做查询，那么merge的操作会被触发，这样随机访问磁盘的次数不会减少还增加了change buffer的维护代价，反而起到了反作用。</p><h3 id="索引的选择"><a href="#索引的选择" class="headerlink" title="索引的选择"></a>索引的选择</h3><ul><li>在业务保证唯一性的前提下，尽量选择普通索引。</li><li>如果更新后面马上伴随这查询，应该关闭change buffer</li></ul><h3 id="change-buffer和redo-log"><a href="#change-buffer和redo-log" class="headerlink" title="change buffer和redo log"></a>change buffer和redo log</h3><p>使用change buffer的更新语句执行的过程：</p><ol><li>如果数据页在内存中，直接更新内存</li><li>如果数据页不在内存中，在change buffer中记录更新操作</li><li>将1或2的动作记录在redo log中</li></ol><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>redo log主要是节省随机写磁盘的IO消耗（转为顺序写）</li><li>change buffer主要节省随机读磁盘的IO消耗</li></ul><h2 id="为什么MySQL优化器会选错索引"><a href="#为什么MySQL优化器会选错索引" class="headerlink" title="为什么MySQL优化器会选错索引"></a>为什么MySQL优化器会选错索引</h2><p>优化器选择索引的目的是找一个最优的方案，并用最小的代价去执行语句，扫描行数是影响执行速度的代价之一，扫描行数越少，意味着访问磁盘数据越少，消耗的CPU资源也越少（扫描行数并不是唯一判断标准，还会结合是否使用临时表、是否排序等因素进行综合判断）。<br>在不涉及临时表和排序的情况下，选错索引肯定是在判断扫描行数的时候出错了</p><h3 id="扫描行数如何计算的"><a href="#扫描行数如何计算的" class="headerlink" title="扫描行数如何计算的"></a>扫描行数如何计算的</h3><p>执行语句前MySQL并不能精确的知道这个条件的记录有多少条，只能根据统计信息来估算扫描记录数。</p><h4 id="索引的基数"><a href="#索引的基数" class="headerlink" title="索引的基数"></a>索引的基数</h4><p>一个索引上不同的值越多，这个索引的区分度就越好，而一个索引上不同的值的个数称为基数，基数越大说明区分度越好。</p><h4 id="基数的计算"><a href="#基数的计算" class="headerlink" title="基数的计算"></a>基数的计算</h4><p>MySQL使用采样统计（选择采样而不是全表扫描是为了节省计算成本）：</p><ul><li>InnoDB默认会选择N个数据页，统计这些页面上的不同值得到一个平均值，然后乘以索引的页面数得到基数。</li><li>数据表持续更新的过程中，当变更的数据行占比超过1&#x2F;M的时候，会自动触发做一次索引统计</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>当发现explain的结果预估的rows值跟实际差距比较大可以使用<code>analyze table</code>命令解决</li><li>使用<code>force index()</code>强行选择某个索引</li><li>优化SQL语句引导MySQL选择更合适的索引</li><li>新建一个更合适的索引</li></ol><h2 id="字符串前缀索引"><a href="#字符串前缀索引" class="headerlink" title="字符串前缀索引"></a>字符串前缀索引</h2><p>给一个字符串字段上加索引有如下两种选择：</p><ol><li>整个字符串加索引：<code>alter table user add index idx_email(email);</code></li><li>前六个字符索引：<code>alter table user add index idx_email(email(6));</code></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>前缀索引的索引结构只保存了前n个字符，索引占用的空间会更小</li><li>使用前缀索引定义合适的长度，即可以节省空间，又不会增加太多查询成本</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>增加了查询额外扫描次数，需要查找到所有前缀匹配的记录，每条记录都要回表查询完整数据进行判断。</li><li>使用前缀索引会破坏覆盖索引（查询字段上都建了索引，不需要回表）对查询性能的优化</li></ul><h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><ul><li>倒序存储加前缀索引：当字符串的前n为重复度高的情况</li><li>hash字段：添加一个hash字段，保存字符串字段的校验码（如crc32）</li></ul><p>这两种方法都不支持范围查找，都会产生额外的cpu计算消耗，hash字段的查询性能更稳定，crc32计算的值冲突概率非常小。</p><h2 id="独立索引"><a href="#独立索引" class="headerlink" title="独立索引"></a>独立索引</h2><p>必须是独立的索引字段才能用到索引，在索引上使用函数、表达式都会导致不能使用索引树搜索，从而导致慢查询。</p><h3 id="CASE1：在索引上使用函数"><a href="#CASE1：在索引上使用函数" class="headerlink" title="CASE1：在索引上使用函数"></a>CASE1：在索引上使用函数</h3><p>建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tradelog` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `operator` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`),</span><br><span class="line">  KEY `t_modified` (`t_modified`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>如果要查询几年内某个月的交易总数，查询语句可能如下：<br><code>select count(*) from tradelog where month(t_modified)=7;</code><br>索引上使用函数可能会导致其失去有序性，从而不能使用树搜索（不代表使用索引，可以在索引上遍历），即使没有改变索引的有序性优化器还是不能用索引快速查找，所以要避免这种写法。</p><h3 id="CASE2：隐式类型转换"><a href="#CASE2：隐式类型转换" class="headerlink" title="CASE2：隐式类型转换"></a>CASE2：隐式类型转换</h3><p>假如有如下语句：<br><code>select * from tradelog where tradeid=110717;</code><br>tradeid字段是varchar类型，如果要和数字作比较会将其转换为数字类型，对于优化器来说上述语句相当于:<br><code>select * from tradelog where  CAST(tradid AS signed int) = 110717;</code><br>可以看到隐式的在索引字段上使用了函数，从而导致不能使用树搜索。</p><h3 id="CASE3：隐式编码转换"><a href="#CASE3：隐式编码转换" class="headerlink" title="CASE3：隐式编码转换"></a>CASE3：隐式编码转换</h3><p>如果在做连表查询是，驱动表和被驱动表的字段编码类型不一致，会导致索引不能使用树搜索。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【极客时间】<a href="https://time.geekbang.org/column/article/70848">MySQL实战45讲</a>：09、10、11节</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;索引的底层实现&quot;&gt;&lt;a href=&quot;#索引的底层实现&quot; class=&quot;headerlink&quot; title=&quot;索引的底层实现&quot;&gt;&lt;/a&gt;索引的底层实现&lt;/h2&gt;&lt;p&gt;InnoDB存储引擎数据结构使用B+树&lt;/p&gt;
&lt;h3 id=&quot;B-树&quot;&gt;&lt;a href=&quot;#B-树</summary>
      
    
    
    
    <category term="数据库" scheme="https://harryzhang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://harryzhang.cn/tags/MySQL/"/>
    
    <category term="索引" scheme="https://harryzhang.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 中一条 SQL 语句是如何执行的？</title>
    <link href="https://harryzhang.cn/2023/03/25/MySQL-%E4%B8%AD%E4%B8%80%E6%9D%A1-SQL-%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/"/>
    <id>https://harryzhang.cn/2023/03/25/MySQL-%E4%B8%AD%E4%B8%80%E6%9D%A1-SQL-%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/</id>
    <published>2023-03-25T07:11:22.000Z</published>
    <updated>2023-03-25T07:18:09.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL语句执行的经过"><a href="#SQL语句执行的经过" class="headerlink" title="SQL语句执行的经过"></a>SQL语句执行的经过</h2><p>从用户发起请求，到服务接口调用MySQL驱动，MySQL服务器执行完SQL语句返回结果中间发生了什么？首先放一张图来看整个过程使用到的各个组件，然后再对各个过程进行分析。</p><p><img src="https://upload-images.jianshu.io/upload_images/14151453-bfe61aa3f5d1fcad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-bfe61aa3f5d1fcad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SQL语句执行链路"></p><h3 id="1-连接过程"><a href="#1-连接过程" class="headerlink" title="1. 连接过程"></a>1. 连接过程</h3><p>以Openresty服务器为例，Openresty是多进程+I&#x2F;O多路复用结构（Nginx的I&#x2F;O模型），可以支撑高的并发，一个Worker就是一个进程，一个进程可以处理多条请求。<br>我们知道当需要执行SQL语句时需要先于MySQL服务器建立连接，如果每个一个请求都建立一个连接，使用完再关闭连接，如果频繁的创建和销毁连接显然是不合理的，浪费系统资源造成性能下降，这时连接池就出现了。</p><h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><p>连接池会维护多个（长）连接，一个SQL语句执行时分配一个连接，使用完不会销毁连接，而是放到空闲队列中等待下次使用，这样可以在高并发的场景大大减少创建、销毁连接带来的性能问题。</p><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>类似Web服务器通过连接池维护与数据库服务器的连接，MySQL的连接器提供了同样的功能，也维护了一个连接池，不同的是MySQL连接器同时还有权限验证的功能。</p><ul><li>修改密码不会影响已经建立的链接。</li><li>连接完成后如果没有操作，改连接就会处于空闲状态，可以使用<code>show processlist</code>命令查看，如果长时间没有操作连接器会在到达超时时间后断开它。</li></ul><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>长连接是客户端持续有请求，使用的是同一个连接，建立连接的过程通常是比较慢的，建议尽量使用长连接。但是长连接累计较多时可能会导致内存过大（内存管理在连接对象里），比系统强行kill，引起MySQL异常重启，可以使用以下两种方法解决：</p><ul><li>定期断开长连接。</li><li>如果是MySQL5.7及以上的版本，可以在每次执行一个比较大的操作后执行<code>mysql_reset_connection</code>重新初始化连接资源（不会重新建立连接）。</li></ul><h3 id="2-执行过程"><a href="#2-执行过程" class="headerlink" title="2. 执行过程"></a>2. 执行过程</h3><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>如果是查询语句，而且开启了查询缓存，连接器拿到一个查询请求后，会先查看查询缓存是否有（之前执行过这条语句）。缓存key为sql语句，value是查询结果。</p><ul><li>不建议开启查询缓存，除非是基本不会变的数据表。因为只要对表有更新，该表上的所有查询缓存都会清空，导致查询命中率很低。</li></ul><h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>分析器的功能就是对SQL语句做词法分析和语法分析，解析这条语句要干什么，语法错误会返回错误提醒。</p><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>优化器是在表中有多个索引的时候决定使用哪个索引，或者有多表关联（join）的时候决定各个表的连接顺序。</p><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>通过分析器知道了要做什么，优化器知道了改怎么做，执行器就是真正的语句执行阶段。开始执行的时候要先判断对表是否有权限（在优化器之前也会做预检查）。执行器会调用存储引擎提供的接口进行读写操作。</p><h3 id="3-更新语句执行过程"><a href="#3-更新语句执行过程" class="headerlink" title="3. 更新语句执行过程"></a>3. 更新语句执行过程</h3><p>查询语句是只读的，比较简单，经过一系列组件最终查询到结果返回。但是更新语句就相对复杂一些，涉及到两个日志模块：redo log和binlog。</p><h4 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h4><p>如果每次更新都要刷盘，整个过程磁盘IO成本、查询成本都比较高，为了提升更新效率，InnoDB引擎提供了redo log（顺序写入速度很快）。</p><p><strong>WAL（Write-Ahead Logging）</strong>：先写日志，再写磁盘。当有一条记录需要更新的时候，InnoDB引擎会先将记录写入redo log并更新内存，这时候更新就算完成了，再需要的时候再将这个操作更新到磁盘里。</p><p><strong>日志结构</strong>：redo log大小是固定的，比如配置一组4个文件，每个文件1G，<br>就可以记录总共4G的记录。从头开始写，写完后又回到开头循环写入。</p><p><strong>crash-safe</strong>：故障安全，redo log除了能提高更新操作的效率，同时还保证了故障安全，在数据库异常时不会导致数据丢失。</p><h4 id="binlog（归档日志）"><a href="#binlog（归档日志）" class="headerlink" title="binlog（归档日志）"></a>binlog（归档日志）</h4><p>MySQL最开始没有InnoDB引擎，binlog日志只用于归档和复制，只依靠binlog没有crash-safe能力。</p><ul><li>redo log是InnoDB引擎独有的，属于存储层；binlog是MySQL提供的，属于server层</li><li>redo log是物理日志，记录在某个数据页上做了什么修改；binlog是逻辑日志，记录SQL语句的原始逻辑</li><li>redo log是循环写的，空间固定，用完会从头开始写；binlog是追加写的，一定大小后切换到下一个文件，不会覆盖</li></ul><h4 id="Buffer-Pool缓冲池"><a href="#Buffer-Pool缓冲池" class="headerlink" title="Buffer Pool缓冲池"></a>Buffer Pool缓冲池</h4><p>InnoDB重要的内存结构，数据的操作都是在Buffer Pool中操作的，如果数据不在缓冲内存中，会先从磁盘中读取到数据页到缓冲池，然后再执行相关操作。</p><h4 id="update执行过程"><a href="#update执行过程" class="headerlink" title="update执行过程"></a>update执行过程</h4><p><code>update T set k = k + 2 where id = &#39;1&#39; limit 1</code></p><ol><li>执行器调引擎读接口找id&#x3D;2这一行，如果数据页本来在内存就直接返回，否则先从磁盘load到内存中再返回。</li><li>然后执行器将k值加上2，得到新的一行数据，在调用引擎的写接口写入这行新数据。</li><li>引擎将这行数据更新到内存中，同时将更新操作记录到redo log，此时redo log处于prepare状态，然后告知执行器执行完成，可以提交事务。</li><li>执行器生成这个操作的binlog并写入磁盘。</li><li>执行器调用存储引擎的事务提交接口，引擎把刚写入redo log改为commit状态，更新完成。</li></ol><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>保证了crash-safe能力，如果不使用两阶段提交，使用binlog恢复数据库时会导致与原数据库状态不一致。</p><p>假如不使用两阶段提交，在写日志时机器发生故障：</p><ol><li>redo log写入（比如k，本来为0，执行更新后<br>k &#x3D; 2）后发生故障，binlog未写入。由于redo log写完之后即使系统崩溃，也会能将数据恢复，恢复后这一行数据k&#x3D;2。但是binlog没写完就crash，binlog没有记录这条语句，如果使用binlog来恢复时会少一个事务，恢复后的k&#x3D;0，原数据库k&#x3D;2。</li><li>binlog写入后发生故障，redo log未写入。redo log为写入，崩溃后这个事务无效，k&#x3D;0。但是binlog已经记录了更新语句，之后恢复时会多出一个事务，恢复后k&#x3D;2，原数据库k&#x3D;0。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>MySQL连接器使用连接池维护连接，并进行检查权限，接收一个SQL语句</li><li>然后通过分析器、优化器知道如何执行SQL语句</li><li>通过执行器与存储引擎交互，完成数据的读写。</li><li>数据更新同时会写入两个重要的日志文件：redo log和binlog，并通过两阶段提交保证了crash-safe能力。</li></ol><p><strong>参考资料</strong><br><a href="https://mp.weixin.qq.com/s/J_ng048H4eHBm_4VBjFiWw">【码农有道】详解一条 SQL 的执行过程</a><br><a href="https://time.geekbang.org/column/article/68319">【极客时间】MySQL实战45讲01、02讲</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL语句执行的经过&quot;&gt;&lt;a href=&quot;#SQL语句执行的经过&quot; class=&quot;headerlink&quot; title=&quot;SQL语句执行的经过&quot;&gt;&lt;/a&gt;SQL语句执行的经过&lt;/h2&gt;&lt;p&gt;从用户发起请求，到服务接口调用MySQL驱动，MySQL服务器执行完SQL语</summary>
      
    
    
    
    <category term="数据库" scheme="https://harryzhang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://harryzhang.cn/tags/MySQL/"/>
    
    <category term="SQL语句" scheme="https://harryzhang.cn/tags/SQL%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 和 NoSQL基础知识概述</title>
    <link href="https://harryzhang.cn/2023/03/25/MySQL-%E5%92%8C-NoSQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0/"/>
    <id>https://harryzhang.cn/2023/03/25/MySQL-%E5%92%8C-NoSQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0/</id>
    <published>2023-03-25T07:10:58.000Z</published>
    <updated>2023-03-25T07:18:51.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li><p>B+Tree</p><ul><li><p>平衡树，查找树，所有叶子节点位于同一层</p></li><li><p>进行查找时首先再根节点进行二分查找，找到一个key所在的指针，然后递归的在指针所指向的节点进行查找，直到查到叶子节点，然后在叶子节点二分查找，找出key所对应的data</p></li><li><p>插入删除操作会破坏数的平衡性，需要进行分裂、合并、旋转等操作来维护平衡性</p></li><li><p>与红黑树相比</p><ul><li>B+树的高度更低</li><li>更适合磁盘访问，节点大小设置和磁盘页大小一致</li><li>磁盘预读，减少I&#x2F;O</li></ul></li></ul></li><li><p>MySQL索引</p><ul><li><p>索引类型</p><ul><li><p>B+Tree索引</p><ul><li><p>大多数MySQL存储引擎的默认索引类型</p></li><li><p>有序性保证查找、排序、分组效率更高</p></li><li><p>可以指定多个列为索引列，多个索引列共同组成键</p></li><li><p>适用于全键值、键值范围和键前缀（只支持最左前缀）查找</p></li><li><p>主索引和辅助索引</p><ul><li>主索引的叶子节点data域记录着完整的数据记录，称为聚簇索引，一个表只能有一个聚簇索引</li><li>辅助索引的叶子节点域记录着主键的值，因此使用辅助索引要先查到主键的值，再到主索引查数据</li></ul></li></ul></li><li><p>哈希索引</p><ul><li><p>O(1)查找，但失去了有序性</p><ul><li>无法用于排序和分组</li><li>只支持精确查找，不能用于部分查找和范围查找</li></ul></li><li><p>InnoDB自适应哈希索引，当某个索引值被使用的非常频繁时，会在B+Tree索引只上再建一个哈希索引，以实现快速的哈希查找</p></li></ul></li><li><p>全文索引</p><ul><li>查找文本中的关键字而不是等值比较</li></ul></li><li><p>空间数据索引</p></li></ul></li><li><p>索引优化</p><ul><li><p>独立的列：索引列不能是表达式的一部分，也不能是函数的参数，否则不会使用索引</p></li><li><p>多列索引：需要使用多个列作为条件查询时，使用多列索引比使用单列索引性能更好</p></li><li><p>索引列的顺序：选择性强的索引列放在前面</p></li><li><p>前缀索引：对于BLOB、TEXT、VARCHAR类型的数据，必须使用前缀索引，只索引开始的部分字符</p></li><li><p>覆盖索引：索引包含所有需要查询的字段的值</p><ul><li>索引通常远小于数据行的大小，只读取索引能减少数据访问量</li><li>一些存储引擎（MyISAM）在内存中只缓存索引，只访问索引可以不使用系统调用</li><li>对于InnoDB引擎，若辅助索引能够覆盖查询，则无需访问主索引</li></ul></li></ul></li><li><p>优点</p><ul><li>大大减少需要扫描的数据行数</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表</li><li>将随机I&#x2F;O变为顺序I&#x2F;O</li></ul></li><li><p>使用条件</p><ul><li><p>对于非常小的表大部分情况下全表扫描更高效（如用来保存配置信息的表）</p></li><li><p>对于中型大型的表，使用索引的效果非常明显</p></li><li><p>对于特大型的表，建立和维护索引的代价会随之增长</p><ul><li>分区</li><li>分库分表</li></ul></li></ul></li></ul></li></ul><h3 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h3><ul><li><p>使用Explain进行分析</p><ul><li>Select_type：查询类型，如简单查询，联合查询、子查询</li><li>key：使用的索引</li><li>Rows：扫描的行数</li></ul></li><li><p>优化数据访问</p><ul><li><p>减少请求的数据量</p><ul><li>只返回必要的列，拒绝无脑select * from…</li><li>只返回必要的行，使用limit限制返回的数据数量</li><li>缓存重复查询的数据</li></ul></li><li><p>减少扫描的行数</p><ul><li>用索引覆盖查询</li></ul></li></ul></li><li><p>重构查询方式</p><ul><li>切分大查询</li><li>分解大连接查询（将一个大连接查询分解成对每个表进行</li></ul></li></ul><p>一次单表查询，然后在应用程序中进行关联）<br>      - 让缓存更高效，分解后多个查询，即使一个表发生改变，其他表的缓存仍然可以使用<br>      - 单表查询的结果可能被其他查询用到，减少冗余记录的查询<br>      - 减少锁竞争<br>      - 应用层进行连接，更容易对数据库进行拆分，从而更容易做到高性能和可伸缩<br>      - 查询本身效率提升</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><ul><li><p>InnoDB</p><ul><li>MySQL默认的事务型存储引擎</li><li>实现了四个标准的事务隔离级别</li><li>主索引是聚簇索引，在索引中保存了数据，对查询性能很大提升</li><li>内部做了优化，比如磁盘读取数据时采用可预测性读，自动创建自适应哈希索引，能加快插入操作的插入缓冲区</li><li>支持真正的在线热备份</li></ul></li><li><p>MyISAM</p><ul><li>设计简单，提供了很多特性，如压缩表、空间数据索引</li><li>不支持事务、不支持行级锁</li></ul></li><li><p>如果不是特殊特性需要，建议都使用InnoDB引擎</p></li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li><p>主从复制</p><ul><li><p>binlog线程：负责将主服务器上的数据更改写入二进制日志中</p></li><li><p>I&#x2F;O线程：负责从主服务器上读取binlog，并写入从服务器的中继日志（Relay Log）</p></li><li><p>SQL线程：负责读取中继日志，解析出SQL更改并在从服务器中重放（Replay）</p></li><li><p>主从复制不是强一致性，只能保证最终一致性</p></li><li><p>复制模式</p><ul><li><p>异步模式</p><ul><li>主节点不会主动push binlog，同步不及时</li></ul></li><li><p>半同步复制</p><ul><li>主节点只需要接收到一台从节点的返回信息就会commit，否则会等到超时然后切换成异步模式再提交，不保证从节点写入db。减少了数据延迟，响应时间会变长</li></ul></li><li><p>全同步复制</p><ul><li>全同步模式是主节点和从节点全部执行了commit并确认才会想客户端返回成功。响应时间最长</li></ul></li></ul></li></ul></li><li><p>读写分离</p><ul><li><p>优点</p><ul><li>主从服务器负责各自的读写，减少锁竞争</li><li>增加冗余，提高可用性</li></ul></li><li><p>中间件</p><ul><li>MySQL-Proxy</li><li>MySQL-Router</li><li>MyCat</li></ul></li></ul></li></ul><h3 id="binlog的业务应用"><a href="#binlog的业务应用" class="headerlink" title="binlog的业务应用"></a>binlog的业务应用</h3><ul><li><p>数据异构</p><ul><li>随着业务发展，一些表各个业务都关注，但是对字段的使用场景不同。如订单表，可以通过binlog解析成用户维度的订单信息供用户中心查询、商户维度的订单表供运营管理、审计等</li></ul></li><li><p>缓存更新</p><ul><li>客户端更新了数据，缓存还未过期，可以通过binlog获取数据变更，并同步到缓存中</li></ul></li><li><p>任务分发</p><ul><li>多个系统依赖同一块重要数据，当数据发生变化需要通知其他系统。可以由调度系统订阅binlog进行相应的任务分发、消息发送</li></ul></li></ul><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><h3 id="not-only-sql"><a href="#not-only-sql" class="headerlink" title="not only sql"></a>not only sql</h3><h3 id="KV型"><a href="#KV型" class="headerlink" title="KV型"></a>KV型</h3><ul><li>Redis</li></ul><h3 id="搜索型"><a href="#搜索型" class="headerlink" title="搜索型"></a>搜索型</h3><ul><li>ElasticSearch</li></ul><h3 id="列式"><a href="#列式" class="headerlink" title="列式"></a>列式</h3><ul><li><p>HBase</p><ul><li>海量数据存储，数据持久化</li><li>读写性能好</li><li>横向扩展再关系型数据库中最方便的之一</li><li>本身没有单点故障，高可用</li><li>可存储结构化或半结构化的数据</li><li>比较重，依赖Hadoop组件，运维成本高</li><li>KV式，条件查询弱</li><li>不支持分页查询</li></ul></li></ul><h3 id="文档型"><a href="#文档型" class="headerlink" title="文档型"></a>文档型</h3><ul><li>MongoDB</li></ul><p><a href="https://github.com/CyC2018/CS-Notes">【参考资料】GitHub-CyC2018&#x2F;CS-Notes</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h2&gt;&lt;h3 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索</summary>
      
    
    
    
    <category term="数据库" scheme="https://harryzhang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://harryzhang.cn/tags/MySQL/"/>
    
    <category term="NoSQL" scheme="https://harryzhang.cn/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础知识概述</title>
    <link href="https://harryzhang.cn/2023/03/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0/"/>
    <id>https://harryzhang.cn/2023/03/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0/</id>
    <published>2023-03-25T07:10:28.000Z</published>
    <updated>2023-03-25T07:18:55.925Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li><p>ACID</p><ul><li><p>原子性</p></li><li><p>隔离性</p></li><li><p>一致性</p></li><li><p>持久性</p><ul><li>应对系统崩溃，可以用Redo Log恢复</li></ul></li></ul></li><li><p>AUTOCOMMIT：MySQL默认采用自动提交，不显示start transaction，每个查询都会被当成一个事务执行并自动提交</p></li></ul><h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><ul><li><p>丢失修改</p></li><li><p>脏读</p></li><li><p>不可重复读</p></li><li><p>幻读</p><ul><li>insert操作引起</li></ul></li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li><p>锁粒度</p><ul><li>行锁</li><li>表锁</li></ul></li><li><p>锁类型</p><ul><li><p>读写锁</p><ul><li>互斥锁（X锁、写锁）</li><li>共享锁（S锁、读锁）</li><li>一个事务对数据A加了X锁，期间其他事务不能对A加任何锁</li></ul></li></ul></li></ul><p>一个事务对数据A加了S锁，其他事务可以对A加S锁，但是不能加X锁</p><pre><code>- 意向锁    - 可以更容易支持多粒度加锁    - IX/IS锁，表示一个事务想要再表中的某个数据行上加X/S锁        - 一个事务再获得某个数据行的S锁之前，必须先获得表的IS锁或更强的锁        - 一个事务在获得某个数据行的X锁之前，必须先获得表的IX锁        - 任意IS/IX锁之间都是兼容的</code></pre><ul><li><p>封锁协议</p><ul><li>一级：事务T要修改A时必须加X锁，直到T结束才释放（解决丢失修改问题）</li><li>二级：在一级基础上事务T要读取A时必须加S锁，读取完立即释放锁（解决脏读问题）</li><li>三级：在二级的基础上，要求读取A时必须加S锁，直到事务结束才释放（解决不可重复读问题）</li><li>两段锁协议：加锁和解锁分两个阶段进行，保证可串行化调度</li></ul></li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li>读未提交（RU）</li><li>读提交（RC）</li><li>可重复度（RR）</li><li>可串行化（Serializable）</li></ul><h3 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h3><ul><li><p>版本号</p><ul><li>系统版本号SYS_ID:每开启一个新事务时递增</li><li>事务版本号TRX_ID:事务开启时的系统版本号</li></ul></li><li><p>ReadView</p><ul><li>当前系统未提交的事务列表，以及最大ID和最小ID</li></ul></li><li><p>快照读：SELECT，不需要进行加锁</p></li><li><p>当前读：INSERT、UPDATE、DELETE，需要加锁</p></li><li><p>SELECT时可以显式指定加锁</p><ul><li>select * from table where ? lock in share mode;(S锁)</li><li>select * from table where ? for update;(X锁)</li></ul></li></ul><h3 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h3><ul><li>可重复读级别下，使用MVCC+Next-Key Lock可以解决幻读</li><li>Record Locks: 锁定一个记录上的索引</li><li>Gap Locks：锁定索引之间的间隙，但是不包括索引本身</li></ul><h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><ul><li><p>异常</p><ul><li>冗余数据、修改异常、删除异常、插入异常</li></ul></li><li><p>范式</p><ul><li>为了解决异常</li><li>第一范式：属性不可分割</li><li>第二范式：非主属性完全依赖于键码</li><li>第三范式：非主属性不传递函数依赖于键码</li></ul></li></ul><p><a href="https://github.com/CyC2018/CS-Notes">【参考文章】GitHub-CyC2018&#x2F;CS-Notes</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ACID&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原子性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隔离性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="https://harryzhang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://harryzhang.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis 集群架构</title>
    <link href="https://harryzhang.cn/2023/03/25/Redis-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/"/>
    <id>https://harryzhang.cn/2023/03/25/Redis-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/</id>
    <published>2023-03-25T07:04:57.000Z</published>
    <updated>2023-03-25T07:07:54.828Z</updated>
    
    <content type="html"><![CDATA[<p>单实例往往不能满足生产环境的需求，需要引入Redis集群，比较常见的Redis集群方案有主从复制、哨兵模式、官网的Redis Cluster，另外还有一些Proxy模式，各大厂商也有自己的方案。</p><h2 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h2><h4 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h4><p><img src="https://upload-images.jianshu.io/upload_images/14151453-e32695d0c4b0efc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-e32695d0c4b0efc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol><li>slave向master发送SYNC命令，master接收到命令后通过bgsave保存快照（RDB持久化），并使用缓冲区记录保存快照期间执行的写命令</li><li>master将快照文件发送给slave，继续往缓冲区记录写命令</li><li>slave收到快照文件后载入数据</li><li>master快照发送完成后想slave发送缓冲去的写命令，slave接收命令并执行，完成复制初始化</li><li>此后每次执行一个写命令都会同步发送给slave，保持master于slave之间的数据一致性</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>最简单的一种集群方案，本质上写入还是单实例（Master节点），读可以在主节点或从节点，能够实现读写分离。缺点是容量依赖单节点，无法实现分区，不具备自动容错与恢复。</p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>为了解决主从复制模式不能自动进行故障恢复的不足，引入特殊的哨兵节点（Sentinel），用来监控Redis节点，在发生故障时选举出领头哨兵，由领头哨兵从所有的Slave节点中选一个作为新的Master节点，完成故障转移。</p><h4 id="基本架构-1"><a href="#基本架构-1" class="headerlink" title="基本架构"></a>基本架构</h4><p><img src="https://upload-images.jianshu.io/upload_images/14151453-85d5f5a9c7b7a142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-85d5f5a9c7b7a142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>Sentinel内部互相有连接，用于监控其他Sentinel和通信，同时每个Sentinel和每个Redis节点之间有两条连接，一个连接用来发送命令通信，一个连接用来订阅Redis节点的<code>_sentinel_:hello</code>频道和获取监控该节点其他Sentinel的信息。</p><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p>与Master建立连接后，Sentinel会执行以下操作：</p><ol><li>定期向Master和Slave发送INFO命令，发送INFO命令可以获取当前数据库节点信息，如果当前是Master节点，能自动发现Master的Slave节点。</li><li>定期向Master和Slave的<code>_sentinel_:hello</code>频道发送自己的信息</li><li>定期向Master、Slave和其他Sentinel发送PING命令</li></ol><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>如果Sentinel向数据库节点发送的PING命令超时，Sentinel认为其主管下线，如果该节点是主节点，Sentinel会向其他Sentinel发送命令询问他们是否也认为改Master主观下线，如果达到一定数量的投票，Sentinel会认为改Master客观下线，并开启选举领头节点进行故障恢复，选举采用Raft算法：</p><ol><li>认为Master客观下线的Sentinel-1向每个Sentinel发送命令，要求对方选自己为领头哨兵。</li><li>如果目标Sentinel节点没有选过其他人，则会同意选举Sentinel-1为领头哨兵</li><li>如果有超过一半的Sentinel统一Sentinel-1当选领头，则Sentinel-1成为领头。</li><li>如果有多个Sentinel同时竞选，导致一轮投票没有选出领头，则开启下一轮竞选，直到选出领头。</li></ol><p>领头哨兵从故障Master的Slave节点选出一个当选新的Master，选择的规则如下：</p><ol><li>所有在线的Slave选优先级最高的，优先级通过slave-priority配置</li><li>如果有多个高优先级的Slave，则选取复制偏移量最大的（数据最完整的）</li><li>如果以上条件都一样，选取id最小的</li></ol><p>挑选出要升级的Slave后，领头Sentinel向该节点发送命令使其成为Master，然后再向其他Slave发送命令接收新的Master，其他Slave收到命令后向新的Master节点发送命令进行数据同步，将故障的Master更新为新的Master的Slave节点。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>能够自动故障转移，提高了可用性，但是同样还是存在主从复制模式的难以扩容，受限于Redis单机能力的缺点。</p><h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h2><h4 id="基本架构-2"><a href="#基本架构-2" class="headerlink" title="基本架构"></a>基本架构</h4><p><img src="https://upload-images.jianshu.io/upload_images/14151453-2f8e053a25c9dd4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-2f8e053a25c9dd4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>Cluster采用无中心架构</p><ol><li>所有Redis节点彼此互联，内部使用二进制协议优化传输速度和带宽</li><li>节点的fail是通过集群中半数以上节点检测失效判定的</li><li>客户端与key所在的Redis节点不需要直连，内部会做重定向；不需要中间代理层，客户端连接集群任意一个节点即可。</li></ol><h4 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h4><ol><li>Redis Cluster引入了槽位slot的概念（取值0-16383），每个节点均分这些slot</li><li>当对某个key操作的时候，Redis会计算key的crc16值，然后对16384取模，这样每个key都会对应一个0-16383范围的哈希槽，根据哈希槽找到负责对应槽位的节点，然后自动跳转到这个槽位上进行存取操作</li><li>为了提高可用性，Cluster同时支持主从复制，每个Master对应一个或多个Slave节点，当主节点宕机的时候启动从节点</li><li>如果一个集群半数以上的Master节点认为某个Master节点疑似下线，那么这个Master将被标记为已下线。</li></ol><p>故障转移的方法和Sentinel模式类似：</p><ol><li>从复制故障Master节点的所有Slave节点选一个作为新的Master</li><li>被选中的Slave节点执行<code>SLAVEOF no one</code>命令，成为新的Master节点</li><li>新的Master节点会撤销所有对已下线Master节点的槽指派，将这些槽指派给自己</li><li>新的Master节点向集群广播一条PONG消息，让集群中的其他节点知道这个节点已经由Slave变成了Master节点，并且已接管了槽位</li><li>新的主节点开始接受和自己负责处理的slot有关的命令请求，故障转移完成。</li></ol><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>无中心架构，不存在单点故障</li><li>不需要中间代理，减少依赖</li><li>支持横向扩展，伸缩性更好，能提供的并发能力更高</li><li>能自动故障转移，高可用</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>客户端实现复杂</li><li>数据异步复制，不保证数据强一致性</li><li>Slave作为冷备不提供服务</li><li>批量操作限制</li><li>事务支持有限，只支持多key在同一节点的事务操作</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【1】书籍：Redis设计与实现<br>【2】 <a href="https://segmentfault.com/a/1190000022028642">一文掌握Redis的三种集群方案</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单实例往往不能满足生产环境的需求，需要引入Redis集群，比较常见的Redis集群方案有主从复制、哨兵模式、官网的Redis Cluster，另外还有一些Proxy模式，各大厂商也有自己的方案。&lt;/p&gt;
&lt;h2 id=&quot;主从复制模式&quot;&gt;&lt;a href=&quot;#主从复制模式&quot; c</summary>
      
    
    
    
    <category term="缓存" scheme="https://harryzhang.cn/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="Redis" scheme="https://harryzhang.cn/tags/Redis/"/>
    
    <category term="Redis 集群" scheme="https://harryzhang.cn/tags/Redis-%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Redis 热点 key 问题如何解决?</title>
    <link href="https://harryzhang.cn/2023/03/25/Redis-%E7%83%AD%E7%82%B9-key-%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"/>
    <id>https://harryzhang.cn/2023/03/25/Redis-%E7%83%AD%E7%82%B9-key-%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</id>
    <published>2023-03-25T07:04:18.000Z</published>
    <updated>2023-03-25T07:08:22.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是热点key？"><a href="#什么是热点key？" class="headerlink" title="什么是热点key？"></a>什么是热点key？</h2><p>对于web应用来说，用户消费的数据远远大于生产的数据，大多人使用都只是进行浏览，少数的人才会进行评论。对于web服务来说，某些热门的内容，读请求的量级可能是非常大的，数据库无法支持这么高并发的请求，基本都会使用Redis集群做缓存，但是如果如果热点数据的请求量过大，导致热点key所在Redis节点无法支撑，这种情况就需要采用额外的措施解决。当然Redis的性能还是非常好的，大多数业务量级都可以撑住，除非业务体量很大。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h3><p>这种方式就是将热点数据同时缓存在服务器的内存中，增加一级缓存，如果数据在内存缓存中，就直接读，不用去请求Redis。如果数据没有再请求Redis，获取到数据再写入内存缓存中。这样就大大减少了Redis的压力，而且直接读内存的速度会更快。</p><h3 id="备份热点key"><a href="#备份热点key" class="headerlink" title="备份热点key"></a>备份热点key</h3><p>为了不让热点key只请求到某一个redis节点，可以在热点key后面加一个随机数，这样热点数据可能就hash到不同的槽位，从而请求到不同的Redis节点，相当于一个key有了多个不同的备份，分散在多个Redis节点上。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【1】<a href="https://juejin.cn/post/6844903886667382798">关于Redis热点key的一些思考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是热点key？&quot;&gt;&lt;a href=&quot;#什么是热点key？&quot; class=&quot;headerlink&quot; title=&quot;什么是热点key？&quot;&gt;&lt;/a&gt;什么是热点key？&lt;/h2&gt;&lt;p&gt;对于web应用来说，用户消费的数据远远大于生产的数据，大多人使用都只是进行浏览，少数</summary>
      
    
    
    
    <category term="缓存" scheme="https://harryzhang.cn/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="Redis" scheme="https://harryzhang.cn/tags/Redis/"/>
    
    <category term="热点 key" scheme="https://harryzhang.cn/tags/%E7%83%AD%E7%82%B9-key/"/>
    
  </entry>
  
  <entry>
    <title>Redis 基础知识概述</title>
    <link href="https://harryzhang.cn/2023/03/25/Redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0/"/>
    <id>https://harryzhang.cn/2023/03/25/Redis-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0/</id>
    <published>2023-03-25T07:03:37.000Z</published>
    <updated>2023-03-25T07:17:13.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h3><ul><li>字符串、整数、浮点数</li></ul><h3 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h3><ul><li>列表</li></ul><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><ul><li>集合</li></ul><h3 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h3><ul><li>有序集合</li></ul><h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><ul><li>哈希表</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul><li>链地址法解决冲突</li><li>rehash、渐进式rehash</li></ul><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><ul><li><p>基于有序链表建多级索引</p></li><li><p>相比红黑树的优点</p><ul><li>实现起来更简单</li><li>范围查找更快</li><li>支持无锁操作</li></ul></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><ul><li>string可以进行自增自减运算，适合频繁读写的计数器</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h3 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h3><ul><li>类似缓存，利用快速查找特性。DNS记录</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul><li>List类型可以模拟消息队列</li></ul><h3 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h3><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul><li><p>RedLock</p><ul><li>多个redis节点，申请锁，当超过N&#x2F;2个节点能获得锁则认为可以获得锁</li><li>互斥：任何时刻只能有一个client获取锁</li><li>避免死锁</li><li>只要大部分redis节点存活就可以正常提供服务</li></ul></li><li><p>SETNX命令自行实现</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>Set可以实现交集、并集实现共同关注等功能</li><li>ZSet有序性实现排行榜</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="MUTI、EXEC将多个命令包围"><a href="#MUTI、EXEC将多个命令包围" class="headerlink" title="MUTI、EXEC将多个命令包围"></a>MUTI、EXEC将多个命令包围</h3><h3 id="不支持回滚，当一个命令出错会继续执行剩下的命令"><a href="#不支持回滚，当一个命令出错会继续执行剩下的命令" class="headerlink" title="不支持回滚，当一个命令出错会继续执行剩下的命令"></a>不支持回滚，当一个命令出错会继续执行剩下的命令</h3><h3 id="WATCH命令"><a href="#WATCH命令" class="headerlink" title="WATCH命令"></a>WATCH命令</h3><ul><li>乐观锁，可以监控一个或多个键，一旦被监控的某个键被修改，之后的事务就不会执行</li></ul><h3 id="具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性"><a href="#具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性" class="headerlink" title="具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性"></a>具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性</h3><h3 id="流水线方式，减少通信次数"><a href="#流水线方式，减少通信次数" class="headerlink" title="流水线方式，减少通信次数"></a>流水线方式，减少通信次数</h3><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><ul><li>基于Reactor模式开发了自己的网络事件处理器，使用I&#x2F;O多路复用同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会调用对应事件类型的事件处理器</li></ul><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><ul><li>定时事件</li><li>周期性事件</li></ul><h2 id="集群方案"><a href="#集群方案" class="headerlink" title="集群方案"></a>集群方案</h2><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><ul><li><p>Sentinel</p><ul><li>集群监控：定期ping集群中的其他服务器和哨兵，检查是否在线</li><li>消息通知：如果某个redis实例故障，哨兵负责发消息给管理员</li><li>故障转移：如果主节点挂了，会在从节点中选举出新的主节点</li><li>配置中心：发生故障转移后通知客户端新的master地址</li></ul></li><li><p>至少要3个哨兵，保证自身的健壮性</p></li></ul><h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis-Cluster"></a>Redis-Cluster</h3><ul><li><p>一共分配16383个槽位（slot）</p></li><li><p>方案说明</p><ul><li>通过哈希方式将数据分片，每个节点均分存储一定哈希槽区间的数据</li><li>每份数据分片会存在多个互为主从的多节点上</li><li>数据写入主节点，在同步从节点，同一分片的多个节点间的数据不保持一致性</li><li>读取数据时如果key没有分配在该节点会返回转向指令，指向正确的节点</li><li>每个redis需要额外开放一个加1w的端口来进行节点间通信（gossip协议）</li></ul></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>无中心架构，支持动态扩容，对业务透明</li><li>具备Sentinel的监控和自动故障转移能力</li><li>客户端不需要连接所有节点（会自动转向）</li><li>高性能，客户端直连redis服务器，免去proxy代理的损耗</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>运维复杂，数据迁移需要人工干预</li><li>不支持批量操作（pipeline）</li></ul><h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ul><li><p>大面积缓存失效</p></li><li><p>解决方案</p><ul><li>设置随机的过期时间</li><li>并发不多的时候加锁排队</li></ul></li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><ul><li><p>缓存和DB都不存在的数据</p></li><li><p>解决方案</p><ul><li>接口层拦截</li><li>设置空缓存，过期时间要短</li><li>布隆过滤器</li></ul></li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><ul><li><p>缓存中没有，但是并发用户很多</p></li><li><p>解决方案</p><ul><li><p>设置热点数据永不过期</p><ul><li>persist key</li></ul></li><li><p>加互斥锁</p></li><li><p>缓存预热</p></li><li><p>缓存降级</p></li></ul></li></ul><h2 id="对比Memcached"><a href="#对比Memcached" class="headerlink" title="对比Memcached"></a>对比Memcached</h2><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><ul><li>仅支持字符串类型</li><li>不支持持久化</li><li>不支持分布式</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>读写性能优异，Read：11w&#x2F;s、Write：8.1w&#x2F;s</li><li>支持RDB和AOF两种持久化方式</li><li>支持事务，具有原子性</li><li>数据结构丰富</li><li>支持主从复制</li></ul><h3 id="Redis缺点"><a href="#Redis缺点" class="headerlink" title="Redis缺点"></a>Redis缺点</h3><ul><li>内存通常比较小且贵，不适用海量数据</li><li>比较难支持在线扩容</li></ul><h2 id="键的过期时间"><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h2><h3 id="每个键设置过期时间，过期后会自动删除"><a href="#每个键设置过期时间，过期后会自动删除" class="headerlink" title="每个键设置过期时间，过期后会自动删除"></a>每个键设置过期时间，过期后会自动删除</h3><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><h2 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h2><h3 id="当内存超出容量，会施行淘汰策略"><a href="#当内存超出容量，会施行淘汰策略" class="headerlink" title="当内存超出容量，会施行淘汰策略"></a>当内存超出容量，会施行淘汰策略</h3><h3 id="全局键空间选择性删除"><a href="#全局键空间选择性删除" class="headerlink" title="全局键空间选择性删除"></a>全局键空间选择性删除</h3><ul><li>noevication</li><li>allkeys-lru</li><li>allkeys-random</li></ul><h3 id="设置过期时间的键空间选择性移除"><a href="#设置过期时间的键空间选择性移除" class="headerlink" title="设置过期时间的键空间选择性移除"></a>设置过期时间的键空间选择性移除</h3><ul><li>volatile-lru</li><li>volatile-random</li><li>volatile-ttl</li></ul><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB（默认方式）"><a href="#RDB（默认方式）" class="headerlink" title="RDB（默认方式）"></a>RDB（默认方式）</h3><ul><li><p>数据快照</p></li><li><p>优点</p><ul><li>只有一个dump.rdb文件，方便持久化</li><li>容灾兴好，一个文件可以安全的保存到磁盘</li><li>单独进程处理，不会影响主进程的IO操作</li><li>数据集大时比AOF启动更快</li></ul></li><li><p>缺点</p><ul><li>定期执行持久化操作，故障会丢失数据</li></ul></li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><ul><li><p>写命令追加到AOF文件</p><ul><li>always：每个写命令都同步</li><li>everysec：每秒同步一次</li><li>no：让操作系统决定何时同步</li></ul></li><li><p>优点</p><ul><li>数据安全，always模式每进行一次写命令就记录到aof文件一次</li><li>append模式写文件，即使中途宕机可以redis-check-aof工具解决数据一致性问题</li><li>AOF重写机制，减少冗余命令</li></ul></li><li><p>缺点</p><ul><li>文件大，恢复速度慢</li></ul></li></ul><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p><code>slaveof  $&#123;host&#125;  $&#123;port&#125;</code></p><h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><ul><li>主服务器创建快照文件（rdb）发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完再向从服务器发送存储在缓冲区的写命令</li><li>从服务器丢弃所有旧数据，载入快照文件，接收主服务器发来的写命令</li><li>主服务器每执行一次写命令，就向所有从服务器发送相同的写命令</li></ul><h3 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h3><ul><li>从服务器比较多的时候，为了不影响主服务器的性能，可以设置中间层来分担主服务器的复制工作</li></ul><p><a href="https://github.com/CyC2018/CS-Notes">【参考文章】GitHub-CyC2018&#x2F;CS-Notes</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;h3 id=&quot;STRING&quot;&gt;&lt;a href=&quot;#STRING&quot; class=&quot;headerlink&quot; title=&quot;STRIN</summary>
      
    
    
    
    <category term="缓存" scheme="https://harryzhang.cn/categories/%E7%BC%93%E5%AD%98/"/>
    
    
    <category term="Redis" scheme="https://harryzhang.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>TCP是如何实现可靠传输的？</title>
    <link href="https://harryzhang.cn/2023/03/25/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%EF%BC%9F/"/>
    <id>https://harryzhang.cn/2023/03/25/TCP%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%EF%BC%9F/</id>
    <published>2023-03-25T06:43:37.000Z</published>
    <updated>2023-03-25T06:58:47.366Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机网络的经典五层协议中，TCP属于运输层，实现了进程间的通信，保证了数据的可靠传输，属于计算机网络协议族中最重要的协议之一，那么TCP是如何实现可靠数据传输的呢？</p><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>运输层的进程间通信是通过socket实现的，socket是一个抽象的概念，在Linux系统中以文件的形式存在。网络层通过IP来区分主机，运输层则增加了端口的概念来区分进程。TCP协议中使用目标IP、目标端口、源IP、源端口来定义一个socket，只需要在运输层的报文头部附加上这些信息，目标主机就会知道数据要发送那个socket，对应监听该socket的进程就可以收到数据进行处理。</p><h2 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h2><p>TCP报文包括首部和数据部分，首部附加了TCP报文的信息，首部长度固定部分为20字节，还有40字节的可选部分，具体如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/14151453-cdbb73e6c3f47d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-cdbb73e6c3f47d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>其中几个关键字段的作用如下：</p><ul><li>源端口和目的端口：分别16个字节（表示范围0-65535），用来区分主机上的进程</li><li>序号：TCP连接中的每个字节都编一个序号，表示本报文的第一个字节在整个数据包中的偏移位置</li><li>确认号：期望收到对方的下一个报文段的数据的第一个字节的序号</li><li>数据偏移：首部长度，4字节为单位</li><li>标志位<ul><li>ACK：ACK&#x3D;1表示接收发向发送方发的确认报文</li><li>SYN：同步SYN&#x3D;1表示是一个连接请求或连接接受报文</li><li>FIN：FIN&#x3D;1表示发送方已经发送完毕，可以断开连接</li></ul></li><li>窗口：发送方接收缓冲区剩下的字节数</li><li>校验和：检验报文在网络传输过程中是否发生了变化</li><li>选项字段：<ul><li>窗口扩大选项，用于流量控制</li><li>时间戳选项</li><li>选择确认选项，由于接收方收到了不连续的报文，告知发送方目前收到的数据报范围（两个4字节的边界表示）</li></ul></li></ul><h2 id="可靠传输原理"><a href="#可靠传输原理" class="headerlink" title="可靠传输原理"></a>可靠传输原理</h2><p>网络层只管尽可能将数据从一个主机发送到另一个主机，并不保证数据可靠到达，由于网络环境总是不稳定的，可能存在丢包、差错等请求，TCP则通过一系列的机制在运输层保证了数据的可靠传输。<br>网络传输可能发生的异常情况和解决方法：</p><ul><li>丢包：超时重传</li><li>差错：校验码来检验数据正确收到</li></ul><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p>要实现可靠传输，最简单的方法就是发送方发送一个报文，接收方收到报文后发送确认报文表示我收到了，你可以发下一个了，传输模型如下：<br><img src="https://upload-images.jianshu.io/upload_images/14151453-60467e00e08bd710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-60467e00e08bd710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这种方式保证可靠传输称为停止等待协议，这种方式缺点也很明显，效率非常低。</p><h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>为了提高传输效率，充分利用带宽，发送方会连续的发送数据包，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/14151453-3e2aee42126ae328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-3e2aee42126ae328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>客户端不等收到前一个包的确认报文就开始不断的发下一个包，这样可以充分利用网络带宽，提高传输效率，但是于此同时也带来了另外的问题，那么TCP是如何解决这些问题的？</p><h4 id="确认报文冗余"><a href="#确认报文冗余" class="headerlink" title="确认报文冗余"></a>确认报文冗余</h4><p><strong>累计确认</strong>：网络中充斥着大量的发送包和确认回复报文，这些数据只是为了确认报文到达，并不是实际需要传输的数据。是不是一定要每一个报文都要发一个回复确认的报文呢，TCP采用了累计确认的方法：接收方在累计收到了一定量的数据包后发送一个确认报文告诉发送方在此之前的数据包都已经收到了，这样便可以减少确认报文的数量，提高带宽利用率。</p><h4 id="丢包的处理"><a href="#丢包的处理" class="headerlink" title="丢包的处理"></a>丢包的处理</h4><p><strong>GBN（回退n步）</strong>：如果发生丢包的情况，在连续ARQ中，如果接受方收到了123 567个字节，编号为4字节的包丢失了，按照累计确认只能发送3的确认回复，567都要丢掉，因为发送发会进行重传。</p><p><strong>选择确认ACK</strong>：在TCP报文头部的选项字段部分设置已收到的报文，每一段用两个边界来确定，比如上述情况可以用[1,3]和[5,7]来表示，客户端就会根据选项只重传丢失的数据段。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>因为接收方读数据的能力有限，发送发不能一直发送报文直到把缓冲区所有数据发送完，这样会导致接收方无法接收丢弃掉数据包，发送方收不到确认认为超时又会继续重传，产生了大量无用数据的重传。对此情况TCP使用滑动窗口来解决，基本模型如下：<br><img src="https://upload-images.jianshu.io/upload_images/14151453-06581f647ab4c35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-06581f647ab4c35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li>发送方根据接受方缓冲区的大小，设置自己可发送窗口大小，处于窗口内的数据表示可以发送，之外的数据不能发送</li><li>当窗口内的未确认数据收到确认回复时，整个窗口往前移动，知道发送完所有数据</li></ul><p>滑动窗口机制实现了TCP的<strong>流量控制</strong>，不至于发送太快导致太多的数据丢弃和重传。</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>为了避免网络过分拥挤导致丢包严重，传输效率低，TCP实现了拥塞控制机制，拥塞控制的解决办法本质上是流量控制，控制发送方发送的速度，而上文提到流量控制是通过滑动窗口来实现的，所以最终也是通过调整发送方的滑动窗口大小来实现的。</p><p>拥塞控制的几个重要的概念：慢启动、拥塞避免、快恢复、快重传</p><h3 id="Reno算法模型"><a href="#Reno算法模型" class="headerlink" title="Reno算法模型"></a>Reno算法模型</h3><p><img src="https://upload-images.jianshu.io/upload_images/14151453-2ca1f629fb91be2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-2ca1f629fb91be2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><ul><li>慢启动：最开始的时候把窗口设置为较小的值，然后每轮变成两倍（虽然叫慢启动，但其实是指数增长）</li><li>拥塞避免：当窗口大小达到初始阈值ssthresh，每轮窗口大小增加1（试探网络最大的负载能力）</li><li>如果发生了超时，表示极可能发生了拥塞，此时直接执行慢启动，尽可能让网络中的报文先接收，以尽快恢复网络状况。</li><li>快重传：如果收到三个重复的ACK，表示中间有段数据丢包了，发送方无需等待计时器到达超时时间，立即进行重传丢失的报文段。</li><li>快恢复：连续收到了三个重复ACK，说明网络情况还不是很拥堵，此时将窗口初始的阈值减半，然后执行拥塞避免，这个过程称为快恢复。</li></ul><p>Reno算法是比较常见的TCP实现的拥塞控制算法，其他拥塞算法还有Tahoe（已废弃不用）、New Reno等，通过拥塞控制算法可以很大程度避免网络拥挤。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【书籍】计算机网络：自顶向下方法<br>【码农有道】<a href="https://mp.weixin.qq.com/s/B1Qttaejav4UzPn0GNoOHw">这一篇TCP总结请收下</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在计算机网络的经典五层协议中，TCP属于运输层，实现了进程间的通信，保证了数据的可靠传输，属于计算机网络协议族中最重要的协议之一，那么TCP是如何实现可靠数据传输的呢？&lt;/p&gt;
&lt;h2 id=&quot;底层实现&quot;&gt;&lt;a href=&quot;#底层实现&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://harryzhang.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="https://harryzhang.cn/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS原理详解</title>
    <link href="https://harryzhang.cn/2023/03/25/HTTPS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://harryzhang.cn/2023/03/25/HTTPS%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-03-25T06:43:24.000Z</published>
    <updated>2023-03-25T06:58:23.210Z</updated>
    
    <content type="html"><![CDATA[<p>Web应用存在HTTP和HTTPS两种通信方式，HTTP默认端口80，数据以明文传输，HTTPS默认端口443，数据加密传输。</p><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>HTTPS实际上并不是一种新的网络协议，是HTTP的基础上加了SSL层，数据的加密就是在SSL层完成的。<br><img src="https://upload-images.jianshu.io/upload_images/14151453-4915c1ecfe442f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-4915c1ecfe442f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h2 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h2><h3 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h3><p>客户端和服务器已明文方式传输数据，没有安全性，数据再传输过程中可能被劫持和篡改<br><img src="https://upload-images.jianshu.io/upload_images/14151453-af0efb8a2b3599db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-af0efb8a2b3599db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="对称加密传输"><a href="#对称加密传输" class="headerlink" title="对称加密传输"></a>对称加密传输</h3><p>对称加密算法：双方使用同一秘钥对数据进行加解密（AES、DES）<br><img src="https://upload-images.jianshu.io/upload_images/14151453-046d2c536baae247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-046d2c536baae247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br><strong>特点</strong>：</p><ul><li>如果不知道秘钥，是无法解出对应的明文，但是如果所有客户端都用相同的秘钥，相当于没有加密，坏人也可以作为一个用户拿到秘钥。</li><li>加解密性能高</li></ul><p>一种改进的方案是每个客户端先协商一个加密算法和秘钥，不同客户端使用不同的算法和秘钥，这就坏人即使作为一个用户也不知道别的用户的秘钥。但是这种方式协商秘钥的过程是公开明文的，坏人也有办法窃取到秘钥的，仍然存在风险。</p><h3 id="非对称加密传输"><a href="#非对称加密传输" class="headerlink" title="非对称加密传输"></a>非对称加密传输</h3><p>非对称加密算法：加密解密采用不同的秘钥，私钥加密后的密文，所有的公钥都可以解密，公钥加密后的密文只有私钥能解密。私钥通常只有一个人有，公钥可以公开发给所有人。（常见算法：RSA）<br><img src="https://upload-images.jianshu.io/upload_images/14151453-eefe11cf0a2b22f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-eefe11cf0a2b22f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>特点</strong>：</p><ul><li>只要把私钥保存在服务器，公钥发给客户端，那么客户端向服务器发送的数据就是安全的，但是服务器向客户端发送的数据坏人也可以通过公钥解密</li><li>加解密消耗的时间较长，传输效率会降低</li></ul><h3 id="HTTPS（对称加密-非对称加密）"><a href="#HTTPS（对称加密-非对称加密）" class="headerlink" title="HTTPS（对称加密+非对称加密）"></a>HTTPS（对称加密+非对称加密）</h3><p><img src="https://upload-images.jianshu.io/upload_images/14151453-9a21634026ce4d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-9a21634026ce4d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><strong>特点</strong>：</p><ul><li>使用非对称加密传输协商一个对称加密算法和秘钥</li><li>使用对称加密算法对数据加密传输</li><li>数据双向安全，且效率较高</li></ul><h2 id="CA机构和数字证书"><a href="#CA机构和数字证书" class="headerlink" title="CA机构和数字证书"></a>CA机构和数字证书</h2><p>从前面可以看到，协商阶段时候用非对称加密，客户端一开始就要持有公钥，那么客户端如何安全的获取公钥呢？<br>如果服务端直接将公钥发给客户端，中间可能被坏人劫持，返回一个假公钥，客户端使用假公钥进行加密后请求，坏人就可以使用假私钥解出明文，篡改内容后再使用真公钥加密后请求到服务器，这时服务器拿到的是被篡改后的数据。<br><img src="https://upload-images.jianshu.io/upload_images/14151453-fb5c49e4b5019e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-fb5c49e4b5019e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>数字证书和CA机构就是用来保证服务器安全的发送公钥给客户端的。<br><strong>校验过程</strong></p><ol><li>读取证书中的所有者，有效期等信息进行校验</li><li>查找系统内置的受信任证书发布机构CA，与服务器下发的证书中的CA对比，校验是否是合法机构颁发</li><li>如果找不到，浏览器报错警告证书不可信</li><li>如果找到了：</li></ol><ul><li>对证书里的数字签名使用公钥解密得到明文的hash摘要</li><li>浏览器使用相同的hash算法计算明文的hash值，将这个值与上述计算的摘要对比验证证书的合法性。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个完整的HTTPS请求流程如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/14151453-06d256f8dff32472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-06d256f8dff32472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【1】<a href="https://juejin.cn/post/6844903830916694030">【掘金】深入理解HTTPS工作原理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Web应用存在HTTP和HTTPS两种通信方式，HTTP默认端口80，数据以明文传输，HTTPS默认端口443，数据加密传输。&lt;/p&gt;
&lt;h2 id=&quot;HTTPS协议&quot;&gt;&lt;a href=&quot;#HTTPS协议&quot; class=&quot;headerlink&quot; title=&quot;HTTPS协议</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://harryzhang.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTPS" scheme="https://harryzhang.cn/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Session和Cookie</title>
    <link href="https://harryzhang.cn/2023/03/25/Session%E5%92%8CCookie/"/>
    <id>https://harryzhang.cn/2023/03/25/Session%E5%92%8CCookie/</id>
    <published>2023-03-25T06:43:05.000Z</published>
    <updated>2023-03-25T06:58:16.825Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道HTTP协议是无状态的，那么在Web开发中如何做好用户的整个浏览过程的控制，最经典的解决方案就是使用Cookie和Session。<br>Cookie是客户端的机制，把用户数据缓存在客户端，而Session是服务端的机制，每个用户都会被分配一个唯一的SessionID，可以通过url传输或保存在客户端的Cookie中，也可以将Session保存在数据库中，比如Redis中。</p><h2 id="Session和Cookie是怎么来的？"><a href="#Session和Cookie是怎么来的？" class="headerlink" title="Session和Cookie是怎么来的？"></a>Session和Cookie是怎么来的？</h2><p>假如你在浏览器上从来没有登录过GitHub，当你第一次登录的时候需要输入用户名和密码进行验证，通过验证后会调到个人首页，那么在登录成功后你点击你的某个代码仓库的时候服务器如何验证你的身份呢？因为HTTP协议是无状态的，服务器并不知道你上次已经验证过了，一种方法是每次请求都带上用户名和密码，这显然会导致用户体验极差。那么就需要再客户端或服务器上保存身份信息了，于是Cookie和Session就产生了。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="Cookie原理"><a href="#Cookie原理" class="headerlink" title="Cookie原理"></a>Cookie原理</h4><p>Cookie就是本地计算机保存一些用户操作的历史信息，用户再次访问时在HTTP请求头中带上Cookie信息，服务端就可以对其进行验证。<br><img src="https://upload-images.jianshu.io/upload_images/14151453-e9dd7894922a2adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-e9dd7894922a2adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="数据内容"><a href="#数据内容" class="headerlink" title="数据内容"></a>数据内容</h4><p>Cookie本质上是由浏览器管理存储在客户端的一小段文本，Chrome浏览器可以使用EditThisCookie插件来管理Cookie，如下图所示。<br><img src="https://upload-images.jianshu.io/upload_images/14151453-ae9b877211f0b906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-ae9b877211f0b906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="会话Cookie和持久Cookie"><a href="#会话Cookie和持久Cookie" class="headerlink" title="会话Cookie和持久Cookie"></a>会话Cookie和持久Cookie</h4><ul><li>会话Cookie：Cookie是有有效期的，如果不设置过期时间，则表示这个Cookie的生命周期从创建到浏览器关闭为止，只要关闭浏览器Cookie就消失了，相当于数据保存在内存中，进程结束就丢失了</li><li>持久Cookie：如果设置了过期时间，浏览器会把Cookie数据保存到磁盘上，关闭浏览器再次打开依然有效，直到Cookie过期，浏览器通常都使用的持久Cookie。</li></ul><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="Session原理"><a href="#Session原理" class="headerlink" title="Session原理"></a>Session原理</h4><p>Session是服务器用来保存用户操作的历史信息的，使用SessionID来标识Session，SessionID由服务器产生，保证随机性和唯一性，相当于一个随机秘钥，避免在传输中暴露用户真实密码，但是服务器仍要将请求对Session进行对应，需要借助Cookie保存客户端的标识（SessionID）。<br><img src="https://upload-images.jianshu.io/upload_images/14151453-849911fdca5ee4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-849911fdca5ee4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>当服务器需要对某个请求创建Session的时候，首先检查这个客户端的请求是否包含了SessionID，如果已经包含则表示次客户端之前已经创建过，只需要根据SessionID查询对应的Session。如果请求没有携带SessionID，则会生成一个Session和对应的SessionID，同时在本次响应中返回SessionID。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【1】<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md">build-web-application-with-golang</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道HTTP协议是无状态的，那么在Web开发中如何做好用户的整个浏览过程的控制，最经典的解决方案就是使用Cookie和Session。&lt;br&gt;Cookie是客户端的机制，把用户数据缓存在客户端，而Session是服务端的机制，每个用户都会被分配一个唯一的SessionI</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://harryzhang.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Session" scheme="https://harryzhang.cn/tags/Session/"/>
    
    <category term="Cookie" scheme="https://harryzhang.cn/tags/Cookie/"/>
    
  </entry>
  
  <entry>
    <title>什么是WebSocket？</title>
    <link href="https://harryzhang.cn/2023/03/25/%E4%BB%80%E4%B9%88%E6%98%AFWebSocket%EF%BC%9F/"/>
    <id>https://harryzhang.cn/2023/03/25/%E4%BB%80%E4%B9%88%E6%98%AFWebSocket%EF%BC%9F/</id>
    <published>2023-03-25T06:42:47.000Z</published>
    <updated>2023-03-25T06:58:29.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>WebSocket是一种网络通信协议，是HTML5新增的特性，实现了基于浏览器的远程socket，使浏览器和服务器可以进行全双工通信，大部分浏览器都对此做了支持。<br>WebSocket的URL格式形如：ws:&#x2F;&#x2F;localhost:80&#x2F;、wss:&#x2F;&#x2F;localhost:443&#x2F;</p><h2 id="为什么有了HTTP协议还要WebSocket"><a href="#为什么有了HTTP协议还要WebSocket" class="headerlink" title="为什么有了HTTP协议还要WebSocket"></a>为什么有了HTTP协议还要WebSocket</h2><p>HTTP协议采用的是客户端（浏览器）轮询的方式，即客户端发送请求，服务端做出响应，为了获取最新的数据，需要不断的轮询发出HTTP请求，占用大量带宽。<br>WebSocket采用了一些特殊的报头，使得浏览器和服务器只需要通过“握手”建立一条连接通道后，此链接保持活跃状态，之后的客户端和服务器的通信都使用这个连接，解决了Web实时性的问题，相比于HTTP有一下好处：</p><ul><li>一个Web客户端只建立一个TCP连接</li><li>WebSocket服务端可以主动推送（push）数据到Web客户端</li><li>有更加轻量级的头，减少了数据传输量</li></ul><h2 id="WebSocket原理"><a href="#WebSocket原理" class="headerlink" title="WebSocket原理"></a>WebSocket原理</h2><p><img src="https://upload-images.jianshu.io/upload_images/14151453-83f761a12847fa76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-83f761a12847fa76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>WebSocket建立连接必须由浏览器发起，是一个标准的HTTP请求，如下图所示<br><img src="https://upload-images.jianshu.io/upload_images/14151453-0f3bd32d35e06362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-0f3bd32d35e06362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><ol><li>请求地址以<code>ws://</code>开头</li><li>请求头<code>Upgrade: websocket</code>和<code>Connection:Upgrade</code>表示要将这个连接转换为WebSocket连接</li><li><code>Sec-WebSocket-Key</code>用于标识连接，是一个base64编码的字符串</li><li><code>Sec-WebSocket-Version</code>指定了WebSocket协议版本</li></ol><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><ol><li>响应状态码<code>101</code>表示本次连接的HTTP协议将被更改</li><li><code>Upgrade: websocket</code>表示更改后的协议是WebSocket</li><li><code>Sec-WebSocket-Accept</code>通过如下方式计算：</li></ol><ul><li>对请求头的<code>Sec-WebSocket-Key</code>字符串加上一个固定的字符串，例如：<br><code>H+VLjR1wb4JQ62TmabK87g==258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code></li><li>然后对该字符串用sha1算法散列出二进制值，再对其进行base64加密，例如：<br><code>ccJoRDcGOFzCVrIwpX/qF3BoIN0=</code></li></ul><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>WebSocket的协议比较简单，在第一次handshake通过之后，连接建立成功，之后的通讯数据都是以”\x00”开头，以”\xFF”结尾，对客户端来说这个是透明的，WebSocket的实现组件会对原始数据掐头去尾。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>建立在TCP协议只上，服务端比较容易实现</li><li>于HTTP协议有良好的兼容性，默认端口也是80和443，握手阶段使用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器</li><li>数据格式轻量，通信高效且节省带宽</li><li>支持传输文本数据和二进制数据</li><li>没有同源限制，客户端可以与任意服务器通信</li><li>也支持加密传输，WS+SSL，URL形如<code>wss://</code></li></ol><h2 id="Go语言实现"><a href="#Go语言实现" class="headerlink" title="Go语言实现"></a>Go语言实现</h2><p>go的标准SDK中没有支持WebSocket，但是官方维护的net子包中支持<br><code>go get golang.org/x/net/websocket</code></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> sock = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> wsuri = <span class="string">&quot;ws://127.0.0.1:7777&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onload&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        sock = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(wsuri);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        sock.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;connected to &quot;</span> + wsuri);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        sock.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;connection closed (&quot;</span> + e.<span class="property">code</span> + <span class="string">&quot;)&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        sock.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;message received: &quot;</span> + e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">send</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> msg = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;message&#x27;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">        sock.<span class="title function_">send</span>(msg);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>WebSocket Echo Test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        Message: <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello, world!&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;send();&quot;</span>&gt;</span>Send Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>客户端JavaScript代码，通过<code>new WebSocket(wsuri)</code>创建了一个WebSocket连接，握手成功后会触发onopen事件，客户端绑定了四个事件：</p><ul><li>onopen：建立连接后触发</li><li>onmessage：收到消息后触发</li><li>onerror：发生错误时触发</li><li>onclose：关闭连接时触发</li></ul><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;golang.org/x/net/websocket&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleEcho</span><span class="params">(ws *websocket.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> reply <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = websocket.Message.Receive(ws, &amp;reply); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;[server] Can&#x27;t receive&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;[server] Received from client:&quot;</span>, reply)</span><br><span class="line"></span><br><span class="line">msg := <span class="string">&quot;welcome: &quot;</span> + reply</span><br><span class="line"><span class="keyword">if</span> err = websocket.Message.Send(ws, msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;[server] Can&#x27;t Send&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;[server] Send to client:&quot;</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, websocket.Handler(handleEcho))</span><br><span class="line">log.Println(<span class="string">&quot;[server] listen in 127.0.0.1:7777&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:7777&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;[server] ListenAndServe:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后在客户端页面点击Send Message按钮，可以看到服务端如下响应：<br><img src="https://upload-images.jianshu.io/upload_images/14151453-e2ef3c1cb34f117d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-e2ef3c1cb34f117d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.2.md">build-web-application-with-golang</a><br>【2】<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096">廖雪峰：WebSocket</a><br>【3】<a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰：WebSocket教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;WebSocket是一种网络通信协议，是HTML5新增的特性，实现了基于浏览器的远程socket，使浏览器和服务器可以进行全</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://harryzhang.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="WebSocket" scheme="https://harryzhang.cn/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础概述</title>
    <link href="https://harryzhang.cn/2023/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/"/>
    <id>https://harryzhang.cn/2023/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/</id>
    <published>2023-03-25T05:58:26.000Z</published>
    <updated>2023-03-25T06:58:34.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><ul><li><p>TCP、UDP</p><ul><li><p>特点</p><ul><li><p>UDP：无连接，尽最大可能交付数据，面向报文，支持一对一、一对多、多对一、多对多的交互通信，不可靠（快、实时性好）</p><ul><li>DNS、TFTP</li></ul></li><li><p>TCP：面向连接，可靠交付，有流量控制、拥塞控制，全双工通信，面向字节流，只能点对点（一对一）</p><ul><li>HTTP、FTP、TELENT、SMTP</li></ul></li></ul></li><li><p>TCP三次握手</p><ul><li>防止失效的连接请求到达服务器，导致服务器打开无用的连接</li></ul></li><li><p>TCP四次挥手</p><ul><li><p>TIME_WAIT&#x3D;2MSL</p><ul><li>确保最后一个确认报文能到达，因为如果丢失会重传</li><li>让本次连接产生的所有报文都从网络中消失</li></ul></li></ul></li><li><p>TCP可靠传输</p><ul><li>超时重传RTT</li></ul></li><li><p>TCP滑动窗口</p></li><li><p>TCP流量控制</p><ul><li>控制发送方速率，保证接收方来得及接收（通过确认报文的窗口字段控制发送方窗口大小）</li></ul></li><li><p>TCP拥塞控制</p><ul><li>慢启动、拥塞避免、快重传、快恢复</li></ul></li></ul></li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul><li><p>DNS</p><ul><li>UDP+TCP</li></ul></li><li><p>DHCP</p><ul><li>动态主机配置</li></ul></li><li><p>Web页面请求过程</p><ul><li><ol><li>DHCP配置主机信息</li></ol></li><li><ol start="2"><li>ARP解析MAC地址</li></ol></li><li><ol start="3"><li>DNS解析域名</li></ol></li><li><ol start="4"><li>HTTP请求页面</li></ol><ul><li>三次握手建立连接</li><li>开始通信</li></ul></li></ul></li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h3 id="阻塞式I-x2F-O"><a href="#阻塞式I-x2F-O" class="headerlink" title="阻塞式I&#x2F;O"></a>阻塞式I&#x2F;O</h3><ul><li>直到数据从内核缓冲区复制到应用进程缓冲区才返回（cpu并不会阻塞，其他进程还可以执行，cpu利用率较高）</li></ul><h3 id="非阻塞式I-x2F-O"><a href="#非阻塞式I-x2F-O" class="headerlink" title="非阻塞式I&#x2F;O"></a>非阻塞式I&#x2F;O</h3><ul><li>应用进程执行系统调用后内核返回一个错误码，需要轮询来获知IO操作是否完成（CPU利用率低）</li></ul><h3 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h3><ul><li><p>select、poll等待数据，当监听的某个套接字可读，再使用recvfrom把数据从内核复制到进程中</p><ul><li><p>select</p><ul><li>会修改fd，默认只能监听少于1024个，轮询</li></ul></li><li><p>poll</p><ul><li>提供了更多的事件类型，对fd的重复利用更高</li></ul></li><li><p>epoll</p><ul><li><p>比上述两种更加灵活，对多线程更友好</p><ul><li><p>epoll_create</p><ul><li>创建一个epoll句柄</li></ul></li><li><p>epoll_ctl</p><ul><li>为fd注册事件并绑定一个回调函数，当设备就绪callback把fd加入就绪队列（列表）</li></ul></li><li><p>epoll_wait</p><ul><li>轮询就绪队列（schedule_timeout()）</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="信号驱动I-x2F-O"><a href="#信号驱动I-x2F-O" class="headerlink" title="信号驱动I&#x2F;O"></a>信号驱动I&#x2F;O</h3><ul><li>sigaction系统调用，当数据到达时内核会向进程发送SIGIO信号，收到信号后调用recvfrom（相比轮询的非阻塞I&#x2F;O模型CPU利用率更高）</li></ul><h3 id="异步I-x2F-O"><a href="#异步I-x2F-O" class="headerlink" title="异步I&#x2F;O"></a>异步I&#x2F;O</h3><ul><li>aio_read系统调用，内核会在数据复制完成后向应用进程发送信号（注意和信号驱动I&#x2F;O的区别）</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul><li><p>1xx：信息性</p></li><li><p>2xx：成功</p></li><li><p>3xx：重定向</p><ul><li>301：永久重定向，会缓存</li><li>302：临时重定向，不缓存，有url劫持问题</li></ul></li><li><p>4xx：客户端错误，服务端无法处理的请求</p></li><li><p>5xx：服务器错误</p></li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li>客户端保存状态</li></ul><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ul><li>服务器保存状态</li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul><li>HTTP+SSL</li><li>使用非对称加密协商对称加密使用的Secretkey</li><li>使用Secretkey对称加密数据</li><li>使用数字证书保证公钥的正确性</li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul><li>二进制分帧层</li><li>服务端推送</li><li>首部压缩</li></ul><p><a href="https://github.com/CyC2018/CS-Notes">【参考文章】GitHub-CyC2018&#x2F;CS-Notes</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h2&gt;&lt;h3 id=&quot;网络层&quot;&gt;&lt;a href=&quot;#网络层&quot; class=&quot;headerlink&quot; title=&quot;网络层&quot;&gt;&lt;/a&gt;网络层&lt;/h3&gt;&lt;h</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://harryzhang.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 系统 I/O 模型及 select/poll/epoll 详解</title>
    <link href="https://harryzhang.cn/2023/03/19/Linux-%E7%B3%BB%E7%BB%9F-I-O-%E6%A8%A1%E5%9E%8B%E5%8F%8A-select-poll-epoll-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://harryzhang.cn/2023/03/19/Linux-%E7%B3%BB%E7%BB%9F-I-O-%E6%A8%A1%E5%9E%8B%E5%8F%8A-select-poll-epoll-%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-03-19T14:06:15.000Z</published>
    <updated>2023-03-19T14:07:53.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念说明"><a href="#基本概念说明" class="headerlink" title="基本概念说明"></a>基本概念说明</h2><p>理解Linux的IO模型之前，首先要了解一些基本概念，才能理解这些IO模型设计的依据</p><h3 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h3><p>操作系统使用虚拟内存来映射物理内存，对于32位的操作系统来说，虚拟地址空间为4G（2^32）。操作系统的核心是内核，为了保护用户进程不能直接操作内核，保证内核安全，操作系统将虚拟地址空间划分为内核空间和用户空间。内核可以访问全部的地址空间，拥有访问底层硬件设备的权限，普通的应用程序需要访问硬件设备必须通过<strong>系统调用</strong>来实现。</p><p>对于Linux系统来说，将虚拟内存的最高1G字节的空间作为内核空间仅供内核使用，低3G字节的空间供用户进程使用，称为用户空间。</p><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><ul><li>就绪</li><li>阻塞</li><li>运行</li></ul><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><h3 id="缓存I-x2F-O"><a href="#缓存I-x2F-O" class="headerlink" title="缓存I&#x2F;O"></a>缓存I&#x2F;O</h3><p>又被称为标准I&#x2F;O，大多数文件系统的默认I&#x2F;O都是缓存I&#x2F;O。在Linux系统的缓存I&#x2F;O机制中，操作系统会将I&#x2F;O的数据缓存在页缓存（内存）中，也就是数据先被拷贝到内核的缓冲区（内核地址空间），然后才会从内核缓冲区拷贝到应用程序的缓冲区（用户地址空间）。</p><p>这种方式很明显的缺点就是数据传输过程中需要再应用程序地址空间和内核空间进行多次数据拷贝操作，这些操作带来的CPU以及内存的开销是非常大的。</p><h3 id="二I-x2F-O模式"><a href="#二I-x2F-O模式" class="headerlink" title="二I&#x2F;O模式"></a>二I&#x2F;O模式</h3><p>由于Linux系统采用的缓存I&#x2F;O模式，对于一次I&#x2F;O访问，以读操作举例，数据先会被拷贝到内核缓冲区，然后才会从内核缓冲区拷贝到应用程序的缓存区，当一个read系统调用发生的时候，会经历两个阶段：</p><ul><li>等待数据到来，进程处于阻塞状态</li><li>当数据准备就绪后，将数据从内核拷贝到用户进程，进程处于运行状态</li></ul><p>正是因为这两个状态，Linux系统才产生了多种不同的网络I&#x2F;O模式的方案</p><h2 id="Linux系统I-x2F-O模型"><a href="#Linux系统I-x2F-O模型" class="headerlink" title="Linux系统I&#x2F;O模型"></a>Linux系统I&#x2F;O模型</h2><h3 id="阻塞IO（blocking-IO）"><a href="#阻塞IO（blocking-IO）" class="headerlink" title="阻塞IO（blocking IO）"></a>阻塞IO（blocking IO）</h3><p>Linux系统默认情况下所有socke都是blocking的，一个读操作流程如下：<br><img src="https://upload-images.jianshu.io/upload_images/14151453-5b4abb97fad3f18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-5b4abb97fad3f18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>以UDP socket为例，当用户进程调用了recvfrom系统调用，如果数据还没准备好，应用进程被阻塞，内核直到数据到来且将数据从内核缓冲区拷贝到了应用进程缓冲区，然后向用户进程返回结果，用户进程才解除block状态，重新运行起来。</p><p>阻塞模行下只是阻塞了当前的应用进程，其他进程还可以执行，不消耗CPU时间，CPU的利用率较高。</p><h3 id="非阻塞IO（nonblocking-IO）"><a href="#非阻塞IO（nonblocking-IO）" class="headerlink" title="非阻塞IO（nonblocking IO）"></a>非阻塞IO（nonblocking IO）</h3><p>Linux可以设置socket为非阻塞的，非阻塞模式下执行一个读操作流程如下：<br><img src="https://upload-images.jianshu.io/upload_images/14151453-485bfdc370909781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-485bfdc370909781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>当用户进程发出recvfrom系统调用时，如果kernel中的数据还没准备好，recvfrom会立即返回一个error结果，不会阻塞用户进程，用户进程收到error时知道数据还没准备好，过一会再调用recvfrom，直到kernel中的数据准备好了，内核就立即将数据拷贝到用户内存然后返回ok，这个过程需要用户进程去轮询内核数据是否准备好。</p><p>非阻塞模型下由于要处理更多的系统调用，因此CPU利用率比较低。</p><h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p>应用进程使用sigaction系统调用，内核立即返回，等到kernel数据准备好时会给用户进程发送一个信号，告诉用户进程可以进行IO操作了，然后用户进程再调用IO系统调用如recvfrom，将数据从内核缓冲区拷贝到应用进程。流程如下：<br><img src="https://upload-images.jianshu.io/upload_images/14151453-1f14b7a7da55a2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-1f14b7a7da55a2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>相比于轮询的方式，不需要多次系统调用轮询，信号驱动IO的CPU利用率更高。</p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>异步IO模型与其他模型最大的区别是，异步IO在系统调用返回的时候所有操作都已经完成，应用进程既不需要等待数据准备，也不需要在数据到来后等待数据从内核缓冲区拷贝到用户缓冲区，流程如下：<br><img src="https://upload-images.jianshu.io/upload_images/14151453-95971297cce5bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-95971297cce5bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="><br>在数据拷贝完成后，kernel会给用户进程发送一个信号告诉其read操作完成了。</p><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>是用select、poll等待数据，可以等待多个socket中的任一个变为可读，这一过程会被阻塞，当某个套接字数据到来时返回，之后再用recvfrom系统调用把数据从内核缓存区复制到用户进程，流程如下：<br><img src="https://upload-images.jianshu.io/upload_images/14151453-8845990e0d75eb9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-8845990e0d75eb9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>流程类似阻塞IO，甚至比阻塞IO更差，多使用了一个系统调用，但是IO多路复用最大的特点是让单个进程能同时处理多个IO事件的能力，又被称为事件驱动IO，相比于多线程模型，IO复用模型不需要线程的创建、切换、销毁，系统开销更小，适合高并发的场景。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select是IO多路复用模型的一种实现，当select函数返回后可以通过轮询fdset来找到就绪的socket。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span><br></pre></td></tr></table></figure><p>优点是几乎所有平台都支持，缺点在于能够监听的fd数量有限，Linux系统上一般为1024，是写死在宏定义中的，要修改需要重新编译内核。而且每次都要把所有的fd在用户空间和内核空间拷贝，这个操作是比较耗时的。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll和select基本相同，不同的是poll没有最大fd数量限制（实际也会受到物理资源的限制，因为系统的fd数量是有限的），而且提供了更多的时间类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">int</span> nfds, <span class="type">int</span> timeout)</span></span><br></pre></td></tr></table></figure><p>总结：select和poll都需要在返回后通过轮询的方式检查就绪的socket，事实上同时连的大量socket在一个时刻只有很少的处于就绪状态，因此随着监视的描述符数量的变多，其性能也会逐渐下降。</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll是select和poll的改进版本，更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span><br></pre></td></tr></table></figure><p>epoll_create()用来创建一个epoll句柄。<br>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I&#x2F;O 准备好的描述符加入到一个就绪链表中管理。<br> epoll_wait() 可以从就绪链表中得到事件完成的描述符，因此进程不需要通过轮询来获得事件完成的描述符。</p><h5 id="LT模式（水平触发，默认）"><a href="#LT模式（水平触发，默认）" class="headerlink" title="LT模式（水平触发，默认）"></a>LT模式（水平触发，默认）</h5><p>当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序可以不立即处理该事件，下次调用epoll_wait还会再次通知该事件，支持block和nonblocking socket。</p><h5 id="ET模式（边缘触发）"><a href="#ET模式（边缘触发）" class="headerlink" title="ET模式（边缘触发）"></a>ET模式（边缘触发）</h5><p>当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序需要立即处理该事件，如果不立即处理，下次调用epoll_wait不会再次通知该事件。</p><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用nonblocking socket，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p>select的timeout参数精度为微妙，而poll和epoll都是毫秒，会因此select更加适合对实时性要求比较高的场景</p></li><li><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p></li><li><p>epoll适合高并发的场景，有大量描述符需要同时监听，并且最好是长连接。<br>不适合监控的描述符状态变化频繁且短暂，因为epoll的描述符都存在内核中，每次对其状态修改都要通过epoll_ctl系统调用来实现，频繁的系统调用导致频繁在内核态和用户态切换，会大大降低性能。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>【segmentfault】<a href="https://segmentfault.com/a/1190000003063859">Linux IO模式及 select、poll、epoll详解</a><br>【GitHub】<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md#%E4%B8%80io-%E6%A8%A1%E5%9E%8B">CyC2018&#x2F;CS-Notes</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念说明&quot;&gt;&lt;a href=&quot;#基本概念说明&quot; class=&quot;headerlink&quot; title=&quot;基本概念说明&quot;&gt;&lt;/a&gt;基本概念说明&lt;/h2&gt;&lt;p&gt;理解Linux的IO模型之前，首先要了解一些基本概念，才能理解这些IO模型设计的依据&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="操作系统" scheme="https://harryzhang.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://harryzhang.cn/tags/Linux/"/>
    
    <category term="I/O模型" scheme="https://harryzhang.cn/tags/I-O%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="select/poll/epoll" scheme="https://harryzhang.cn/tags/select-poll-epoll/"/>
    
  </entry>
  
  <entry>
    <title>算法(8): LRU 策略</title>
    <link href="https://harryzhang.cn/2023/03/19/%E7%AE%97%E6%B3%95-8-LRU-%E7%AD%96%E7%95%A5/"/>
    <id>https://harryzhang.cn/2023/03/19/%E7%AE%97%E6%B3%95-8-LRU-%E7%AD%96%E7%95%A5/</id>
    <published>2023-03-19T13:58:05.000Z</published>
    <updated>2023-03-19T14:00:33.583Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/lru-cache/">LeetCode No.146 LRU缓存机制</a></p><p>LRU（Least Recent Used）策略：优先淘汰最近最少使用的数据，常用于缓存淘汰机制，如Linux系统的内存淘汰、Redis的缓存淘汰等。</p><h2 id="基于哈希表和双向链表实现LRU"><a href="#基于哈希表和双向链表实现LRU" class="headerlink" title="基于哈希表和双向链表实现LRU"></a>基于哈希表和双向链表实现LRU</h2><p>核心思路是，利用双向链表存储键值对，哈希表存储键在链表中对应的节点指针，如下图所示<br><img src="https://upload-images.jianshu.io/upload_images/14151453-0372ff8cff5afd07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/14151453-0372ff8cff5afd07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这样的好处是使访问和更新操作时间复杂度都在O(1)。</p><h3 id="PUT操作"><a href="#PUT操作" class="headerlink" title="PUT操作"></a>PUT操作</h3><ul><li>判断哈希表中key是否已存在，如果存在为修改操作：<ol><li>将链表节点修改为新的键值对</li><li>将节点移到头部</li></ol></li><li>如果不存在为新增操作，此时如果容量已满，需要淘汰数据<ol><li>取出链表尾节点，删除哈希表中对应key</li><li>删除链表尾节点</li><li>在链表头部添加新的节点</li><li>将新的链表头节点加到哈希表</li></ol></li><li>如果容量没有满，直接添加节点，执行上述步骤3、4即可</li></ul><h3 id="GET操作"><a href="#GET操作" class="headerlink" title="GET操作"></a>GET操作</h3><ul><li>判断哈希表中key是否存在，如果存在将节点移动到链表头部，返回对应的值</li><li>如果不存在直接返回nil值</li></ul><h3 id="Go语言实现"><a href="#Go语言实现" class="headerlink" title="Go语言实现"></a>Go语言实现</h3><p>使用Go内建map类型和container包的list（双向链表）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/list&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pair <span class="keyword">struct</span> &#123;</span><br><span class="line">key <span class="type">int</span></span><br><span class="line">val <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="built_in">cap</span> <span class="type">int</span></span><br><span class="line">list *list.List</span><br><span class="line">kv <span class="keyword">map</span>[<span class="type">int</span>]*list.Element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line"><span class="built_in">cap</span>: capacity,</span><br><span class="line">list: list.New(),</span><br><span class="line">kv: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*list.Element),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v, ok := this.kv[key]; ok == <span class="literal">true</span> &#123;</span><br><span class="line">this.list.MoveToFront(v)</span><br><span class="line"><span class="keyword">return</span> v.Value.(Pair).val</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>)  &#123;</span><br><span class="line"><span class="keyword">if</span> elem, ok := this.kv[key]; ok == <span class="literal">true</span> &#123;</span><br><span class="line">elem.Value = Pair&#123;key: key, val: value&#125;</span><br><span class="line">this.list.MoveToFront(elem)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> this.list.Len() &gt;= this.<span class="built_in">cap</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(this.kv, this.list.Back().Value.(Pair).key)</span><br><span class="line">this.list.Remove(this.list.Back())</span><br><span class="line">&#125;</span><br><span class="line">this.list.PushFront(Pair&#123;key: key, val: value&#125;)</span><br><span class="line">this.kv[key] = this.list.Front()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/lru-cache/&quot;&gt;LeetCode No.146 LRU缓存机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LRU（Least Recent Used）策略：优先淘汰最近最少使用的数据，常用于缓存淘汰机制</summary>
      
    
    
    
    <category term="算法" scheme="https://harryzhang.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://harryzhang.cn/tags/leetcode/"/>
    
    <category term="LRU" scheme="https://harryzhang.cn/tags/LRU/"/>
    
    <category term="缓存" scheme="https://harryzhang.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>算法(7): 动态规划</title>
    <link href="https://harryzhang.cn/2023/03/19/%E7%AE%97%E6%B3%95-7-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://harryzhang.cn/2023/03/19/%E7%AE%97%E6%B3%95-7-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2023-03-19T13:56:37.000Z</published>
    <updated>2023-03-19T13:57:12.016Z</updated>
    
    <content type="html"><![CDATA[<ul><li>动态规划的关键思想在于将问题转换成较小的子问题，然后根据子问题的结果总结出一个状态转移方程，最后得到整个问题的解</li></ul><h3 id="7-1-打家劫舍"><a href="#7-1-打家劫舍" class="headerlink" title="7.1 打家劫舍"></a>7.1 打家劫舍</h3><p><a href="https://leetcode-cn.com/problems/house-robber/">LeetCode No.198</a></p><blockquote><p>问题描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<br>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p></blockquote><p><strong>思路</strong>：当设选第i个房屋，则不能选i-1，假设dp[i]表示前i个房屋能偷到的最高金额，则有 dp[i] &#x3D; max(dp[i - 1], dp[i - 2] + nums[i])</p><p><code>示例代码：</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    ans := dp[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> ans &lt; dp[i] &#123;</span><br><span class="line">            ans = dp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-1-1-打家劫舍2"><a href="#7-1-1-打家劫舍2" class="headerlink" title="7.1-1 打家劫舍2"></a>7.1-1 打家劫舍2</h3><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">LeetCode No.213</a></p><blockquote><p>问题描述：房屋变成了环形排列，其他和7.1相同</p></blockquote><p><strong>思路</strong>：环形排列后，第一个和最后一个不能同时偷，可以转化为[0, n-1]和[1, n]两个单排街道较大值。同时，可以看到第i个问题的最大值只和第i-1和i-2有关，可以只用两个值来保存前两个结果，降低空间复杂度。</p><p><code>示例代码：</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(dorob(nums[<span class="number">1</span>:]), dorob(nums[:n<span class="number">-1</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dorob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    fisrt, second := nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    ans := second</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">        fisrt, second = second, max(fisrt + nums[i], second)</span><br><span class="line">        <span class="keyword">if</span> second &gt; ans &#123;</span><br><span class="line">            ans = second</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-分割等和子集"><a href="#7-2-分割等和子集" class="headerlink" title="7.2 分割等和子集"></a>7.2 分割等和子集</h3><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">LeetCode No.416</a></p><blockquote><p>问题描述：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>输入: [1, 5, 11, 5]<br>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11]</p></blockquote><p><strong>思路</strong>：如果数组大小为奇数，结果必为false。然后该问题可以转化为背包大小为sum&#x2F;2的0-1背包问题，如果恰好能装满则结果为true。</p><p><code>示例代码：</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    W := sum &gt;&gt; <span class="number">1</span></span><br><span class="line">    dp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="comment">// 这里进行了空间优化，需要从后向前算，否则计算后面的时候前面的值已经改过，不是上一层的值了。</span></span><br><span class="line">        <span class="comment">// dp[i][w] = dp[i - 1][w] || dp[i-1][w-v]</span></span><br><span class="line">        <span class="keyword">for</span> i := W; i &gt;= n; i-- &#123;</span><br><span class="line">            dp[i] = dp[i] || dp[i - n]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-青蛙过河"><a href="#7-3-青蛙过河" class="headerlink" title="7.3 青蛙过河"></a>7.3 青蛙过河</h3><p><a href="https://leetcode-cn.com/problems/frog-jump/">LeetCode No.403</a></p><blockquote><p>题目描述：一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。<br>给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。<br>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。<br><strong>输入</strong>：[0,1,3,5,6,8,12,17]<br>总共有8个石子。<br>第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,<br>第三个石子在序号为3的单元格的位置， 以此定义整个数组…<br>最后一个石子处于序号为17的单元格的位置。<br><strong>输出</strong>： true。即青蛙可以成功过河，按照如下方案跳跃：<br>跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着<br>跳2个单位到第4块石子, 然后跳3个单位到第6块石子,<br>跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。</p></blockquote><p><strong>思路</strong>：参考官方题解动态规划的方法，使用dmap[curpos] &#x3D; {jumps}表示到达当前curpos可以由jumps集合的任意一个步长一次到达当前位置，对于dmap[0] &#x3D; {0}，依次遍历每个石头的位置，对每个位置pos遍历jumps集合，对每个jump遍历k &#x3D; [jump-1，jump+1]，如果当前位置跳k补可以到达某个石头的位置（dmap中的存在key&#x3D;curpos+k），则将k添加到dmap[curpos+k]的集合。</p><p><code>示例代码：</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canCross</span><span class="params">(stones []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 用集合模拟set，只需要键值当做集合的元素，value设为空结构</span></span><br><span class="line">dmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">dmap[<span class="number">0</span>] = <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;<span class="number">0</span>: &#123;&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(stones); i++ &#123;</span><br><span class="line">dmap[stones[i]] = <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, cur_pos := <span class="keyword">range</span> stones &#123;</span><br><span class="line">steps := dmap[cur_pos]</span><br><span class="line"><span class="keyword">for</span> step, _ := <span class="keyword">range</span> steps &#123;</span><br><span class="line"><span class="keyword">for</span> k := step - <span class="number">1</span>; k &lt;= step + <span class="number">1</span>; k++ &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := dmap[cur_pos + k]; ok == <span class="literal">true</span> &amp;&amp; k &gt; <span class="number">0</span> &#123;</span><br><span class="line">dmap[cur_pos + k][k] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(dmap[stones[<span class="built_in">len</span>(stones) - <span class="number">1</span>]]) != <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-编辑距离"><a href="#7-4-编辑距离" class="headerlink" title="7.4 编辑距离"></a>7.4 编辑距离</h3><p><a href="https://leetcode-cn.com/problems/edit-distance/">LeetCode No.72</a></p><blockquote><p>题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。</p></blockquote><p><strong>思路</strong>：使用dp[i][j]表示从word1[:i]转换为word2[:j]需要的最少次数，对于任意一个单词为空，所需次数为另一个单词的长度，只能通过增或删来达到相同。对于dp[i][j]，dp[i-1][j]表示从word2中删除一个字符得到，dp[i][j - 1]表示从word1中增加一个字符得到，dp[i-1][j-1]表示从word1中修改一个字符得到，对于word1[i] &#x3D;&#x3D; word2[j]则不需要修改。那么dp[i][j]只能为上述三种情况的最小值。所以有状态转移方程：</p><ul><li>当word1[i] &#x3D;&#x3D; word2[j]时 dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1)</li><li>当word1[i] !&#x3D; word2[j]时 dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1</li></ul><p><code>示例代码：</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDistance</span><span class="params">(word1 <span class="type">string</span>, word2 <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">LFROM, LTO := <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="type">int</span>, LFROM + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= LFROM; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, LTO + <span class="number">1</span>)</span><br><span class="line">dp[i][<span class="number">0</span>] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= LTO; j++ &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = j</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= LFROM; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= LTO; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>] &#123;</span><br><span class="line">dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[LFROM][LTO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;动态规划的关键思想在于将问题转换成较小的子问题，然后根据子问题的结果总结出一个状态转移方程，最后得到整个问题的解&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;7-1-打家劫舍&quot;&gt;&lt;a href=&quot;#7-1-打家劫舍&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="算法" scheme="https://harryzhang.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://harryzhang.cn/tags/leetcode/"/>
    
    <category term="动态规划" scheme="https://harryzhang.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法(6): 贪心算法</title>
    <link href="https://harryzhang.cn/2023/03/19/%E7%AE%97%E6%B3%95-6-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>https://harryzhang.cn/2023/03/19/%E7%AE%97%E6%B3%95-6-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2023-03-19T13:55:40.000Z</published>
    <updated>2023-03-19T13:56:25.642Z</updated>
    
    <content type="html"><![CDATA[<p>分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。</p><h2 id="5-1-不同的二叉搜索树"><a href="#5-1-不同的二叉搜索树" class="headerlink" title="5.1 不同的二叉搜索树"></a>5.1 不同的二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">LeetCode No.95</a></p><blockquote><p>问题描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p></blockquote><p><strong>思路</strong>：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1…n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。</p><p><code>示例代码：</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateTrees</span><span class="params">(n <span class="type">int</span>)</span></span> []*TreeNode &#123;</span><br><span class="line"><span class="keyword">return</span> _generateTrees(<span class="number">1</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">generateTrees</span><span class="params">(start, end <span class="type">int</span>)</span></span> []*TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> start &gt; end &#123;</span><br><span class="line"><span class="keyword">return</span> []*TreeNode&#123;<span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">res := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">left := _generateTrees(start, i - <span class="number">1</span>)</span><br><span class="line">right := _generateTrees(i + <span class="number">1</span>, end)</span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> left &#123;</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> right &#123;</span><br><span class="line">tmp := &amp;TreeNode&#123;</span><br><span class="line">Val: i,</span><br><span class="line">Left: l,</span><br><span class="line">Right: r,</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-为运算表达式设计优先级"><a href="#5-2-为运算表达式设计优先级" class="headerlink" title="5.2 为运算表达式设计优先级"></a>5.2 为运算表达式设计优先级</h2><p><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">LeetCode No.241</a></p><blockquote><p>题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p></blockquote><p><strong>思路</strong>：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。</p><p><code>示例代码：</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">diffWaysToCompute</span><span class="params">(expression <span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">num, err := strconv.Atoi(expression)</span><br><span class="line"><span class="comment">// 如果为纯数字，直接返回数字</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;num&#125;</span><br><span class="line">&#125;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> expression &#123;</span><br><span class="line"><span class="comment">// 跳过非运算符</span></span><br><span class="line"><span class="keyword">if</span> ch != <span class="string">&#x27;+&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算运算符左右两边子表达式的结果</span></span><br><span class="line">left := diffWaysToCompute(expression[ : i])</span><br><span class="line">right := diffWaysToCompute(expression[i + <span class="number">1</span> : ])</span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> left &#123;</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> right &#123;</span><br><span class="line"><span class="keyword">var</span> tmp <span class="type">int</span></span><br><span class="line"><span class="keyword">switch</span> ch &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: tmp = l + r</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: tmp = l - r</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: tmp = l * r</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。&lt;/p&gt;
&lt;h2 id=&quot;5-1-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#5-1-不同的二叉搜索树&quot; class=&quot;header</summary>
      
    
    
    
    <category term="算法" scheme="https://harryzhang.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://harryzhang.cn/tags/leetcode/"/>
    
    <category term="贪心" scheme="https://harryzhang.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>算法(5): 分治/归并</title>
    <link href="https://harryzhang.cn/2023/03/19/%E7%AE%97%E6%B3%95-5-%E5%88%86%E6%B2%BB-%E5%BD%92%E5%B9%B6/"/>
    <id>https://harryzhang.cn/2023/03/19/%E7%AE%97%E6%B3%95-5-%E5%88%86%E6%B2%BB-%E5%BD%92%E5%B9%B6/</id>
    <published>2023-03-19T13:54:37.000Z</published>
    <updated>2023-03-19T13:55:12.104Z</updated>
    
    <content type="html"><![CDATA[<p>分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。</p><h2 id="5-1-不同的二叉搜索树"><a href="#5-1-不同的二叉搜索树" class="headerlink" title="5.1 不同的二叉搜索树"></a>5.1 不同的二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">LeetCode No.95</a></p><blockquote><p>问题描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p></blockquote><p><strong>思路</strong>：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1…n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。</p><p><code>示例代码：</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateTrees</span><span class="params">(n <span class="type">int</span>)</span></span> []*TreeNode &#123;</span><br><span class="line"><span class="keyword">return</span> _generateTrees(<span class="number">1</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">generateTrees</span><span class="params">(start, end <span class="type">int</span>)</span></span> []*TreeNode &#123;</span><br><span class="line"><span class="keyword">if</span> start &gt; end &#123;</span><br><span class="line"><span class="keyword">return</span> []*TreeNode&#123;<span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">res := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">left := _generateTrees(start, i - <span class="number">1</span>)</span><br><span class="line">right := _generateTrees(i + <span class="number">1</span>, end)</span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> left &#123;</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> right &#123;</span><br><span class="line">tmp := &amp;TreeNode&#123;</span><br><span class="line">Val: i,</span><br><span class="line">Left: l,</span><br><span class="line">Right: r,</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-为运算表达式设计优先级"><a href="#5-2-为运算表达式设计优先级" class="headerlink" title="5.2 为运算表达式设计优先级"></a>5.2 为运算表达式设计优先级</h2><p><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">LeetCode No.241</a></p><blockquote><p>题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p></blockquote><p><strong>思路</strong>：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。</p><p><code>示例代码：</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">diffWaysToCompute</span><span class="params">(expression <span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">num, err := strconv.Atoi(expression)</span><br><span class="line"><span class="comment">// 如果为纯数字，直接返回数字</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">int</span>&#123;num&#125;</span><br><span class="line">&#125;</span><br><span class="line">res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> expression &#123;</span><br><span class="line"><span class="comment">// 跳过非运算符</span></span><br><span class="line"><span class="keyword">if</span> ch != <span class="string">&#x27;+&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算运算符左右两边子表达式的结果</span></span><br><span class="line">left := diffWaysToCompute(expression[ : i])</span><br><span class="line">right := diffWaysToCompute(expression[i + <span class="number">1</span> : ])</span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> left &#123;</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> right &#123;</span><br><span class="line"><span class="keyword">var</span> tmp <span class="type">int</span></span><br><span class="line"><span class="keyword">switch</span> ch &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: tmp = l + r</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: tmp = l - r</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: tmp = l * r</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。&lt;/p&gt;
&lt;h2 id=&quot;5-1-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#5-1-不同的二叉搜索树&quot; class=&quot;header</summary>
      
    
    
    
    <category term="算法" scheme="https://harryzhang.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://harryzhang.cn/tags/leetcode/"/>
    
    <category term="二叉搜索树" scheme="https://harryzhang.cn/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
</feed>
