{"meta":{"title":"Harry 的个人空间","subtitle":"","description":"","author":"harry zhang","url":"https://harryzhz.github.io","root":"/"},"pages":[{"title":"about","date":"2023-03-12T16:11:09.000Z","updated":"2023-03-15T16:00:23.237Z","comments":true,"path":"about/index.html","permalink":"https://harryzhz.github.io/about/index.html","excerpt":"","text":"平平无奇"},{"title":"全部标签","date":"2023-03-19T05:57:02.000Z","updated":"2023-03-19T06:45:08.655Z","comments":true,"path":"tags/index.html","permalink":"https://harryzhz.github.io/tags/index.html","excerpt":"","text":""},{"title":"全部分类","date":"2023-03-19T05:56:46.000Z","updated":"2023-03-19T06:44:59.152Z","comments":true,"path":"categories/index.html","permalink":"https://harryzhz.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2023-03-19T05:57:22.000Z","updated":"2023-03-19T06:46:31.862Z","comments":true,"path":"friends/index.html","permalink":"https://harryzhz.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux 系统 I/O 模型及 select/poll/epoll 详解","slug":"Linux-系统-I-O-模型及-select-poll-epoll-详解","date":"2023-03-19T14:06:15.000Z","updated":"2023-03-19T14:07:53.184Z","comments":true,"path":"2023/03/19/Linux-系统-I-O-模型及-select-poll-epoll-详解/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/Linux-%E7%B3%BB%E7%BB%9F-I-O-%E6%A8%A1%E5%9E%8B%E5%8F%8A-select-poll-epoll-%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"基本概念说明理解Linux的IO模型之前，首先要了解一些基本概念，才能理解这些IO模型设计的依据 用户空间和内核空间操作系统使用虚拟内存来映射物理内存，对于32位的操作系统来说，虚拟地址空间为4G（2^32）。操作系统的核心是内核，为了保护用户进程不能直接操作内核，保证内核安全，操作系统将虚拟地址空间划分为内核空间和用户空间。内核可以访问全部的地址空间，拥有访问底层硬件设备的权限，普通的应用程序需要访问硬件设备必须通过系统调用来实现。 对于Linux系统来说，将虚拟内存的最高1G字节的空间作为内核空间仅供内核使用，低3G字节的空间供用户进程使用，称为用户空间。 进程的状态 就绪 阻塞 运行 进程切换文件描述符fd缓存I&#x2F;O又被称为标准I&#x2F;O，大多数文件系统的默认I&#x2F;O都是缓存I&#x2F;O。在Linux系统的缓存I&#x2F;O机制中，操作系统会将I&#x2F;O的数据缓存在页缓存（内存）中，也就是数据先被拷贝到内核的缓冲区（内核地址空间），然后才会从内核缓冲区拷贝到应用程序的缓冲区（用户地址空间）。 这种方式很明显的缺点就是数据传输过程中需要再应用程序地址空间和内核空间进行多次数据拷贝操作，这些操作带来的CPU以及内存的开销是非常大的。 二I&#x2F;O模式由于Linux系统采用的缓存I&#x2F;O模式，对于一次I&#x2F;O访问，以读操作举例，数据先会被拷贝到内核缓冲区，然后才会从内核缓冲区拷贝到应用程序的缓存区，当一个read系统调用发生的时候，会经历两个阶段： 等待数据到来，进程处于阻塞状态 当数据准备就绪后，将数据从内核拷贝到用户进程，进程处于运行状态 正是因为这两个状态，Linux系统才产生了多种不同的网络I&#x2F;O模式的方案 Linux系统I&#x2F;O模型阻塞IO（blocking IO）Linux系统默认情况下所有socke都是blocking的，一个读操作流程如下： 以UDP socket为例，当用户进程调用了recvfrom系统调用，如果数据还没准备好，应用进程被阻塞，内核直到数据到来且将数据从内核缓冲区拷贝到了应用进程缓冲区，然后向用户进程返回结果，用户进程才解除block状态，重新运行起来。 阻塞模行下只是阻塞了当前的应用进程，其他进程还可以执行，不消耗CPU时间，CPU的利用率较高。 非阻塞IO（nonblocking IO）Linux可以设置socket为非阻塞的，非阻塞模式下执行一个读操作流程如下： 当用户进程发出recvfrom系统调用时，如果kernel中的数据还没准备好，recvfrom会立即返回一个error结果，不会阻塞用户进程，用户进程收到error时知道数据还没准备好，\b过一会再调用recvfrom，直到kernel中的数据准备好了，内核就立即将数据拷贝到用户内存然后返回ok，这个过程需要用户进程去轮询内核数据是否准备好。 非阻塞模型下由于要处理更多的系统调用，因此CPU利用率比较低。 信号驱动IO应用进程使用sigaction系统调用，内核立即返回，等到kernel数据准备好时会给用户进程发送一个信号，告诉用户进程可以进行IO操作了，然后用户进程再调用IO系统调用如recvfrom，将数据从内核缓冲区拷贝到应用进程。流程如下： 相比于轮询的方式，不需要多次系统调用轮询，信号驱动IO的CPU利用率更高。 异步IO异步IO模型与其他模型最大的区别是，异步IO在系统调用返回的时候所有操作都已经完成，应用进程既不需要等待数据准备，也不需要在数据到来后等待数据从内核缓冲区拷贝到用户缓冲区，流程如下：在数据拷贝完成后，kernel会给用户进程发送一个信号告诉其read操作完成了。 IO多路复用是用select、poll等待数据，可以等待多个socket中的任一个变为可读，这一过程会被阻塞，当某个套接字数据到来时返回，之后再用recvfrom系统调用把数据从内核缓存区复制到用户进程，流程如下： 流程类似阻塞IO，甚至比阻塞IO更差，多使用了一个系统调用，但是IO多路复用最大的特点是让单个进程能同时处理多个IO事件的能力，又被称为事件驱动IO，相比于多线程模型，IO复用模型不需要线程的创建、切换、销毁，系统开销更小，适合高并发的场景。 selectselect是IO多路复用模型的一种实现，当select函数返回后可以通过轮询fdset来找到就绪的socket。 1int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout) 优点是几乎所有平台都支持，缺点在于能够监听的fd数量有限，Linux系统上一般为1024，是写死在宏定义中的，要修改需要重新编译内核。而且每次都要把所有的fd在用户空间和内核空间拷贝，这个操作是比较耗时的。 pollpoll和select基本相同，不同的是poll没有最大fd数量限制（实际也会受到物理资源的限制，因为系统的fd数量是有限的），而且提供了更多的时间类型。 1int poll(struct pollfd *fds, unsigned int nfds, int timeout) 总结：select和poll都需要在返回后通过轮询的方式检查就绪的socket，事实上同时连的大量socket在一个时刻只有很少的处于就绪状态，因此随着监视的描述符数量的变多，其性能也会逐渐下降。 epollepoll是select和poll的改进版本，更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。 123int epoll_create(int size)int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout) epoll_create()用来创建一个epoll句柄。epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I&#x2F;O 准备好的描述符加入到一个就绪链表中管理。 epoll_wait() 可以从就绪链表中得到事件完成的描述符，因此进程不需要通过轮询来获得事件完成的描述符。 LT模式（水平触发，默认）当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序可以不立即处理该事件，下次调用epoll_wait还会再次通知该事件，支持block和nonblocking socket。 ET模式（边缘触发）当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序需要立即处理该事件，如果不立即处理，下次调用epoll_wait不会再次通知该事件。 ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用nonblocking socket，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。 应用场景 select的timeout参数精度为微妙，而poll和epoll都是毫秒，会因此select更加适合对实时性要求比较高的场景 poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。 epoll适合高并发的场景，有大量描述符需要同时监听，并且最好是长连接。不适合监控的描述符状态变化频繁且短暂，因为epoll的描述符都存在内核中，每次对其状态修改都要通过epoll_ctl系统调用来实现，频繁的系统调用导致频繁在内核态和用户态切换，会大大降低性能。 参考【segmentfault】Linux IO模式及 select、poll、epoll详解【GitHub】CyC2018&#x2F;CS-Notes","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://harryzhz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://harryzhz.github.io/tags/Linux/"},{"name":"I/O模型","slug":"I-O模型","permalink":"https://harryzhz.github.io/tags/I-O%E6%A8%A1%E5%9E%8B/"},{"name":"select/poll/epoll","slug":"select-poll-epoll","permalink":"https://harryzhz.github.io/tags/select-poll-epoll/"}]},{"title":"算法(8): LRU 策略","slug":"算法-8-LRU-策略","date":"2023-03-19T13:58:05.000Z","updated":"2023-03-19T14:00:33.583Z","comments":true,"path":"2023/03/19/算法-8-LRU-策略/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/%E7%AE%97%E6%B3%95-8-LRU-%E7%AD%96%E7%95%A5/","excerpt":"","text":"LeetCode No.146 LRU缓存机制 LRU（Least Recent Used）策略：优先淘汰最近最少使用的数据，常用于缓存淘汰机制，如Linux系统的内存淘汰、Redis的缓存淘汰等。 基于哈希表和双向链表实现LRU核心思路是，利用双向链表存储键值对，哈希表存储键在链表中对应的节点指针，如下图所示 这样的好处是使访问和更新操作时间复杂度都在O(1)。 PUT操作 判断哈希表中key是否已存在，如果存在为修改操作： 将链表节点修改为新的键值对 将节点移到头部 如果不存在为新增操作，此时如果容量已满，需要淘汰数据 取出链表尾节点，删除哈希表中对应key 删除链表尾节点 在链表头部添加新的节点 将新的链表头节点加到哈希表 如果容量没有满，直接添加节点，执行上述步骤3、4即可 GET操作 判断哈希表中key是否存在，如果存在将节点移动到链表头部，返回对应的值 如果不存在直接返回nil值 Go语言实现使用Go内建map类型和container包的list（双向链表） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import ( &quot;container/list&quot;)type Pair struct &#123; key int val int&#125;type LRUCache struct &#123; cap int list *list.List kv map[int]*list.Element&#125;func Constructor(capacity int) LRUCache &#123; return LRUCache&#123; cap: capacity, list: list.New(), kv: make(map[int]*list.Element), &#125;&#125;func (this *LRUCache) Get(key int) int &#123; if v, ok := this.kv[key]; ok == true &#123; this.list.MoveToFront(v) return v.Value.(Pair).val &#125; else &#123; return -1 &#125;&#125;func (this *LRUCache) Put(key int, value int) &#123; if elem, ok := this.kv[key]; ok == true &#123; elem.Value = Pair&#123;key: key, val: value&#125; this.list.MoveToFront(elem) return &#125; if this.list.Len() &gt;= this.cap &#123; delete(this.kv, this.list.Back().Value.(Pair).key) this.list.Remove(this.list.Back()) &#125; this.list.PushFront(Pair&#123;key: key, val: value&#125;) this.kv[key] = this.list.Front()&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://harryzhz.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://harryzhz.github.io/tags/leetcode/"},{"name":"LRU","slug":"LRU","permalink":"https://harryzhz.github.io/tags/LRU/"},{"name":"缓存","slug":"缓存","permalink":"https://harryzhz.github.io/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"算法(7): 动态规划","slug":"算法-7-动态规划","date":"2023-03-19T13:56:37.000Z","updated":"2023-03-19T13:57:12.016Z","comments":true,"path":"2023/03/19/算法-7-动态规划/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/%E7%AE%97%E6%B3%95-7-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划的关键思想在于将问题转换成较小的子问题，然后根据子问题的结果总结出一个状态转移方程，最后得到整个问题的解 7.1 打家劫舍LeetCode No.198 问题描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 思路：当设选第i个房屋，则不能选i-1，假设dp[i]表示前i个房屋能偷到的最高金额，则有 dp[i] &#x3D; max(dp[i - 1], dp[i - 2] + nums[i]) 示例代码： 12345678910111213141516171819func rob(nums []int) int &#123; n := len(nums) if n == 0 &#123; return 0 &#125; if n == 1 &#123; return nums[0] &#125; dp := make([]int, n) dp[0], dp[1] = nums[0], max(nums[0], nums[1]) ans := dp[1] for i := 2; i &lt; n; i++ &#123; dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) if ans &lt; dp[i] &#123; ans = dp[i] &#125; &#125; return ans&#125; 7.1-1 打家劫舍2LeetCode No.213 问题描述：房屋变成了环形排列，其他和7.1相同 思路：环形排列后，第一个和最后一个不能同时偷，可以转化为[0, n-1]和[1, n]两个单排街道较大值。同时，可以看到第i个问题的最大值只和第i-1和i-2有关，可以只用两个值来保存前两个结果，降低空间复杂度。 示例代码： 1234567891011121314151617181920212223func rob(nums []int) int &#123; n := len(nums) if n == 1 &#123; return nums[0] &#125; return max(dorob(nums[1:]), dorob(nums[:n-1]))&#125;func dorob(nums []int) int &#123; n := len(nums) if n == 1 &#123; return nums[0] &#125; fisrt, second := nums[0], max(nums[0], nums[1]) ans := second for i := 2; i &lt; n; i++ &#123; fisrt, second = second, max(fisrt + nums[i], second) if second &gt; ans &#123; ans = second &#125; &#125; return ans&#125; 7.2 分割等和子集LeetCode No.416 问题描述：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11] 思路：如果数组大小为奇数，结果必为false。然后该问题可以转化为背包大小为sum&#x2F;2的0-1背包问题，如果恰好能装满则结果为true。 示例代码： 1234567891011121314151617181920func canPartition(nums []int) bool &#123; sum := 0 for _, n := range nums &#123; sum += n &#125; if sum % 2 != 0 &#123; return false &#125; W := sum &gt;&gt; 1 dp := make(map[int]bool) dp[0] = true for _, n := range nums &#123; // 这里进行了空间优化，需要从后向前算，否则计算后面的时候前面的值已经改过，不是上一层的值了。 // dp[i][w] = dp[i - 1][w] || dp[i-1][w-v] for i := W; i &gt;= n; i-- &#123; dp[i] = dp[i] || dp[i - n] &#125; &#125; return dp[W]&#125; 7.3 青蛙过河LeetCode No.403 题目描述：一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。输入：[0,1,3,5,6,8,12,17]总共有8个石子。第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,第三个石子在序号为3的单元格的位置， 以此定义整个数组…最后一个石子处于序号为17的单元格的位置。输出： true。即青蛙可以成功过河，按照如下方案跳跃：跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着跳2个单位到第4块石子, 然后跳3个单位到第6块石子,跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。 思路：参考官方题解动态规划的方法，使用dmap[curpos] &#x3D; {jumps}表示到达当前curpos可以由jumps集合的任意一个步长一次到达当前位置，对于dmap[0] &#x3D; {0}，依次遍历每个石头的位置，对每个位置pos遍历jumps集合，对每个jump遍历k &#x3D; [jump-1，jump+1]，如果当前位置跳k补可以到达某个石头的位置（dmap中的存在key&#x3D;curpos+k），则将k添加到dmap[curpos+k]的集合。 示例代码： 12345678910111213141516171819func canCross(stones []int) bool &#123; // 用集合模拟set，只需要键值当做集合的元素，value设为空结构 dmap := make(map[int]map[int]struct&#123;&#125;, 0) dmap[0] = map[int]struct&#123;&#125;&#123;0: &#123;&#125;&#125; for i := 1; i &lt; len(stones); i++ &#123; dmap[stones[i]] = map[int]struct&#123;&#125;&#123;&#125; &#125; for _, cur_pos := range stones &#123; steps := dmap[cur_pos] for step, _ := range steps &#123; for k := step - 1; k &lt;= step + 1; k++ &#123; if _, ok := dmap[cur_pos + k]; ok == true &amp;&amp; k &gt; 0 &#123; dmap[cur_pos + k][k] = struct&#123;&#125;&#123;&#125; &#125; &#125; &#125; &#125; return len(dmap[stones[len(stones) - 1]]) != 0&#125; 7.4 编辑距离LeetCode No.72 题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。 思路：使用dp[i][j]表示从word1[:i]转换为word2[:j]需要的最少次数，对于任意一个单词为空，所需次数为另一个单词的长度，只能通过增或删来达到相同。对于dp[i][j]，dp[i-1][j]表示从word2中删除一个字符得到，dp[i][j - 1]表示从word1中增加一个字符得到，dp[i-1][j-1]表示从word1中修改一个字符得到，对于word1[i] &#x3D;&#x3D; word2[j]则不需要修改。那么dp[i][j]只能为上述三种情况的最小值。所以有状态转移方程： 当word1[i] &#x3D;&#x3D; word2[j]时 dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1) 当word1[i] !&#x3D; word2[j]时 dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1 示例代码： 12345678910111213141516171819202122232425262728func min(x, y int) int &#123; if x &lt; y &#123; return x &#125; return y&#125;func minDistance(word1 string, word2 string) int &#123; LFROM, LTO := len(word1), len(word2) dp := make([][]int, LFROM + 1) for i := 0; i &lt;= LFROM; i++ &#123; dp[i] = make([]int, LTO + 1) dp[i][0] = i &#125; for j := 0; j &lt;= LTO; j++ &#123; dp[0][j] = j &#125; for i := 1; i &lt;= LFROM; i++ &#123; for j := 1; j &lt;= LTO; j++ &#123; if word1[i - 1] == word2[j - 1] &#123; dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1) &#125; else &#123; dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1 &#125; &#125; &#125; return dp[LFROM][LTO]&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://harryzhz.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://harryzhz.github.io/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"https://harryzhz.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"算法(6): 贪心算法","slug":"算法-6-贪心算法","date":"2023-03-19T13:55:40.000Z","updated":"2023-03-19T13:56:25.642Z","comments":true,"path":"2023/03/19/算法-6-贪心算法/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/%E7%AE%97%E6%B3%95-6-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","excerpt":"","text":"分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。 5.1 不同的二叉搜索树LeetCode No.95 问题描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。 思路：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1…n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。 示例代码： 12345678910111213141516171819202122232425func generateTrees(n int) []*TreeNode &#123; return _generateTrees(1, n)&#125;func _generateTrees(start, end int) []*TreeNode &#123; if start &gt; end &#123; return []*TreeNode&#123;nil&#125; &#125; res := []*TreeNode&#123;&#125; for i := start; i &lt;= end; i++ &#123; left := _generateTrees(start, i - 1) right := _generateTrees(i + 1, end) for _, l := range left &#123; for _, r := range right &#123; tmp := &amp;TreeNode&#123; Val: i, Left: l, Right: r, &#125; res = append(res, tmp) &#125; &#125; &#125; return res&#125; 5.2 为运算表达式设计优先级LeetCode No.241 题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。 思路：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。 示例代码： 1234567891011121314151617181920212223242526272829func diffWaysToCompute(expression string) []int &#123; num, err := strconv.Atoi(expression) // 如果为纯数字，直接返回数字 if err == nil &#123; return []int&#123;num&#125; &#125; res := []int&#123;&#125; for i, ch := range expression &#123; // 跳过非运算符 if ch != &#x27;+&#x27; &amp;&amp; ch != &#x27;-&#x27; &amp;&amp; ch != &#x27;*&#x27; &#123; continue &#125; // 计算运算符左右两边子表达式的结果 left := diffWaysToCompute(expression[ : i]) right := diffWaysToCompute(expression[i + 1 : ]) for _, l := range left &#123; for _, r := range right &#123; var tmp int switch ch &#123; case &#x27;+&#x27;: tmp = l + r case &#x27;-&#x27;: tmp = l - r case &#x27;*&#x27;: tmp = l * r &#125; res = append(res, tmp) &#125; &#125; &#125; return res&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://harryzhz.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://harryzhz.github.io/tags/leetcode/"},{"name":"贪心","slug":"贪心","permalink":"https://harryzhz.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"算法(5): 分治/归并","slug":"算法-5-分治-归并","date":"2023-03-19T13:54:37.000Z","updated":"2023-03-19T13:55:12.104Z","comments":true,"path":"2023/03/19/算法-5-分治-归并/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/%E7%AE%97%E6%B3%95-5-%E5%88%86%E6%B2%BB-%E5%BD%92%E5%B9%B6/","excerpt":"","text":"分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。 5.1 不同的二叉搜索树LeetCode No.95 问题描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。 思路：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1…n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。 示例代码： 12345678910111213141516171819202122232425func generateTrees(n int) []*TreeNode &#123; return _generateTrees(1, n)&#125;func _generateTrees(start, end int) []*TreeNode &#123; if start &gt; end &#123; return []*TreeNode&#123;nil&#125; &#125; res := []*TreeNode&#123;&#125; for i := start; i &lt;= end; i++ &#123; left := _generateTrees(start, i - 1) right := _generateTrees(i + 1, end) for _, l := range left &#123; for _, r := range right &#123; tmp := &amp;TreeNode&#123; Val: i, Left: l, Right: r, &#125; res = append(res, tmp) &#125; &#125; &#125; return res&#125; 5.2 为运算表达式设计优先级LeetCode No.241 题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。 思路：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。 示例代码： 1234567891011121314151617181920212223242526272829func diffWaysToCompute(expression string) []int &#123; num, err := strconv.Atoi(expression) // 如果为纯数字，直接返回数字 if err == nil &#123; return []int&#123;num&#125; &#125; res := []int&#123;&#125; for i, ch := range expression &#123; // 跳过非运算符 if ch != &#x27;+&#x27; &amp;&amp; ch != &#x27;-&#x27; &amp;&amp; ch != &#x27;*&#x27; &#123; continue &#125; // 计算运算符左右两边子表达式的结果 left := diffWaysToCompute(expression[ : i]) right := diffWaysToCompute(expression[i + 1 : ]) for _, l := range left &#123; for _, r := range right &#123; var tmp int switch ch &#123; case &#x27;+&#x27;: tmp = l + r case &#x27;-&#x27;: tmp = l - r case &#x27;*&#x27;: tmp = l * r &#125; res = append(res, tmp) &#125; &#125; &#125; return res&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://harryzhz.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://harryzhz.github.io/tags/leetcode/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://harryzhz.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"算法(4): 搜索","slug":"算法-4-搜索","date":"2023-03-19T13:52:31.000Z","updated":"2023-03-19T13:53:40.173Z","comments":true,"path":"2023/03/19/算法-4-搜索/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/%E7%AE%97%E6%B3%95-4-%E6%90%9C%E7%B4%A2/","excerpt":"","text":"3.1 深度优先DFS 问题1：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。Input: “23”Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”] 思路：深度优先搜索，从根节点到每个叶子节点的所有路径即结果，深度为子串的长度 示例代码: 1234567891011121314151617181920212223242526272829303132333435var ( letterMap = []string&#123; &quot; &quot;, //0 &quot;&quot;, //1 &quot;abc&quot;, //2 &quot;def&quot;, //3 &quot;ghi&quot;, //4 &quot;jkl&quot;, //5 &quot;mno&quot;, //6 &quot;pqrs&quot;, //7 &quot;tuv&quot;, //8 &quot;wxyz&quot;, //9 &#125; res = []string&#123;&#125;)func letterCombinations(digits string) []string &#123; if digits == &quot;&quot; &#123; return []string&#123;&#125; &#125; res = []string&#123;&#125; dfs(digits, 0, &quot;&quot;) return res&#125;func dfs(digits string, i int, s string) &#123; if i == len(digits) &#123; res = append(res, s) return &#125; curs := letterMap[digits[i] - &#x27;0&#x27;] for _, ch := range curs &#123; dfs(digits, i+1, s + string(ch)) &#125;&#125; 问题2：给定一个数组，要求在这个数组中找出 k 个数之和为 target 的所有组合。Input: nums &#x3D; [1, 0, -1, 0, -2, 2], and target &#x3D; 0.Output: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 思路：深度优先搜索，层数为k。注意去重的处理。 示例代码: 123456789101112131415161718192021222324252627282930313233import &quot;sort&quot;var res = [][]int&#123;&#125;func fourSum(nums []int, target int) [][]int &#123; if len(nums) == 0 &#123; return [][]int&#123;&#125; &#125; sort.Ints(nums) res = [][]int&#123;&#125; r := []int&#123;&#125; dfs_sum(nums, 0, r, target) return res&#125;func dfs_sum(nums []int, i int, r []int, target int) &#123; if i == 4 || 0 == len(nums) &#123; if len(r) &gt;= 4 &amp;&amp; r[0] + r[1] + r[2] + r[3] == target &#123; res = append(res, []int&#123;r[0], r[1], r[2], r[3]&#125;) &#125; return &#125; for j := 0; j &lt; len(nums); j++ &#123; if j &gt; 0 &amp;&amp; nums[j] == nums[j-1] &#123; continue &#125; r = append(r, nums[j]) dfs_sum(nums[j+1:], i + 1, r, target) if len(r) &gt;= 1 &#123; r = r[:len(r)-1] &#125; &#125;&#125; 3.2 宽度优先搜索 BFS宽度优先搜索通常用在求最短路径，按层遍历，第一次满足要求的层数就是最短的路径。BFS需要借助队列来保存每一层的节点，访问过的节点要做标记避免重复访问。 3.2.1 二进制矩阵中的最短路径LeetCode No.1091 题目描述：给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：1 路径途经的所有单元格都的值都是 0 。2 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。畅通路径的长度 是该路径途经的单元格总数。 思路：从左上角开始，遍历所有可以走的方向，BFS方式求到达右下角的最小层数。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243type Pos struct &#123; x, y int&#125;func shortestPathBinaryMatrix(grid [][]int) int &#123; if len(grid) == 0 || len(grid[0]) == 0 &#123; return -1 &#125; M, N := len(grid), len(grid[0]) direction := []Pos&#123;&#123;1, -1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125;&#125; Q := list.New() // 根节点入队 Q.PushBack(Pos&#123;0, 0&#125;) path_len := 0 for Q.Len() != 0 &#123; // 保存当前层的长度 level_size := Q.Len() path_len++ // 依次处理当前层的所有节点 for i := 0; i &lt; level_size; i++ &#123; cur_pos := Q.Front().Value.(Pos) Q.Remove(Q.Front()) if grid[cur_pos.x][cur_pos.y] == 1 &#123; continue &#125; // 如果到达右下角返回结果 if cur_pos.x == (M - 1) &amp;&amp; cur_pos.y == (N - 1) &#123; return path_len &#125; // 访问过的位置标记为1 grid[cur_pos.x][cur_pos.y] = 1 // 遍历所有能走的方向，加入队列 for _, dr := range direction &#123; nx, ny := cur_pos.x + dr.x, cur_pos.y + dr.y if nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N &#123; continue &#125; Q.PushBack(Pos&#123;nx, ny&#125;) &#125; &#125; &#125; return -1&#125; 3.2.2 完全平方数LeetCode No.279 题目描述：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 思路：转化为BFS问题模型，从1到根号n的所有平方数（1，4，9…）为每次所有可能的路径。从n开始遍历，当n&#x3D;0时即为结果。 示例代码： 123456789101112131415161718192021222324252627282930313233func numSquares(n int) int &#123; numsqs := []int&#123;&#125; for i, ii := 1, 1; ii &lt;= n; i, ii = i + 1, (i + 1) * (i + 1)&#123; numsqs = append(numsqs, ii) &#125; mark := map[int]bool&#123;&#125; Q := list.New() Q.PushBack(n) mark[n] = true ans := 0 for Q.Len() != 0 &#123; lv_size := Q.Len() ans++ for i := 0; i &lt; lv_size; i++ &#123; cur := Q.Front().Value.(int) Q.Remove(Q.Front()) for _, nq := range numsqs &#123; if cur == nq &#123; return ans &#125; if cur &lt; nq &#123; break &#125; if mark[cur - nq] &#123; continue &#125; mark[cur - nq] = true Q.PushBack(cur - nq) &#125; &#125; &#125; return n&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://harryzhz.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://harryzhz.github.io/tags/leetcode/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"https://harryzhz.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"https://harryzhz.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]},{"title":"算法(3): 二分查找","slug":"算法-3-二分查找","date":"2023-03-19T13:51:01.000Z","updated":"2023-03-19T13:51:59.644Z","comments":true,"path":"2023/03/19/算法-3-二分查找/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/%E7%AE%97%E6%B3%95-3-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"二分查找是一种在有序列表中查找元素的高效方法，时间复杂度（logN），二分查找思路和时间都比较简单，但是实际问题中的细节不可忽视。 3.1 搜索插入位置LeetCode No.35 问题描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置，你可以假设数组中无重复元素。 思路：按照二分查找法，定义low，high两个指针，结束条件为low &gt; high，如果目标值不存在返回low的位置就是要插入的位置。 示例代码： 12345678910111213141516func searchInsert(nums []int, target int) int &#123; l, h := 0, len(nums) - 1 var m int for l &lt;= h &#123; m = h + l &gt;&gt; 1 if nums[m] == target &#123; return m &#125; if nums[m] &gt; target &#123; h = m - 1 &#125; else &#123; l = m + 1 &#125; &#125; return l&#125; 3.2 搜索旋转排序数组LeetCode No.33 问题描述：整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 思路：进行二分之后的mid位置元素位置可能有两种情况：左边元素的所有元素是有序的，或右边的所有元素是有序的。 如果是左边有序，则nums[mid] &gt; nums[low]，反之是右边有序 在知道是那边有序后即可根据边界和target来选择去左半区还是右半区搜索 示例代码： 1234567891011121314151617181920212223func search(nums []int, target int) int &#123; low, high := 0, len(nums) - 1 for low &lt;= high &#123; mid := (low + high) / 2 if nums[mid] == target &#123; return mid &#125; if nums[mid] &gt;= nums[low] &#123; if target &lt; nums[mid] &amp;&amp; target &gt;= nums[low] &#123; high = mid - 1 &#125; else &#123; low = mid + 1 &#125; &#125; else &#123; if target &gt; nums[mid] &amp;&amp; target &lt;= nums[high] &#123; low = mid + 1 &#125; else &#123; high = mid - 1 &#125; &#125; &#125; return -1&#125; 3.3 排序数组中查找元素的第一个和最后一个位置（有重复元素）LeetCode No.34 问题描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置，如果数组中不存在目标值 target，返回 [-1, -1]。 思路：找到最左边的target位置和target+1最左边的位置-1，要找最左边的target，那么当nums[mid] &gt;&#x3D; target时都要继续往左半区搜索。 示例代码： 123456789101112131415161718192021222324func searchRange(nums []int, target int) []int &#123; ledge := search(nums, target) if ledge == len(nums) || nums[ledge] != target &#123; return []int&#123;-1, -1&#125; &#125; redge := search(nums, target + 1) - 1 return []int&#123;ledge, redge&#125;&#125;func search(nums []int, target int) int &#123; l, r := 0, len(nums) - 1 for l &lt;= r &#123; mid := (l + r) / 2 if nums[mid] &gt;= target &#123; r = mid - 1 if l &gt; r &amp;&amp; nums[mid] == target &#123; return mid &#125; &#125; else &#123; l = mid + 1 &#125; &#125; return l&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://harryzhz.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://harryzhz.github.io/tags/leetcode/"},{"name":"二分查找","slug":"二分查找","permalink":"https://harryzhz.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"算法(2): 排序","slug":"算法-2-排序","date":"2023-03-19T13:43:50.000Z","updated":"2023-03-19T13:50:13.288Z","comments":true,"path":"2023/03/19/算法-2-排序/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/%E7%AE%97%E6%B3%95-2-%E6%8E%92%E5%BA%8F/","excerpt":"","text":"2.1 快速排序 题目描述：实现快速排序 思路：采用交换法，选第一个数为基准数pivot，在pl &lt;&#x3D; pr的前提下，指针pl从基准数+1的位置向右走，直到碰到比pivot大的数，指针pr从最右边向左走，直到碰到比pivot小的数，交换arr[pl], arr[pr]，循环结束时pr &#x3D; pl - 1，将基准数和pr交换。递归调用对基准数位置两边的区间调整。 示例代码： 12345678910111213141516171819202122232425262728func partition(arr []int, left, right int) int &#123; pivot := arr[left] pl, pr := left + 1, right for pl &lt;= pr &#123; for ; pl &lt;= pr &amp;&amp; arr[pl] &lt; pivot; pl++ &#123;&#125; for ; pl &lt;= pr &amp;&amp; arr[pr] &gt; pivot; pr-- &#123;&#125; if pl &lt; pr &#123; arr[pl], arr[pr] = arr[pr], arr[pl] &#125; &#125; // 结束时pr = pl -1 arr[left], arr[pr] = arr[pr], arr[left] return pr&#125;func recursive(arr []int, left, right int) &#123; if left &gt;= right &#123; return &#125; mid := partition(arr, left, right) recursive(arr, left, mid - 1) recursive(arr, mid + 1, right)&#125;func QuickSort(arr []int) []int &#123; recursive(arr, 0, len(arr) - 1) return arr&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://harryzhz.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"快速排序","slug":"快速排序","permalink":"https://harryzhz.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}]},{"title":"算法(1): 双指针","slug":"算法-1-双指针","date":"2023-03-19T13:41:00.000Z","updated":"2023-03-19T14:26:40.107Z","comments":true,"path":"2023/03/19/算法-1-双指针/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/%E7%AE%97%E6%B3%95-1-%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"双指针通常用在有序数组，链表的数据结构上，根据题目条件移动对应的指针。比如判断子串、链表是否有环的问题。 1.1 最长子串LeetCode No.524 题目描述：给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串输入:s &#x3D; “abpcplea”, d &#x3D; [“ale”,”apple”,”monkey”,”plea”]输出:“apple” 思路：本题主要思路是要将删除s中某些字符后和target匹配转化为判断是target是否为s的子串判断是否为子串：使用双指针，如果当前字符相等，两个指针同时+1，否则只有母字符串的指针+1，最后判断目标字符传的指针是否等于其长度即可。参考原文 示例代码： 1234567891011121314151617181920func is_substr(s, target string) bool &#123; j := 0 for i := 0; i &lt; len(s) &amp;&amp; j &lt; len(target); i++ &#123; if s[i] == target[j] &#123; j++ &#125; &#125; return j == len(target)&#125;func findLongestWord(s string, dictionary []string) string &#123; var longest string for _, cur := range dictionary &#123; // 如果当前字符串是s的子串，当当前字符串长度大于目前结果 或 长度相等但是当前串字典序排在前面时更新目前结果 if is_substr(s, cur) &amp;&amp; (len(cur) &gt; len(longest) || len(cur) == len(longest) &amp;&amp; cur &lt; longest) &#123; longest = cur &#125; &#125; return longest&#125; 1.2 两数之和LeetCode No.167 题目描述：给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9输出：[1,2] 思路：因为输入数组有序，那么可以用左右两个指针，初始位于两端，判断当前两数和如果大于target，那么right指针减一，如果小于target，left加一，如果等于就返回。 示例代码: 1234567891011121314func twoSum(numbers []int, target int) []int &#123; for left, right := 0, len(numbers) - 1; left &lt; right; &#123; cur := numbers[left] + numbers[right] if cur == target &#123; return []int&#123;left+1, right+1&#125; &#125; if cur &lt; target &#123; left++ &#125; else &#123; right-- &#125; &#125; return []int&#123;&#125;&#125; 1.3 判断链表是否存在环LeetCode No.141 题目描述：给定一个链表，判断链表中是否有环。 思路：经典解法使用快慢指针，如果存在环两个指针一定会相遇，注意指针空的判断，避免出现野指针。 示例代码： 1234567891011121314func hasCycle(head *ListNode) bool &#123; if head == nil || head.Next == nil &#123; return false &#125; faster, slower := head.Next.Next, head.Next for faster != nil &amp;&amp; faster.Next != nil &amp;&amp; slower != nil &#123; if faster == slower &#123; return true &#125; faster = faster.Next.Next slower = slower.Next &#125; return false&#125; 1.4 接雨水LeetCode No.42 题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 思路：当前柱子能接的雨水数为其左右最高的柱子的较小值减当前柱子的高度 方法1：先求出每个柱子i左边的最大高度left_max[i]，右边最大高度right_max[i]，然后遍历一次计算。时间复杂度T &#x3D; O(3n) 示例代码： 123456789101112131415161718func trap(height []int) int &#123; res, n := 0, len(height) if n == 0 &#123; return res &#125; left_max, right_max := make([]int, n), make([]int, n) left_max[0], right_max[n - 1] = height[0], height[n - 1] for i := 1; i &lt; n; i++ &#123; left_max[i] = max(left_max[i - 1], height[i]) &#125; for i := n - 2; i &gt;= 0; i-- &#123; right_max[i] = max(right_max[i + 1], height[i]) &#125; for i := 0; i &lt; n; i++ &#123; res += min(right_max[i], left_max[i]) - height[i] &#125; return res&#125; 方法2：只需遍历一次的双指针解法，两个指针最终在最高点相遇。 示例代码： 12345678910111213141516171819func trap(height []int) int &#123; res, left, right := 0, 0, len(height) - 1 if right &lt; 0 &#123; return res &#125; left_max, right_max := 0, 0 for left &lt; right &#123; if height[left] &gt; height[right] &#123; right_max = max(right_max, height[right]) res += right_max - height[right] right-- &#125; else &#123; left_max = max(left_max, height[left]) res += left_max - height[left] left++ &#125; &#125; return res&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://harryzhz.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://harryzhz.github.io/tags/leetcode/"}]},{"title":"数据结构(5): 栈|队列|堆","slug":"数据结构-5-栈-队列-堆","date":"2023-03-19T13:39:14.000Z","updated":"2023-03-19T14:11:42.479Z","comments":true,"path":"2023/03/19/数据结构-5-栈-队列-堆/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5-%E6%A0%88-%E9%98%9F%E5%88%97-%E5%A0%86/","excerpt":"","text":"6.1 栈6.1.1用两个栈实现一个队列LeetCode No.232 题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）： 思路： 两个栈一个栈做队头（出元素），另一个栈做队尾（入元素） 每次push只需要push到尾栈 pop时如果头栈为空则将尾栈全部“倒入”头栈，如果头栈不为空取出栈顶元素返回，否则返回失败（此时队列为空）。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657type MyQueue struct &#123; stack_head []int stack_tail []int&#125;/** Initialize your data structure here. */func Constructor() MyQueue &#123; return MyQueue&#123; stack_head: make([]int, 0), stack_tail: make([]int, 0), &#125;&#125;/** Push element x to the back of queue. */func (this *MyQueue) Push(x int) &#123; this.stack_tail = append(this.stack_tail, x)&#125;func(this *MyQueue) tail2head() &#123; for i := len(this.stack_tail) - 1; i &gt;= 0; i-- &#123; this.stack_head = append(this.stack_head, this.stack_tail[i]) this.stack_tail = this.stack_tail[:len(this.stack_tail) - 1] &#125;&#125;/** Removes the element from in front of queue and returns that element. */func (this *MyQueue) Pop() int &#123; if len(this.stack_head) == 0 &#123; this.tail2head() &#125; if len(this.stack_head) &gt; 0 &#123; r := this.stack_head[len(this.stack_head) - 1] this.stack_head = this.stack_head[:len(this.stack_head) - 1] return r &#125; return -1&#125;/** Get the front element. */func (this *MyQueue) Peek() int &#123; if len(this.stack_head) == 0 &#123; this.tail2head() &#125; if len(this.stack_head) &gt; 0 &#123; return this.stack_head[len(this.stack_head) - 1] &#125; return -1&#125;/** Returns whether the queue is empty. */func (this *MyQueue) Empty() bool &#123; return len(this.stack_head) == 0 &amp;&amp; len(this.stack_tail) == 0&#125; 6.1.2 逆波兰表达式求值LeetCode No.150 问题描述：根据 逆波兰表示法，求表达式的值。有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。输入: [“2”, “1”, “+”, “3”, “*”]输出: 9解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9 思路：借助一个栈，如果是数值就入栈，如果是运算符就从栈顶取出两个元素计算，然后将结果入栈，最后栈中只剩一个元素就是结果。 示例代码： 1234567891011121314151617181920212223242526func operate(x, y int, op string) int &#123; switch op &#123; case &quot;+&quot;: return x + y case &quot;-&quot;: return x - y case &quot;*&quot;: return x * y case &quot;/&quot;: return x / y default: return 0 &#125;&#125;func evalRPN(tokens []string) int &#123; stack := []int&#123;&#125; for i := 0; i &lt; len(tokens); i++ &#123; switch tokens[i] &#123; case &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;: cur := operate(stack[len(stack) - 2], stack[len(stack) - 1], tokens[i]) stack = stack[:len(stack) - 1] stack[len(stack) - 1] = cur default: num, _ := strconv.Atoi(tokens[i]) stack = append(stack, num) &#125; &#125; return stack[0]&#125; 6.1.3 中缀表达式生成逆波兰表达式 借助一个符号栈和结果队列，具体过程见代码注释 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859func is_operation(b byte) bool &#123; return b == &#x27;+&#x27; || b == &#x27;-&#x27; || b == &#x27;*&#x27; || b == &#x27;/&#x27;&#125;func compare_priority(a, b byte) int &#123; if (a == &#x27;+&#x27; || a == &#x27;-&#x27;) &amp;&amp; (b == &#x27;*&#x27; || b == &#x27;/&#x27;) &#123; return -1 &#125; else if (b == &#x27;+&#x27; || b == &#x27;-&#x27;) &amp;&amp; (a == &#x27;*&#x27; || a == &#x27;/&#x27;) &#123; return 1 &#125; else &#123; return 0 &#125;&#125;func toRPN(s string) []string &#123; // 运算符栈 ops_stack := []byte&#123;&#125; // 结果队列 res_queue := []string&#123;&#125; n := len(s) for i := 0; i &lt; n; i++ &#123; if s[i] == &#x27;(&#x27; &#123; // 遇到左括号直接入栈 ops_stack = append(ops_stack, s[i]) &#125; else if s[i] == &#x27;)&#x27; &#123; // 遇到右括号，则将栈中的运算符依次弹出加入到结果队列，直到碰到左括号，然后将这对括号丢弃 for ops_stack[len(ops_stack) - 1] != &#x27;(&#x27; &#123; res_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1])) ops_stack = ops_stack[:len(ops_stack) - 1] &#125; ops_stack = ops_stack[:len(ops_stack) - 1] &#125; else if is_operation(s[i]) &#123; // 遇到运算符，当前运算符的优先级小于等于栈顶运算符的优先级，则依次将栈顶弹出加入到结果队列 for len(ops_stack) &gt; 0 &amp;&amp; is_operation(ops_stack[len(ops_stack) - 1]) &amp;&amp; compare_priority(s[i], ops_stack[len(ops_stack) - 1]) &lt;= 0 &#123; res_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1])) ops_stack = ops_stack[:len(ops_stack) - 1] &#125; ops_stack = append(ops_stack, s[i]) &#125; else if s[i] == &#x27; &#x27; &#123; // 跳过空字符 continue &#125; else &#123; // 遇到数字加入到结果队列 num := 0 for ; i &lt; n &amp;&amp; s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;; i++ &#123; num = num * 10 + int(s[i] - &#x27;0&#x27;) &#125; i-- res_queue = append(res_queue, strconv.Itoa(num)) &#125; &#125; // 运算符栈中剩余的元素弹出添加到结果队列 for len(ops_stack) &gt; 0 &#123; res_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1])) ops_stack = ops_stack[:len(ops_stack) - 1] &#125; return res_queue&#125; 6.2 堆定义：最大堆的堆顶为最大元素，最小堆同理 6.2.1 Golang实现堆类型因为go本身没有实现堆类型，只提供了接口，使用时必须实现堆接口才能使用对应的堆方法，所以自己用golang的container&#x2F;heap接口实现一个通用的堆类型，创建堆需要一个比较函数作为参数实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 比较函数类型type Comparator func(a, b interface&#123;&#125;) bool// 堆元素类型type Elements struct &#123; es []interface&#123;&#125; cmp Comparator&#125;// 堆类型type Heap struct &#123; elements *Elements&#125;// 创建堆func NewHeap(cmp Comparator) *Heap &#123; return &amp;Heap&#123; elements: &amp;Elements&#123; es: make([]interface&#123;&#125;, 0), cmp: cmp, &#125;, &#125;&#125;// 堆元素实现了container/heap接口func (e Elements) Len() int &#123; return len(e.es) &#125;func (e Elements) Less(i, j int) bool &#123; return e.cmp(e.es[i], e.es[j]) &#125;func (e Elements) Swap(i, j int) &#123; e.es[i], e.es[j] = e.es[j], e.es[i] &#125;func (e *Elements) Push(item interface&#123;&#125;) &#123; e.es = append(e.es, item) &#125;func (e *Elements) Pop() interface&#123;&#125; &#123; length := len(e.es) if length == 0 &#123; return nil &#125; top := e.es[length - 1] e.es = e.es[:length - 1] return top&#125;// 入堆func (h *Heap) Push(i interface&#123;&#125;) &#123; heap.Push(h.elements, i)&#125;// 堆顶元素出堆func (h *Heap) Pop() interface&#123;&#125; &#123; return heap.Pop(h.elements)&#125;// 查看堆顶元素func (h Heap) Top() interface&#123;&#125; &#123; if len(h.elements.es) == 0 &#123; return nil &#125; return h.elements.es[0]&#125;// 获取堆大小func (h Heap) Len() int &#123; return h.elements.Len()&#125;func CompareInt(a, b interface&#123;&#125;) bool &#123; if a.(int) &gt; b.(int) &#123; return true &#125; return false&#125; 6.2.2 数组中的第K个最大元素LeetCode No.215 问题描述：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素输入: [3,2,1,5,6,4] 和 k &#x3D; 2输出: 5 思路：使用最小堆，首先将前k个元素加入堆作为目前的最大的k个元素，然后遍历剩下的n-k个元素，如果堆顶元素比当前元素小，取出堆顶，将当前元素加入堆。最后堆顶的元素即为第k大的元素。时间复杂度：O(n*log(n))空间复杂度：O(k) 示例代码： 12345678910111213141516func findKthLargest(nums []int, k int) int &#123; heap1:= NewHeap(CompareInt) // 前k个元素建立大小为k的小顶堆 for i := 0; i &lt; k; i++ &#123; heap1.Push(nums[i]) &#125; // 遍历剩余的元素更新堆 for i := k; i &lt; len(nums); i++ &#123; top := heap1.Top().(int) if top &gt; nums[i] &#123; heap1.Pop() heap1.Push(nums[i]) &#125; &#125; return heap1.Top().(int)&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://harryzhz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://harryzhz.github.io/tags/leetcode/"},{"name":"栈","slug":"栈","permalink":"https://harryzhz.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://harryzhz.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"堆","slug":"堆","permalink":"https://harryzhz.github.io/tags/%E5%A0%86/"}]},{"title":"数据结构(4): 树","slug":"数据结构-4-树","date":"2023-03-19T13:36:55.000Z","updated":"2023-03-19T14:11:44.657Z","comments":true,"path":"2023/03/19/数据结构-4-树/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4-%E6%A0%91/","excerpt":"","text":"4.1 根据前序与中序序列构造二叉树LeetCode No.105 问题描述：根据一棵树的前序遍历与中序遍历构造二叉树。 思路：根据二叉树的前序和中序（或后序和中序）的序列可唯一构造一棵二叉树，必须要有中序。前序遍历的第一个为根节点，找到根节点在中序中的位置，中序左边的节点都是根节点的左子树，右边的同理，然后可以用递归的方式求解。 示例代码： 1234567891011121314151617181920212223242526272829303132333435type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;func index(nums []int, val int) int &#123; for i, v := range nums &#123; if v == val &#123; return i &#125; &#125; return -1&#125;func buildTree(preorder []int, inorder []int) *TreeNode &#123; if len(preorder) == 0 || len(inorder) == 0 &#123; return nil &#125; if len(preorder) == 1 || len(inorder) == 1 &#123; return &amp;TreeNode&#123; Val: preorder[0], Left: nil, Right: nil, &#125; &#125; val := preorder[0] pos := index(inorder, val) root := &amp;TreeNode&#123; Val: val, Left: buildTree(preorder[1 : pos + 1], inorder[ : pos]), Right: buildTree(preorder[pos + 1 : ], inorder[pos + 1:]), &#125; return root&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://harryzhz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://harryzhz.github.io/tags/leetcode/"},{"name":"树","slug":"树","permalink":"https://harryzhz.github.io/tags/%E6%A0%91/"},{"name":"二叉树","slug":"二叉树","permalink":"https://harryzhz.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"数据结构(3): 链表","slug":"数据结构-3-链表","date":"2023-03-19T13:35:07.000Z","updated":"2023-03-19T14:11:46.240Z","comments":true,"path":"2023/03/19/数据结构-3-链表/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3-%E9%93%BE%E8%A1%A8/","excerpt":"","text":"3.1 删除单向链表倒数第n个节点LeetCode No.19 问题描述：删除单向链表倒数第n个节点（只遍历一次）Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2Output: [1,2,3,5] 思路：两个指针，p1先走n步，然后p1和p2再一起走，当p1到链表结尾，p2就是要删除的节点。注意处理可能删除的是头结点（n&#x3D;length）或者不需要删除（n&gt;length）的情况。可以通过增加一个虚拟的头节点，避免对头节点的特殊处理。 示例代码 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; p1, p2 := head, head i := 0 for ; i &lt; n &amp;&amp; p1 != nil ; i++ &#123; p1 = p1.Next &#125; if p1 == nil &#123; if i &lt; n &#123; // 不需要删除 return head &#125; else &#123; // 删除头节点 return head.Next &#125; &#125; for p1.Next != nil &#123; p1 = p1.Next p2 = p2.Next &#125; t := p2.Next if t != nil &#123; p2.Next = t.Next &#125; return head&#125; 3.2 K个一组翻转链表LeetCode No.25 题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。进阶：你可以设计一个只使用常数额外空间的算法来解决此问题吗？你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 思路： 先遍历一遍求出链表长度n，则需要翻转n&#x2F;k组。使用一个虚拟头节点保存结果，每一轮翻转完将尾节保存，下一轮翻转结束后将上一轮的为节点的Next节点指向当前轮的头结点。 示例代码： 12345678910111213141516171819202122232425262728func reverseKGroup(head *ListNode, k int) *ListNode &#123; n := 0 for p := head; p != nil; p = p.Next &#123; n++ &#125; reshead := &amp;ListNode&#123;&#125; var lasttail *ListNode for i, p := 0, head; i &lt;= n/k; i++ &#123; if i == n / k &#123; lasttail.Next = p break &#125; curhead, curtail := p, p for j := 0; j &lt; k; j++ &#123; tmp := p p = p.Next tmp.Next = curhead curhead = tmp &#125; if i == 0 &#123; reshead.Next = curhead &#125; else &#123; lasttail.Next = curhead &#125; lasttail = curtail &#125; return reshead.Next&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://harryzhz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://harryzhz.github.io/tags/leetcode/"},{"name":"链表","slug":"链表","permalink":"https://harryzhz.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"数据结构(2): 数组","slug":"数据结构-2-数组","date":"2023-03-19T13:31:25.000Z","updated":"2023-03-19T13:43:02.860Z","comments":true,"path":"2023/03/19/数据结构-2-数组/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E6%95%B0%E7%BB%84/","excerpt":"","text":"2.1 大于n&#x2F;k次的元素LeetCode No.229 题目描述：给一个整数数组，找出所有出现次数大于n&#x2F;3的元素。Input: nums &#x3D; [3,2,3]Output: [3] 摩尔投票法： 一般情况一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n&#x2F;k ⌋ 次的元素。n&#x2F;k的众数最多只有k - 1个，原因：假设有k个众数，则 出现次数（⌊ n&#x2F;k ⌋ +1） × \\times× 众数个数 k &gt; n。 思路：此题为例 k &#x3D; 3, 则最多有2个出现次数大于n&#x2F;3的元素，把此情景想像成在大会中投票选出两个候选者， 则有两个候选 n1 和n2。 如果投n1（当前元素等于n1），则n1的票数 c1++; 如果投n2（当前元素等于n2），则n2的票数c2++; 如果n1,n2都不投（即当前值与n1，n2都不相等）,那么检查此时n1或n2的票数是否为0： 如果为0,则当前元素成为新的候选人替代掉票数为0的人； 如果n1,n2两个人的票数都不为0，那么n1,n2两个候选人的票数均减一； 最后会有这么几种可能：有2个大于n&#x2F;3，有1个大于n&#x2F;3，有0个大于n&#x2F;3，遍历结束后选出了两个候选人，但是这两个候选人是否满足&gt; n&#x2F;3，还需要再遍历一遍数组，找出两个候选人的具体票数，因为不一定有。参考原文 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738func majorityElement(nums []int) []int &#123; v1, c1, v2, c2 := 0, 0, 0, 0 for _, n := range nums &#123; if n == v1 &#123; c1++ &#125; else if n == v2 &#123; c2++ &#125; else &#123; if c1 == 0 &#123; v1 = n c1++ &#125; else if c2 == 0 &#123; v2 = n c2++ &#125; else &#123; c1-- c2-- &#125; &#125; &#125; r := make([]int, 0) c1, c2 = 0, 0 for _, n := range nums &#123; if n == v1 &#123; c1++ &#125; if n == v2 &amp;&amp; v2 != v1 &#123; c2++ &#125; &#125; if c1 &gt; len(nums) / 3 &#123; r = append(r, v1) &#125; if c2 &gt; len(nums) / 3 &#123; r = append(r, v2) &#125; return r&#125; 2.2 缺失的第一个正数LeetCode No.41 题目描述：给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。进阶：实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案 思路：长度为N的整数数组，没有出现的最小正整数一定在[1, N + 1]。 方法1：最容易的做法用一个额外的哈希表记录出现的数字，然后从1遍历到N+1，根据hash表如果出现缺失就返回。但是该方法空间复杂度为O(n)。 示例代码： 123456789101112func firstMissingPositive(nums []int) int &#123; m := map[int]bool&#123;&#125; for _, n := range nums &#123; m[n] = true &#125; for i := 1; i &lt;= len(nums); i++ &#123; if m[i] == false &#123; return i &#125; &#125; return len(nums) + 1&#125; 方法2：在原数组上建哈希表，因为结果只需要判断[1, N]的数，因此可以以负数当做标记（参考LeetCode官方题解）。 将数组中所有小于等于 0 的数修改为 N+1 遍历每一个数x，可能已经打过标记，因此原值为|x|，如果|x|在[1, N]范围，则给数组nums[|x| - 1]元素加上负号，已加过的不能再加。 遍历数组检查，如果值非负数返回i + 1，全为负数返回N+1 示例代码: 12345678910111213141516171819202122232425262728293031func IntAbs(x int) int &#123; if x &lt; 0 &#123; return -x &#125; return x&#125;// 只关注正整数，用&quot;-&quot;号做标记func firstMissingPositive(nums []int) int &#123; n := len(nums) // 预处理，将元素全部变为整数 for i, v := range nums &#123; if v &lt;= 0 &#123; nums[i] = n + 1 &#125; &#125; // 打标记 for i := 0; i &lt; n; i++ &#123; x := IntAbs(nums[i]) if x &lt;= n &amp;&amp; nums[x - 1] &gt; 0 &#123; nums[x - 1] *= -1 &#125; &#125; // 检查标记 for i := 0; i &lt; n; i++ &#123; if nums[i] &gt; 0 &#123; return i + 1 &#125; &#125; return n + 1&#125; 方法3：置换，将数组恢复成形如[1, 2, … , N]的形式，即nums[i-1]&#x3D;i（参考LeetCode官方题解）。 设v &#x3D; nums[i], 如果nums[i] &#x3D;&#x3D; nums [v-1]，则不需要置换，否则将nums[v-1]设为v，此时要先把nums[v-1]的值保存到nums[i]，此时v-1已经是正确的位置，但是i不一定是正确的位置，需要继续置换。 检查每个位置的值是否正确，全部正确返回N+1，否则返回i+1 示例代码: 123456789101112131415func firstMissingPositive(nums []int) int &#123; n := len(nums) for i, v := range nums &#123; for v &gt; 0 &amp;&amp; v &lt; n + 1 &amp;&amp; nums[i] != nums[v - 1] &#123; nums[v - 1], nums[i] = v, nums[v - 1] v = nums[i] &#125; &#125; for i, v := range nums &#123; if v != i + 1 &#123; return i + 1 &#125; &#125; return n + 1&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://harryzhz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://harryzhz.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"数据结构(1): 字符串","slug":"数据结构-1-字符串","date":"2023-03-19T13:04:01.000Z","updated":"2023-03-19T13:50:44.172Z","comments":true,"path":"2023/03/19/数据结构-1-字符串/","link":"","permalink":"https://harryzhz.github.io/2023/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"1.1 字符串移位 问题：将字符的前k个字符移到字符串结尾。Input：“abcde”，2Output：“cdeab” 三步翻转法： 将字符串分为前k位和后（n-k）位两部分，将两部分分别翻转，最后再整体翻转即可。时间复杂度：T &#x3D; O(n)参考原文 示例代码： 1234567891011121314151617// 反转字符串func reverse(s string) string &#123; runes := []rune(s) for l, r := 0, len(runes) - 1; l &lt; r; l, r = l + 1, r - 1 &#123; runes[l], runes[r] = runes[r], runes[l] &#125; return string(runes)&#125;// 三步反转法对字符串进行循环移位func shift_string(s string, k int) string &#123; runes := []rune(s) ls, rs := runes[:k], runes[k:] rls := reverse(string(ls)) rrs := reverse(string(rs)) return reverse(rls + rrs)&#125; 1.2 最长回文子串LeetCode No.5 问题：找出一个子串包含的最长回文子串。Input: s &#x3D; “babad”Output: “bab”Note: “aba” is also a valid answer. 解法1：从某个子串向两边扩展，遍历找出最长的一个（需要考虑偶数个、奇数个字符的回文子串） 示例代码 12345678910111213141516171819202122232425262728293031func LongestPalindrome(s string) string &#123; rs := []rune(s) mx, st := 0, 0 i, j, c := 0, 0, 0 for i = 0; i &lt; len(rs); i++ &#123; // 奇数个字符的回文子串 for j = 0; i - j &gt;= 0 &amp;&amp; i + j &lt; len(rs); j++ &#123; if rs[i - j] != rs[i + j] &#123; break &#125; c = 2 * j + 1 &#125; if c &gt; mx &#123; mx = c st = i - j + 1 &#125; // 偶数个字符的回文子串 for j = 0; (i - j) &gt;= 0 &amp;&amp; (i + j + 1) &lt; len(rs); j++ &#123; if rs[i - j] != rs[i + j + 1] &#123; break &#125; c = j * 2 + 2 &#125; if c &gt; mx &#123; mx = c st = i - j + 1 &#125; &#125; return string(rs[st: st + mx])&#125; 解法2：马拉车算法具体思路参考原文 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344func min(x, y int) int &#123; if x &lt; y &#123; return x &#125; return y&#125;func LongestPalindrome1(s string) string &#123; if len(s) &lt; 2 &#123; return s &#125; news := make([]rune, len(s)) news[0] = &#x27;#&#x27; for _, r := range s &#123; news = append(news, r) news = append(news, &#x27;#&#x27;) &#125; dp := make([]int, len(news)) mx, center, maxlen, maxst := 0, 0, 1, 0 for i := 0; i &lt; len(news); i++ &#123; // 算法核心转移方程 if i &lt; mx &#123; dp[i] = min(mx - i, dp[2*center - i]) &#125; // 以i为中心，只接从距离i为d[i] + 1的位置扩散 left, right := i - (1 + dp[i]), i + (1+ dp[i]) for left &gt;= 0 &amp;&amp; right &lt; len(news) &amp;&amp; news[left] == news[right] &#123; dp[i]++ left++ right-- &#125; // 更新mx if i + dp[i] &gt; mx &#123; mx = i + dp[i] center = i &#125; // 更新最大长度和对应在源字符串的起始位置 if dp[i] &gt; maxlen &#123; maxlen = dp[i] maxst = (i - maxlen) / 2 &#125; &#125; return s[maxst : maxst + maxlen]&#125; 1.3 字符串的全排列 问题描述：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串abc、acb、bac、bca、cab 和 cba。 解法1：递归方法DFS搜索，想象成树 示例代码: 1234567891011121314151617var res = []string&#123;&#125;func dfs_search(s string, lv int, cur string) &#123; if lv == 0 &#123; res = append(res, cur) &#125; for i := 0; i &lt; len(s); i++ &#123; // 去掉当前字符，下一层在剩下的字符中挑 dfs_search(s[:i] + s[i+1:], lv - 1, cur + string(s[i])) &#125;&#125;func FullPermutation(s string) []string &#123; res = []string&#123;&#125; dfs_search(s, len(s), &quot;&quot;) return res&#125; 解法2：字典序排列，从当前字符串s生成刚好比他大的下一个字符串排列参考原文 找到排列中最后一个升序的位置i 找到i后面最后一个比s[i]大的位置j 交换s[i]和s[j] 将i+1之后的字符串反转 示例代码: 1234567891011121314151617181920212223242526// 字典序排列算法func next_permutation(s string) (bool, string) &#123; rs := []rune(s) i, j := 0, 0 // 找到最后一个升序的位置i for i = len(rs) - 2; i &gt;= 0 &amp;&amp; rs[i] &gt;= rs[i+1]; i-- &#123;&#125; if i &lt; 0 &#123; return false, &quot;&quot; &#125; // 找到i后面最后一个比rs[i]大的位置j for j = len(rs) - 1; j &gt; i &amp;&amp; rs[j] &lt;= rs[i]; j-- &#123;&#125; // 交换rs[i], s[j] rs[i], rs[j] = rs[j], rs[i] // 反转rs[i+1:] rev := reverse(string(rs[i + 1:])) return true, string(rs[:i+1]) + rev&#125;func DictOrderFullPermutation(s string) []string &#123; res := []string&#123;&#125; for ok, next_str := true, s; ok; ok, next_str = next_permutation(next_str) &#123; res = append(res, next_str) &#125; return res&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://harryzhz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://harryzhz.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"leetcode","slug":"leetcode","permalink":"https://harryzhz.github.io/tags/leetcode/"}]},{"title":"Linux进程管理:supervisor和nohup原理及使用","slug":"Linux进程管理-supervisor和nohup原理及使用","date":"2023-03-13T00:49:37.000Z","updated":"2023-03-19T13:34:40.029Z","comments":true,"path":"2023/03/13/Linux进程管理-supervisor和nohup原理及使用/","link":"","permalink":"https://harryzhz.github.io/2023/03/13/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-supervisor%E5%92%8Cnohup%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/","excerpt":"","text":"原理守护进程（daemon）守护进程是一类在后台运行的特殊进程，用于执行特定的系统任务。他独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括： 系统日志进程syslogd Web服务器httpd 邮件服务器sendmail 数据库服务器mysqld等 守护进程一般在系统启动时开始运行，除非强行终止，否则会持续运行知道系统关机，通常以超级用户（root）权限运行。 前台任务与后台任务假如有个简单的go的web服务器程序，使用如下方式启动，称为前台任务。独占了命令窗口，只有运行完了或手动终止（Ctrl+C），才能执行其他命令。 如果以如下方式，在命令结尾加上符号&amp;，启动的进程就会称为后台任务。后台任务又如下特点： 继承当前session的标准输出(stdout)和标准错误(stderr)，因此如上图所示，后台任务的所有输出仍会同步的在命令行显示 不再继承当前session的标准输入(stdin)，无法向这个任务输入指令，如果它试图读取标准输入，就会暂停执行（halt） SIGHUP信号变为后台任务并不代表进程成为了守护进程，因为当session关闭后，后台任务就会终止。Linux系统终端session退出流程如下： 用户准备退出session 系统向改session发送SIGHUP信号 session将SIGHUP信号发送给所有子进程 子进程收到SIGHUP信号后会自动退出 nohupnohup 是后台作业的意思， nohup运行的进程将会忽略终端信号运行。即后台运行一个命令。nohup COMMAND &amp; 用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响它的运行。 使用nohup命令的方式可以启动一个守护进程，如下图所示： nohup命令对进程做了如下操作： 忽略SIGHUP信号，因此当session关闭进程就不会退出 关闭标准输入，该进程不再接收任何输入，即使运行在前台 重定向标准输出和标准错误到文件nohup.out（默认情况，可以指定输出的文件） nohup不会自动把进程变为后台任务，所以必须加上&amp;。 supervisorsupervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。supervisor管理进程是通过fork&#x2F;exec的方式把被管理的进程当做子进程来启动，用户只需要在配置文件中将要管理的进程进行配置。 结构supervisor主要由Supervisord、Supervisorctl、Web server和XML-RPC interface组成： supervisord：主进程，负责管理进程的server，它会根据配置文件创建指定数量的应用程序的子进程，管理子进程的整个生命周期，对crash的进程重启，对进程变化发送事件通知等。同时通过内置web server和XML-RPC Interface可以轻松实现进程管理。 supervisorctl：管理client，用户通过命令行发送消息给supervisord，可以查看进程状态，加载配置文件，启停进程，查看进程标准输出和错误输出，远程操作等。 Web server：superviosr提供了web server功能，可通过web控制进程。 XML-RPC interface： XML-RPC接口，提供XML-RPC服务来对子进程进行管理和监控。 macOS环境安装使用安装并启动12$ brew install supervisor$ brew services start supervisor 创建配置目录和配置文件默认的配置文件路径为/usr/local/etc/supervisord.conf，查看该文件可以看到如下内容： 123$ tail -n2 /usr/local/etc/supervisord.conf[include]files = /usr/local/etc/supervisor.d/*.ini 可以看到include了/usr/local/etc/supervisor.d/目录下的.ini文件，因此我们需要创建改目录，然后对要管理的进程或进程组创建对应的.ini格式的配置文件 12$ mkdir -pv /usr/local/etc/supervisor.d$ vim /usr/local/etc/supervisor.d/myserver.ini 编辑配置文件内容如下： 123456789[program:server]process_name=%(program_name)s_%(process_num)02dcommand=/usr/local/go/bin/go run /Users/harryzhang/go/src/server/server.go # 要执行的命令autostart=true # 系统开机自动启动autorestart=true # 进程终止自动重启user=harryzhang # 用户numprocs=1 # 启动进程数redirect_stderr=true # 是否将标准错误重定向到标准输出stdout_logfile=/Users/harryzhang/go/src/server/server.log # 指定标准输出保存的文件路径 重启supervisor编辑好配置文件后重启supervisor就可以生效，可以使用supervisorctl命令查看和管理进程状态。 1234567$ brew services restart supervisorStopping `supervisor`... (might take a while)==&gt; Successfully stopped `supervisor` (label: homebrew.mxcl.supervisor)==&gt; Successfully started `supervisor` (label: homebrew.mxcl.supervisor)$ supervisorctl statusserver:server_00 RUNNING pid 41382, uptime 0:00:04 如果指定的命令执行没有异常，会看到进程已处于运行状态，如果没有处于运行状态，可以查看日志文件，可能为命令执行出错直接退出了。 参考【1】Linux 守护进程的启动方法 【2】进程管理工具supervisor 和 nohup","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://harryzhz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://harryzhz.github.io/tags/Linux/"},{"name":"守护进程","slug":"守护进程","permalink":"https://harryzhz.github.io/tags/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"}]}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://harryzhz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"算法","slug":"算法","permalink":"https://harryzhz.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://harryzhz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://harryzhz.github.io/tags/Linux/"},{"name":"I/O模型","slug":"I-O模型","permalink":"https://harryzhz.github.io/tags/I-O%E6%A8%A1%E5%9E%8B/"},{"name":"select/poll/epoll","slug":"select-poll-epoll","permalink":"https://harryzhz.github.io/tags/select-poll-epoll/"},{"name":"leetcode","slug":"leetcode","permalink":"https://harryzhz.github.io/tags/leetcode/"},{"name":"LRU","slug":"LRU","permalink":"https://harryzhz.github.io/tags/LRU/"},{"name":"缓存","slug":"缓存","permalink":"https://harryzhz.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"动态规划","slug":"动态规划","permalink":"https://harryzhz.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","permalink":"https://harryzhz.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"https://harryzhz.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"https://harryzhz.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"https://harryzhz.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"二分查找","slug":"二分查找","permalink":"https://harryzhz.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"快速排序","slug":"快速排序","permalink":"https://harryzhz.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"栈","slug":"栈","permalink":"https://harryzhz.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://harryzhz.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"堆","slug":"堆","permalink":"https://harryzhz.github.io/tags/%E5%A0%86/"},{"name":"树","slug":"树","permalink":"https://harryzhz.github.io/tags/%E6%A0%91/"},{"name":"二叉树","slug":"二叉树","permalink":"https://harryzhz.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://harryzhz.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://harryzhz.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"字符串","permalink":"https://harryzhz.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"守护进程","slug":"守护进程","permalink":"https://harryzhz.github.io/tags/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"}]}