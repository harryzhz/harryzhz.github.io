{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"node_modules/hexo-theme-volantis/source/css/Readme.md","path":"css/Readme.md","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/css/first.styl","path":"css/first.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/app.js","path":"js/app.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/aplayer.js","path":"js/plugins/aplayer.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/parallax.js","path":"js/plugins/parallax.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/rightMenu.js","path":"js/plugins/rightMenu.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/rightMenus.js","path":"js/plugins/rightMenus.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/search/hexo.js","path":"js/search/hexo.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/contributors.js","path":"js/plugins/tags/contributors.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/friends.js","path":"js/plugins/tags/friends.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/sites.js","path":"js/plugins/tags/sites.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.nojekyll","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1679328496466},{"_id":"source/CNAME","hash":"4abcec34201ece318489203a9b6c7510711d6fe3","modified":1679328488572},{"_id":"source/about/index.md","hash":"66c5b842c80d6fbb554aff0267352d00572effd6","modified":1678896023237},{"_id":"source/categories/index.md","hash":"8432c770011786e35038abb0134e66564b9ef052","modified":1679208299152},{"_id":"source/tags/index.md","hash":"ceab5572620c5bfc491d95fbe7c41cd7c38efb83","modified":1679208308655},{"_id":"source/friends/index.md","hash":"82e628bc7e4c0efe3fe96a8c5c76576e98f6c037","modified":1679208391862},{"_id":"source/_posts/2023/03-19-Linux-系统-I-O-模型及-select-poll-epoll-详解.md","hash":"4a6f019e99982114f0395621b7c807b61f9ab2d1","modified":1679234873184},{"_id":"source/_posts/2023/03-13-Linux进程管理-supervisor和nohup原理及使用.md","hash":"9589e3ee137be57063ade380b41db9475d0ace1f","modified":1679232880029},{"_id":"source/_posts/2023/03-19-数据结构-2-数组.md","hash":"6617e78e56160b11bd3564a86e99e87cd162963d","modified":1679236450345},{"_id":"source/_posts/2023/03-19-数据结构-1-字符串.md","hash":"6e85efe0a0b63deccac7f2c54d25625b871fda53","modified":1679233844172},{"_id":"source/_posts/2023/03-19-数据结构-4-树.md","hash":"e420726ef4f4d5c13c8262c06ddf378b74d77978","modified":1679235104657},{"_id":"source/_posts/2023/03-19-数据结构-3-链表.md","hash":"3f9d0ae00e6779e0c3aa85e49334058a7af1f997","modified":1679235106240},{"_id":"source/_posts/2023/03-19-数据结构-5-栈-队列-堆.md","hash":"37004b3a86cf924306c067560fbae6c9eacdf30c","modified":1679235102479},{"_id":"source/_posts/2023/03-19-算法-1-双指针.md","hash":"aee52409234924e337f9b7b49b92179723f75b1d","modified":1679236190124},{"_id":"source/_posts/2023/03-19-算法-2-排序.md","hash":"f8db5cb72373d47887c805b8bfd5a57787e1ede9","modified":1679233813288},{"_id":"source/_posts/2023/03-19-算法-3-二分查找.md","hash":"dbdb41e28321e2fea4137a16c2ac3340991a3e34","modified":1679233919644},{"_id":"source/_posts/2023/03-19-算法-4-搜索.md","hash":"182f1b86bdf5fd0d7b4328e22871ac5d7797f478","modified":1679234020173},{"_id":"source/_posts/2023/03-19-算法-5-分治-归并.md","hash":"c9e71ecaff8ea3ef8177aa93a2426895edaf0c82","modified":1679234112104},{"_id":"source/_posts/2023/03-19-算法-6-贪心算法.md","hash":"ef2032ca91c8ad068c0878b039ab351fb0d5ec78","modified":1679234185642},{"_id":"source/_posts/2023/03-19-算法-7-动态规划.md","hash":"417f3b2aa9baed3fa7f27a30ae7a903bbffdc657","modified":1679234232016},{"_id":"source/_posts/2023/03-19-算法-8-LRU-策略.md","hash":"c085fea88b4a9f1ada230ecf4249c6251848cba2","modified":1679234433583},{"_id":"source/_posts/2023/03-25-HTTPS原理详解.md","hash":"22500f11ad311b1bb2bf8859f24e2a3339d652e8","modified":1679727503210},{"_id":"source/_posts/2023/03-25-Session和Cookie.md","hash":"a90f6899579a5bfb479935058982ea4596bde836","modified":1679727496825},{"_id":"source/_posts/2023/03-25-TCP是如何实现可靠传输的？.md","hash":"0b1e15a1d05df0c8be49ae5fcfb1d0038d94cb75","modified":1679727527366},{"_id":"source/_posts/2023/03-25-什么是WebSocket？.md","hash":"f76e0f7107114b8ec8ce26c90ef6cf027b9455df","modified":1679727509044},{"_id":"source/_posts/2023/03-25-计算机网络基础概述.md","hash":"b99697fae03c696f4519dc7e90d1a301850a3276","modified":1679727514841},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/blank.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1678894222412},{"_id":"node_modules/hexo-theme-volantis/CHANGELOG.md","hash":"3ae7ef835db0043e093a89516154849e85ae9ce8","modified":1678894223366},{"_id":"node_modules/hexo-theme-volantis/LICENSE","hash":"13b0862f4ed1914abe887a47df2c3ca5adfa8f3f","modified":1678894222402},{"_id":"node_modules/hexo-theme-volantis/README.md","hash":"7c43923ced74698b0dfffb0ff1c53a70ad16e6fb","modified":1678894223366},{"_id":"node_modules/hexo-theme-volantis/_config.yml","hash":"8f8e65ce2447e742da135b33a16b3ac3207ae4bf","modified":1678894225351},{"_id":"node_modules/hexo-theme-volantis/package.json","hash":"1a30bf176963bfb78ab5ccd18b52e5146a7456cb","modified":1678894223357},{"_id":"node_modules/hexo-theme-volantis/languages/en.yml","hash":"cb84db341aeab91676b603cf47bba07c57474d94","modified":1678894225352},{"_id":"node_modules/hexo-theme-volantis/languages/zh-CN.yml","hash":"3cf7e00abc512c446f8506887ee02605f7e229dd","modified":1678894226506},{"_id":"node_modules/hexo-theme-volantis/layout/404.ejs","hash":"48e160ad704be637cafc433d2365fc0eb8bab8cb","modified":1678894222406},{"_id":"node_modules/hexo-theme-volantis/languages/zh-TW.yml","hash":"30df1cf6181375c4d05cb6dcfbdc0487ea39369c","modified":1678894226510},{"_id":"node_modules/hexo-theme-volantis/layout/_pre.ejs","hash":"3ac804505c282ff8b16858037c1d2bf9305c3063","modified":1678894222405},{"_id":"node_modules/hexo-theme-volantis/layout/category.ejs","hash":"9ee883e5f73c05b3963770b74b63d7bb7e4e1ed5","modified":1678894222651},{"_id":"node_modules/hexo-theme-volantis/layout/docs.ejs","hash":"16917af05431c049aa103744a5fb2595d5848d4c","modified":1678894222658},{"_id":"node_modules/hexo-theme-volantis/layout/friends.ejs","hash":"d976c3d2180432319cc4deb503481f0c606811a6","modified":1678894222661},{"_id":"node_modules/hexo-theme-volantis/layout/index.ejs","hash":"8ea7d49272b068cd1a4037846c72eb37e9823512","modified":1678894222681},{"_id":"node_modules/hexo-theme-volantis/layout/layout.ejs","hash":"cd97c3e9b21549e8e18cd1bf3579d078391255a9","modified":1678894222687},{"_id":"node_modules/hexo-theme-volantis/layout/list.ejs","hash":"a85b2984717ee6d5058ec5635f3f287f45c3d4ba","modified":1678894222689},{"_id":"node_modules/hexo-theme-volantis/layout/page.ejs","hash":"16917af05431c049aa103744a5fb2595d5848d4c","modified":1678894222693},{"_id":"node_modules/hexo-theme-volantis/layout/post.ejs","hash":"16917af05431c049aa103744a5fb2595d5848d4c","modified":1678894222695},{"_id":"node_modules/hexo-theme-volantis/layout/tag.ejs","hash":"696e7b1c70b4438e6a8d925f99cbc4222dd4035d","modified":1678894223271},{"_id":"node_modules/hexo-theme-volantis/layout/archive.ejs","hash":"f99913b253f8ab22f81280a6ce5145bec3cd3de6","modified":1678894222410},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/artalkcount.ejs","hash":"94c9e591e38ac00d6beafa44de4d29e70680c673","modified":1678894222411},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/author.ejs","hash":"68e8f198c406b6946fbf0a0f756e8a334982ba84","modified":1678894222412},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/counter.ejs","hash":"1bd825605f3dacf685848b93a25269f49269b4d7","modified":1678894222653},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/date.ejs","hash":"ba6c554dbc6c1870debb2b87c5fa25caa089be8f","modified":1678894222655},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/music.ejs","hash":"2c1884e59131d47a82d2556ac28ef784b4ddaa10","modified":1678894222691},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/category.ejs","hash":"e95b88bf5f8b11b4f886859cf634a72aa46c8650","modified":1678894222649},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/tags.ejs","hash":"24aae7e64ce05ddb13e793a181bfa74257a830e4","modified":1678894223273},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/share.ejs","hash":"0f3b1db92319734baa8da1636340839ed2d37a7b","modified":1678894223269},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/thumbnail.ejs","hash":"60045f2bf695b4be5ad3fd19db46890f1cdee68a","modified":1678894223278},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/walinecount.ejs","hash":"a407ec847c8f0e224efd22b7234e2921cca1d5be","modified":1678894223284},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/updated.ejs","hash":"edf445ad8153419a5dc7c4ec4c8490967cd9d33d","modified":1678894223283},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/wordcount.ejs","hash":"eebaab3821af95ee64d8d56f33ca6c9c60b9b6f0","modified":1678894223287},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/archive.ejs","hash":"d5f776437c108c72c002b11f1d23d30b50e0079a","modified":1678894222408},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/article.ejs","hash":"11d61f5ce1bdc6f1fb1163e5e7a213fb5cbb6b53","modified":1678894222412},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/categories.ejs","hash":"c2bc61780cab948ef8ab5076511ebccacab1cd79","modified":1678894222649},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/cover.ejs","hash":"b03a268d75dedeb8d6e29e3e352bd6cdf921545a","modified":1678894222654},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/footer.ejs","hash":"baec06d381d8358ee6762e4b0a67d27cd0c7a511","modified":1678894222661},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/head.ejs","hash":"72471ce27235fb3c67c2961b65b41861b92a2463","modified":1679211214852},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/header.ejs","hash":"06ce9cd8ad7e64e83cb52cda555fd73b1c6c2b52","modified":1678894222666},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/meta.ejs","hash":"ced9c966a9f4d84e485c325ef3551be218ddd033","modified":1678894222691},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/post.ejs","hash":"7d144c80f2980efaab6198512746c0c5d77f03db","modified":1678894222695},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/side.ejs","hash":"27f9df84585ffb24e2ba2423761f90f690c65787","modified":1678894223270},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/_pre.ejs","hash":"2f635098c719d9dbf0f23eeead370c6550d1ecff","modified":1678894222405},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/blogger.ejs","hash":"b1429acdd791cd5f00a0f0303bcd8674cf73ed52","modified":1678894222647},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/category.ejs","hash":"d8e7ad7e1418659208036a0a43cb4db2ee61abd7","modified":1678894222649},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/copyright.ejs","hash":"8e4929772970e58482f10e0867692cfcf59dee5d","modified":1678894222653},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/group.ejs","hash":"2eed9614049441b51e6819f393f80faf5441870b","modified":1678894222665},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/grid.ejs","hash":"7d266197f6037f32c33bd74741730c5558417402","modified":1678894222665},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/header.ejs","hash":"b132e332ddf12d1bb1d99480200561d8c38edd04","modified":1678894222667},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/lastupdate.ejs","hash":"c311ba4c8b255c45313dc1ab7ddafd99ec7fe8af","modified":1678894222681},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/list.ejs","hash":"0c9319e7e81d88c721b3fe9acf6171f81faade68","modified":1678894222689},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/load.ejs","hash":"b71e0617165d5db546d22297229d7f380091fd83","modified":1678894222690},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/music.ejs","hash":"2f560f3168e3811cd1d8d8a6bad9112932be9b04","modified":1678894222692},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/page.ejs","hash":"e6a20fb75a3e835a404dddd929db4d3762a367c0","modified":1678894222692},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/qrcode.ejs","hash":"128b7c6b4b2191ead4079688e55333bb97df0cdd","modified":1678894222696},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/references.ejs","hash":"08f2dbd23fc9835f4c24bdda4cf288593d61c25a","modified":1678894222697},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/related_posts.ejs","hash":"f7a514d1f3f5ae40c6fb55d61f8b2a0bba13401c","modified":1678894222697},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/tagcloud.ejs","hash":"a68ccb41f7b589f9076a750e77e17f178af3e9d0","modified":1678894223272},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/text.ejs","hash":"9302a6084c8f930532f7f8793b1b20ca1964473e","modified":1678894223275},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/toc.ejs","hash":"200bf0096d8965e5fb7039b261317c848e36be85","modified":1678894223282},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/webinfo.ejs","hash":"29b70c3e5882afa3045b1282d03f88d30ccf5e84","modified":1678894223284},{"_id":"node_modules/hexo-theme-volantis/scripts/events/index.js","hash":"af7aaa4431393889671853db03c8b684265eaa50","modified":1678894223322},{"_id":"node_modules/hexo-theme-volantis/scripts/filters/img.js","hash":"160732831bec5baf89fa07a85fec5229c3cb9cd7","modified":1678894223321},{"_id":"node_modules/hexo-theme-volantis/scripts/filters/z-lazyload.js","hash":"df6c5b0a6eff5e655d2b8de85c646ba1e5a16535","modified":1678894223357},{"_id":"node_modules/hexo-theme-volantis/scripts/filters/replace.js","hash":"aa6fe807d7b24a60475ce8126a1be7b314cd26ba","modified":1678894223334},{"_id":"node_modules/hexo-theme-volantis/scripts/filters/content-visibility.js","hash":"048a8f1b80e8999d5f7a37bb8c4dabdebbebabdc","modified":1678894223308},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/custom-files.js","hash":"8483fcdc7dbbfde40276dc3daa1ddc5e40380360","modified":1678894223313},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/first-style.js","hash":"ba2e2325a365704abae3f1d204b058731e21bfbf","modified":1678894223314},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/getList.js","hash":"595400c37b79599f779876808e0308ead7de0a32","modified":1678894223317},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/related-posts.js","hash":"cab8c291a8ff460b29b3248ac86827c143aca9ee","modified":1678894223333},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/revisioned.js","hash":"57a9d91cd755f8100f149a0fe6cbb45d9c77e13c","modified":1678894223334},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/btn.js","hash":"e9b6e26f106505cf14a72524ab5e8b5bc85f362a","modified":1678894223302},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/btns.js","hash":"648671420faa0ac00076a8c7bb011c908b83fd5a","modified":1678894223304},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/checkbox.js","hash":"0798edc6833d5978709ca5ed56aed33cea46e694","modified":1678894223306},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/contributors.js","hash":"a00573000e7ddf7a9d2f03f29fd62cb8a9752a48","modified":1678894223310},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/dropmenu.js","hash":"19176a6edf7acc6ad31c96961e59da526f200980","modified":1678894223313},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/folding.js","hash":"a809988c63f358e2ae903d905dc81ed80860bacd","modified":1678894223315},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/fancybox.js","hash":"9eac73fa2d7d14ae585b302255270933641a4859","modified":1678894223313},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/frame.js","hash":"e78834c005bda8f80ba86c78911b9db7566b878b","modified":1678894223315},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/ghcard.js","hash":"1ed7c1508180756ad4752769aa91289d37a7e23d","modified":1678894223318},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/friends.js","hash":"a902e1ac279014a30eda85e477c52144214cc66c","modified":1678894223316},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/image.js","hash":"63a4b3e1e3d661b6ab2b3fcfcfb657e3b632b9cb","modified":1678894223320},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/inline-labels.js","hash":"08fbdc0ea622270e1236a28778f875c8ad2e5516","modified":1678894223323},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/link.js","hash":"9dec9c65819d1135a7a248adaa26acbf24427cd0","modified":1678894223323},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/md.js","hash":"66d6b7c17638e778a8796d64cd42d0c622eba67e","modified":1678894223324},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/media.js","hash":"b3871bc024d7fce9500f31073d690c4cd33bce18","modified":1678894223325},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/note.js","hash":"ac86ba50da98d9546522feaca672259620b053d8","modified":1678894223327},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/pandown.js","hash":"4d6f6dab955106ade379d6c55603e1e7eb97a107","modified":1678894223330},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/site.js","hash":"dd23a06f2e8a3cc70730cf199a0661777532ff0b","modified":1678894223343},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/swiper.js","hash":"f0171f07f494c0b0f3f8af265344add15813a676","modified":1678894223353},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/span.js","hash":"b825115f037386797efa1b0aee3a1df21629f243","modified":1678894223347},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/timeline.js","hash":"9b6b88ada712a8f3a04a825cf73a409f072ed045","modified":1678894223356},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/tabs.js","hash":"f0054f1c970cac728b3ad289a3c531c070c06896","modified":1678894223355},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/table.js","hash":"ad82046fc64f932019d8a7b3e9a8ff07973a6c3b","modified":1678894223353},{"_id":"node_modules/hexo-theme-volantis/source/css/Readme.md","hash":"cf408308dcbc62f4fc2bd5aa38303b368cc88a7e","modified":1678894223369},{"_id":"node_modules/hexo-theme-volantis/source/css/first.styl","hash":"55fe35847a1d1d831eb71288c0233efb1dd8a630","modified":1678894223384},{"_id":"node_modules/hexo-theme-volantis/source/css/style.styl","hash":"00892839230a1b05a5f9d9350baacd67d894fc85","modified":1678894224272},{"_id":"node_modules/hexo-theme-volantis/source/js/app.js","hash":"fe351c107526d7f0aa127ea6feb7f90dcf161f16","modified":1678894223295},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/featured.ejs","hash":"7abe0c7080dfcec063b4f52e4ca569bf0510c7c1","modified":1678894222660},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/dock.ejs","hash":"7abe0c7080dfcec063b4f52e4ca569bf0510c7c1","modified":1678894222657},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/focus.ejs","hash":"7abe0c7080dfcec063b4f52e4ca569bf0510c7c1","modified":1678894222660},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/layout.ejs","hash":"39a463ce33ce6138d40055e72118941515ba2f63","modified":1678894222681},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/search.ejs","hash":"2f536370d1b51fa7c33798be21e690638f0df74e","modified":1678894223268},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/_ctrl.ejs","hash":"8dd82dc0d7cd59c55d9e1239ec80c0303a4069bf","modified":1678894222404},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/content-visibility-scroll-fix.ejs","hash":"8aa467244e0976efbdc80e28dd266b0ac0bd2dc7","modified":1678894222652},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/global.ejs","hash":"27a98869f648ff7aed5c290d900d4cf06e51f2f8","modified":1678894222662},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/index.ejs","hash":"782b9f2cf693d0a7094adac730a4d543335ea614","modified":1678894222667},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/toc.ejs","hash":"d71bac519593ac09e9e5c521e5999925e253f4b6","modified":1678894223280},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/analytics/LCCounter.ejs","hash":"ecad85a3d5776614335783e13a9497b1538731a3","modified":1678894222689},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/analytics/script.ejs","hash":"a757c6fd89e11ab3e4cbd3e4cc02091a836fcd70","modified":1678894222698},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/index.ejs","hash":"462334ae298659214464f3a8af3da1c514cf76e1","modified":1678894222674},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/aplayer/layout.ejs","hash":"51b4f54a165fbca56c9beec3ce19bc62f10097d9","modified":1678894222683},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/aplayer/script.ejs","hash":"dc0b773f0d26c660b36625fdbd17a2d8455e6095","modified":1678894222698},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/chat/index.ejs","hash":"56d2e577fbd08859e118cfb1d1b8d230850a3675","modified":1678894222678},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/darkmode/script.ejs","hash":"742f0e0988741e3eb82bb0d99a081447b45a41b1","modified":1678894223243},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/index.ejs","hash":"3d781c01f494b89d1d31d3210c100c822787c9b7","modified":1678894222679},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/end-of-support/script.ejs","hash":"b415d8e5dfca4a47c199b1adeb220ff57eaec219","modified":1678894223246},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/github-api/script.ejs","hash":"8c414c5c39fb6c36c2a4881463f3dc3346cc9b46","modified":1678894223248},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/highlight/script.ejs","hash":"06befe70f47454fbfaa95245fe4cdb8d4f6f9f3c","modified":1678894223253},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/lazyload/script.ejs","hash":"d80dd5864200d86bc6c43d0fd1efab6538e703cf","modified":1678894223254},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/nodewaves/script.ejs","hash":"f28854fba682c345424f6217525507f0a3e2b17d","modified":1678894223255},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/parallax/script.ejs","hash":"7c88aedd458b2c9df27e57db5c6ecb3090c58eba","modified":1678894223257},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/pjax/animate.ejs","hash":"050f626db44ef423e5f8689447197a37f7de6e27","modified":1678894222407},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/pjax/pdata.ejs","hash":"eb90a00163519e6ed01a4f38380caf4dc2bd5049","modified":1678894222694},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/rightmenu/layout.ejs","hash":"aa49c2498e2e61dd4ac0d68db89a1bdee86a9208","modified":1678894222684},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/pjax/index.ejs","hash":"4daf9937293b6e2b4bf458d3e868da18900d2864","modified":1678894222680},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/preload/script.ejs","hash":"1c3bf70b6df9da59c5554a921d7447e20684241d","modified":1678894223258},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/rightmenus/layout.ejs","hash":"31a1787705aa13d3e0eb1aacf76bc4db869cb37a","modified":1678894222686},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/scrollreveal/script.ejs","hash":"bfcd40a4c86a79d11b6ea9460f5bb6c3a60be48e","modified":1678894223260},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/search/script.ejs","hash":"c6525e6d76b6e968a1803fe8aea076dfc23659a0","modified":1678894223264},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/share/layout.ejs","hash":"f46f00d5866082bb60137b5044ead669a062bc9f","modified":1678894222687},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/slow-network/script.ejs","hash":"5a2f3eaadb6dbe4350e6d32094a0bad62ba240bc","modified":1678894223265},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/swiper/script.ejs","hash":"766ab47f4b26502fb71383ae442a1db629fe9e12","modified":1678894223267},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/check-configuration.js","hash":"08f383bd163383a157db177b77143c467de98a29","modified":1678894223305},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/check-environment.js","hash":"9d29a3f34ea715a0dc7cb5c2f76b5713d718e6e6","modified":1678894223305},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/config.js","hash":"8dafa15769d43693523e435fad10b85f614a0600","modified":1678894223307},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/render-stylus.js","hash":"36c2f32d2101eaa84041daf70393df6f3a3fa331","modified":1678894223334},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/stellar-tag-utils.js","hash":"8d62893faf26d15d2833f8090bd6257a7282f5e2","modified":1678894223348},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/head/generate_preload_fontfamily.js","hash":"d37dbe38fa9125fdce99b2ef9e92582ed08eea82","modified":1678894223317},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/head/autoCanonical.js","hash":"f3ea74759129c71041371a1d77c687eb6aa88d3a","modified":1678894223297},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/head/generate_seo.js","hash":"e0059a60cc5978be6792dcf795a2ece3a509f41a","modified":1678894223317},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/head/generate_title__keywords__description.js","hash":"179a07b7b2270398216a34d79595d98e30962b22","modified":1678894223317},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/index.js","hash":"bcb770787c77e39cdc156b7fd58cde8e00b79153","modified":1678894223323},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/AutoPrefixCSS.styl","hash":"c76f624d332c59b73c1d6b95b30b2afb560976eb","modified":1678894223372},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/Readme.md","hash":"77d9e986d24898b98eba2010185951fd1fb8b95c","modified":1678894223367},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/color.styl","hash":"02d9bbe630f33ec2c604cb8acdddbe28431fcb05","modified":1678894223377},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/effect.styl","hash":"47db4f84182194a8a233931424c9bc79c6cf0117","modified":1678894223383},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/fonts.styl","hash":"fa199b11b568a6b0d6fc4e87ef12ab36ac254966","modified":1678894223387},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/func.styl","hash":"430adedc7e6f57013e54d15e6f8dce21e9ea2579","modified":1678894223391},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/base_first.styl","hash":"2db7ec30d52473fa40bca89dcd29854498e8ca3e","modified":1678894223373},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/layout.styl","hash":"d1bdce2e7974b1feb585adcdf95e36a054a36ec4","modified":1678894224265},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/cover_first.styl","hash":"32f0e09eba832607165096c68f70698a75d685b5","modified":1678894223377},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/dark_first.styl","hash":"bcb419588c1972bd47869309dea43ff319440d33","modified":1678894223379},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/fontfamily_first.styl","hash":"5024a9162f4787ac4234d5b8549fad40dbecf865","modified":1678894223386},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/navbar_first.styl","hash":"e268d81dc78fdf9758d314cdc5cc087aec1c70e6","modified":1678894224267},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/search_first.styl","hash":"955c9eb68b90b97dba0bd27909347cfc91ce68c5","modified":1678894224270},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/index.styl","hash":"835b3640c257cd229b20c088536b053b92c9796c","modified":1678894224264},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/aplayer.js","hash":"95f2e47535c8d37e90cab7726d25845cf01ca477","modified":1678894223289},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/parallax.js","hash":"3c3210bde6e86d7d157c34c14796abe98cb1bbd0","modified":1678894223332},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/rightMenu.js","hash":"cb2f17ab10127065f7b9f5f87a49921d25b287e1","modified":1678894223339},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/rightMenus.js","hash":"877f548870ea7f63a46de071a120aaea96dd4a25","modified":1678894223340},{"_id":"node_modules/hexo-theme-volantis/source/js/search/hexo.js","hash":"4b4ecb0c950b95bed02e0e1274aa50c4989553a3","modified":1678894223319},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/_ctrl/cdnCtrl.ejs","hash":"8fe3924efab31cf8a6d7ad07a2985b01a2154acb","modified":1678894222652},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/_ctrl/coverCtrl.ejs","hash":"ee3f2108e61db024466b08beddb895ad97330f63","modified":1678894222654},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/artitalk/index.ejs","hash":"98fb39a1ac55b9af0c1501b051ac2698a3684686","modified":1678894222668},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/bbtalk/index.ejs","hash":"bd513c00f6d5fb57e504db7e89c3326d9f68dd88","modified":1678894222669},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/fcircle/index.ejs","hash":"2a220187916a0474a083a8f716c0a3b9a8f57548","modified":1678894222670},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/gitter/index.ejs","hash":"e90bf8daf46f34ca9b37049154dda6d1f155d037","modified":1678894222671},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/indent/index.ejs","hash":"7d112cde9b8d1785d8c541cde94361e0bfc60f30","modified":1678894222672},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/katex/index.ejs","hash":"159e21313df49ef1ab14122bfe7e02d2d4f6fcdf","modified":1678894222676},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/mathjax/index.ejs","hash":"91a412d8324fbacd7a340e4ad031b4e917a16f2f","modified":1678894222676},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/snackbar/index.ejs","hash":"bddb75f7112d2b438f462a6ebef79810ef5ac291","modified":1678894222677},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/chat/gitter/script.ejs","hash":"e4f06c50c23d433a0e63fc703a35704c336ba090","modified":1678894222699},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/chat/tidio/script.ejs","hash":"bb678b5e8a9fb87fc1c1e48914da3a1a052a8e02","modified":1678894222699},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/artalk/script.ejs","hash":"799633e92efc6abb5d0a9ded8b6db70948dcddad","modified":1678894222728},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/beaudar/script.ejs","hash":"285226000b8bff1f96b8b69da268a0af79d04b98","modified":1678894222730},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/disqus/script.ejs","hash":"3a67befc560e6d0695f64c05d82c68ee9771a1a7","modified":1678894223204},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/discuss/script.ejs","hash":"b8a13e121923d31a5b6870be84c69e5587f4f0ce","modified":1678894222730},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/disqusjs/script.ejs","hash":"569912aebbde81490e57ab2ce49e35bf678723f2","modified":1678894223214},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/giscus/script.ejs","hash":"45fe8d3e47d2a990292426d14091cffa46301704","modified":1678894223215},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/gitalk/script.ejs","hash":"00a20cd4a398204b1193b0e9d3fac2c5f32daad3","modified":1678894223217},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/hashover/script.ejs","hash":"7ecd8879c66b907da04093a465d346f6569cee83","modified":1678894223219},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/isso/script.ejs","hash":"aa7c81e6df9b803966efe5eda8edbc85b924f34b","modified":1678894223220},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/livere/script.ejs","hash":"54340ba16d4f46ed4f3c6f67ac7ba1a2e68be67a","modified":1678894223222},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/twikoo/script.ejs","hash":"c0fc694962e94a478b85ae7adb95917fc5f8f2c4","modified":1678894223224},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/utterances/script.ejs","hash":"afbb35e59b3b3af34627416ee47ecad1d564bdbc","modified":1678894223237},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/vssue/script.ejs","hash":"8171fdfbe668277942eaa55847ba646532d245eb","modified":1678894223239},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/waline/script.ejs","hash":"945fa1928c6bd1599134b8627b35d3dd7cd79013","modified":1678894223239},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/z-custom/script.ejs","hash":"e5cfe25fb88b7a3dd0c68e20b2e17d44eb2a1f04","modified":1678894223240},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/highlight/highlightjs/script.ejs","hash":"3ffdc0dea93efd49b23910fe7a295784c7053b97","modified":1678894223251},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/highlight/prismjs/script.ejs","hash":"1349c07f6a1f3efca0a00f483c918d091007d9b3","modified":1678894223252},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/blogposting.js","hash":"f8543b0460c9a5b23ee43d8ed49e018c1c627439","modified":1678894223298},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/breadcrumblist.js","hash":"df6316082af2df061f16bb01d5b5d3478f98c662","modified":1678894223299},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/config.js","hash":"e4c3c23e58f0bac72010f962d92da641445e748a","modified":1678894223307},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/index.js","hash":"41e4af773dfb4755752cb74a6d70e4b5b0c1ce4d","modified":1678894223323},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/organization.js","hash":"02c08f0362aec5d310b8c7e69823cd88ed49ea5e","modified":1678894223329},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/person.js","hash":"afca448311d62a44566d9471594a43495a6be6db","modified":1678894223333},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/website.js","hash":"556f28164d31b3898d06cb8f76472bc6547bb1db","modified":1678894223356},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_base/base.styl","hash":"712eb4803dc595eb111ebd89546e6ed3fb1ec7ce","modified":1679227404421},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_base/fontfamily_async.styl","hash":"48c006682b8f44681662e4b0f8d3ebfdf85add69","modified":1678894223386},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/archive.styl","hash":"a96709230abbc8d4fc40361b8fc02d4249abb4a1","modified":1678894223370},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/article.styl","hash":"8d9fe767bb92fc57681817f21af7b2cdc07b0dc3","modified":1679228928742},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/footer.styl","hash":"bb850b4707ee025e267e079fcf85484849cf4f41","modified":1678894223387},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/friends-simpleuser.styl","hash":"07c477e15bf75615faff5587cc82dbc6004a901a","modified":1678894223388},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/friends-traditional.styl","hash":"2da0419cd5874d03d7d5bafdb081beb6cb786608","modified":1678894223389},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/img.styl","hash":"55d79f07b717d3e28515b41401f656d1593be624","modified":1678894223397},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/loading.styl","hash":"56a2b9f46edd5b87e49d11647dc9396b0d833d54","modified":1678894224265},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/main.styl","hash":"d75ac5fd9ee7cddcbaa421d676c2ae0c4501b121","modified":1678894224266},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/md.styl","hash":"2e3e0f52e88065fa690cba07a8df2e94cbbf3e69","modified":1679228705261},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/pagination.styl","hash":"65dacf95771fc518a06cbf301f4c0b06201d7321","modified":1678894224268},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/posts.styl","hash":"31cf7bdbb44caa173f3dfd49d98157cb6be85c6f","modified":1678894224269},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/sidebar.styl","hash":"4b75b29b67b88ef5ee365535d521c3ee8256a1ea","modified":1678894224270},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/snackbar.styl","hash":"752a7fea5284a61fd9305d3b0fcaa43f2e64862f","modified":1678894224271},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/toc.styl","hash":"3346fbcbcbc2533997a8bf1fbbf801d9120b03ab","modified":1678894224274},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/search.styl","hash":"ac9f4c4f6e1ac38757dfeae3483a55983e1491d0","modified":1678894224270},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/video.styl","hash":"680e8cf8fc5d62913dad4ccd06135caad2bb3e92","modified":1678894224274},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/aplayer.styl","hash":"da809e1dde8adb9d1c98f0daeb52a2d920d497f7","modified":1678894223370},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/cursor.styl","hash":"bc055048c7d017be8cf25a3385f516656c96cf66","modified":1678894223377},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/fontcolor.styl","hash":"fa13f91f8be68b62210048d1481c3b23e23f939b","modified":1678894223384},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/gitalk.styl","hash":"c4c9950fd6654f87ca4f481cf3065ca4069fac48","modified":1678894223394},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/index.styl","hash":"a18de4930b88f62e557e62e8fbb9e2ce550c5d49","modified":1678894224263},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/mathjax.styl","hash":"11ee86571f31f9aa61dcc48b40977dcd974d76a4","modified":1678894224266},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/message.styl","hash":"995b46084664f2ed2cf025c1a208089ecfe1147e","modified":1678894224267},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/pjaxanimate.styl","hash":"86c80d1d1c8a02c0eb4c0b5d29ff41c9a5dd5ac3","modified":1678894224268},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/Readme.md","hash":"51986550e80990e1db23e2ee4165e5e4800e4b9f","modified":1678894223367},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/btns.styl","hash":"bf592cd78c146bb671217f106632b9e5bcc7c145","modified":1678894223374},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/checkbox.styl","hash":"8c62dd38914d939069d9222c54787a24cb5c31f7","modified":1678894223374},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/dropmenu.styl","hash":"a136ebb90bedef15c1d8b8d75e09b37c3873f5e8","modified":1678894223383},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/fancybox.styl","hash":"1b4709787f9bda8ce565aa9a4aaf7f1f58751b44","modified":1678894223383},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/folding.styl","hash":"253f13e60218e0d014a1df99933f5cdba507f3b1","modified":1678894223384},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/frame.styl","hash":"6ffbb29514781aa4fa7d7653706554ce33f4525b","modified":1678894223387},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/friends.styl","hash":"8f9e60b94c02197e4555f923d357017742bf8d7b","modified":1678894223390},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/ghcard.styl","hash":"58adb206695a704b1f40df42e2dc10e9e9055aeb","modified":1678894223391},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/image.styl","hash":"bb4b07841602592e421597ba8dd7110edec789d8","modified":1678894223397},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/link.styl","hash":"82cdcc537612eec3e1af40d00edf80b14116c191","modified":1678894224265},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/media.styl","hash":"576c9eede3a8f9ec2ba1a970e92a49154ec3acb3","modified":1678894224267},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/note.styl","hash":"005d3c55c2216d7c88661f79ad466ad89fad4784","modified":1678894224267},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/sites.styl","hash":"01593f3b8a233bc2c3193796707e4ed77df217bb","modified":1678894224270},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/span.styl","hash":"6e9f8b453244d9241d3fceed0a56e12c86a4b446","modified":1678894224272},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/swiper.styl","hash":"819385594f1825e26074ade900835a3f4031fe42","modified":1678894224272},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/table.styl","hash":"ef07ab4fe8a391ea9039fbe53333aaf58e3ce033","modified":1678894224273},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/tabs.styl","hash":"a2366f4fe1d9f06e47a7a994cfc80a1edbf6c535","modified":1678894224273},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/tag.json","hash":"506f87e397f258b097ba24ce16c33b5353bab462","modified":1678894223363},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/text.styl","hash":"b2c2f3946fb611ad052c61d7309098edbf494c86","modified":1678894224273},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/timeline.styl","hash":"f84f411a3b7dcdbfd4fb19ac4e0f91300c5e19be","modified":1678894224273},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/contributors.js","hash":"cf1af362cf73c83a28ae2651eb1daafaed2ec91f","modified":1678894223312},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/friends.js","hash":"7d53cf366638d0e254f7f26de01c8892710d1d23","modified":1678894223316},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/sites.js","hash":"47b0ff4a3ccea2da9b60023cb4288f979504b0c7","modified":1678894223347},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_dark/dark_async.styl","hash":"a5da6f0b232a767057321fa51e382fd2d86bd98d","modified":1678894223378},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_dark/dark_plugins.styl","hash":"c56c2271847809e21e4938d770577622aeb161aa","modified":1678894223381},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/index.styl","hash":"6c681c760fa63425e7564c0d68532bb5ac95690a","modified":1678894224263},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_rightmenu/reading.styl","hash":"cb01065424dbd32c79b973b06fcdbc1c72917bc6","modified":1678894224269},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_rightmenu/rightmenu.styl","hash":"ef456a92173c303b61015f3581450aa14f0d2b41","modified":1678894224269},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/highlightjs/clipboard.styl","hash":"6818ba853fd6a319ff4eb50d228b1d625db9a0fd","modified":1678894223375},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/highlightjs/color.styl","hash":"319ccc46d5d387ee14a22e0de1a518288331629b","modified":1678894223377},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/highlightjs/index.styl","hash":"38089b686a0cfdde555539c1c0c5b3fe402afada","modified":1678894224261},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/highlightjs/language.styl","hash":"4fade2fe067f557d3b420d0b9a9d88d18feb9a72","modified":1678894224264},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/prismjs/clipboard.styl","hash":"0f92935e3bb9732b6e1cc7f305577144f1fe99a8","modified":1678894223376},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/prismjs/language.styl","hash":"3af7fae25a0e2c54f0aacb1d8cbe383d5c1e60a5","modified":1678894224264},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/prismjs/index.styl","hash":"215face68fab1c31cfa8d4c21941c72efe54cb78","modified":1678894224263},{"_id":"public/baidusitemap.xml","hash":"77f440773ca1de880185fdb2e21203e1f2766d98","modified":1679727741888},{"_id":"public/atom.xml","hash":"3433a11ec9b467f2fe77ac08eca5cb0d33c90381","modified":1679727741888},{"_id":"public/sitemap.xml","hash":"6e42468e426271b9065cedd62310eeb942036123","modified":1679727741888},{"_id":"public/sitemap.txt","hash":"f8f89ad96f0949095c7ca57a377e948cfd6c633d","modified":1679727741888},{"_id":"public/content.json","hash":"43a0d08fcea87eeeac52e3cc581b312713f147a2","modified":1679727741888},{"_id":"public/about/index.html","hash":"db2a62395818e25aa1808d102967437dca9cb57a","modified":1679727741888},{"_id":"public/tags/index.html","hash":"fe0267f2310f5b285e4db808ce623131741c1956","modified":1679727741888},{"_id":"public/categories/index.html","hash":"aaab72cbef62f7c0b1c4b6f0f209b6440f1a2ac6","modified":1679727741888},{"_id":"public/friends/index.html","hash":"fee021a11a392bac86ba0157c2dcd6ea17889c4d","modified":1679727741888},{"_id":"public/2023/03/25/TCP是如何实现可靠传输的？/index.html","hash":"ffc0738a622ad36ec08f19634c9a2b65bd1439f8","modified":1679727741888},{"_id":"public/2023/03/25/HTTPS原理详解/index.html","hash":"032a0712fef8ec4171bb9ee25fd856678545e951","modified":1679727741888},{"_id":"public/2023/03/25/Session和Cookie/index.html","hash":"5ad7574921c63373c82f1e8b44abc85475b380f0","modified":1679727741888},{"_id":"public/2023/03/25/什么是WebSocket？/index.html","hash":"ebda4c8c2b1405c21714b19b3d22229c18d65713","modified":1679727741888},{"_id":"public/2023/03/25/计算机网络基础概述/index.html","hash":"0aea1ca80a085a0f4f6f53ba2fd868d8d203f87f","modified":1679727741888},{"_id":"public/2023/03/19/Linux-系统-I-O-模型及-select-poll-epoll-详解/index.html","hash":"d5df25d78df429d6c34e5dd90642e7157ca95b99","modified":1679727741888},{"_id":"public/2023/03/19/算法-8-LRU-策略/index.html","hash":"178a2166af4b604d00b677e1ba8be95d061f81d5","modified":1679727741888},{"_id":"public/2023/03/19/算法-7-动态规划/index.html","hash":"910da9b2c6857453bc0f0ef31853d512905f5218","modified":1679727741888},{"_id":"public/2023/03/19/算法-6-贪心算法/index.html","hash":"417f0c61d40091a170e07f2db3c73a06fa05a41c","modified":1679727741888},{"_id":"public/2023/03/19/算法-5-分治-归并/index.html","hash":"44e2f732cc8c45315385b6a182e53030aae00701","modified":1679727741888},{"_id":"public/2023/03/19/算法-4-搜索/index.html","hash":"365074a9717936ec5d25e16145a32b803e752331","modified":1679727741888},{"_id":"public/2023/03/19/算法-3-二分查找/index.html","hash":"fa71b16c7679d98791d37ed00ceb8991c666186b","modified":1679727741888},{"_id":"public/2023/03/19/算法-2-排序/index.html","hash":"4516d3459a7a4b7ea583273a04cb98436cbccc29","modified":1679727741888},{"_id":"public/2023/03/19/算法-1-双指针/index.html","hash":"262d1b4a5b0190b7d0f269c9d2ae293ad36958d6","modified":1679727741888},{"_id":"public/2023/03/19/数据结构-5-栈-队列-堆/index.html","hash":"fc27790ffb986158433c8d7a1b60896950726ffc","modified":1679727741888},{"_id":"public/2023/03/19/数据结构-4-树/index.html","hash":"8bb047275283be5b27feb5b58f09235b42529612","modified":1679727741888},{"_id":"public/2023/03/19/数据结构-3-链表/index.html","hash":"47d6a5f6c9c6f22ce2db9e7ca91f98b398c90e3b","modified":1679727741888},{"_id":"public/2023/03/19/数据结构-2-数组/index.html","hash":"56a20434b45c688d438af178aa680ed0f9b36f99","modified":1679727741888},{"_id":"public/2023/03/19/数据结构-1-字符串/index.html","hash":"099785c4b900407ffffcd0ea88267f8844ea8be7","modified":1679727741888},{"_id":"public/2023/03/13/Linux进程管理-supervisor和nohup原理及使用/index.html","hash":"1f8ef118c66b8d169fa71566b0ab48f6b7088f64","modified":1679727741888},{"_id":"public/archives/index.html","hash":"d53c65d4d6f6831203d15035506a9d7a20797a7c","modified":1679727741888},{"_id":"public/archives/page/2/index.html","hash":"a7ede04d41e20920aaba212dcc0da65758031897","modified":1679727741888},{"_id":"public/archives/2023/index.html","hash":"7cd0ad8a0ead45a05f3c6414ad06d49775f7b66a","modified":1679727741888},{"_id":"public/archives/2023/page/2/index.html","hash":"b6c69b074ac24e89e279925129520a9bd003885e","modified":1679727741888},{"_id":"public/archives/2023/03/index.html","hash":"acf2c09e33ab4a02fe724a405fb27904a8face07","modified":1679727741888},{"_id":"public/archives/2023/03/page/2/index.html","hash":"b2f83bd28246e9d0e5308ae3831ac15251900cb4","modified":1679727741888},{"_id":"public/categories/操作系统/index.html","hash":"ffbea493524e038b27abb0d80bbeb8b648421b83","modified":1679727741888},{"_id":"public/categories/数据结构/index.html","hash":"4c9c0220c96994c377fa4299d2b143ea3c15209d","modified":1679727741888},{"_id":"public/categories/算法/index.html","hash":"863bfe8b4c3b4bc6612b758903fc19885c6011db","modified":1679727741888},{"_id":"public/categories/计算机网络/index.html","hash":"b9eeaa78832f6992d223a7c046f871b5be8a45f3","modified":1679727741888},{"_id":"public/index.html","hash":"d641e8d6c5d4d592b89a83567bd3852784df4a4e","modified":1679727741888},{"_id":"public/page/2/index.html","hash":"2a1c0209b86e478304f25fabc98a790b10a46a9a","modified":1679727741888},{"_id":"public/tags/Linux/index.html","hash":"aaa2956ae55b4a717800339e176f52ba4293c168","modified":1679727741888},{"_id":"public/tags/I-O模型/index.html","hash":"3e8e8d2c084f2f02217fdc8f07f1b5a379bd8d16","modified":1679727741888},{"_id":"public/tags/select-poll-epoll/index.html","hash":"4999ee29ffa3fb4d53c7ffec26e24be5047e971a","modified":1679727741888},{"_id":"public/tags/守护进程/index.html","hash":"aee4b14b7ac588daef73e7c044a3825f10ebcbe1","modified":1679727741888},{"_id":"public/tags/数组/index.html","hash":"6b32f63f12c01426c9d19ce18400b7348f560a63","modified":1679727741888},{"_id":"public/tags/leetcode/index.html","hash":"54e6faf2f49beaa60769b2b51dc081fd183c8fb8","modified":1679727741888},{"_id":"public/tags/leetcode/page/2/index.html","hash":"1a468bcd99136f6e2f24aa520a28751f0d71eb87","modified":1679727741888},{"_id":"public/tags/字符串/index.html","hash":"bb0c7f64ba42789c7d8a27e37337ebf074fe3a4c","modified":1679727741888},{"_id":"public/tags/树/index.html","hash":"f27be917db79f571333c1515ae08a0af0e60fe94","modified":1679727741888},{"_id":"public/tags/二叉树/index.html","hash":"7a0c33ca973699ef64a9eb00421c64003fe8fcc3","modified":1679727741888},{"_id":"public/tags/链表/index.html","hash":"382b390be64dd237404a27a5768989da30bfff24","modified":1679727741888},{"_id":"public/tags/栈/index.html","hash":"80f3d4ba5d54850d47ef6ab6e404bc779bcb699f","modified":1679727741888},{"_id":"public/tags/队列/index.html","hash":"b3a683b79b3a235b228ea6beae81e06240e20874","modified":1679727741888},{"_id":"public/tags/堆/index.html","hash":"21f1848b1c0fb68ac8c856e1a07e14f4e22a8a85","modified":1679727741888},{"_id":"public/tags/快速排序/index.html","hash":"616f7b4e9d8b626558c298b04de605587984d3fd","modified":1679727741888},{"_id":"public/tags/二分查找/index.html","hash":"214aa7d78c32493ce0c29eac0ad98cf4e2b97777","modified":1679727741888},{"_id":"public/tags/深度优先搜索/index.html","hash":"3b0eeabf0799aaf7e3af59d3188c9fb2474e8418","modified":1679727741888},{"_id":"public/tags/广度优先搜索/index.html","hash":"3943c231bab4014d13a5ffb66a86b067b7d89e8d","modified":1679727741888},{"_id":"public/tags/二叉搜索树/index.html","hash":"c0d5d6012e1968687dea167c2d3c175ee903fba6","modified":1679727741888},{"_id":"public/tags/贪心/index.html","hash":"909a185e91e1f7509feb18acc1c93944906a9343","modified":1679727741888},{"_id":"public/tags/动态规划/index.html","hash":"ec38f481d1301d3bd23ec641c4386a40f7969232","modified":1679727741888},{"_id":"public/tags/LRU/index.html","hash":"36a01f970f1223fd78f5d0327a7dcfb68e3931a4","modified":1679727741888},{"_id":"public/tags/缓存/index.html","hash":"431c33ca1b52e4010b659b3e3c92509115cc8030","modified":1679727741888},{"_id":"public/tags/HTTPS/index.html","hash":"abb6161cb6f31db17daa9f523b3b16199108d6cf","modified":1679727741888},{"_id":"public/tags/Session/index.html","hash":"7fc28720d710e9b5fe476815f0d8fda53f605365","modified":1679727741888},{"_id":"public/tags/Cookie/index.html","hash":"ef5a62b827769cec3d93c8c29a0b320490dc776c","modified":1679727741888},{"_id":"public/tags/TCP/index.html","hash":"0c036115e0360cd6d268f29f9c1549ca9aacaefa","modified":1679727741888},{"_id":"public/tags/WebSocket/index.html","hash":"d05647480e480d5fa976db8cb3846bac6db26171","modified":1679727741888},{"_id":"public/CNAME","hash":"4abcec34201ece318489203a9b6c7510711d6fe3","modified":1679727741888},{"_id":"public/css/Readme.html","hash":"942e993f16d5c13b617561506efbed0088016a5d","modified":1679727741888},{"_id":"public/js/plugins/aplayer.js","hash":"95f2e47535c8d37e90cab7726d25845cf01ca477","modified":1679727741888},{"_id":"public/js/plugins/parallax.js","hash":"3c3210bde6e86d7d157c34c14796abe98cb1bbd0","modified":1679727741888},{"_id":"public/js/search/hexo.js","hash":"4b4ecb0c950b95bed02e0e1274aa50c4989553a3","modified":1679727741888},{"_id":"public/js/plugins/tags/contributors.js","hash":"cf1af362cf73c83a28ae2651eb1daafaed2ec91f","modified":1679727741888},{"_id":"public/js/plugins/tags/friends.js","hash":"7d53cf366638d0e254f7f26de01c8892710d1d23","modified":1679727741888},{"_id":"public/js/plugins/tags/sites.js","hash":"47b0ff4a3ccea2da9b60023cb4288f979504b0c7","modified":1679727741888},{"_id":"public/css/first.css","hash":"860db6f11ac4199eb835856caacef5947ef122bf","modified":1679727741888},{"_id":"public/css/style.css","hash":"5d53331cf5e2362537d3f6f0bd8560df700dfd67","modified":1679727741888},{"_id":"public/js/plugins/rightMenu.js","hash":"58d3b19e244f20cb24b0c24120d3f00fc26dc5fe","modified":1679727741888},{"_id":"public/js/plugins/rightMenus.js","hash":"2532b97ea0215add163f74216a23b3f8f4949407","modified":1679727741888},{"_id":"public/js/app.js","hash":"fe351c107526d7f0aa127ea6feb7f90dcf161f16","modified":1679727741888}],"Category":[{"name":"操作系统","_id":"clfnmj1720004htfi2rb98hji"},{"name":"数据结构","_id":"clfnmj17b000fhtfihdg976ai"},{"name":"算法","_id":"clfnmj17m0019htfid7mratia"},{"name":"计算机网络","_id":"clfnmj17t0026htfihzt2g5kg"}],"Data":[],"Page":[{"title":"about","date":"2023-03-12T16:11:09.000Z","_content":"\n## 平平无奇","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-03-13 00:11:09\n---\n\n## 平平无奇","updated":"2023-03-15T16:00:23.237Z","path":"about/index.html","comments":1,"layout":"page","_id":"clfnmj16t0000htfi111z6tco","content":"<h2 id=\"平平无奇\"><a href=\"#平平无奇\" class=\"headerlink\" title=\"平平无奇\"></a>平平无奇</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"平平无奇\"><a href=\"#平平无奇\" class=\"headerlink\" title=\"平平无奇\"></a>平平无奇</h2>"},{"title":"全部分类","date":"2023-03-19T05:56:46.000Z","layout":"category","_content":"\n","source":"categories/index.md","raw":"---\ntitle: 全部分类\ndate: 2023-03-19 13:56:46\nlayout: category\n---\n\n","updated":"2023-03-19T06:44:59.152Z","path":"categories/index.html","comments":1,"_id":"clfnmj16z0002htfic9nq3gm4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"全部标签","date":"2023-03-19T05:57:02.000Z","layout":"tag","_content":"","source":"tags/index.md","raw":"---\ntitle: 全部标签\ndate: 2023-03-19 13:57:02\nlayout: tag\n---\n","updated":"2023-03-19T06:45:08.655Z","path":"tags/index.html","comments":1,"_id":"clfnmj1740006htfi2gnjgwpj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"friends","date":"2023-03-19T05:57:22.000Z","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2023-03-19 13:57:22\nlayout: friends\n---\n","updated":"2023-03-19T06:46:31.862Z","path":"friends/index.html","comments":1,"_id":"clfnmj1760008htfi4yute1b7","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Linux 系统 I/O 模型及 select/poll/epoll 详解","date":"2023-03-19T14:06:15.000Z","_content":"\n## 基本概念说明\n理解Linux的IO模型之前，首先要了解一些基本概念，才能理解这些IO模型设计的依据\n\n### 用户空间和内核空间\n操作系统使用虚拟内存来映射物理内存，对于32位的操作系统来说，虚拟地址空间为4G（2^32）。操作系统的核心是内核，为了保护用户进程不能直接操作内核，保证内核安全，操作系统将虚拟地址空间划分为内核空间和用户空间。内核可以访问全部的地址空间，拥有访问底层硬件设备的权限，普通的应用程序需要访问硬件设备必须通过**系统调用**来实现。\n\n对于Linux系统来说，将虚拟内存的最高1G字节的空间作为内核空间仅供内核使用，低3G字节的空间供用户进程使用，称为用户空间。\n\n### 进程的状态\n- 就绪\n- 阻塞\n- 运行\n\n### 进程切换\n\n### 文件描述符fd\n\n###  缓存I/O\n又被称为标准I/O，大多数文件系统的默认I/O都是缓存I/O。在Linux系统的缓存I/O机制中，操作系统会将I/O的数据缓存在页缓存（内存）中，也就是数据先被拷贝到内核的缓冲区（内核地址空间），然后才会从内核缓冲区拷贝到应用程序的缓冲区（用户地址空间）。\n\n这种方式很明显的缺点就是数据传输过程中需要再应用程序地址空间和内核空间进行多次数据拷贝操作，这些操作带来的CPU以及内存的开销是非常大的。\n\n### 二I/O模式\n由于Linux系统采用的缓存I/O模式，对于一次I/O访问，以读操作举例，数据先会被拷贝到内核缓冲区，然后才会从内核缓冲区拷贝到应用程序的缓存区，当一个read系统调用发生的时候，会经历两个阶段：\n- 等待数据到来，进程处于阻塞状态\n- 当数据准备就绪后，将数据从内核拷贝到用户进程，进程处于运行状态\n\n正是因为这两个状态，Linux系统才产生了多种不同的网络I/O模式的方案\n\n## Linux系统I/O模型\n### 阻塞IO（blocking IO）\nLinux系统默认情况下所有socke都是blocking的，一个读操作流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-5b4abb97fad3f18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n以UDP socket为例，当用户进程调用了recvfrom系统调用，如果数据还没准备好，应用进程被阻塞，内核直到数据到来且将数据从内核缓冲区拷贝到了应用进程缓冲区，然后向用户进程返回结果，用户进程才解除block状态，重新运行起来。\n\n阻塞模行下只是阻塞了当前的应用进程，其他进程还可以执行，不消耗CPU时间，CPU的利用率较高。\n\n### 非阻塞IO（nonblocking IO）\nLinux可以设置socket为非阻塞的，非阻塞模式下执行一个读操作流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-485bfdc370909781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当用户进程发出recvfrom系统调用时，如果kernel中的数据还没准备好，recvfrom会立即返回一个error结果，不会阻塞用户进程，用户进程收到error时知道数据还没准备好，\b过一会再调用recvfrom，直到kernel中的数据准备好了，内核就立即将数据拷贝到用户内存然后返回ok，这个过程需要用户进程去轮询内核数据是否准备好。\n\n非阻塞模型下由于要处理更多的系统调用，因此CPU利用率比较低。\n\n### 信号驱动IO\n应用进程使用sigaction系统调用，内核立即返回，等到kernel数据准备好时会给用户进程发送一个信号，告诉用户进程可以进行IO操作了，然后用户进程再调用IO系统调用如recvfrom，将数据从内核缓冲区拷贝到应用进程。流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-1f14b7a7da55a2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n相比于轮询的方式，不需要多次系统调用轮询，信号驱动IO的CPU利用率更高。\n\n### 异步IO\n异步IO模型与其他模型最大的区别是，异步IO在系统调用返回的时候所有操作都已经完成，应用进程既不需要等待数据准备，也不需要在数据到来后等待数据从内核缓冲区拷贝到用户缓冲区，流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-95971297cce5bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在数据拷贝完成后，kernel会给用户进程发送一个信号告诉其read操作完成了。\n\n### IO多路复用\n是用select、poll等待数据，可以等待多个socket中的任一个变为可读，这一过程会被阻塞，当某个套接字数据到来时返回，之后再用recvfrom系统调用把数据从内核缓存区复制到用户进程，流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-8845990e0d75eb9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n流程类似阻塞IO，甚至比阻塞IO更差，多使用了一个系统调用，但是IO多路复用最大的特点是让单个进程能同时处理多个IO事件的能力，又被称为事件驱动IO，相比于多线程模型，IO复用模型不需要线程的创建、切换、销毁，系统开销更小，适合高并发的场景。\n\n####  select\nselect是IO多路复用模型的一种实现，当select函数返回后可以通过轮询fdset来找到就绪的socket。\n```c\nint select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)\n```\n\n优点是几乎所有平台都支持，缺点在于能够监听的fd数量有限，Linux系统上一般为1024，是写死在宏定义中的，要修改需要重新编译内核。而且每次都要把所有的fd在用户空间和内核空间拷贝，这个操作是比较耗时的。\n\n#### poll\npoll和select基本相同，不同的是poll没有最大fd数量限制（实际也会受到物理资源的限制，因为系统的fd数量是有限的），而且提供了更多的时间类型。\n```c\nint poll(struct pollfd *fds, unsigned int nfds, int timeout)\n```\n\n总结：select和poll都需要在返回后通过轮询的方式检查就绪的socket，事实上同时连的大量socket在一个时刻只有很少的处于就绪状态，因此随着监视的描述符数量的变多，其性能也会逐渐下降。\n\n#### epoll\nepoll是select和poll的改进版本，更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。\n```c\nint epoll_create(int size)\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)\n```\nepoll_create()用来创建一个epoll句柄。\nepoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个就绪链表中管理。\n epoll_wait() 可以从就绪链表中得到事件完成的描述符，因此进程不需要通过轮询来获得事件完成的描述符。\n\n##### LT模式（水平触发，默认）\n当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序可以不立即处理该事件，下次调用epoll_wait还会再次通知该事件，支持block和nonblocking socket。\n\n##### ET模式（边缘触发）\n当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序需要立即处理该事件，如果不立即处理，下次调用epoll_wait不会再次通知该事件。\n\nET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用nonblocking socket，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n#### 应用场景\n- select的timeout参数精度为微妙，而poll和epoll都是毫秒，会因此select更加适合对实时性要求比较高的场景\n\n- poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。\n\n- epoll适合高并发的场景，有大量描述符需要同时监听，并且最好是长连接。\n不适合监控的描述符状态变化频繁且短暂，因为epoll的描述符都存在内核中，每次对其状态修改都要通过epoll_ctl系统调用来实现，频繁的系统调用导致频繁在内核态和用户态切换，会大大降低性能。\n\n## 参考\n【segmentfault】[Linux IO模式及 select、poll、epoll详解](https://segmentfault.com/a/1190000003063859)\n【GitHub】[CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md#%E4%B8%80io-%E6%A8%A1%E5%9E%8B)","source":"_posts/2023/03-19-Linux-系统-I-O-模型及-select-poll-epoll-详解.md","raw":"---\ntitle: Linux 系统 I/O 模型及 select/poll/epoll 详解\ndate: 2023-03-19 22:06:15\ncategories:\n- 操作系统\ntags:\n- Linux\n- I/O模型\n- select/poll/epoll\n---\n\n## 基本概念说明\n理解Linux的IO模型之前，首先要了解一些基本概念，才能理解这些IO模型设计的依据\n\n### 用户空间和内核空间\n操作系统使用虚拟内存来映射物理内存，对于32位的操作系统来说，虚拟地址空间为4G（2^32）。操作系统的核心是内核，为了保护用户进程不能直接操作内核，保证内核安全，操作系统将虚拟地址空间划分为内核空间和用户空间。内核可以访问全部的地址空间，拥有访问底层硬件设备的权限，普通的应用程序需要访问硬件设备必须通过**系统调用**来实现。\n\n对于Linux系统来说，将虚拟内存的最高1G字节的空间作为内核空间仅供内核使用，低3G字节的空间供用户进程使用，称为用户空间。\n\n### 进程的状态\n- 就绪\n- 阻塞\n- 运行\n\n### 进程切换\n\n### 文件描述符fd\n\n###  缓存I/O\n又被称为标准I/O，大多数文件系统的默认I/O都是缓存I/O。在Linux系统的缓存I/O机制中，操作系统会将I/O的数据缓存在页缓存（内存）中，也就是数据先被拷贝到内核的缓冲区（内核地址空间），然后才会从内核缓冲区拷贝到应用程序的缓冲区（用户地址空间）。\n\n这种方式很明显的缺点就是数据传输过程中需要再应用程序地址空间和内核空间进行多次数据拷贝操作，这些操作带来的CPU以及内存的开销是非常大的。\n\n### 二I/O模式\n由于Linux系统采用的缓存I/O模式，对于一次I/O访问，以读操作举例，数据先会被拷贝到内核缓冲区，然后才会从内核缓冲区拷贝到应用程序的缓存区，当一个read系统调用发生的时候，会经历两个阶段：\n- 等待数据到来，进程处于阻塞状态\n- 当数据准备就绪后，将数据从内核拷贝到用户进程，进程处于运行状态\n\n正是因为这两个状态，Linux系统才产生了多种不同的网络I/O模式的方案\n\n## Linux系统I/O模型\n### 阻塞IO（blocking IO）\nLinux系统默认情况下所有socke都是blocking的，一个读操作流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-5b4abb97fad3f18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n以UDP socket为例，当用户进程调用了recvfrom系统调用，如果数据还没准备好，应用进程被阻塞，内核直到数据到来且将数据从内核缓冲区拷贝到了应用进程缓冲区，然后向用户进程返回结果，用户进程才解除block状态，重新运行起来。\n\n阻塞模行下只是阻塞了当前的应用进程，其他进程还可以执行，不消耗CPU时间，CPU的利用率较高。\n\n### 非阻塞IO（nonblocking IO）\nLinux可以设置socket为非阻塞的，非阻塞模式下执行一个读操作流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-485bfdc370909781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当用户进程发出recvfrom系统调用时，如果kernel中的数据还没准备好，recvfrom会立即返回一个error结果，不会阻塞用户进程，用户进程收到error时知道数据还没准备好，\b过一会再调用recvfrom，直到kernel中的数据准备好了，内核就立即将数据拷贝到用户内存然后返回ok，这个过程需要用户进程去轮询内核数据是否准备好。\n\n非阻塞模型下由于要处理更多的系统调用，因此CPU利用率比较低。\n\n### 信号驱动IO\n应用进程使用sigaction系统调用，内核立即返回，等到kernel数据准备好时会给用户进程发送一个信号，告诉用户进程可以进行IO操作了，然后用户进程再调用IO系统调用如recvfrom，将数据从内核缓冲区拷贝到应用进程。流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-1f14b7a7da55a2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n相比于轮询的方式，不需要多次系统调用轮询，信号驱动IO的CPU利用率更高。\n\n### 异步IO\n异步IO模型与其他模型最大的区别是，异步IO在系统调用返回的时候所有操作都已经完成，应用进程既不需要等待数据准备，也不需要在数据到来后等待数据从内核缓冲区拷贝到用户缓冲区，流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-95971297cce5bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在数据拷贝完成后，kernel会给用户进程发送一个信号告诉其read操作完成了。\n\n### IO多路复用\n是用select、poll等待数据，可以等待多个socket中的任一个变为可读，这一过程会被阻塞，当某个套接字数据到来时返回，之后再用recvfrom系统调用把数据从内核缓存区复制到用户进程，流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-8845990e0d75eb9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n流程类似阻塞IO，甚至比阻塞IO更差，多使用了一个系统调用，但是IO多路复用最大的特点是让单个进程能同时处理多个IO事件的能力，又被称为事件驱动IO，相比于多线程模型，IO复用模型不需要线程的创建、切换、销毁，系统开销更小，适合高并发的场景。\n\n####  select\nselect是IO多路复用模型的一种实现，当select函数返回后可以通过轮询fdset来找到就绪的socket。\n```c\nint select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)\n```\n\n优点是几乎所有平台都支持，缺点在于能够监听的fd数量有限，Linux系统上一般为1024，是写死在宏定义中的，要修改需要重新编译内核。而且每次都要把所有的fd在用户空间和内核空间拷贝，这个操作是比较耗时的。\n\n#### poll\npoll和select基本相同，不同的是poll没有最大fd数量限制（实际也会受到物理资源的限制，因为系统的fd数量是有限的），而且提供了更多的时间类型。\n```c\nint poll(struct pollfd *fds, unsigned int nfds, int timeout)\n```\n\n总结：select和poll都需要在返回后通过轮询的方式检查就绪的socket，事实上同时连的大量socket在一个时刻只有很少的处于就绪状态，因此随着监视的描述符数量的变多，其性能也会逐渐下降。\n\n#### epoll\nepoll是select和poll的改进版本，更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。\n```c\nint epoll_create(int size)\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)\n```\nepoll_create()用来创建一个epoll句柄。\nepoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个就绪链表中管理。\n epoll_wait() 可以从就绪链表中得到事件完成的描述符，因此进程不需要通过轮询来获得事件完成的描述符。\n\n##### LT模式（水平触发，默认）\n当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序可以不立即处理该事件，下次调用epoll_wait还会再次通知该事件，支持block和nonblocking socket。\n\n##### ET模式（边缘触发）\n当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序需要立即处理该事件，如果不立即处理，下次调用epoll_wait不会再次通知该事件。\n\nET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用nonblocking socket，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n#### 应用场景\n- select的timeout参数精度为微妙，而poll和epoll都是毫秒，会因此select更加适合对实时性要求比较高的场景\n\n- poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。\n\n- epoll适合高并发的场景，有大量描述符需要同时监听，并且最好是长连接。\n不适合监控的描述符状态变化频繁且短暂，因为epoll的描述符都存在内核中，每次对其状态修改都要通过epoll_ctl系统调用来实现，频繁的系统调用导致频繁在内核态和用户态切换，会大大降低性能。\n\n## 参考\n【segmentfault】[Linux IO模式及 select、poll、epoll详解](https://segmentfault.com/a/1190000003063859)\n【GitHub】[CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md#%E4%B8%80io-%E6%A8%A1%E5%9E%8B)","slug":"Linux-系统-I-O-模型及-select-poll-epoll-详解","published":1,"updated":"2023-03-19T14:07:53.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj16w0001htfi4vki430r","content":"<h2 id=\"基本概念说明\"><a href=\"#基本概念说明\" class=\"headerlink\" title=\"基本概念说明\"></a>基本概念说明</h2><p>理解Linux的IO模型之前，首先要了解一些基本概念，才能理解这些IO模型设计的依据</p>\n<h3 id=\"用户空间和内核空间\"><a href=\"#用户空间和内核空间\" class=\"headerlink\" title=\"用户空间和内核空间\"></a>用户空间和内核空间</h3><p>操作系统使用虚拟内存来映射物理内存，对于32位的操作系统来说，虚拟地址空间为4G（2^32）。操作系统的核心是内核，为了保护用户进程不能直接操作内核，保证内核安全，操作系统将虚拟地址空间划分为内核空间和用户空间。内核可以访问全部的地址空间，拥有访问底层硬件设备的权限，普通的应用程序需要访问硬件设备必须通过<strong>系统调用</strong>来实现。</p>\n<p>对于Linux系统来说，将虚拟内存的最高1G字节的空间作为内核空间仅供内核使用，低3G字节的空间供用户进程使用，称为用户空间。</p>\n<h3 id=\"进程的状态\"><a href=\"#进程的状态\" class=\"headerlink\" title=\"进程的状态\"></a>进程的状态</h3><ul>\n<li>就绪</li>\n<li>阻塞</li>\n<li>运行</li>\n</ul>\n<h3 id=\"进程切换\"><a href=\"#进程切换\" class=\"headerlink\" title=\"进程切换\"></a>进程切换</h3><h3 id=\"文件描述符fd\"><a href=\"#文件描述符fd\" class=\"headerlink\" title=\"文件描述符fd\"></a>文件描述符fd</h3><h3 id=\"缓存I-x2F-O\"><a href=\"#缓存I-x2F-O\" class=\"headerlink\" title=\"缓存I&#x2F;O\"></a>缓存I&#x2F;O</h3><p>又被称为标准I&#x2F;O，大多数文件系统的默认I&#x2F;O都是缓存I&#x2F;O。在Linux系统的缓存I&#x2F;O机制中，操作系统会将I&#x2F;O的数据缓存在页缓存（内存）中，也就是数据先被拷贝到内核的缓冲区（内核地址空间），然后才会从内核缓冲区拷贝到应用程序的缓冲区（用户地址空间）。</p>\n<p>这种方式很明显的缺点就是数据传输过程中需要再应用程序地址空间和内核空间进行多次数据拷贝操作，这些操作带来的CPU以及内存的开销是非常大的。</p>\n<h3 id=\"二I-x2F-O模式\"><a href=\"#二I-x2F-O模式\" class=\"headerlink\" title=\"二I&#x2F;O模式\"></a>二I&#x2F;O模式</h3><p>由于Linux系统采用的缓存I&#x2F;O模式，对于一次I&#x2F;O访问，以读操作举例，数据先会被拷贝到内核缓冲区，然后才会从内核缓冲区拷贝到应用程序的缓存区，当一个read系统调用发生的时候，会经历两个阶段：</p>\n<ul>\n<li>等待数据到来，进程处于阻塞状态</li>\n<li>当数据准备就绪后，将数据从内核拷贝到用户进程，进程处于运行状态</li>\n</ul>\n<p>正是因为这两个状态，Linux系统才产生了多种不同的网络I&#x2F;O模式的方案</p>\n<h2 id=\"Linux系统I-x2F-O模型\"><a href=\"#Linux系统I-x2F-O模型\" class=\"headerlink\" title=\"Linux系统I&#x2F;O模型\"></a>Linux系统I&#x2F;O模型</h2><h3 id=\"阻塞IO（blocking-IO）\"><a href=\"#阻塞IO（blocking-IO）\" class=\"headerlink\" title=\"阻塞IO（blocking IO）\"></a>阻塞IO（blocking IO）</h3><p>Linux系统默认情况下所有socke都是blocking的，一个读操作流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-5b4abb97fad3f18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-5b4abb97fad3f18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>以UDP socket为例，当用户进程调用了recvfrom系统调用，如果数据还没准备好，应用进程被阻塞，内核直到数据到来且将数据从内核缓冲区拷贝到了应用进程缓冲区，然后向用户进程返回结果，用户进程才解除block状态，重新运行起来。</p>\n<p>阻塞模行下只是阻塞了当前的应用进程，其他进程还可以执行，不消耗CPU时间，CPU的利用率较高。</p>\n<h3 id=\"非阻塞IO（nonblocking-IO）\"><a href=\"#非阻塞IO（nonblocking-IO）\" class=\"headerlink\" title=\"非阻塞IO（nonblocking IO）\"></a>非阻塞IO（nonblocking IO）</h3><p>Linux可以设置socket为非阻塞的，非阻塞模式下执行一个读操作流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-485bfdc370909781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-485bfdc370909781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>当用户进程发出recvfrom系统调用时，如果kernel中的数据还没准备好，recvfrom会立即返回一个error结果，不会阻塞用户进程，用户进程收到error时知道数据还没准备好，\b过一会再调用recvfrom，直到kernel中的数据准备好了，内核就立即将数据拷贝到用户内存然后返回ok，这个过程需要用户进程去轮询内核数据是否准备好。</p>\n<p>非阻塞模型下由于要处理更多的系统调用，因此CPU利用率比较低。</p>\n<h3 id=\"信号驱动IO\"><a href=\"#信号驱动IO\" class=\"headerlink\" title=\"信号驱动IO\"></a>信号驱动IO</h3><p>应用进程使用sigaction系统调用，内核立即返回，等到kernel数据准备好时会给用户进程发送一个信号，告诉用户进程可以进行IO操作了，然后用户进程再调用IO系统调用如recvfrom，将数据从内核缓冲区拷贝到应用进程。流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-1f14b7a7da55a2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-1f14b7a7da55a2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>相比于轮询的方式，不需要多次系统调用轮询，信号驱动IO的CPU利用率更高。</p>\n<h3 id=\"异步IO\"><a href=\"#异步IO\" class=\"headerlink\" title=\"异步IO\"></a>异步IO</h3><p>异步IO模型与其他模型最大的区别是，异步IO在系统调用返回的时候所有操作都已经完成，应用进程既不需要等待数据准备，也不需要在数据到来后等待数据从内核缓冲区拷贝到用户缓冲区，流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-95971297cce5bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-95971297cce5bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>在数据拷贝完成后，kernel会给用户进程发送一个信号告诉其read操作完成了。</p>\n<h3 id=\"IO多路复用\"><a href=\"#IO多路复用\" class=\"headerlink\" title=\"IO多路复用\"></a>IO多路复用</h3><p>是用select、poll等待数据，可以等待多个socket中的任一个变为可读，这一过程会被阻塞，当某个套接字数据到来时返回，之后再用recvfrom系统调用把数据从内核缓存区复制到用户进程，流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-8845990e0d75eb9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-8845990e0d75eb9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>流程类似阻塞IO，甚至比阻塞IO更差，多使用了一个系统调用，但是IO多路复用最大的特点是让单个进程能同时处理多个IO事件的能力，又被称为事件驱动IO，相比于多线程模型，IO复用模型不需要线程的创建、切换、销毁，系统开销更小，适合高并发的场景。</p>\n<h4 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h4><p>select是IO多路复用模型的一种实现，当select函数返回后可以通过轮询fdset来找到就绪的socket。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">select</span><span class=\"params\">(<span class=\"type\">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class=\"keyword\">struct</span> timeval *timeout)</span></span><br></pre></td></tr></table></figure>\n\n<p>优点是几乎所有平台都支持，缺点在于能够监听的fd数量有限，Linux系统上一般为1024，是写死在宏定义中的，要修改需要重新编译内核。而且每次都要把所有的fd在用户空间和内核空间拷贝，这个操作是比较耗时的。</p>\n<h4 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h4><p>poll和select基本相同，不同的是poll没有最大fd数量限制（实际也会受到物理资源的限制，因为系统的fd数量是有限的），而且提供了更多的时间类型。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> pollfd *fds, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> nfds, <span class=\"type\">int</span> timeout)</span></span><br></pre></td></tr></table></figure>\n\n<p>总结：select和poll都需要在返回后通过轮询的方式检查就绪的socket，事实上同时连的大量socket在一个时刻只有很少的处于就绪状态，因此随着监视的描述符数量的变多，其性能也会逐渐下降。</p>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>epoll是select和poll的改进版本，更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create</span><span class=\"params\">(<span class=\"type\">int</span> size)</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_ctl</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"type\">int</span> op, <span class=\"type\">int</span> fd, <span class=\"keyword\">struct</span> epoll_event *event)</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event * events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span></span><br></pre></td></tr></table></figure>\n<p>epoll_create()用来创建一个epoll句柄。<br>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I&#x2F;O 准备好的描述符加入到一个就绪链表中管理。<br> epoll_wait() 可以从就绪链表中得到事件完成的描述符，因此进程不需要通过轮询来获得事件完成的描述符。</p>\n<h5 id=\"LT模式（水平触发，默认）\"><a href=\"#LT模式（水平触发，默认）\" class=\"headerlink\" title=\"LT模式（水平触发，默认）\"></a>LT模式（水平触发，默认）</h5><p>当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序可以不立即处理该事件，下次调用epoll_wait还会再次通知该事件，支持block和nonblocking socket。</p>\n<h5 id=\"ET模式（边缘触发）\"><a href=\"#ET模式（边缘触发）\" class=\"headerlink\" title=\"ET模式（边缘触发）\"></a>ET模式（边缘触发）</h5><p>当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序需要立即处理该事件，如果不立即处理，下次调用epoll_wait不会再次通知该事件。</p>\n<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用nonblocking socket，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><ul>\n<li><p>select的timeout参数精度为微妙，而poll和epoll都是毫秒，会因此select更加适合对实时性要求比较高的场景</p>\n</li>\n<li><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>\n</li>\n<li><p>epoll适合高并发的场景，有大量描述符需要同时监听，并且最好是长连接。<br>不适合监控的描述符状态变化频繁且短暂，因为epoll的描述符都存在内核中，每次对其状态修改都要通过epoll_ctl系统调用来实现，频繁的系统调用导致频繁在内核态和用户态切换，会大大降低性能。</p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【segmentfault】<a href=\"https://segmentfault.com/a/1190000003063859\">Linux IO模式及 select、poll、epoll详解</a><br>【GitHub】<a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md#%E4%B8%80io-%E6%A8%A1%E5%9E%8B\">CyC2018&#x2F;CS-Notes</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本概念说明\"><a href=\"#基本概念说明\" class=\"headerlink\" title=\"基本概念说明\"></a>基本概念说明</h2><p>理解Linux的IO模型之前，首先要了解一些基本概念，才能理解这些IO模型设计的依据</p>\n<h3 id=\"用户空间和内核空间\"><a href=\"#用户空间和内核空间\" class=\"headerlink\" title=\"用户空间和内核空间\"></a>用户空间和内核空间</h3><p>操作系统使用虚拟内存来映射物理内存，对于32位的操作系统来说，虚拟地址空间为4G（2^32）。操作系统的核心是内核，为了保护用户进程不能直接操作内核，保证内核安全，操作系统将虚拟地址空间划分为内核空间和用户空间。内核可以访问全部的地址空间，拥有访问底层硬件设备的权限，普通的应用程序需要访问硬件设备必须通过<strong>系统调用</strong>来实现。</p>\n<p>对于Linux系统来说，将虚拟内存的最高1G字节的空间作为内核空间仅供内核使用，低3G字节的空间供用户进程使用，称为用户空间。</p>\n<h3 id=\"进程的状态\"><a href=\"#进程的状态\" class=\"headerlink\" title=\"进程的状态\"></a>进程的状态</h3><ul>\n<li>就绪</li>\n<li>阻塞</li>\n<li>运行</li>\n</ul>\n<h3 id=\"进程切换\"><a href=\"#进程切换\" class=\"headerlink\" title=\"进程切换\"></a>进程切换</h3><h3 id=\"文件描述符fd\"><a href=\"#文件描述符fd\" class=\"headerlink\" title=\"文件描述符fd\"></a>文件描述符fd</h3><h3 id=\"缓存I-x2F-O\"><a href=\"#缓存I-x2F-O\" class=\"headerlink\" title=\"缓存I&#x2F;O\"></a>缓存I&#x2F;O</h3><p>又被称为标准I&#x2F;O，大多数文件系统的默认I&#x2F;O都是缓存I&#x2F;O。在Linux系统的缓存I&#x2F;O机制中，操作系统会将I&#x2F;O的数据缓存在页缓存（内存）中，也就是数据先被拷贝到内核的缓冲区（内核地址空间），然后才会从内核缓冲区拷贝到应用程序的缓冲区（用户地址空间）。</p>\n<p>这种方式很明显的缺点就是数据传输过程中需要再应用程序地址空间和内核空间进行多次数据拷贝操作，这些操作带来的CPU以及内存的开销是非常大的。</p>\n<h3 id=\"二I-x2F-O模式\"><a href=\"#二I-x2F-O模式\" class=\"headerlink\" title=\"二I&#x2F;O模式\"></a>二I&#x2F;O模式</h3><p>由于Linux系统采用的缓存I&#x2F;O模式，对于一次I&#x2F;O访问，以读操作举例，数据先会被拷贝到内核缓冲区，然后才会从内核缓冲区拷贝到应用程序的缓存区，当一个read系统调用发生的时候，会经历两个阶段：</p>\n<ul>\n<li>等待数据到来，进程处于阻塞状态</li>\n<li>当数据准备就绪后，将数据从内核拷贝到用户进程，进程处于运行状态</li>\n</ul>\n<p>正是因为这两个状态，Linux系统才产生了多种不同的网络I&#x2F;O模式的方案</p>\n<h2 id=\"Linux系统I-x2F-O模型\"><a href=\"#Linux系统I-x2F-O模型\" class=\"headerlink\" title=\"Linux系统I&#x2F;O模型\"></a>Linux系统I&#x2F;O模型</h2><h3 id=\"阻塞IO（blocking-IO）\"><a href=\"#阻塞IO（blocking-IO）\" class=\"headerlink\" title=\"阻塞IO（blocking IO）\"></a>阻塞IO（blocking IO）</h3><p>Linux系统默认情况下所有socke都是blocking的，一个读操作流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-5b4abb97fad3f18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>以UDP socket为例，当用户进程调用了recvfrom系统调用，如果数据还没准备好，应用进程被阻塞，内核直到数据到来且将数据从内核缓冲区拷贝到了应用进程缓冲区，然后向用户进程返回结果，用户进程才解除block状态，重新运行起来。</p>\n<p>阻塞模行下只是阻塞了当前的应用进程，其他进程还可以执行，不消耗CPU时间，CPU的利用率较高。</p>\n<h3 id=\"非阻塞IO（nonblocking-IO）\"><a href=\"#非阻塞IO（nonblocking-IO）\" class=\"headerlink\" title=\"非阻塞IO（nonblocking IO）\"></a>非阻塞IO（nonblocking IO）</h3><p>Linux可以设置socket为非阻塞的，非阻塞模式下执行一个读操作流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-485bfdc370909781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>当用户进程发出recvfrom系统调用时，如果kernel中的数据还没准备好，recvfrom会立即返回一个error结果，不会阻塞用户进程，用户进程收到error时知道数据还没准备好，\b过一会再调用recvfrom，直到kernel中的数据准备好了，内核就立即将数据拷贝到用户内存然后返回ok，这个过程需要用户进程去轮询内核数据是否准备好。</p>\n<p>非阻塞模型下由于要处理更多的系统调用，因此CPU利用率比较低。</p>\n<h3 id=\"信号驱动IO\"><a href=\"#信号驱动IO\" class=\"headerlink\" title=\"信号驱动IO\"></a>信号驱动IO</h3><p>应用进程使用sigaction系统调用，内核立即返回，等到kernel数据准备好时会给用户进程发送一个信号，告诉用户进程可以进行IO操作了，然后用户进程再调用IO系统调用如recvfrom，将数据从内核缓冲区拷贝到应用进程。流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-1f14b7a7da55a2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>相比于轮询的方式，不需要多次系统调用轮询，信号驱动IO的CPU利用率更高。</p>\n<h3 id=\"异步IO\"><a href=\"#异步IO\" class=\"headerlink\" title=\"异步IO\"></a>异步IO</h3><p>异步IO模型与其他模型最大的区别是，异步IO在系统调用返回的时候所有操作都已经完成，应用进程既不需要等待数据准备，也不需要在数据到来后等待数据从内核缓冲区拷贝到用户缓冲区，流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-95971297cce5bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>在数据拷贝完成后，kernel会给用户进程发送一个信号告诉其read操作完成了。</p>\n<h3 id=\"IO多路复用\"><a href=\"#IO多路复用\" class=\"headerlink\" title=\"IO多路复用\"></a>IO多路复用</h3><p>是用select、poll等待数据，可以等待多个socket中的任一个变为可读，这一过程会被阻塞，当某个套接字数据到来时返回，之后再用recvfrom系统调用把数据从内核缓存区复制到用户进程，流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-8845990e0d75eb9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>流程类似阻塞IO，甚至比阻塞IO更差，多使用了一个系统调用，但是IO多路复用最大的特点是让单个进程能同时处理多个IO事件的能力，又被称为事件驱动IO，相比于多线程模型，IO复用模型不需要线程的创建、切换、销毁，系统开销更小，适合高并发的场景。</p>\n<h4 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h4><p>select是IO多路复用模型的一种实现，当select函数返回后可以通过轮询fdset来找到就绪的socket。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">select</span><span class=\"params\">(<span class=\"type\">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class=\"keyword\">struct</span> timeval *timeout)</span></span><br></pre></td></tr></table></figure>\n\n<p>优点是几乎所有平台都支持，缺点在于能够监听的fd数量有限，Linux系统上一般为1024，是写死在宏定义中的，要修改需要重新编译内核。而且每次都要把所有的fd在用户空间和内核空间拷贝，这个操作是比较耗时的。</p>\n<h4 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h4><p>poll和select基本相同，不同的是poll没有最大fd数量限制（实际也会受到物理资源的限制，因为系统的fd数量是有限的），而且提供了更多的时间类型。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> pollfd *fds, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> nfds, <span class=\"type\">int</span> timeout)</span></span><br></pre></td></tr></table></figure>\n\n<p>总结：select和poll都需要在返回后通过轮询的方式检查就绪的socket，事实上同时连的大量socket在一个时刻只有很少的处于就绪状态，因此随着监视的描述符数量的变多，其性能也会逐渐下降。</p>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>epoll是select和poll的改进版本，更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create</span><span class=\"params\">(<span class=\"type\">int</span> size)</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_ctl</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"type\">int</span> op, <span class=\"type\">int</span> fd, <span class=\"keyword\">struct</span> epoll_event *event)</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event * events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span></span><br></pre></td></tr></table></figure>\n<p>epoll_create()用来创建一个epoll句柄。<br>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I&#x2F;O 准备好的描述符加入到一个就绪链表中管理。<br> epoll_wait() 可以从就绪链表中得到事件完成的描述符，因此进程不需要通过轮询来获得事件完成的描述符。</p>\n<h5 id=\"LT模式（水平触发，默认）\"><a href=\"#LT模式（水平触发，默认）\" class=\"headerlink\" title=\"LT模式（水平触发，默认）\"></a>LT模式（水平触发，默认）</h5><p>当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序可以不立即处理该事件，下次调用epoll_wait还会再次通知该事件，支持block和nonblocking socket。</p>\n<h5 id=\"ET模式（边缘触发）\"><a href=\"#ET模式（边缘触发）\" class=\"headerlink\" title=\"ET模式（边缘触发）\"></a>ET模式（边缘触发）</h5><p>当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序需要立即处理该事件，如果不立即处理，下次调用epoll_wait不会再次通知该事件。</p>\n<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用nonblocking socket，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><ul>\n<li><p>select的timeout参数精度为微妙，而poll和epoll都是毫秒，会因此select更加适合对实时性要求比较高的场景</p>\n</li>\n<li><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>\n</li>\n<li><p>epoll适合高并发的场景，有大量描述符需要同时监听，并且最好是长连接。<br>不适合监控的描述符状态变化频繁且短暂，因为epoll的描述符都存在内核中，每次对其状态修改都要通过epoll_ctl系统调用来实现，频繁的系统调用导致频繁在内核态和用户态切换，会大大降低性能。</p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【segmentfault】<a href=\"https://segmentfault.com/a/1190000003063859\">Linux IO模式及 select、poll、epoll详解</a><br>【GitHub】<a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md#%E4%B8%80io-%E6%A8%A1%E5%9E%8B\">CyC2018&#x2F;CS-Notes</a></p>\n"},{"title":"Linux进程管理:supervisor和nohup原理及使用","date":"2023-03-13T00:49:37.000Z","_content":"\n## 原理\n\n### 守护进程（daemon）\n守护进程是一类在后台运行的特殊进程，用于执行特定的系统任务。他独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。Linux系统的大多数服务器就是通过守护进程实现的。\n常见的守护进程包括：\n- 系统日志进程syslogd\n- Web服务器httpd\n- 邮件服务器sendmail\n- 数据库服务器mysqld等\n\n守护进程一般在系统启动时开始运行，除非强行终止，否则会持续运行知道系统关机，通常以超级用户（root）权限运行。\n\n### 前台任务与后台任务\n假如有个简单的go的web服务器程序，使用如下方式启动，称为前台任务。独占了命令窗口，只有运行完了或手动终止（Ctrl+C），才能执行其他命令。\n![](https://upload-images.jianshu.io/upload_images/14151453-ec0b4b889fe10808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果以如下方式，在命令结尾加上符号`&`，启动的进程就会称为后台任务。\n![](https://upload-images.jianshu.io/upload_images/14151453-35d2076e46e71ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n后台任务又如下特点：\n- 继承当前session的标准输出(stdout)和标准错误(stderr)，因此如上图所示，后台任务的所有输出仍会同步的在命令行显示\n- 不再继承当前session的标准输入(stdin)，无法向这个任务输入指令，如果它试图读取标准输入，就会暂停执行（halt）\n\n### SIGHUP信号\n变为后台任务并不代表进程成为了守护进程，因为当session关闭后，后台任务就会终止。Linux系统终端session退出流程如下：\n1. 用户准备退出session\n2. 系统向改session发送`SIGHUP`信号\n3. session将`SIGHUP`信号发送给所有子进程\n4. 子进程收到`SIGHUP`信号后会自动退出\n\n## nohup\nnohup 是后台作业的意思， nohup运行的进程将会忽略终端信号运行。即后台运行一个命令。nohup COMMAND & 用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响它的运行。\n\n使用nohup命令的方式可以启动一个守护进程，如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-a2bafec78cb93512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nnohup命令对进程做了如下操作：\n- 忽略`SIGHUP`信号，因此当session关闭进程就不会退出\n- 关闭标准输入，该进程不再接收任何输入，即使运行在前台\n- 重定向标准输出和标准错误到文件nohup.out（默认情况，可以指定输出的文件）\n\nnohup不会自动把进程变为后台任务，所以必须加上`&`。\n\n## supervisor\nsupervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。\nsupervisor管理进程是通过fork/exec的方式把被管理的进程当做子进程来启动，用户只需要在配置文件中将要管理的进程进行配置。\n\n### 结构\nsupervisor主要由Supervisord、Supervisorctl、Web server和XML-RPC interface组成：\n- supervisord：主进程，负责管理进程的server，它会根据配置文件创建指定数量的应用程序的子进程，管理子进程的整个生命周期，对crash的进程重启，对进程变化发送事件通知等。同时通过内置web server和XML-RPC Interface可以轻松实现进程管理。\n- supervisorctl：管理client，用户通过命令行发送消息给supervisord，可以查看进程状态，加载配置文件，启停进程，查看进程标准输出和错误输出，远程操作等。\n- Web server：superviosr提供了web server功能，可通过web控制进程。\n- XML-RPC interface： XML-RPC接口，提供XML-RPC服务来对子进程进行管理和监控。\n\n### macOS环境安装使用\n\n#### 安装并启动\n```shell\n$ brew install supervisor\n$ brew services start supervisor\n```\n#### 创建配置目录和配置文件\n默认的配置文件路径为`/usr/local/etc/supervisord.conf`，查看该文件可以看到如下内容：\n```shell\n$ tail -n2 /usr/local/etc/supervisord.conf\n[include]\nfiles = /usr/local/etc/supervisor.d/*.ini\n```\n可以看到include了`/usr/local/etc/supervisor.d/`目录下的`.ini`文件，因此我们需要创建改目录，然后对要管理的进程或进程组创建对应的`.ini`格式的配置文件\n```shell\n$ mkdir -pv /usr/local/etc/supervisor.d\n$ vim /usr/local/etc/supervisor.d/myserver.ini\n```\n编辑配置文件内容如下：\n```shell\n[program:server]\nprocess_name=%(program_name)s_%(process_num)02d\ncommand=/usr/local/go/bin/go run /Users/harryzhang/go/src/server/server.go # 要执行的命令\nautostart=true # 系统开机自动启动\nautorestart=true # 进程终止自动重启\nuser=harryzhang # 用户\nnumprocs=1 # 启动进程数\nredirect_stderr=true # 是否将标准错误重定向到标准输出\nstdout_logfile=/Users/harryzhang/go/src/server/server.log # 指定标准输出保存的文件路径\n```\n\n#### 重启supervisor\n编辑好配置文件后重启supervisor就可以生效，可以使用supervisorctl命令查看和管理进程状态。\n```shell\n$ brew services restart supervisor\nStopping `supervisor`... (might take a while)\n==> Successfully stopped `supervisor` (label: homebrew.mxcl.supervisor)\n==> Successfully started `supervisor` (label: homebrew.mxcl.supervisor)\n\n$ supervisorctl status\nserver:server_00                 RUNNING   pid 41382, uptime 0:00:04\n```\n如果指定的命令执行没有异常，会看到进程已处于运行状态，如果没有处于运行状态，可以查看日志文件，可能为命令执行出错直接退出了。\n\n## 参考\n【1】[Linux 守护进程的启动方法](http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html)\n\n【2】[进程管理工具supervisor 和 nohup](https://segmentfault.com/a/1190000017370468)","source":"_posts/2023/03-13-Linux进程管理-supervisor和nohup原理及使用.md","raw":"---\ntitle: 'Linux进程管理:supervisor和nohup原理及使用'\ndate: 2023-03-13 08:49:37\ncategories:\n- 操作系统\ntags:\n- Linux\n- 守护进程\n---\n\n## 原理\n\n### 守护进程（daemon）\n守护进程是一类在后台运行的特殊进程，用于执行特定的系统任务。他独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。Linux系统的大多数服务器就是通过守护进程实现的。\n常见的守护进程包括：\n- 系统日志进程syslogd\n- Web服务器httpd\n- 邮件服务器sendmail\n- 数据库服务器mysqld等\n\n守护进程一般在系统启动时开始运行，除非强行终止，否则会持续运行知道系统关机，通常以超级用户（root）权限运行。\n\n### 前台任务与后台任务\n假如有个简单的go的web服务器程序，使用如下方式启动，称为前台任务。独占了命令窗口，只有运行完了或手动终止（Ctrl+C），才能执行其他命令。\n![](https://upload-images.jianshu.io/upload_images/14151453-ec0b4b889fe10808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果以如下方式，在命令结尾加上符号`&`，启动的进程就会称为后台任务。\n![](https://upload-images.jianshu.io/upload_images/14151453-35d2076e46e71ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n后台任务又如下特点：\n- 继承当前session的标准输出(stdout)和标准错误(stderr)，因此如上图所示，后台任务的所有输出仍会同步的在命令行显示\n- 不再继承当前session的标准输入(stdin)，无法向这个任务输入指令，如果它试图读取标准输入，就会暂停执行（halt）\n\n### SIGHUP信号\n变为后台任务并不代表进程成为了守护进程，因为当session关闭后，后台任务就会终止。Linux系统终端session退出流程如下：\n1. 用户准备退出session\n2. 系统向改session发送`SIGHUP`信号\n3. session将`SIGHUP`信号发送给所有子进程\n4. 子进程收到`SIGHUP`信号后会自动退出\n\n## nohup\nnohup 是后台作业的意思， nohup运行的进程将会忽略终端信号运行。即后台运行一个命令。nohup COMMAND & 用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响它的运行。\n\n使用nohup命令的方式可以启动一个守护进程，如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-a2bafec78cb93512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nnohup命令对进程做了如下操作：\n- 忽略`SIGHUP`信号，因此当session关闭进程就不会退出\n- 关闭标准输入，该进程不再接收任何输入，即使运行在前台\n- 重定向标准输出和标准错误到文件nohup.out（默认情况，可以指定输出的文件）\n\nnohup不会自动把进程变为后台任务，所以必须加上`&`。\n\n## supervisor\nsupervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。\nsupervisor管理进程是通过fork/exec的方式把被管理的进程当做子进程来启动，用户只需要在配置文件中将要管理的进程进行配置。\n\n### 结构\nsupervisor主要由Supervisord、Supervisorctl、Web server和XML-RPC interface组成：\n- supervisord：主进程，负责管理进程的server，它会根据配置文件创建指定数量的应用程序的子进程，管理子进程的整个生命周期，对crash的进程重启，对进程变化发送事件通知等。同时通过内置web server和XML-RPC Interface可以轻松实现进程管理。\n- supervisorctl：管理client，用户通过命令行发送消息给supervisord，可以查看进程状态，加载配置文件，启停进程，查看进程标准输出和错误输出，远程操作等。\n- Web server：superviosr提供了web server功能，可通过web控制进程。\n- XML-RPC interface： XML-RPC接口，提供XML-RPC服务来对子进程进行管理和监控。\n\n### macOS环境安装使用\n\n#### 安装并启动\n```shell\n$ brew install supervisor\n$ brew services start supervisor\n```\n#### 创建配置目录和配置文件\n默认的配置文件路径为`/usr/local/etc/supervisord.conf`，查看该文件可以看到如下内容：\n```shell\n$ tail -n2 /usr/local/etc/supervisord.conf\n[include]\nfiles = /usr/local/etc/supervisor.d/*.ini\n```\n可以看到include了`/usr/local/etc/supervisor.d/`目录下的`.ini`文件，因此我们需要创建改目录，然后对要管理的进程或进程组创建对应的`.ini`格式的配置文件\n```shell\n$ mkdir -pv /usr/local/etc/supervisor.d\n$ vim /usr/local/etc/supervisor.d/myserver.ini\n```\n编辑配置文件内容如下：\n```shell\n[program:server]\nprocess_name=%(program_name)s_%(process_num)02d\ncommand=/usr/local/go/bin/go run /Users/harryzhang/go/src/server/server.go # 要执行的命令\nautostart=true # 系统开机自动启动\nautorestart=true # 进程终止自动重启\nuser=harryzhang # 用户\nnumprocs=1 # 启动进程数\nredirect_stderr=true # 是否将标准错误重定向到标准输出\nstdout_logfile=/Users/harryzhang/go/src/server/server.log # 指定标准输出保存的文件路径\n```\n\n#### 重启supervisor\n编辑好配置文件后重启supervisor就可以生效，可以使用supervisorctl命令查看和管理进程状态。\n```shell\n$ brew services restart supervisor\nStopping `supervisor`... (might take a while)\n==> Successfully stopped `supervisor` (label: homebrew.mxcl.supervisor)\n==> Successfully started `supervisor` (label: homebrew.mxcl.supervisor)\n\n$ supervisorctl status\nserver:server_00                 RUNNING   pid 41382, uptime 0:00:04\n```\n如果指定的命令执行没有异常，会看到进程已处于运行状态，如果没有处于运行状态，可以查看日志文件，可能为命令执行出错直接退出了。\n\n## 参考\n【1】[Linux 守护进程的启动方法](http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html)\n\n【2】[进程管理工具supervisor 和 nohup](https://segmentfault.com/a/1190000017370468)","slug":"Linux进程管理-supervisor和nohup原理及使用","published":1,"updated":"2023-03-19T13:34:40.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj16z0003htfi2lthgtz6","content":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"守护进程（daemon）\"><a href=\"#守护进程（daemon）\" class=\"headerlink\" title=\"守护进程（daemon）\"></a>守护进程（daemon）</h3><p>守护进程是一类在后台运行的特殊进程，用于执行特定的系统任务。他独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。Linux系统的大多数服务器就是通过守护进程实现的。<br>常见的守护进程包括：</p>\n<ul>\n<li>系统日志进程syslogd</li>\n<li>Web服务器httpd</li>\n<li>邮件服务器sendmail</li>\n<li>数据库服务器mysqld等</li>\n</ul>\n<p>守护进程一般在系统启动时开始运行，除非强行终止，否则会持续运行知道系统关机，通常以超级用户（root）权限运行。</p>\n<h3 id=\"前台任务与后台任务\"><a href=\"#前台任务与后台任务\" class=\"headerlink\" title=\"前台任务与后台任务\"></a>前台任务与后台任务</h3><p>假如有个简单的go的web服务器程序，使用如下方式启动，称为前台任务。独占了命令窗口，只有运行完了或手动终止（Ctrl+C），才能执行其他命令。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-ec0b4b889fe10808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-ec0b4b889fe10808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>如果以如下方式，在命令结尾加上符号<code>&amp;</code>，启动的进程就会称为后台任务。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-35d2076e46e71ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-35d2076e46e71ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>后台任务又如下特点：</p>\n<ul>\n<li>继承当前session的标准输出(stdout)和标准错误(stderr)，因此如上图所示，后台任务的所有输出仍会同步的在命令行显示</li>\n<li>不再继承当前session的标准输入(stdin)，无法向这个任务输入指令，如果它试图读取标准输入，就会暂停执行（halt）</li>\n</ul>\n<h3 id=\"SIGHUP信号\"><a href=\"#SIGHUP信号\" class=\"headerlink\" title=\"SIGHUP信号\"></a>SIGHUP信号</h3><p>变为后台任务并不代表进程成为了守护进程，因为当session关闭后，后台任务就会终止。Linux系统终端session退出流程如下：</p>\n<ol>\n<li>用户准备退出session</li>\n<li>系统向改session发送<code>SIGHUP</code>信号</li>\n<li>session将<code>SIGHUP</code>信号发送给所有子进程</li>\n<li>子进程收到<code>SIGHUP</code>信号后会自动退出</li>\n</ol>\n<h2 id=\"nohup\"><a href=\"#nohup\" class=\"headerlink\" title=\"nohup\"></a>nohup</h2><p>nohup 是后台作业的意思， nohup运行的进程将会忽略终端信号运行。即后台运行一个命令。nohup COMMAND &amp; 用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响它的运行。</p>\n<p>使用nohup命令的方式可以启动一个守护进程，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-a2bafec78cb93512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-a2bafec78cb93512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>nohup命令对进程做了如下操作：</p>\n<ul>\n<li>忽略<code>SIGHUP</code>信号，因此当session关闭进程就不会退出</li>\n<li>关闭标准输入，该进程不再接收任何输入，即使运行在前台</li>\n<li>重定向标准输出和标准错误到文件nohup.out（默认情况，可以指定输出的文件）</li>\n</ul>\n<p>nohup不会自动把进程变为后台任务，所以必须加上<code>&amp;</code>。</p>\n<h2 id=\"supervisor\"><a href=\"#supervisor\" class=\"headerlink\" title=\"supervisor\"></a>supervisor</h2><p>supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。<br>supervisor管理进程是通过fork&#x2F;exec的方式把被管理的进程当做子进程来启动，用户只需要在配置文件中将要管理的进程进行配置。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>supervisor主要由Supervisord、Supervisorctl、Web server和XML-RPC interface组成：</p>\n<ul>\n<li>supervisord：主进程，负责管理进程的server，它会根据配置文件创建指定数量的应用程序的子进程，管理子进程的整个生命周期，对crash的进程重启，对进程变化发送事件通知等。同时通过内置web server和XML-RPC Interface可以轻松实现进程管理。</li>\n<li>supervisorctl：管理client，用户通过命令行发送消息给supervisord，可以查看进程状态，加载配置文件，启停进程，查看进程标准输出和错误输出，远程操作等。</li>\n<li>Web server：superviosr提供了web server功能，可通过web控制进程。</li>\n<li>XML-RPC interface： XML-RPC接口，提供XML-RPC服务来对子进程进行管理和监控。</li>\n</ul>\n<h3 id=\"macOS环境安装使用\"><a href=\"#macOS环境安装使用\" class=\"headerlink\" title=\"macOS环境安装使用\"></a>macOS环境安装使用</h3><h4 id=\"安装并启动\"><a href=\"#安装并启动\" class=\"headerlink\" title=\"安装并启动\"></a>安装并启动</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">brew install supervisor</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">brew services start supervisor</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"创建配置目录和配置文件\"><a href=\"#创建配置目录和配置文件\" class=\"headerlink\" title=\"创建配置目录和配置文件\"></a>创建配置目录和配置文件</h4><p>默认的配置文件路径为<code>/usr/local/etc/supervisord.conf</code>，查看该文件可以看到如下内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">tail</span> -n2 /usr/local/etc/supervisord.conf</span></span><br><span class=\"line\">[include]</span><br><span class=\"line\">files = /usr/local/etc/supervisor.d/*.ini</span><br></pre></td></tr></table></figure>\n<p>可以看到include了<code>/usr/local/etc/supervisor.d/</code>目录下的<code>.ini</code>文件，因此我们需要创建改目录，然后对要管理的进程或进程组创建对应的<code>.ini</code>格式的配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">mkdir</span> -pv /usr/local/etc/supervisor.d</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">vim /usr/local/etc/supervisor.d/myserver.ini</span></span><br></pre></td></tr></table></figure>\n<p>编辑配置文件内容如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[program:server]</span><br><span class=\"line\">process_name=%(program_name)s_%(process_num)02d</span><br><span class=\"line\">command=/usr/local/go/bin/go run /Users/harryzhang/go/src/server/server.go # 要执行的命令</span><br><span class=\"line\">autostart=true # 系统开机自动启动</span><br><span class=\"line\">autorestart=true # 进程终止自动重启</span><br><span class=\"line\">user=harryzhang # 用户</span><br><span class=\"line\">numprocs=1 # 启动进程数</span><br><span class=\"line\">redirect_stderr=true # 是否将标准错误重定向到标准输出</span><br><span class=\"line\">stdout_logfile=/Users/harryzhang/go/src/server/server.log # 指定标准输出保存的文件路径</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重启supervisor\"><a href=\"#重启supervisor\" class=\"headerlink\" title=\"重启supervisor\"></a>重启supervisor</h4><p>编辑好配置文件后重启supervisor就可以生效，可以使用supervisorctl命令查看和管理进程状态。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">brew services restart supervisor</span></span><br><span class=\"line\">Stopping `supervisor`... (might take a while)</span><br><span class=\"line\">==&gt; Successfully stopped `supervisor` (label: homebrew.mxcl.supervisor)</span><br><span class=\"line\">==&gt; Successfully started `supervisor` (label: homebrew.mxcl.supervisor)</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">supervisorctl status</span></span><br><span class=\"line\">server:server_00                 RUNNING   pid 41382, uptime 0:00:04</span><br></pre></td></tr></table></figure>\n<p>如果指定的命令执行没有异常，会看到进程已处于运行状态，如果没有处于运行状态，可以查看日志文件，可能为命令执行出错直接退出了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html\">Linux 守护进程的启动方法</a></p>\n<p>【2】<a href=\"https://segmentfault.com/a/1190000017370468\">进程管理工具supervisor 和 nohup</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"守护进程（daemon）\"><a href=\"#守护进程（daemon）\" class=\"headerlink\" title=\"守护进程（daemon）\"></a>守护进程（daemon）</h3><p>守护进程是一类在后台运行的特殊进程，用于执行特定的系统任务。他独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。Linux系统的大多数服务器就是通过守护进程实现的。<br>常见的守护进程包括：</p>\n<ul>\n<li>系统日志进程syslogd</li>\n<li>Web服务器httpd</li>\n<li>邮件服务器sendmail</li>\n<li>数据库服务器mysqld等</li>\n</ul>\n<p>守护进程一般在系统启动时开始运行，除非强行终止，否则会持续运行知道系统关机，通常以超级用户（root）权限运行。</p>\n<h3 id=\"前台任务与后台任务\"><a href=\"#前台任务与后台任务\" class=\"headerlink\" title=\"前台任务与后台任务\"></a>前台任务与后台任务</h3><p>假如有个简单的go的web服务器程序，使用如下方式启动，称为前台任务。独占了命令窗口，只有运行完了或手动终止（Ctrl+C），才能执行其他命令。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-ec0b4b889fe10808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>如果以如下方式，在命令结尾加上符号<code>&amp;</code>，启动的进程就会称为后台任务。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-35d2076e46e71ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>后台任务又如下特点：</p>\n<ul>\n<li>继承当前session的标准输出(stdout)和标准错误(stderr)，因此如上图所示，后台任务的所有输出仍会同步的在命令行显示</li>\n<li>不再继承当前session的标准输入(stdin)，无法向这个任务输入指令，如果它试图读取标准输入，就会暂停执行（halt）</li>\n</ul>\n<h3 id=\"SIGHUP信号\"><a href=\"#SIGHUP信号\" class=\"headerlink\" title=\"SIGHUP信号\"></a>SIGHUP信号</h3><p>变为后台任务并不代表进程成为了守护进程，因为当session关闭后，后台任务就会终止。Linux系统终端session退出流程如下：</p>\n<ol>\n<li>用户准备退出session</li>\n<li>系统向改session发送<code>SIGHUP</code>信号</li>\n<li>session将<code>SIGHUP</code>信号发送给所有子进程</li>\n<li>子进程收到<code>SIGHUP</code>信号后会自动退出</li>\n</ol>\n<h2 id=\"nohup\"><a href=\"#nohup\" class=\"headerlink\" title=\"nohup\"></a>nohup</h2><p>nohup 是后台作业的意思， nohup运行的进程将会忽略终端信号运行。即后台运行一个命令。nohup COMMAND &amp; 用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响它的运行。</p>\n<p>使用nohup命令的方式可以启动一个守护进程，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-a2bafec78cb93512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>nohup命令对进程做了如下操作：</p>\n<ul>\n<li>忽略<code>SIGHUP</code>信号，因此当session关闭进程就不会退出</li>\n<li>关闭标准输入，该进程不再接收任何输入，即使运行在前台</li>\n<li>重定向标准输出和标准错误到文件nohup.out（默认情况，可以指定输出的文件）</li>\n</ul>\n<p>nohup不会自动把进程变为后台任务，所以必须加上<code>&amp;</code>。</p>\n<h2 id=\"supervisor\"><a href=\"#supervisor\" class=\"headerlink\" title=\"supervisor\"></a>supervisor</h2><p>supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。<br>supervisor管理进程是通过fork&#x2F;exec的方式把被管理的进程当做子进程来启动，用户只需要在配置文件中将要管理的进程进行配置。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>supervisor主要由Supervisord、Supervisorctl、Web server和XML-RPC interface组成：</p>\n<ul>\n<li>supervisord：主进程，负责管理进程的server，它会根据配置文件创建指定数量的应用程序的子进程，管理子进程的整个生命周期，对crash的进程重启，对进程变化发送事件通知等。同时通过内置web server和XML-RPC Interface可以轻松实现进程管理。</li>\n<li>supervisorctl：管理client，用户通过命令行发送消息给supervisord，可以查看进程状态，加载配置文件，启停进程，查看进程标准输出和错误输出，远程操作等。</li>\n<li>Web server：superviosr提供了web server功能，可通过web控制进程。</li>\n<li>XML-RPC interface： XML-RPC接口，提供XML-RPC服务来对子进程进行管理和监控。</li>\n</ul>\n<h3 id=\"macOS环境安装使用\"><a href=\"#macOS环境安装使用\" class=\"headerlink\" title=\"macOS环境安装使用\"></a>macOS环境安装使用</h3><h4 id=\"安装并启动\"><a href=\"#安装并启动\" class=\"headerlink\" title=\"安装并启动\"></a>安装并启动</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">brew install supervisor</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">brew services start supervisor</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"创建配置目录和配置文件\"><a href=\"#创建配置目录和配置文件\" class=\"headerlink\" title=\"创建配置目录和配置文件\"></a>创建配置目录和配置文件</h4><p>默认的配置文件路径为<code>/usr/local/etc/supervisord.conf</code>，查看该文件可以看到如下内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">tail</span> -n2 /usr/local/etc/supervisord.conf</span></span><br><span class=\"line\">[include]</span><br><span class=\"line\">files = /usr/local/etc/supervisor.d/*.ini</span><br></pre></td></tr></table></figure>\n<p>可以看到include了<code>/usr/local/etc/supervisor.d/</code>目录下的<code>.ini</code>文件，因此我们需要创建改目录，然后对要管理的进程或进程组创建对应的<code>.ini</code>格式的配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">mkdir</span> -pv /usr/local/etc/supervisor.d</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">vim /usr/local/etc/supervisor.d/myserver.ini</span></span><br></pre></td></tr></table></figure>\n<p>编辑配置文件内容如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[program:server]</span><br><span class=\"line\">process_name=%(program_name)s_%(process_num)02d</span><br><span class=\"line\">command=/usr/local/go/bin/go run /Users/harryzhang/go/src/server/server.go # 要执行的命令</span><br><span class=\"line\">autostart=true # 系统开机自动启动</span><br><span class=\"line\">autorestart=true # 进程终止自动重启</span><br><span class=\"line\">user=harryzhang # 用户</span><br><span class=\"line\">numprocs=1 # 启动进程数</span><br><span class=\"line\">redirect_stderr=true # 是否将标准错误重定向到标准输出</span><br><span class=\"line\">stdout_logfile=/Users/harryzhang/go/src/server/server.log # 指定标准输出保存的文件路径</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重启supervisor\"><a href=\"#重启supervisor\" class=\"headerlink\" title=\"重启supervisor\"></a>重启supervisor</h4><p>编辑好配置文件后重启supervisor就可以生效，可以使用supervisorctl命令查看和管理进程状态。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">brew services restart supervisor</span></span><br><span class=\"line\">Stopping `supervisor`... (might take a while)</span><br><span class=\"line\">==&gt; Successfully stopped `supervisor` (label: homebrew.mxcl.supervisor)</span><br><span class=\"line\">==&gt; Successfully started `supervisor` (label: homebrew.mxcl.supervisor)</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">supervisorctl status</span></span><br><span class=\"line\">server:server_00                 RUNNING   pid 41382, uptime 0:00:04</span><br></pre></td></tr></table></figure>\n<p>如果指定的命令执行没有异常，会看到进程已处于运行状态，如果没有处于运行状态，可以查看日志文件，可能为命令执行出错直接退出了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html\">Linux 守护进程的启动方法</a></p>\n<p>【2】<a href=\"https://segmentfault.com/a/1190000017370468\">进程管理工具supervisor 和 nohup</a></p>\n"},{"title":"数据结构(2): 数组","date":"2023-03-19T13:31:25.000Z","_content":"\n## 2.1 大于n/k次的元素\n[LeetCode No.229](https://leetcode-cn.com/problems/majority-element-ii/)\n\n> 题目描述：给一个整数数组，找出所有出现次数大于n/3的元素。\nInput: nums = [3,2,3]\nOutput: [3]\n\n**摩尔投票法**： 一般情况一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/k ⌋ 次的元素。n/k的众数最多只有k - 1个，原因：假设有k个众数，则 出现次数（⌊ n/k ⌋ +1） × \\times× 众数个数 k > n。\n\n思路：此题为例 k = 3, 则最多有2个出现次数大于n/3的元素，把此情景想像成在大会中投票选出两个候选者， 则有两个候选 n1 和n2。\n- 如果投n1（当前元素等于n1），则n1的票数 c1++;\n- 如果投n2（当前元素等于n2），则n2的票数c2++;\n- 如果n1,n2都不投（即当前值与n1，n2都不相等）,那么检查此时n1或n2的票数是否为0：\n  1. 如果为0,则当前元素成为新的候选人替代掉票数为0的人；\n  2. 如果n1,n2两个人的票数都不为0，那么n1,n2两个候选人的票数均减一；\n\n最后会有这么几种可能：有2个大于n/3，有1个大于n/3，有0个大于n/3，遍历结束后选出了两个候选人，但是这两个候选人是否满足> n/3，还需要再遍历一遍数组，找出两个候选人的具体票数，因为不一定有。\n[参考原文](https://blog.csdn.net/weixin_43946031/article/details/113856373)\n\n` 示例代码：`\n```go\nfunc majorityElement(nums []int) []int {\n    v1, c1, v2, c2 := 0, 0, 0, 0\n    for _, n := range nums {\n        if n == v1 {\n            c1++\n        } else if n == v2 {\n            c2++\n        } else {\n            if c1 == 0 {\n                v1 = n\n                c1++\n            } else if c2 == 0 {\n                v2 = n\n                c2++\n            } else {\n                c1--\n                c2-- \n            }\n        }\n    }\n    r := make([]int, 0)\n    c1, c2 = 0, 0\n    for _, n := range nums {\n        if n == v1 {\n            c1++\n        }\n        if n == v2 && v2 != v1 {\n            c2++\n        }\n    }\n    if c1 > len(nums) / 3 {\n        r = append(r, v1)\n    }\n    if c2 > len(nums) / 3 {\n        r = append(r, v2)\n    }\n    return r\n}\n```\n\n## 2.2 缺失的第一个正数\n[LeetCode No.41](https://leetcode-cn.com/problems/first-missing-positive/)\n\n> 题目描述：给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。\n进阶：实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案\n\n**思路：**长度为N的整数数组，没有出现的最小正整数一定在[1, N + 1]。\n\n方法1：最容易的做法用一个额外的哈希表记录出现的数字，然后从1遍历到N+1，根据hash表如果出现缺失就返回。但是该方法空间复杂度为O(n)。\n\n`示例代码：`\n```go\nfunc firstMissingPositive(nums []int) int {\n\tm := map[int]bool{}\n\tfor _, n := range nums {\n\t\tm[n] = true\n\t}\n\tfor i := 1; i <= len(nums); i++ {\n\t\tif m[i] == false {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn len(nums) + 1\n}\n```\n\n方法2：在原数组上建哈希表，因为结果只需要判断[1, N]的数，因此可以以负数当做标记（参考LeetCode官方题解）。\n- 将数组中所有小于等于 0 的数修改为 N+1\n- 遍历每一个数x，可能已经打过标记，因此原值为|x|，如果|x|在[1, N]范围，则给数组nums[|x| - 1]元素加上负号，已加过的不能再加。\n- 遍历数组检查，如果值非负数返回i + 1，全为负数返回N+1\n\n`示例代码:`\n```go\nfunc IntAbs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n\n// 只关注正整数，用\"-\"号做标记\nfunc firstMissingPositive(nums []int) int {\n\tn := len(nums)\n\t// 预处理，将元素全部变为整数\n\tfor i, v := range nums {\n\t\tif v <= 0 {\n\t\t\tnums[i] = n + 1\n\t\t}\n\t}\n\t// 打标记\n\tfor i := 0; i < n; i++ {\n\t\tx := IntAbs(nums[i])\n\t\tif x <= n && nums[x - 1] > 0 {\n\t\t\tnums[x - 1] *= -1\n\t\t}\n\t}\n\t// 检查标记\n\tfor i := 0; i < n; i++ {\n\t\tif nums[i] > 0 {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn n + 1\n}\n```\n\n方法3：置换，将数组恢复成形如[1, 2, ... , N]的形式，即nums[i-1]=i（参考LeetCode官方题解）。\n- 设v = nums[i], 如果nums[i] == nums [v-1]，则不需要置换，否则将nums[v-1]设为v，此时要先把nums[v-1]的值保存到nums[i]，此时v-1已经是正确的位置，但是i不一定是正确的位置，需要继续置换。\n- 检查每个位置的值是否正确，全部正确返回N+1，否则返回i+1\n\n`示例代码:`\n```go\nfunc firstMissingPositive(nums []int) int {\n\tn := len(nums)\n\tfor i, v := range nums {\n\t\tfor v > 0 && v < n + 1 && nums[i] != nums[v - 1] {\n\t\t\tnums[v - 1], nums[i] = v, nums[v - 1]\n\t\t\tv = nums[i]\n\t\t}\n\t}\n\tfor i, v := range nums {\n\t\tif v != i + 1 {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn n + 1\n}\n```\n","source":"_posts/2023/03-19-数据结构-2-数组.md","raw":"---\ntitle: '数据结构(2): 数组'\ndate: 2023-03-19 21:31:25\ncategories:\n- [数据结构]\ntags:\n- 数组\n- leetcode\n---\n\n## 2.1 大于n/k次的元素\n[LeetCode No.229](https://leetcode-cn.com/problems/majority-element-ii/)\n\n> 题目描述：给一个整数数组，找出所有出现次数大于n/3的元素。\nInput: nums = [3,2,3]\nOutput: [3]\n\n**摩尔投票法**： 一般情况一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/k ⌋ 次的元素。n/k的众数最多只有k - 1个，原因：假设有k个众数，则 出现次数（⌊ n/k ⌋ +1） × \\times× 众数个数 k > n。\n\n思路：此题为例 k = 3, 则最多有2个出现次数大于n/3的元素，把此情景想像成在大会中投票选出两个候选者， 则有两个候选 n1 和n2。\n- 如果投n1（当前元素等于n1），则n1的票数 c1++;\n- 如果投n2（当前元素等于n2），则n2的票数c2++;\n- 如果n1,n2都不投（即当前值与n1，n2都不相等）,那么检查此时n1或n2的票数是否为0：\n  1. 如果为0,则当前元素成为新的候选人替代掉票数为0的人；\n  2. 如果n1,n2两个人的票数都不为0，那么n1,n2两个候选人的票数均减一；\n\n最后会有这么几种可能：有2个大于n/3，有1个大于n/3，有0个大于n/3，遍历结束后选出了两个候选人，但是这两个候选人是否满足> n/3，还需要再遍历一遍数组，找出两个候选人的具体票数，因为不一定有。\n[参考原文](https://blog.csdn.net/weixin_43946031/article/details/113856373)\n\n` 示例代码：`\n```go\nfunc majorityElement(nums []int) []int {\n    v1, c1, v2, c2 := 0, 0, 0, 0\n    for _, n := range nums {\n        if n == v1 {\n            c1++\n        } else if n == v2 {\n            c2++\n        } else {\n            if c1 == 0 {\n                v1 = n\n                c1++\n            } else if c2 == 0 {\n                v2 = n\n                c2++\n            } else {\n                c1--\n                c2-- \n            }\n        }\n    }\n    r := make([]int, 0)\n    c1, c2 = 0, 0\n    for _, n := range nums {\n        if n == v1 {\n            c1++\n        }\n        if n == v2 && v2 != v1 {\n            c2++\n        }\n    }\n    if c1 > len(nums) / 3 {\n        r = append(r, v1)\n    }\n    if c2 > len(nums) / 3 {\n        r = append(r, v2)\n    }\n    return r\n}\n```\n\n## 2.2 缺失的第一个正数\n[LeetCode No.41](https://leetcode-cn.com/problems/first-missing-positive/)\n\n> 题目描述：给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。\n进阶：实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案\n\n**思路：**长度为N的整数数组，没有出现的最小正整数一定在[1, N + 1]。\n\n方法1：最容易的做法用一个额外的哈希表记录出现的数字，然后从1遍历到N+1，根据hash表如果出现缺失就返回。但是该方法空间复杂度为O(n)。\n\n`示例代码：`\n```go\nfunc firstMissingPositive(nums []int) int {\n\tm := map[int]bool{}\n\tfor _, n := range nums {\n\t\tm[n] = true\n\t}\n\tfor i := 1; i <= len(nums); i++ {\n\t\tif m[i] == false {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn len(nums) + 1\n}\n```\n\n方法2：在原数组上建哈希表，因为结果只需要判断[1, N]的数，因此可以以负数当做标记（参考LeetCode官方题解）。\n- 将数组中所有小于等于 0 的数修改为 N+1\n- 遍历每一个数x，可能已经打过标记，因此原值为|x|，如果|x|在[1, N]范围，则给数组nums[|x| - 1]元素加上负号，已加过的不能再加。\n- 遍历数组检查，如果值非负数返回i + 1，全为负数返回N+1\n\n`示例代码:`\n```go\nfunc IntAbs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n\n// 只关注正整数，用\"-\"号做标记\nfunc firstMissingPositive(nums []int) int {\n\tn := len(nums)\n\t// 预处理，将元素全部变为整数\n\tfor i, v := range nums {\n\t\tif v <= 0 {\n\t\t\tnums[i] = n + 1\n\t\t}\n\t}\n\t// 打标记\n\tfor i := 0; i < n; i++ {\n\t\tx := IntAbs(nums[i])\n\t\tif x <= n && nums[x - 1] > 0 {\n\t\t\tnums[x - 1] *= -1\n\t\t}\n\t}\n\t// 检查标记\n\tfor i := 0; i < n; i++ {\n\t\tif nums[i] > 0 {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn n + 1\n}\n```\n\n方法3：置换，将数组恢复成形如[1, 2, ... , N]的形式，即nums[i-1]=i（参考LeetCode官方题解）。\n- 设v = nums[i], 如果nums[i] == nums [v-1]，则不需要置换，否则将nums[v-1]设为v，此时要先把nums[v-1]的值保存到nums[i]，此时v-1已经是正确的位置，但是i不一定是正确的位置，需要继续置换。\n- 检查每个位置的值是否正确，全部正确返回N+1，否则返回i+1\n\n`示例代码:`\n```go\nfunc firstMissingPositive(nums []int) int {\n\tn := len(nums)\n\tfor i, v := range nums {\n\t\tfor v > 0 && v < n + 1 && nums[i] != nums[v - 1] {\n\t\t\tnums[v - 1], nums[i] = v, nums[v - 1]\n\t\t\tv = nums[i]\n\t\t}\n\t}\n\tfor i, v := range nums {\n\t\tif v != i + 1 {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn n + 1\n}\n```\n","slug":"数据结构-2-数组","published":1,"updated":"2023-03-19T14:34:10.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj1740007htfihs2y1184","content":"<h2 id=\"2-1-大于n-x2F-k次的元素\"><a href=\"#2-1-大于n-x2F-k次的元素\" class=\"headerlink\" title=\"2.1 大于n&#x2F;k次的元素\"></a>2.1 大于n&#x2F;k次的元素</h2><p><a href=\"https://leetcode-cn.com/problems/majority-element-ii/\">LeetCode No.229</a></p>\n<blockquote>\n<p>题目描述：给一个整数数组，找出所有出现次数大于n&#x2F;3的元素。<br>Input: nums &#x3D; [3,2,3]<br>Output: [3]</p>\n</blockquote>\n<p><strong>摩尔投票法</strong>： 一般情况一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n&#x2F;k ⌋ 次的元素。n&#x2F;k的众数最多只有k - 1个，原因：假设有k个众数，则 出现次数（⌊ n&#x2F;k ⌋ +1） × \\times× 众数个数 k &gt; n。</p>\n<p>思路：此题为例 k &#x3D; 3, 则最多有2个出现次数大于n&#x2F;3的元素，把此情景想像成在大会中投票选出两个候选者， 则有两个候选 n1 和n2。</p>\n<ul>\n<li>如果投n1（当前元素等于n1），则n1的票数 c1++;</li>\n<li>如果投n2（当前元素等于n2），则n2的票数c2++;</li>\n<li>如果n1,n2都不投（即当前值与n1，n2都不相等）,那么检查此时n1或n2的票数是否为0：<ol>\n<li>如果为0,则当前元素成为新的候选人替代掉票数为0的人；</li>\n<li>如果n1,n2两个人的票数都不为0，那么n1,n2两个候选人的票数均减一；</li>\n</ol>\n</li>\n</ul>\n<p>最后会有这么几种可能：有2个大于n&#x2F;3，有1个大于n&#x2F;3，有0个大于n&#x2F;3，遍历结束后选出了两个候选人，但是这两个候选人是否满足&gt; n&#x2F;3，还需要再遍历一遍数组，找出两个候选人的具体票数，因为不一定有。<br><a href=\"https://blog.csdn.net/weixin_43946031/article/details/113856373\">参考原文</a></p>\n<p><code> 示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">majorityElement</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    v1, c1, v2, c2 := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == v1 &#123;</span><br><span class=\"line\">            c1++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> n == v2 &#123;</span><br><span class=\"line\">            c2++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c1 == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                v1 = n</span><br><span class=\"line\">                c1++</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> c2 == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                v2 = n</span><br><span class=\"line\">                c2++</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                c1--</span><br><span class=\"line\">                c2-- </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    c1, c2 = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == v1 &#123;</span><br><span class=\"line\">            c1++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == v2 &amp;&amp; v2 != v1 &#123;</span><br><span class=\"line\">            c2++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c1 &gt; <span class=\"built_in\">len</span>(nums) / <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        r = <span class=\"built_in\">append</span>(r, v1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c2 &gt; <span class=\"built_in\">len</span>(nums) / <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        r = <span class=\"built_in\">append</span>(r, v2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-缺失的第一个正数\"><a href=\"#2-2-缺失的第一个正数\" class=\"headerlink\" title=\"2.2 缺失的第一个正数\"></a>2.2 缺失的第一个正数</h2><p><a href=\"https://leetcode-cn.com/problems/first-missing-positive/\">LeetCode No.41</a></p>\n<blockquote>\n<p>题目描述：给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<br>进阶：实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案</p>\n</blockquote>\n<p><strong>思路：</strong>长度为N的整数数组，没有出现的最小正整数一定在[1, N + 1]。</p>\n<p>方法1：最容易的做法用一个额外的哈希表记录出现的数字，然后从1遍历到N+1，根据hash表如果出现缺失就返回。但是该方法空间复杂度为O(n)。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tm := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\tm[n] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> m[i] == <span class=\"literal\">false</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(nums) + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法2：在原数组上建哈希表，因为结果只需要判断[1, N]的数，因此可以以负数当做标记（参考LeetCode官方题解）。</p>\n<ul>\n<li>将数组中所有小于等于 0 的数修改为 N+1</li>\n<li>遍历每一个数x，可能已经打过标记，因此原值为|x|，如果|x|在[1, N]范围，则给数组nums[|x| - 1]元素加上负号，已加过的不能再加。</li>\n<li>遍历数组检查，如果值非负数返回i + 1，全为负数返回N+1</li>\n</ul>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IntAbs</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只关注正整数，用&quot;-&quot;号做标记</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">\t<span class=\"comment\">// 预处理，将元素全部变为整数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tnums[i] = n + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 打标记</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\tx := IntAbs(nums[i])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> x &lt;= n &amp;&amp; nums[x - <span class=\"number\">1</span>] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tnums[x - <span class=\"number\">1</span>] *= <span class=\"number\">-1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 检查标记</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[i] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法3：置换，将数组恢复成形如[1, 2, … , N]的形式，即nums[i-1]&#x3D;i（参考LeetCode官方题解）。</p>\n<ul>\n<li>设v &#x3D; nums[i], 如果nums[i] &#x3D;&#x3D; nums [v-1]，则不需要置换，否则将nums[v-1]设为v，此时要先把nums[v-1]的值保存到nums[i]，此时v-1已经是正确的位置，但是i不一定是正确的位置，需要继续置换。</li>\n<li>检查每个位置的值是否正确，全部正确返回N+1，否则返回i+1</li>\n</ul>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> v &gt; <span class=\"number\">0</span> &amp;&amp; v &lt; n + <span class=\"number\">1</span> &amp;&amp; nums[i] != nums[v - <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\tnums[v - <span class=\"number\">1</span>], nums[i] = v, nums[v - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\tv = nums[i]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v != i + <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"2-1-大于n-x2F-k次的元素\"><a href=\"#2-1-大于n-x2F-k次的元素\" class=\"headerlink\" title=\"2.1 大于n&#x2F;k次的元素\"></a>2.1 大于n&#x2F;k次的元素</h2><p><a href=\"https://leetcode-cn.com/problems/majority-element-ii/\">LeetCode No.229</a></p>\n<blockquote>\n<p>题目描述：给一个整数数组，找出所有出现次数大于n&#x2F;3的元素。<br>Input: nums &#x3D; [3,2,3]<br>Output: [3]</p>\n</blockquote>\n<p><strong>摩尔投票法</strong>： 一般情况一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n&#x2F;k ⌋ 次的元素。n&#x2F;k的众数最多只有k - 1个，原因：假设有k个众数，则 出现次数（⌊ n&#x2F;k ⌋ +1） × \\times× 众数个数 k &gt; n。</p>\n<p>思路：此题为例 k &#x3D; 3, 则最多有2个出现次数大于n&#x2F;3的元素，把此情景想像成在大会中投票选出两个候选者， 则有两个候选 n1 和n2。</p>\n<ul>\n<li>如果投n1（当前元素等于n1），则n1的票数 c1++;</li>\n<li>如果投n2（当前元素等于n2），则n2的票数c2++;</li>\n<li>如果n1,n2都不投（即当前值与n1，n2都不相等）,那么检查此时n1或n2的票数是否为0：<ol>\n<li>如果为0,则当前元素成为新的候选人替代掉票数为0的人；</li>\n<li>如果n1,n2两个人的票数都不为0，那么n1,n2两个候选人的票数均减一；</li>\n</ol>\n</li>\n</ul>\n<p>最后会有这么几种可能：有2个大于n&#x2F;3，有1个大于n&#x2F;3，有0个大于n&#x2F;3，遍历结束后选出了两个候选人，但是这两个候选人是否满足&gt; n&#x2F;3，还需要再遍历一遍数组，找出两个候选人的具体票数，因为不一定有。<br><a href=\"https://blog.csdn.net/weixin_43946031/article/details/113856373\">参考原文</a></p>\n<p><code> 示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">majorityElement</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    v1, c1, v2, c2 := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == v1 &#123;</span><br><span class=\"line\">            c1++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> n == v2 &#123;</span><br><span class=\"line\">            c2++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c1 == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                v1 = n</span><br><span class=\"line\">                c1++</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> c2 == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                v2 = n</span><br><span class=\"line\">                c2++</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                c1--</span><br><span class=\"line\">                c2-- </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    c1, c2 = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == v1 &#123;</span><br><span class=\"line\">            c1++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == v2 &amp;&amp; v2 != v1 &#123;</span><br><span class=\"line\">            c2++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c1 &gt; <span class=\"built_in\">len</span>(nums) / <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        r = <span class=\"built_in\">append</span>(r, v1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c2 &gt; <span class=\"built_in\">len</span>(nums) / <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        r = <span class=\"built_in\">append</span>(r, v2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-缺失的第一个正数\"><a href=\"#2-2-缺失的第一个正数\" class=\"headerlink\" title=\"2.2 缺失的第一个正数\"></a>2.2 缺失的第一个正数</h2><p><a href=\"https://leetcode-cn.com/problems/first-missing-positive/\">LeetCode No.41</a></p>\n<blockquote>\n<p>题目描述：给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<br>进阶：实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案</p>\n</blockquote>\n<p><strong>思路：</strong>长度为N的整数数组，没有出现的最小正整数一定在[1, N + 1]。</p>\n<p>方法1：最容易的做法用一个额外的哈希表记录出现的数字，然后从1遍历到N+1，根据hash表如果出现缺失就返回。但是该方法空间复杂度为O(n)。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tm := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\tm[n] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> m[i] == <span class=\"literal\">false</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(nums) + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法2：在原数组上建哈希表，因为结果只需要判断[1, N]的数，因此可以以负数当做标记（参考LeetCode官方题解）。</p>\n<ul>\n<li>将数组中所有小于等于 0 的数修改为 N+1</li>\n<li>遍历每一个数x，可能已经打过标记，因此原值为|x|，如果|x|在[1, N]范围，则给数组nums[|x| - 1]元素加上负号，已加过的不能再加。</li>\n<li>遍历数组检查，如果值非负数返回i + 1，全为负数返回N+1</li>\n</ul>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IntAbs</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只关注正整数，用&quot;-&quot;号做标记</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">\t<span class=\"comment\">// 预处理，将元素全部变为整数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tnums[i] = n + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 打标记</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\tx := IntAbs(nums[i])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> x &lt;= n &amp;&amp; nums[x - <span class=\"number\">1</span>] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tnums[x - <span class=\"number\">1</span>] *= <span class=\"number\">-1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 检查标记</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[i] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法3：置换，将数组恢复成形如[1, 2, … , N]的形式，即nums[i-1]&#x3D;i（参考LeetCode官方题解）。</p>\n<ul>\n<li>设v &#x3D; nums[i], 如果nums[i] &#x3D;&#x3D; nums [v-1]，则不需要置换，否则将nums[v-1]设为v，此时要先把nums[v-1]的值保存到nums[i]，此时v-1已经是正确的位置，但是i不一定是正确的位置，需要继续置换。</li>\n<li>检查每个位置的值是否正确，全部正确返回N+1，否则返回i+1</li>\n</ul>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> v &gt; <span class=\"number\">0</span> &amp;&amp; v &lt; n + <span class=\"number\">1</span> &amp;&amp; nums[i] != nums[v - <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\tnums[v - <span class=\"number\">1</span>], nums[i] = v, nums[v - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\tv = nums[i]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v != i + <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据结构(1): 字符串","date":"2023-03-19T13:04:01.000Z","_content":"\n## 1.1 字符串移位\n> 问题：将字符的前k个字符移到字符串结尾。\nInput：“abcde”，2\nOutput：“cdeab”\n\n**三步翻转法**： 将字符串分为前k位和后（n-k）位两部分，将两部分分别翻转，最后再整体翻转即可。\n时间复杂度：T = O(n)\n[参考原文](https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.01.html)\n\n` 示例代码：`\n```go\n// 反转字符串\nfunc reverse(s string) string {\n\trunes := []rune(s)\n\tfor l, r := 0, len(runes) - 1; l < r; l, r = l + 1, r - 1 {\n\t\trunes[l], runes[r] = runes[r], runes[l]\n\t}\n\treturn string(runes)\n}\n\n// 三步反转法对字符串进行循环移位\nfunc shift_string(s string, k int) string {\n\trunes := []rune(s)\n\tls, rs := runes[:k], runes[k:]\n\trls := reverse(string(ls))\n\trrs := reverse(string(rs))\n\treturn reverse(rls + rrs)\n}\n```\n\n## 1.2 最长回文子串\n[LeetCode No.5](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n\n> 问题：找出一个子串包含的最长回文子串。\nInput: s = \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer.\n\n解法1：从某个子串向两边扩展，遍历找出最长的一个（需要考虑偶数个、奇数个字符的回文子串）\n\n`示例代码`\n```go\nfunc LongestPalindrome(s string) string {\n\trs := []rune(s)\n\tmx, st := 0, 0\n\ti, j, c := 0, 0, 0\n\tfor i = 0; i < len(rs); i++ {\n\t\t// 奇数个字符的回文子串\n\t\tfor j = 0; i - j >= 0 && i + j < len(rs); j++ {\n\t\t\tif rs[i - j] != rs[i + j] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc = 2 * j + 1\n\t\t}\n\t\tif c > mx {\n\t\t\tmx = c\n\t\t\tst = i - j + 1\n\t\t}\n\t\t// 偶数个字符的回文子串\n\t\tfor j = 0; (i - j) >= 0 && (i + j + 1) < len(rs); j++ {\n\t\t\tif rs[i - j] != rs[i + j + 1] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc = j * 2 + 2\n\t\t}\n\t\tif c > mx {\n\t\t\tmx = c\n\t\t\tst = i - j + 1\n\t\t}\n\t}\n\n\treturn string(rs[st: st + mx])\n}\n```\n解法2：马拉车算法\n具体思路[参考原文](https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0005.Longest-Palindromic-Substring/)\n\n`示例代码：`\n```go\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\nfunc LongestPalindrome1(s string) string {\n\tif len(s) < 2 {\n\t\treturn s\n\t}\n\tnews := make([]rune, len(s))\n\tnews[0] = '#'\n\tfor _, r := range s {\n\t\tnews = append(news, r)\n\t\tnews = append(news, '#')\n\t}\n\tdp := make([]int, len(news))\n\tmx, center, maxlen, maxst := 0, 0, 1, 0\n\tfor i := 0; i < len(news); i++ {\n\t\t// 算法核心转移方程\n\t\tif i < mx {\n\t\t\tdp[i] = min(mx - i, dp[2*center - i])\n\t\t}\n\n\t\t// 以i为中心，只接从距离i为d[i] + 1的位置扩散\n\t\tleft, right := i - (1 + dp[i]), i + (1+ dp[i])\n\t\tfor left >= 0 && right < len(news) && news[left] == news[right] {\n\t\t\tdp[i]++\n\t\t\tleft++\n\t\t\tright--\n\t\t}\n\t\t// 更新mx\n\t\tif i + dp[i] > mx {\n\t\t\tmx = i + dp[i]\n\t\t\tcenter = i\n\t\t}\n\t\t// 更新最大长度和对应在源字符串的起始位置\n\t\tif dp[i] > maxlen {\n\t\t\tmaxlen = dp[i]\n\t\t\tmaxst = (i - maxlen) / 2\n\t\t}\n\t}\n\treturn s[maxst : maxst + maxlen]\n}\n```\n\n## 1.3 字符串的全排列\n> 问题描述：输入一个字符串，打印出该字符串中字符的所有排列。\n例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串\nabc、acb、bac、bca、cab 和 cba。\n\n解法1：递归方法DFS搜索，想象成树\n![](https://upload-images.jianshu.io/upload_images/14151453-21cc1e0269c2e662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`示例代码:`\n```go\nvar res = []string{}\n\nfunc dfs_search(s string, lv int, cur string)  {\n\tif lv == 0 {\n\t\tres = append(res, cur)\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\t// 去掉当前字符，下一层在剩下的字符中挑\n\t\tdfs_search(s[:i] + s[i+1:], lv - 1, cur + string(s[i]))\n\t}\n}\n\nfunc FullPermutation(s string) []string  {\n\tres = []string{}\n\tdfs_search(s, len(s), \"\")\n\treturn res\n}\n```\n\n解法2：字典序排列，从当前字符串s生成刚好比他大的下一个字符串排列\n[参考原文](https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.06.html)\n\n1. 找到排列中最后一个升序的位置i\n2. 找到i后面最后一个比s[i]大的位置j\n3. 交换s[i]和s[j]\n4. 将i+1之后的字符串反转\n\n`示例代码:`\n```go\n// 字典序排列算法\nfunc next_permutation(s string) (bool, string)  {\n\trs := []rune(s)\n\ti, j := 0, 0\n\n\t// 找到最后一个升序的位置i\n\tfor i = len(rs) - 2; i >= 0 && rs[i] >= rs[i+1]; i-- {}\n\tif i < 0 {\n\t\treturn false, \"\"\n\t}\n\t// 找到i后面最后一个比rs[i]大的位置j\n\tfor j = len(rs) - 1; j > i && rs[j] <= rs[i]; j-- {}\n\t// 交换rs[i], s[j]\n\trs[i], rs[j] = rs[j], rs[i]\n\t// 反转rs[i+1:]\n\trev := reverse(string(rs[i + 1:]))\n\treturn true, string(rs[:i+1]) + rev\n}\n\nfunc DictOrderFullPermutation(s string) []string  {\n\tres := []string{}\n\tfor ok, next_str := true, s; ok; ok, next_str = next_permutation(next_str) {\n\t\tres = append(res, next_str)\n\t}\n\treturn res\n}\n```\n","source":"_posts/2023/03-19-数据结构-1-字符串.md","raw":"---\ntitle: '数据结构(1): 字符串'\ndate: 2023-03-19 21:04:01\ncategories:\n- [数据结构]\ntags:\n- 字符串\n- leetcode\n---\n\n## 1.1 字符串移位\n> 问题：将字符的前k个字符移到字符串结尾。\nInput：“abcde”，2\nOutput：“cdeab”\n\n**三步翻转法**： 将字符串分为前k位和后（n-k）位两部分，将两部分分别翻转，最后再整体翻转即可。\n时间复杂度：T = O(n)\n[参考原文](https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.01.html)\n\n` 示例代码：`\n```go\n// 反转字符串\nfunc reverse(s string) string {\n\trunes := []rune(s)\n\tfor l, r := 0, len(runes) - 1; l < r; l, r = l + 1, r - 1 {\n\t\trunes[l], runes[r] = runes[r], runes[l]\n\t}\n\treturn string(runes)\n}\n\n// 三步反转法对字符串进行循环移位\nfunc shift_string(s string, k int) string {\n\trunes := []rune(s)\n\tls, rs := runes[:k], runes[k:]\n\trls := reverse(string(ls))\n\trrs := reverse(string(rs))\n\treturn reverse(rls + rrs)\n}\n```\n\n## 1.2 最长回文子串\n[LeetCode No.5](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n\n> 问题：找出一个子串包含的最长回文子串。\nInput: s = \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer.\n\n解法1：从某个子串向两边扩展，遍历找出最长的一个（需要考虑偶数个、奇数个字符的回文子串）\n\n`示例代码`\n```go\nfunc LongestPalindrome(s string) string {\n\trs := []rune(s)\n\tmx, st := 0, 0\n\ti, j, c := 0, 0, 0\n\tfor i = 0; i < len(rs); i++ {\n\t\t// 奇数个字符的回文子串\n\t\tfor j = 0; i - j >= 0 && i + j < len(rs); j++ {\n\t\t\tif rs[i - j] != rs[i + j] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc = 2 * j + 1\n\t\t}\n\t\tif c > mx {\n\t\t\tmx = c\n\t\t\tst = i - j + 1\n\t\t}\n\t\t// 偶数个字符的回文子串\n\t\tfor j = 0; (i - j) >= 0 && (i + j + 1) < len(rs); j++ {\n\t\t\tif rs[i - j] != rs[i + j + 1] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc = j * 2 + 2\n\t\t}\n\t\tif c > mx {\n\t\t\tmx = c\n\t\t\tst = i - j + 1\n\t\t}\n\t}\n\n\treturn string(rs[st: st + mx])\n}\n```\n解法2：马拉车算法\n具体思路[参考原文](https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0005.Longest-Palindromic-Substring/)\n\n`示例代码：`\n```go\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\nfunc LongestPalindrome1(s string) string {\n\tif len(s) < 2 {\n\t\treturn s\n\t}\n\tnews := make([]rune, len(s))\n\tnews[0] = '#'\n\tfor _, r := range s {\n\t\tnews = append(news, r)\n\t\tnews = append(news, '#')\n\t}\n\tdp := make([]int, len(news))\n\tmx, center, maxlen, maxst := 0, 0, 1, 0\n\tfor i := 0; i < len(news); i++ {\n\t\t// 算法核心转移方程\n\t\tif i < mx {\n\t\t\tdp[i] = min(mx - i, dp[2*center - i])\n\t\t}\n\n\t\t// 以i为中心，只接从距离i为d[i] + 1的位置扩散\n\t\tleft, right := i - (1 + dp[i]), i + (1+ dp[i])\n\t\tfor left >= 0 && right < len(news) && news[left] == news[right] {\n\t\t\tdp[i]++\n\t\t\tleft++\n\t\t\tright--\n\t\t}\n\t\t// 更新mx\n\t\tif i + dp[i] > mx {\n\t\t\tmx = i + dp[i]\n\t\t\tcenter = i\n\t\t}\n\t\t// 更新最大长度和对应在源字符串的起始位置\n\t\tif dp[i] > maxlen {\n\t\t\tmaxlen = dp[i]\n\t\t\tmaxst = (i - maxlen) / 2\n\t\t}\n\t}\n\treturn s[maxst : maxst + maxlen]\n}\n```\n\n## 1.3 字符串的全排列\n> 问题描述：输入一个字符串，打印出该字符串中字符的所有排列。\n例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串\nabc、acb、bac、bca、cab 和 cba。\n\n解法1：递归方法DFS搜索，想象成树\n![](https://upload-images.jianshu.io/upload_images/14151453-21cc1e0269c2e662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`示例代码:`\n```go\nvar res = []string{}\n\nfunc dfs_search(s string, lv int, cur string)  {\n\tif lv == 0 {\n\t\tres = append(res, cur)\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\t// 去掉当前字符，下一层在剩下的字符中挑\n\t\tdfs_search(s[:i] + s[i+1:], lv - 1, cur + string(s[i]))\n\t}\n}\n\nfunc FullPermutation(s string) []string  {\n\tres = []string{}\n\tdfs_search(s, len(s), \"\")\n\treturn res\n}\n```\n\n解法2：字典序排列，从当前字符串s生成刚好比他大的下一个字符串排列\n[参考原文](https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.06.html)\n\n1. 找到排列中最后一个升序的位置i\n2. 找到i后面最后一个比s[i]大的位置j\n3. 交换s[i]和s[j]\n4. 将i+1之后的字符串反转\n\n`示例代码:`\n```go\n// 字典序排列算法\nfunc next_permutation(s string) (bool, string)  {\n\trs := []rune(s)\n\ti, j := 0, 0\n\n\t// 找到最后一个升序的位置i\n\tfor i = len(rs) - 2; i >= 0 && rs[i] >= rs[i+1]; i-- {}\n\tif i < 0 {\n\t\treturn false, \"\"\n\t}\n\t// 找到i后面最后一个比rs[i]大的位置j\n\tfor j = len(rs) - 1; j > i && rs[j] <= rs[i]; j-- {}\n\t// 交换rs[i], s[j]\n\trs[i], rs[j] = rs[j], rs[i]\n\t// 反转rs[i+1:]\n\trev := reverse(string(rs[i + 1:]))\n\treturn true, string(rs[:i+1]) + rev\n}\n\nfunc DictOrderFullPermutation(s string) []string  {\n\tres := []string{}\n\tfor ok, next_str := true, s; ok; ok, next_str = next_permutation(next_str) {\n\t\tres = append(res, next_str)\n\t}\n\treturn res\n}\n```\n","slug":"数据结构-1-字符串","published":1,"updated":"2023-03-19T13:50:44.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj1760009htfibrqw4ekc","content":"<h2 id=\"1-1-字符串移位\"><a href=\"#1-1-字符串移位\" class=\"headerlink\" title=\"1.1 字符串移位\"></a>1.1 字符串移位</h2><blockquote>\n<p>问题：将字符的前k个字符移到字符串结尾。<br>Input：“abcde”，2<br>Output：“cdeab”</p>\n</blockquote>\n<p><strong>三步翻转法</strong>： 将字符串分为前k位和后（n-k）位两部分，将两部分分别翻转，最后再整体翻转即可。<br>时间复杂度：T &#x3D; O(n)<br><a href=\"https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.01.html\">参考原文</a></p>\n<p><code> 示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反转字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverse</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trunes := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(runes) - <span class=\"number\">1</span>; l &lt; r; l, r = l + <span class=\"number\">1</span>, r - <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\trunes[l], runes[r] = runes[r], runes[l]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">string</span>(runes)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 三步反转法对字符串进行循环移位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shift_string</span><span class=\"params\">(s <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trunes := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\tls, rs := runes[:k], runes[k:]</span><br><span class=\"line\">\trls := reverse(<span class=\"type\">string</span>(ls))</span><br><span class=\"line\">\trrs := reverse(<span class=\"type\">string</span>(rs))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> reverse(rls + rrs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-最长回文子串\"><a href=\"#1-2-最长回文子串\" class=\"headerlink\" title=\"1.2 最长回文子串\"></a>1.2 最长回文子串</h2><p><a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\">LeetCode No.5</a></p>\n<blockquote>\n<p>问题：找出一个子串包含的最长回文子串。<br>Input: s &#x3D; “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.</p>\n</blockquote>\n<p>解法1：从某个子串向两边扩展，遍历找出最长的一个（需要考虑偶数个、奇数个字符的回文子串）</p>\n<p><code>示例代码</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LongestPalindrome</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trs := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\tmx, st := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\ti, j, c := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(rs); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 奇数个字符的回文子串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j = <span class=\"number\">0</span>; i - j &gt;= <span class=\"number\">0</span> &amp;&amp; i + j &lt; <span class=\"built_in\">len</span>(rs); j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> rs[i - j] != rs[i + j] &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tc = <span class=\"number\">2</span> * j + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c &gt; mx &#123;</span><br><span class=\"line\">\t\t\tmx = c</span><br><span class=\"line\">\t\t\tst = i - j + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 偶数个字符的回文子串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j = <span class=\"number\">0</span>; (i - j) &gt;= <span class=\"number\">0</span> &amp;&amp; (i + j + <span class=\"number\">1</span>) &lt; <span class=\"built_in\">len</span>(rs); j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> rs[i - j] != rs[i + j + <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tc = j * <span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c &gt; mx &#123;</span><br><span class=\"line\">\t\t\tmx = c</span><br><span class=\"line\">\t\t\tst = i - j + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">string</span>(rs[st: st + mx])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解法2：马拉车算法<br>具体思路<a href=\"https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0005.Longest-Palindromic-Substring/\">参考原文</a></p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt; y &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LongestPalindrome1</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) &lt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnews := <span class=\"built_in\">make</span>([]<span class=\"type\">rune</span>, <span class=\"built_in\">len</span>(s))</span><br><span class=\"line\">\tnews[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;#&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\tnews = <span class=\"built_in\">append</span>(news, r)</span><br><span class=\"line\">\t\tnews = <span class=\"built_in\">append</span>(news, <span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(news))</span><br><span class=\"line\">\tmx, center, maxlen, maxst := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(news); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 算法核心转移方程</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &lt; mx &#123;</span><br><span class=\"line\">\t\t\tdp[i] = min(mx - i, dp[<span class=\"number\">2</span>*center - i])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 以i为中心，只接从距离i为d[i] + 1的位置扩散</span></span><br><span class=\"line\">\t\tleft, right := i - (<span class=\"number\">1</span> + dp[i]), i + (<span class=\"number\">1</span>+ dp[i])</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> left &gt;= <span class=\"number\">0</span> &amp;&amp; right &lt; <span class=\"built_in\">len</span>(news) &amp;&amp; news[left] == news[right] &#123;</span><br><span class=\"line\">\t\t\tdp[i]++</span><br><span class=\"line\">\t\t\tleft++</span><br><span class=\"line\">\t\t\tright--</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新mx</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i + dp[i] &gt; mx &#123;</span><br><span class=\"line\">\t\t\tmx = i + dp[i]</span><br><span class=\"line\">\t\t\tcenter = i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新最大长度和对应在源字符串的起始位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> dp[i] &gt; maxlen &#123;</span><br><span class=\"line\">\t\t\tmaxlen = dp[i]</span><br><span class=\"line\">\t\t\tmaxst = (i - maxlen) / <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s[maxst : maxst + maxlen]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-字符串的全排列\"><a href=\"#1-3-字符串的全排列\" class=\"headerlink\" title=\"1.3 字符串的全排列\"></a>1.3 字符串的全排列</h2><blockquote>\n<p>问题描述：输入一个字符串，打印出该字符串中字符的所有排列。<br>例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串<br>abc、acb、bac、bca、cab 和 cba。</p>\n</blockquote>\n<p>解法1：递归方法DFS搜索，想象成树<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-21cc1e0269c2e662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-21cc1e0269c2e662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs_search</span><span class=\"params\">(s <span class=\"type\">string</span>, lv <span class=\"type\">int</span>, cur <span class=\"type\">string</span>)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> lv == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, cur)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 去掉当前字符，下一层在剩下的字符中挑</span></span><br><span class=\"line\">\t\tdfs_search(s[:i] + s[i+<span class=\"number\">1</span>:], lv - <span class=\"number\">1</span>, cur + <span class=\"type\">string</span>(s[i]))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FullPermutation</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span>  &#123;</span><br><span class=\"line\">\tres = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\tdfs_search(s, <span class=\"built_in\">len</span>(s), <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解法2：字典序排列，从当前字符串s生成刚好比他大的下一个字符串排列<br><a href=\"https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.06.html\">参考原文</a></p>\n<ol>\n<li>找到排列中最后一个升序的位置i</li>\n<li>找到i后面最后一个比s[i]大的位置j</li>\n<li>交换s[i]和s[j]</li>\n<li>将i+1之后的字符串反转</li>\n</ol>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字典序排列算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">next_permutation</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> (<span class=\"type\">bool</span>, <span class=\"type\">string</span>)  &#123;</span><br><span class=\"line\">\trs := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\ti, j := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 找到最后一个升序的位置i</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i = <span class=\"built_in\">len</span>(rs) - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; rs[i] &gt;= rs[i+<span class=\"number\">1</span>]; i-- &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>, <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 找到i后面最后一个比rs[i]大的位置j</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j = <span class=\"built_in\">len</span>(rs) - <span class=\"number\">1</span>; j &gt; i &amp;&amp; rs[j] &lt;= rs[i]; j-- &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 交换rs[i], s[j]</span></span><br><span class=\"line\">\trs[i], rs[j] = rs[j], rs[i]</span><br><span class=\"line\">\t<span class=\"comment\">// 反转rs[i+1:]</span></span><br><span class=\"line\">\trev := reverse(<span class=\"type\">string</span>(rs[i + <span class=\"number\">1</span>:]))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>, <span class=\"type\">string</span>(rs[:i+<span class=\"number\">1</span>]) + rev</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DictOrderFullPermutation</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span>  &#123;</span><br><span class=\"line\">\tres := []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ok, next_str := <span class=\"literal\">true</span>, s; ok; ok, next_str = next_permutation(next_str) &#123;</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, next_str)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-1-字符串移位\"><a href=\"#1-1-字符串移位\" class=\"headerlink\" title=\"1.1 字符串移位\"></a>1.1 字符串移位</h2><blockquote>\n<p>问题：将字符的前k个字符移到字符串结尾。<br>Input：“abcde”，2<br>Output：“cdeab”</p>\n</blockquote>\n<p><strong>三步翻转法</strong>： 将字符串分为前k位和后（n-k）位两部分，将两部分分别翻转，最后再整体翻转即可。<br>时间复杂度：T &#x3D; O(n)<br><a href=\"https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.01.html\">参考原文</a></p>\n<p><code> 示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反转字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverse</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trunes := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(runes) - <span class=\"number\">1</span>; l &lt; r; l, r = l + <span class=\"number\">1</span>, r - <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\trunes[l], runes[r] = runes[r], runes[l]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">string</span>(runes)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 三步反转法对字符串进行循环移位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shift_string</span><span class=\"params\">(s <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trunes := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\tls, rs := runes[:k], runes[k:]</span><br><span class=\"line\">\trls := reverse(<span class=\"type\">string</span>(ls))</span><br><span class=\"line\">\trrs := reverse(<span class=\"type\">string</span>(rs))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> reverse(rls + rrs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-最长回文子串\"><a href=\"#1-2-最长回文子串\" class=\"headerlink\" title=\"1.2 最长回文子串\"></a>1.2 最长回文子串</h2><p><a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\">LeetCode No.5</a></p>\n<blockquote>\n<p>问题：找出一个子串包含的最长回文子串。<br>Input: s &#x3D; “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.</p>\n</blockquote>\n<p>解法1：从某个子串向两边扩展，遍历找出最长的一个（需要考虑偶数个、奇数个字符的回文子串）</p>\n<p><code>示例代码</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LongestPalindrome</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trs := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\tmx, st := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\ti, j, c := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(rs); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 奇数个字符的回文子串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j = <span class=\"number\">0</span>; i - j &gt;= <span class=\"number\">0</span> &amp;&amp; i + j &lt; <span class=\"built_in\">len</span>(rs); j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> rs[i - j] != rs[i + j] &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tc = <span class=\"number\">2</span> * j + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c &gt; mx &#123;</span><br><span class=\"line\">\t\t\tmx = c</span><br><span class=\"line\">\t\t\tst = i - j + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 偶数个字符的回文子串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j = <span class=\"number\">0</span>; (i - j) &gt;= <span class=\"number\">0</span> &amp;&amp; (i + j + <span class=\"number\">1</span>) &lt; <span class=\"built_in\">len</span>(rs); j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> rs[i - j] != rs[i + j + <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tc = j * <span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c &gt; mx &#123;</span><br><span class=\"line\">\t\t\tmx = c</span><br><span class=\"line\">\t\t\tst = i - j + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">string</span>(rs[st: st + mx])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解法2：马拉车算法<br>具体思路<a href=\"https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0005.Longest-Palindromic-Substring/\">参考原文</a></p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt; y &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LongestPalindrome1</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) &lt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnews := <span class=\"built_in\">make</span>([]<span class=\"type\">rune</span>, <span class=\"built_in\">len</span>(s))</span><br><span class=\"line\">\tnews[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;#&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\tnews = <span class=\"built_in\">append</span>(news, r)</span><br><span class=\"line\">\t\tnews = <span class=\"built_in\">append</span>(news, <span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(news))</span><br><span class=\"line\">\tmx, center, maxlen, maxst := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(news); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 算法核心转移方程</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &lt; mx &#123;</span><br><span class=\"line\">\t\t\tdp[i] = min(mx - i, dp[<span class=\"number\">2</span>*center - i])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 以i为中心，只接从距离i为d[i] + 1的位置扩散</span></span><br><span class=\"line\">\t\tleft, right := i - (<span class=\"number\">1</span> + dp[i]), i + (<span class=\"number\">1</span>+ dp[i])</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> left &gt;= <span class=\"number\">0</span> &amp;&amp; right &lt; <span class=\"built_in\">len</span>(news) &amp;&amp; news[left] == news[right] &#123;</span><br><span class=\"line\">\t\t\tdp[i]++</span><br><span class=\"line\">\t\t\tleft++</span><br><span class=\"line\">\t\t\tright--</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新mx</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i + dp[i] &gt; mx &#123;</span><br><span class=\"line\">\t\t\tmx = i + dp[i]</span><br><span class=\"line\">\t\t\tcenter = i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新最大长度和对应在源字符串的起始位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> dp[i] &gt; maxlen &#123;</span><br><span class=\"line\">\t\t\tmaxlen = dp[i]</span><br><span class=\"line\">\t\t\tmaxst = (i - maxlen) / <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s[maxst : maxst + maxlen]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-字符串的全排列\"><a href=\"#1-3-字符串的全排列\" class=\"headerlink\" title=\"1.3 字符串的全排列\"></a>1.3 字符串的全排列</h2><blockquote>\n<p>问题描述：输入一个字符串，打印出该字符串中字符的所有排列。<br>例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串<br>abc、acb、bac、bca、cab 和 cba。</p>\n</blockquote>\n<p>解法1：递归方法DFS搜索，想象成树<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-21cc1e0269c2e662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs_search</span><span class=\"params\">(s <span class=\"type\">string</span>, lv <span class=\"type\">int</span>, cur <span class=\"type\">string</span>)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> lv == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, cur)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 去掉当前字符，下一层在剩下的字符中挑</span></span><br><span class=\"line\">\t\tdfs_search(s[:i] + s[i+<span class=\"number\">1</span>:], lv - <span class=\"number\">1</span>, cur + <span class=\"type\">string</span>(s[i]))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FullPermutation</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span>  &#123;</span><br><span class=\"line\">\tres = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\tdfs_search(s, <span class=\"built_in\">len</span>(s), <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解法2：字典序排列，从当前字符串s生成刚好比他大的下一个字符串排列<br><a href=\"https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.06.html\">参考原文</a></p>\n<ol>\n<li>找到排列中最后一个升序的位置i</li>\n<li>找到i后面最后一个比s[i]大的位置j</li>\n<li>交换s[i]和s[j]</li>\n<li>将i+1之后的字符串反转</li>\n</ol>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字典序排列算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">next_permutation</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> (<span class=\"type\">bool</span>, <span class=\"type\">string</span>)  &#123;</span><br><span class=\"line\">\trs := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\ti, j := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 找到最后一个升序的位置i</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i = <span class=\"built_in\">len</span>(rs) - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; rs[i] &gt;= rs[i+<span class=\"number\">1</span>]; i-- &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>, <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 找到i后面最后一个比rs[i]大的位置j</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j = <span class=\"built_in\">len</span>(rs) - <span class=\"number\">1</span>; j &gt; i &amp;&amp; rs[j] &lt;= rs[i]; j-- &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 交换rs[i], s[j]</span></span><br><span class=\"line\">\trs[i], rs[j] = rs[j], rs[i]</span><br><span class=\"line\">\t<span class=\"comment\">// 反转rs[i+1:]</span></span><br><span class=\"line\">\trev := reverse(<span class=\"type\">string</span>(rs[i + <span class=\"number\">1</span>:]))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>, <span class=\"type\">string</span>(rs[:i+<span class=\"number\">1</span>]) + rev</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DictOrderFullPermutation</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span>  &#123;</span><br><span class=\"line\">\tres := []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ok, next_str := <span class=\"literal\">true</span>, s; ok; ok, next_str = next_permutation(next_str) &#123;</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, next_str)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据结构(4): 树","date":"2023-03-19T13:36:55.000Z","_content":"\n### 4.1 根据前序与中序序列构造二叉树\n[LeetCode No.105](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n> 问题描述：根据一棵树的前序遍历与中序遍历构造二叉树。\n\n**思路**：根据二叉树的前序和中序（或后序和中序）的序列可唯一构造一棵二叉树，必须要有中序。前序遍历的第一个为根节点，找到根节点在中序中的位置，中序左边的节点都是根节点的左子树，右边的同理，然后可以用递归的方式求解。\n\n`示例代码：`\n```go\ntype TreeNode struct {\n  Val int\n  Left *TreeNode\n  Right *TreeNode\n}\n\nfunc index(nums []int, val int) int {\n\tfor i, v := range nums {\n\t\tif v == val {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\n\tif len(preorder) == 0 || len(inorder) == 0 {\n\t\treturn nil\n\t}\n\tif len(preorder) == 1 || len(inorder) == 1 {\n\t\treturn &TreeNode{\n\t\t\tVal: preorder[0],\n\t\t\tLeft: nil,\n\t\t\tRight: nil,\n\t\t}\n\t}\n\tval := preorder[0]\n\tpos := index(inorder, val)\n\troot := &TreeNode{\n\t\tVal: val,\n\t\tLeft: buildTree(preorder[1 : pos + 1], inorder[ : pos]),\n\t\tRight: buildTree(preorder[pos + 1 : ], inorder[pos + 1:]),\n\t}\n\treturn root\n}\n```\n","source":"_posts/2023/03-19-数据结构-4-树.md","raw":"---\ntitle: '数据结构(4): 树'\ndate: 2023-03-19 21:36:55\ncategories:\n- [数据结构]\ntags:\n- 树\n- 二叉树\n- leetcode\n---\n\n### 4.1 根据前序与中序序列构造二叉树\n[LeetCode No.105](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n> 问题描述：根据一棵树的前序遍历与中序遍历构造二叉树。\n\n**思路**：根据二叉树的前序和中序（或后序和中序）的序列可唯一构造一棵二叉树，必须要有中序。前序遍历的第一个为根节点，找到根节点在中序中的位置，中序左边的节点都是根节点的左子树，右边的同理，然后可以用递归的方式求解。\n\n`示例代码：`\n```go\ntype TreeNode struct {\n  Val int\n  Left *TreeNode\n  Right *TreeNode\n}\n\nfunc index(nums []int, val int) int {\n\tfor i, v := range nums {\n\t\tif v == val {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\n\tif len(preorder) == 0 || len(inorder) == 0 {\n\t\treturn nil\n\t}\n\tif len(preorder) == 1 || len(inorder) == 1 {\n\t\treturn &TreeNode{\n\t\t\tVal: preorder[0],\n\t\t\tLeft: nil,\n\t\t\tRight: nil,\n\t\t}\n\t}\n\tval := preorder[0]\n\tpos := index(inorder, val)\n\troot := &TreeNode{\n\t\tVal: val,\n\t\tLeft: buildTree(preorder[1 : pos + 1], inorder[ : pos]),\n\t\tRight: buildTree(preorder[pos + 1 : ], inorder[pos + 1:]),\n\t}\n\treturn root\n}\n```\n","slug":"数据结构-4-树","published":1,"updated":"2023-03-19T14:11:44.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj177000ahtfihx9degr6","content":"<h3 id=\"4-1-根据前序与中序序列构造二叉树\"><a href=\"#4-1-根据前序与中序序列构造二叉树\" class=\"headerlink\" title=\"4.1 根据前序与中序序列构造二叉树\"></a>4.1 根据前序与中序序列构造二叉树</h3><p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\">LeetCode No.105</a></p>\n<blockquote>\n<p>问题描述：根据一棵树的前序遍历与中序遍历构造二叉树。</p>\n</blockquote>\n<p><strong>思路</strong>：根据二叉树的前序和中序（或后序和中序）的序列可唯一构造一棵二叉树，必须要有中序。前序遍历的第一个为根节点，找到根节点在中序中的位置，中序左边的节点都是根节点的左子树，右边的同理，然后可以用递归的方式求解。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Val <span class=\"type\">int</span></span><br><span class=\"line\">  Left *TreeNode</span><br><span class=\"line\">  Right *TreeNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">index</span><span class=\"params\">(nums []<span class=\"type\">int</span>, val <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v == val &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildTree</span><span class=\"params\">(preorder []<span class=\"type\">int</span>, inorder []<span class=\"type\">int</span>)</span></span> *TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(preorder) == <span class=\"number\">0</span> || <span class=\"built_in\">len</span>(inorder) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(preorder) == <span class=\"number\">1</span> || <span class=\"built_in\">len</span>(inorder) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;TreeNode&#123;</span><br><span class=\"line\">\t\t\tVal: preorder[<span class=\"number\">0</span>],</span><br><span class=\"line\">\t\t\tLeft: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t\t\tRight: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tval := preorder[<span class=\"number\">0</span>]</span><br><span class=\"line\">\tpos := index(inorder, val)</span><br><span class=\"line\">\troot := &amp;TreeNode&#123;</span><br><span class=\"line\">\t\tVal: val,</span><br><span class=\"line\">\t\tLeft: buildTree(preorder[<span class=\"number\">1</span> : pos + <span class=\"number\">1</span>], inorder[ : pos]),</span><br><span class=\"line\">\t\tRight: buildTree(preorder[pos + <span class=\"number\">1</span> : ], inorder[pos + <span class=\"number\">1</span>:]),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"4-1-根据前序与中序序列构造二叉树\"><a href=\"#4-1-根据前序与中序序列构造二叉树\" class=\"headerlink\" title=\"4.1 根据前序与中序序列构造二叉树\"></a>4.1 根据前序与中序序列构造二叉树</h3><p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\">LeetCode No.105</a></p>\n<blockquote>\n<p>问题描述：根据一棵树的前序遍历与中序遍历构造二叉树。</p>\n</blockquote>\n<p><strong>思路</strong>：根据二叉树的前序和中序（或后序和中序）的序列可唯一构造一棵二叉树，必须要有中序。前序遍历的第一个为根节点，找到根节点在中序中的位置，中序左边的节点都是根节点的左子树，右边的同理，然后可以用递归的方式求解。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Val <span class=\"type\">int</span></span><br><span class=\"line\">  Left *TreeNode</span><br><span class=\"line\">  Right *TreeNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">index</span><span class=\"params\">(nums []<span class=\"type\">int</span>, val <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v == val &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildTree</span><span class=\"params\">(preorder []<span class=\"type\">int</span>, inorder []<span class=\"type\">int</span>)</span></span> *TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(preorder) == <span class=\"number\">0</span> || <span class=\"built_in\">len</span>(inorder) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(preorder) == <span class=\"number\">1</span> || <span class=\"built_in\">len</span>(inorder) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;TreeNode&#123;</span><br><span class=\"line\">\t\t\tVal: preorder[<span class=\"number\">0</span>],</span><br><span class=\"line\">\t\t\tLeft: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t\t\tRight: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tval := preorder[<span class=\"number\">0</span>]</span><br><span class=\"line\">\tpos := index(inorder, val)</span><br><span class=\"line\">\troot := &amp;TreeNode&#123;</span><br><span class=\"line\">\t\tVal: val,</span><br><span class=\"line\">\t\tLeft: buildTree(preorder[<span class=\"number\">1</span> : pos + <span class=\"number\">1</span>], inorder[ : pos]),</span><br><span class=\"line\">\t\tRight: buildTree(preorder[pos + <span class=\"number\">1</span> : ], inorder[pos + <span class=\"number\">1</span>:]),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据结构(3): 链表","date":"2023-03-19T13:35:07.000Z","_content":"\n## 3.1 删除单向链表倒数第n个节点\n[LeetCode No.19](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)\n\n> 问题描述：删除单向链表倒数第n个节点（只遍历一次）\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\n**思路**：两个指针，p1先走n步，然后p1和p2再一起走，当p1到链表结尾，p2就是要删除的节点。注意处理可能删除的是头结点（n=length）或者不需要删除（n>length）的情况。\n**可以通过增加一个虚拟的头节点，避免对头节点的特殊处理。**\n\n`示例代码`\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    p1, p2 := head, head\n    i := 0\n    for ; i < n && p1 != nil ; i++ {\n        p1 = p1.Next\n    }\n    if p1 == nil {\n        if i < n {\n            // 不需要删除\n            return head\n        } else {\n            // 删除头节点\n            return head.Next\n        }\n    }\n    for p1.Next != nil {\n        p1 = p1.Next\n        p2 = p2.Next\n    }\n    t := p2.Next\n    if t != nil {\n        p2.Next = t.Next\n    }\n    return head\n}\n```\n\n## 3.2 K个一组翻转链表\n[LeetCode No.25](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\n\n> 题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n进阶：\n你可以设计一个只使用常数额外空间的算法来解决此问题吗？\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n\n**思路：** 先遍历一遍求出链表长度n，则需要翻转n/k组。使用一个虚拟头节点保存结果，每一轮翻转完将尾节保存，下一轮翻转结束后将上一轮的为节点的Next节点指向当前轮的头结点。\n\n`示例代码：`\n```go\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    n := 0\n    for p := head; p != nil; p = p.Next {\n        n++\n    }\n    reshead := &ListNode{}\n    var lasttail *ListNode\n    for i, p := 0, head; i <= n/k; i++ {\n        if i == n / k {\n            lasttail.Next = p\n            break\n        }\n        curhead, curtail := p, p\n        for j := 0; j < k; j++ {\n            tmp := p\n            p = p.Next\n            tmp.Next = curhead\n            curhead = tmp\n        }\n        if i == 0 {\n            reshead.Next = curhead\n        } else {\n            lasttail.Next = curhead\n        }\n        lasttail = curtail\n    }\n    return reshead.Next\n}\n```\n","source":"_posts/2023/03-19-数据结构-3-链表.md","raw":"---\ntitle: '数据结构(3): 链表'\ndate: 2023-03-19 21:35:07\ncategories:\n- [数据结构]\ntags:\n- 链表\n- leetcode\n---\n\n## 3.1 删除单向链表倒数第n个节点\n[LeetCode No.19](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)\n\n> 问题描述：删除单向链表倒数第n个节点（只遍历一次）\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\n**思路**：两个指针，p1先走n步，然后p1和p2再一起走，当p1到链表结尾，p2就是要删除的节点。注意处理可能删除的是头结点（n=length）或者不需要删除（n>length）的情况。\n**可以通过增加一个虚拟的头节点，避免对头节点的特殊处理。**\n\n`示例代码`\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    p1, p2 := head, head\n    i := 0\n    for ; i < n && p1 != nil ; i++ {\n        p1 = p1.Next\n    }\n    if p1 == nil {\n        if i < n {\n            // 不需要删除\n            return head\n        } else {\n            // 删除头节点\n            return head.Next\n        }\n    }\n    for p1.Next != nil {\n        p1 = p1.Next\n        p2 = p2.Next\n    }\n    t := p2.Next\n    if t != nil {\n        p2.Next = t.Next\n    }\n    return head\n}\n```\n\n## 3.2 K个一组翻转链表\n[LeetCode No.25](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\n\n> 题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n进阶：\n你可以设计一个只使用常数额外空间的算法来解决此问题吗？\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n\n**思路：** 先遍历一遍求出链表长度n，则需要翻转n/k组。使用一个虚拟头节点保存结果，每一轮翻转完将尾节保存，下一轮翻转结束后将上一轮的为节点的Next节点指向当前轮的头结点。\n\n`示例代码：`\n```go\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    n := 0\n    for p := head; p != nil; p = p.Next {\n        n++\n    }\n    reshead := &ListNode{}\n    var lasttail *ListNode\n    for i, p := 0, head; i <= n/k; i++ {\n        if i == n / k {\n            lasttail.Next = p\n            break\n        }\n        curhead, curtail := p, p\n        for j := 0; j < k; j++ {\n            tmp := p\n            p = p.Next\n            tmp.Next = curhead\n            curhead = tmp\n        }\n        if i == 0 {\n            reshead.Next = curhead\n        } else {\n            lasttail.Next = curhead\n        }\n        lasttail = curtail\n    }\n    return reshead.Next\n}\n```\n","slug":"数据结构-3-链表","published":1,"updated":"2023-03-19T14:11:46.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj179000dhtfify4ib4mh","content":"<h2 id=\"3-1-删除单向链表倒数第n个节点\"><a href=\"#3-1-删除单向链表倒数第n个节点\" class=\"headerlink\" title=\"3.1 删除单向链表倒数第n个节点\"></a>3.1 删除单向链表倒数第n个节点</h2><p><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\">LeetCode No.19</a></p>\n<blockquote>\n<p>问题描述：删除单向链表倒数第n个节点（只遍历一次）<br>Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>Output: [1,2,3,5]</p>\n</blockquote>\n<p><strong>思路</strong>：两个指针，p1先走n步，然后p1和p2再一起走，当p1到链表结尾，p2就是要删除的节点。注意处理可能删除的是头结点（n&#x3D;length）或者不需要删除（n&gt;length）的情况。<br><strong>可以通过增加一个虚拟的头节点，避免对头节点的特殊处理。</strong></p>\n<p><code>示例代码</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(head *ListNode, n <span class=\"type\">int</span>)</span></span> *ListNode &#123;</span><br><span class=\"line\">    p1, p2 := head, head</span><br><span class=\"line\">    i := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ; i &lt; n &amp;&amp; p1 != <span class=\"literal\">nil</span> ; i++ &#123;</span><br><span class=\"line\">        p1 = p1.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> p1 == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; n &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不需要删除</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 删除头节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head.Next</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p1.Next != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        p1 = p1.Next</span><br><span class=\"line\">        p2 = p2.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    t := p2.Next</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        p2.Next = t.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-K个一组翻转链表\"><a href=\"#3-2-K个一组翻转链表\" class=\"headerlink\" title=\"3.2 K个一组翻转链表\"></a>3.2 K个一组翻转链表</h2><p><a href=\"https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\">LeetCode No.25</a></p>\n<blockquote>\n<p>题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>进阶：<br>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>\n</blockquote>\n<p><strong>思路：</strong> 先遍历一遍求出链表长度n，则需要翻转n&#x2F;k组。使用一个虚拟头节点保存结果，每一轮翻转完将尾节保存，下一轮翻转结束后将上一轮的为节点的Next节点指向当前轮的头结点。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(head *ListNode, k <span class=\"type\">int</span>)</span></span> *ListNode &#123;</span><br><span class=\"line\">    n := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> p := head; p != <span class=\"literal\">nil</span>; p = p.Next &#123;</span><br><span class=\"line\">        n++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reshead := &amp;ListNode&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lasttail *ListNode</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, p := <span class=\"number\">0</span>, head; i &lt;= n/k; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == n / k &#123;</span><br><span class=\"line\">            lasttail.Next = p</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        curhead, curtail := p, p</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; k; j++ &#123;</span><br><span class=\"line\">            tmp := p</span><br><span class=\"line\">            p = p.Next</span><br><span class=\"line\">            tmp.Next = curhead</span><br><span class=\"line\">            curhead = tmp</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            reshead.Next = curhead</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            lasttail.Next = curhead</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lasttail = curtail</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reshead.Next</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"3-1-删除单向链表倒数第n个节点\"><a href=\"#3-1-删除单向链表倒数第n个节点\" class=\"headerlink\" title=\"3.1 删除单向链表倒数第n个节点\"></a>3.1 删除单向链表倒数第n个节点</h2><p><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\">LeetCode No.19</a></p>\n<blockquote>\n<p>问题描述：删除单向链表倒数第n个节点（只遍历一次）<br>Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>Output: [1,2,3,5]</p>\n</blockquote>\n<p><strong>思路</strong>：两个指针，p1先走n步，然后p1和p2再一起走，当p1到链表结尾，p2就是要删除的节点。注意处理可能删除的是头结点（n&#x3D;length）或者不需要删除（n&gt;length）的情况。<br><strong>可以通过增加一个虚拟的头节点，避免对头节点的特殊处理。</strong></p>\n<p><code>示例代码</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(head *ListNode, n <span class=\"type\">int</span>)</span></span> *ListNode &#123;</span><br><span class=\"line\">    p1, p2 := head, head</span><br><span class=\"line\">    i := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ; i &lt; n &amp;&amp; p1 != <span class=\"literal\">nil</span> ; i++ &#123;</span><br><span class=\"line\">        p1 = p1.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> p1 == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; n &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不需要删除</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 删除头节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head.Next</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p1.Next != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        p1 = p1.Next</span><br><span class=\"line\">        p2 = p2.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    t := p2.Next</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        p2.Next = t.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-K个一组翻转链表\"><a href=\"#3-2-K个一组翻转链表\" class=\"headerlink\" title=\"3.2 K个一组翻转链表\"></a>3.2 K个一组翻转链表</h2><p><a href=\"https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\">LeetCode No.25</a></p>\n<blockquote>\n<p>题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>进阶：<br>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>\n</blockquote>\n<p><strong>思路：</strong> 先遍历一遍求出链表长度n，则需要翻转n&#x2F;k组。使用一个虚拟头节点保存结果，每一轮翻转完将尾节保存，下一轮翻转结束后将上一轮的为节点的Next节点指向当前轮的头结点。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(head *ListNode, k <span class=\"type\">int</span>)</span></span> *ListNode &#123;</span><br><span class=\"line\">    n := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> p := head; p != <span class=\"literal\">nil</span>; p = p.Next &#123;</span><br><span class=\"line\">        n++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reshead := &amp;ListNode&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lasttail *ListNode</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, p := <span class=\"number\">0</span>, head; i &lt;= n/k; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == n / k &#123;</span><br><span class=\"line\">            lasttail.Next = p</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        curhead, curtail := p, p</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; k; j++ &#123;</span><br><span class=\"line\">            tmp := p</span><br><span class=\"line\">            p = p.Next</span><br><span class=\"line\">            tmp.Next = curhead</span><br><span class=\"line\">            curhead = tmp</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            reshead.Next = curhead</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            lasttail.Next = curhead</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lasttail = curtail</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reshead.Next</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据结构(5): 栈|队列|堆","date":"2023-03-19T13:39:14.000Z","_content":"\n## 6.1 栈\n### 6.1.1用两个栈实现一个队列\n[LeetCode No.232](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n> 题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：\n\n**思路：** 两个栈一个栈做队头（出元素），另一个栈做队尾（入元素）\n- 每次push只需要push到尾栈\n- pop时如果头栈为空则将尾栈全部“倒入”头栈，如果头栈不为空取出栈顶元素返回，否则返回失败（此时队列为空）。\n\n`示例代码：`\n```go\ntype MyQueue struct {\n\tstack_head []int\n\tstack_tail []int\n}\n\n\n/** Initialize your data structure here. */\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tstack_head: make([]int, 0),\n\t\tstack_tail: make([]int, 0),\n\t}\n}\n\n\n/** Push element x to the back of queue. */\nfunc (this *MyQueue) Push(x int)  {\n\tthis.stack_tail = append(this.stack_tail, x)\n}\n\nfunc(this *MyQueue) tail2head()  {\n\tfor i := len(this.stack_tail) - 1; i >= 0; i-- {\n\t\tthis.stack_head = append(this.stack_head, this.stack_tail[i])\n\t\tthis.stack_tail = this.stack_tail[:len(this.stack_tail) - 1]\n\t}\n}\n\n/** Removes the element from in front of queue and returns that element. */\nfunc (this *MyQueue) Pop() int {\n\tif len(this.stack_head) == 0 {\n\t\tthis.tail2head()\n\t}\n\tif len(this.stack_head) > 0 {\n\t\tr := this.stack_head[len(this.stack_head) - 1]\n\t\tthis.stack_head = this.stack_head[:len(this.stack_head) - 1]\n\t\treturn r\n\t}\n\treturn -1\n}\n\n\n/** Get the front element. */\nfunc (this *MyQueue) Peek() int {\n\tif len(this.stack_head) == 0 {\n\t\tthis.tail2head()\n\t}\n\tif len(this.stack_head) > 0 {\n\t\treturn this.stack_head[len(this.stack_head) - 1]\n\t}\n\treturn -1\n}\n\n\n/** Returns whether the queue is empty. */\nfunc (this *MyQueue) Empty() bool {\n\treturn len(this.stack_head) == 0 && len(this.stack_tail) == 0\n}\n```\n\n### 6.1.2 逆波兰表达式求值\n[LeetCode No.150](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)\n> 问题描述：根据[ 逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437)，求表达式的值。\n有效的运算符包括 `+`, `-`, `*`, `/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n输入: [\"2\", \"1\", \"+\", \"3\", \"*\"]\n输出: 9\n解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n\n**思路**：借助一个栈，如果是数值就入栈，如果是运算符就从栈顶取出两个元素计算，然后将结果入栈，最后栈中只剩一个元素就是结果。\n\n`示例代码：`\n```go\nfunc operate(x, y int, op string) int {\n\tswitch op {\n\tcase \"+\": return x + y\n\tcase \"-\": return x - y\n\tcase \"*\": return x * y\n\tcase \"/\": return x / y\n\tdefault:\n\t\treturn 0\n\t}\n}\n\nfunc evalRPN(tokens []string) int {\n\tstack := []int{}\n\tfor i := 0; i < len(tokens); i++ {\n\t\tswitch tokens[i] {\n\t\tcase \"+\", \"-\", \"*\", \"/\":\n\t\t\tcur := operate(stack[len(stack) - 2], stack[len(stack) - 1], tokens[i])\n\t\t\tstack = stack[:len(stack) - 1]\n\t\t\tstack[len(stack) - 1] = cur\n\t\tdefault:\n\t\t\tnum, _ := strconv.Atoi(tokens[i])\n\t\t\tstack = append(stack, num)\n\t\t}\n\t}\n\treturn stack[0]\n}\n```\n\n### 6.1.3 中缀表达式生成逆波兰表达式\n- 借助一个符号栈和结果队列，具体过程见代码注释\n\n`示例代码：`\n```go\nfunc is_operation(b byte) bool {\n\treturn b == '+' || b == '-' || b == '*' || b == '/'\n}\n\nfunc compare_priority(a, b byte) int {\n\tif (a == '+' || a == '-') && (b == '*' || b == '/') {\n\t\treturn -1\n\t} else if (b == '+' || b == '-') && (a == '*' || a == '/') {\n\t\treturn 1\n\t} else {\n\t\treturn 0\n\t}\n}\n\nfunc toRPN(s string) []string {\n\t// 运算符栈\n\tops_stack := []byte{}\n\t// 结果队列\n\tres_queue := []string{}\n\tn := len(s)\n\tfor i := 0; i < n; i++ {\n\t\tif s[i] == '(' {\n\t\t\t// 遇到左括号直接入栈\n\t\t\tops_stack = append(ops_stack, s[i])\n\t\t} else if s[i] == ')' {\n\t\t\t// 遇到右括号，则将栈中的运算符依次弹出加入到结果队列，直到碰到左括号，然后将这对括号丢弃\n\t\t\tfor ops_stack[len(ops_stack) - 1] != '(' {\n\t\t\t\tres_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1]))\n\t\t\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t\t\t}\n\t\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t\t} else if is_operation(s[i]) {\n\t\t\t// 遇到运算符，当前运算符的优先级小于等于栈顶运算符的优先级，则依次将栈顶弹出加入到结果队列\n\t\t\tfor len(ops_stack) > 0 && is_operation(ops_stack[len(ops_stack) - 1]) &&\n\t\t\t\tcompare_priority(s[i], ops_stack[len(ops_stack) - 1]) <= 0 {\n\t\t\t\tres_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1]))\n\t\t\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t\t\t}\n\t\t\tops_stack = append(ops_stack, s[i])\n\t\t} else if s[i] == ' ' {\n\t\t\t// 跳过空字符\n\t\t\tcontinue\n\t\t} else {\n\t\t\t// 遇到数字加入到结果队列\n\t\t\tnum := 0\n\t\t\tfor ; i < n && s[i] >= '0' && s[i] <= '9'; i++ {\n\t\t\t\tnum = num * 10 + int(s[i] - '0')\n\t\t\t}\n\t\t\ti--\n\t\t\tres_queue = append(res_queue, strconv.Itoa(num))\n\t\t}\n\t}\n\t// 运算符栈中剩余的元素弹出添加到结果队列\n\tfor len(ops_stack) > 0 {\n\t\tres_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1]))\n\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t}\n\treturn res_queue\n}\n```\n\n## 6.2 堆\n**定义：**最大堆的堆顶为最大元素，最小堆同理\n### 6.2.1 Golang实现堆类型\n因为go本身没有实现堆类型，只提供了接口，使用时必须实现堆接口才能使用对应的堆方法，所以自己用golang的container/heap接口实现一个通用的堆类型，创建堆需要一个比较函数作为参数\n`实现代码：`\n```go\n// 比较函数类型\ntype Comparator func(a, b interface{}) bool\n// 堆元素类型\ntype Elements struct {\n\tes   []interface{}\n\tcmp Comparator\n}\n// 堆类型\ntype Heap struct {\n\telements *Elements\n}\n\n// 创建堆\nfunc NewHeap(cmp Comparator) *Heap {\n\treturn &Heap{\n\t\telements: &Elements{\n\t\t\tes: make([]interface{}, 0),\n\t\t\tcmp: cmp,\n\t\t},\n\t}\n}\n\n// 堆元素实现了container/heap接口\nfunc (e Elements) Len() int { return len(e.es) }\nfunc (e Elements) Less(i, j int) bool { return e.cmp(e.es[i], e.es[j]) }\nfunc (e Elements) Swap(i, j int)      { e.es[i], e.es[j] = e.es[j], e.es[i] }\n\nfunc (e *Elements) Push(item interface{}) { e.es = append(e.es, item) }\nfunc (e *Elements) Pop() interface{} {\n\tlength := len(e.es)\n\tif length == 0 {\n\t\treturn nil\n\t}\n\ttop := e.es[length - 1]\n\te.es = e.es[:length - 1]\n\treturn top\n}\n\n// 入堆\nfunc (h *Heap) Push(i interface{}) {\n\theap.Push(h.elements, i)\n}\n\n// 堆顶元素出堆\nfunc (h *Heap) Pop() interface{} {\n\treturn heap.Pop(h.elements)\n}\n\n// 查看堆顶元素\nfunc (h Heap) Top() interface{} {\n\tif len(h.elements.es) == 0 {\n\t\treturn nil\n\t}\n\treturn h.elements.es[0]\n}\n\n// 获取堆大小\nfunc (h Heap) Len() int  {\n\treturn h.elements.Len()\n}\n\nfunc CompareInt(a, b interface{}) bool {\n\tif a.(int) > b.(int) {\n\t\treturn true\n\t}\n\treturn false\n}\n```\n### 6.2.2 数组中的第K个最大元素\n[LeetCode No.215](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\n> 问题描述：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n\n**思路**：使用最小堆，首先将前k个元素加入堆作为目前的最大的k个元素，然后遍历剩下的n-k个元素，如果堆顶元素比当前元素小，取出堆顶，将当前元素加入堆。最后堆顶的元素即为第k大的元素。\n**时间复杂度**：O(n*log(n))\n**空间复杂度**：O(k)\n\n`示例代码：`\n```go\nfunc findKthLargest(nums []int, k int) int {\n\theap1:= NewHeap(CompareInt)\n\t// 前k个元素建立大小为k的小顶堆\n\tfor i := 0; i < k; i++ {\n\t\theap1.Push(nums[i])\n\t}\n\t// 遍历剩余的元素更新堆\n\tfor i := k; i < len(nums); i++ {\n\t\ttop := heap1.Top().(int)\n\t\tif top > nums[i] {\n\t\t\theap1.Pop()\n\t\t\theap1.Push(nums[i])\n\t\t}\n\t}\n\treturn heap1.Top().(int)\n}\n```\n","source":"_posts/2023/03-19-数据结构-5-栈-队列-堆.md","raw":"---\ntitle: '数据结构(5): 栈|队列|堆'\ndate: 2023-03-19 21:39:14\ncategories:\n- [数据结构]\ntags:\n- 栈\n- 队列\n- 堆\n- leetcode\n---\n\n## 6.1 栈\n### 6.1.1用两个栈实现一个队列\n[LeetCode No.232](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n> 题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：\n\n**思路：** 两个栈一个栈做队头（出元素），另一个栈做队尾（入元素）\n- 每次push只需要push到尾栈\n- pop时如果头栈为空则将尾栈全部“倒入”头栈，如果头栈不为空取出栈顶元素返回，否则返回失败（此时队列为空）。\n\n`示例代码：`\n```go\ntype MyQueue struct {\n\tstack_head []int\n\tstack_tail []int\n}\n\n\n/** Initialize your data structure here. */\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tstack_head: make([]int, 0),\n\t\tstack_tail: make([]int, 0),\n\t}\n}\n\n\n/** Push element x to the back of queue. */\nfunc (this *MyQueue) Push(x int)  {\n\tthis.stack_tail = append(this.stack_tail, x)\n}\n\nfunc(this *MyQueue) tail2head()  {\n\tfor i := len(this.stack_tail) - 1; i >= 0; i-- {\n\t\tthis.stack_head = append(this.stack_head, this.stack_tail[i])\n\t\tthis.stack_tail = this.stack_tail[:len(this.stack_tail) - 1]\n\t}\n}\n\n/** Removes the element from in front of queue and returns that element. */\nfunc (this *MyQueue) Pop() int {\n\tif len(this.stack_head) == 0 {\n\t\tthis.tail2head()\n\t}\n\tif len(this.stack_head) > 0 {\n\t\tr := this.stack_head[len(this.stack_head) - 1]\n\t\tthis.stack_head = this.stack_head[:len(this.stack_head) - 1]\n\t\treturn r\n\t}\n\treturn -1\n}\n\n\n/** Get the front element. */\nfunc (this *MyQueue) Peek() int {\n\tif len(this.stack_head) == 0 {\n\t\tthis.tail2head()\n\t}\n\tif len(this.stack_head) > 0 {\n\t\treturn this.stack_head[len(this.stack_head) - 1]\n\t}\n\treturn -1\n}\n\n\n/** Returns whether the queue is empty. */\nfunc (this *MyQueue) Empty() bool {\n\treturn len(this.stack_head) == 0 && len(this.stack_tail) == 0\n}\n```\n\n### 6.1.2 逆波兰表达式求值\n[LeetCode No.150](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)\n> 问题描述：根据[ 逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437)，求表达式的值。\n有效的运算符包括 `+`, `-`, `*`, `/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n输入: [\"2\", \"1\", \"+\", \"3\", \"*\"]\n输出: 9\n解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n\n**思路**：借助一个栈，如果是数值就入栈，如果是运算符就从栈顶取出两个元素计算，然后将结果入栈，最后栈中只剩一个元素就是结果。\n\n`示例代码：`\n```go\nfunc operate(x, y int, op string) int {\n\tswitch op {\n\tcase \"+\": return x + y\n\tcase \"-\": return x - y\n\tcase \"*\": return x * y\n\tcase \"/\": return x / y\n\tdefault:\n\t\treturn 0\n\t}\n}\n\nfunc evalRPN(tokens []string) int {\n\tstack := []int{}\n\tfor i := 0; i < len(tokens); i++ {\n\t\tswitch tokens[i] {\n\t\tcase \"+\", \"-\", \"*\", \"/\":\n\t\t\tcur := operate(stack[len(stack) - 2], stack[len(stack) - 1], tokens[i])\n\t\t\tstack = stack[:len(stack) - 1]\n\t\t\tstack[len(stack) - 1] = cur\n\t\tdefault:\n\t\t\tnum, _ := strconv.Atoi(tokens[i])\n\t\t\tstack = append(stack, num)\n\t\t}\n\t}\n\treturn stack[0]\n}\n```\n\n### 6.1.3 中缀表达式生成逆波兰表达式\n- 借助一个符号栈和结果队列，具体过程见代码注释\n\n`示例代码：`\n```go\nfunc is_operation(b byte) bool {\n\treturn b == '+' || b == '-' || b == '*' || b == '/'\n}\n\nfunc compare_priority(a, b byte) int {\n\tif (a == '+' || a == '-') && (b == '*' || b == '/') {\n\t\treturn -1\n\t} else if (b == '+' || b == '-') && (a == '*' || a == '/') {\n\t\treturn 1\n\t} else {\n\t\treturn 0\n\t}\n}\n\nfunc toRPN(s string) []string {\n\t// 运算符栈\n\tops_stack := []byte{}\n\t// 结果队列\n\tres_queue := []string{}\n\tn := len(s)\n\tfor i := 0; i < n; i++ {\n\t\tif s[i] == '(' {\n\t\t\t// 遇到左括号直接入栈\n\t\t\tops_stack = append(ops_stack, s[i])\n\t\t} else if s[i] == ')' {\n\t\t\t// 遇到右括号，则将栈中的运算符依次弹出加入到结果队列，直到碰到左括号，然后将这对括号丢弃\n\t\t\tfor ops_stack[len(ops_stack) - 1] != '(' {\n\t\t\t\tres_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1]))\n\t\t\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t\t\t}\n\t\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t\t} else if is_operation(s[i]) {\n\t\t\t// 遇到运算符，当前运算符的优先级小于等于栈顶运算符的优先级，则依次将栈顶弹出加入到结果队列\n\t\t\tfor len(ops_stack) > 0 && is_operation(ops_stack[len(ops_stack) - 1]) &&\n\t\t\t\tcompare_priority(s[i], ops_stack[len(ops_stack) - 1]) <= 0 {\n\t\t\t\tres_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1]))\n\t\t\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t\t\t}\n\t\t\tops_stack = append(ops_stack, s[i])\n\t\t} else if s[i] == ' ' {\n\t\t\t// 跳过空字符\n\t\t\tcontinue\n\t\t} else {\n\t\t\t// 遇到数字加入到结果队列\n\t\t\tnum := 0\n\t\t\tfor ; i < n && s[i] >= '0' && s[i] <= '9'; i++ {\n\t\t\t\tnum = num * 10 + int(s[i] - '0')\n\t\t\t}\n\t\t\ti--\n\t\t\tres_queue = append(res_queue, strconv.Itoa(num))\n\t\t}\n\t}\n\t// 运算符栈中剩余的元素弹出添加到结果队列\n\tfor len(ops_stack) > 0 {\n\t\tres_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1]))\n\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t}\n\treturn res_queue\n}\n```\n\n## 6.2 堆\n**定义：**最大堆的堆顶为最大元素，最小堆同理\n### 6.2.1 Golang实现堆类型\n因为go本身没有实现堆类型，只提供了接口，使用时必须实现堆接口才能使用对应的堆方法，所以自己用golang的container/heap接口实现一个通用的堆类型，创建堆需要一个比较函数作为参数\n`实现代码：`\n```go\n// 比较函数类型\ntype Comparator func(a, b interface{}) bool\n// 堆元素类型\ntype Elements struct {\n\tes   []interface{}\n\tcmp Comparator\n}\n// 堆类型\ntype Heap struct {\n\telements *Elements\n}\n\n// 创建堆\nfunc NewHeap(cmp Comparator) *Heap {\n\treturn &Heap{\n\t\telements: &Elements{\n\t\t\tes: make([]interface{}, 0),\n\t\t\tcmp: cmp,\n\t\t},\n\t}\n}\n\n// 堆元素实现了container/heap接口\nfunc (e Elements) Len() int { return len(e.es) }\nfunc (e Elements) Less(i, j int) bool { return e.cmp(e.es[i], e.es[j]) }\nfunc (e Elements) Swap(i, j int)      { e.es[i], e.es[j] = e.es[j], e.es[i] }\n\nfunc (e *Elements) Push(item interface{}) { e.es = append(e.es, item) }\nfunc (e *Elements) Pop() interface{} {\n\tlength := len(e.es)\n\tif length == 0 {\n\t\treturn nil\n\t}\n\ttop := e.es[length - 1]\n\te.es = e.es[:length - 1]\n\treturn top\n}\n\n// 入堆\nfunc (h *Heap) Push(i interface{}) {\n\theap.Push(h.elements, i)\n}\n\n// 堆顶元素出堆\nfunc (h *Heap) Pop() interface{} {\n\treturn heap.Pop(h.elements)\n}\n\n// 查看堆顶元素\nfunc (h Heap) Top() interface{} {\n\tif len(h.elements.es) == 0 {\n\t\treturn nil\n\t}\n\treturn h.elements.es[0]\n}\n\n// 获取堆大小\nfunc (h Heap) Len() int  {\n\treturn h.elements.Len()\n}\n\nfunc CompareInt(a, b interface{}) bool {\n\tif a.(int) > b.(int) {\n\t\treturn true\n\t}\n\treturn false\n}\n```\n### 6.2.2 数组中的第K个最大元素\n[LeetCode No.215](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\n> 问题描述：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n\n**思路**：使用最小堆，首先将前k个元素加入堆作为目前的最大的k个元素，然后遍历剩下的n-k个元素，如果堆顶元素比当前元素小，取出堆顶，将当前元素加入堆。最后堆顶的元素即为第k大的元素。\n**时间复杂度**：O(n*log(n))\n**空间复杂度**：O(k)\n\n`示例代码：`\n```go\nfunc findKthLargest(nums []int, k int) int {\n\theap1:= NewHeap(CompareInt)\n\t// 前k个元素建立大小为k的小顶堆\n\tfor i := 0; i < k; i++ {\n\t\theap1.Push(nums[i])\n\t}\n\t// 遍历剩余的元素更新堆\n\tfor i := k; i < len(nums); i++ {\n\t\ttop := heap1.Top().(int)\n\t\tif top > nums[i] {\n\t\t\theap1.Pop()\n\t\t\theap1.Push(nums[i])\n\t\t}\n\t}\n\treturn heap1.Top().(int)\n}\n```\n","slug":"数据结构-5-栈-队列-堆","published":1,"updated":"2023-03-19T14:11:42.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj17a000ehtfi4p2500xf","content":"<h2 id=\"6-1-栈\"><a href=\"#6-1-栈\" class=\"headerlink\" title=\"6.1 栈\"></a>6.1 栈</h2><h3 id=\"6-1-1用两个栈实现一个队列\"><a href=\"#6-1-1用两个栈实现一个队列\" class=\"headerlink\" title=\"6.1.1用两个栈实现一个队列\"></a>6.1.1用两个栈实现一个队列</h3><p><a href=\"https://leetcode-cn.com/problems/implement-queue-using-stacks/\">LeetCode No.232</a></p>\n<blockquote>\n<p>题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：</p>\n</blockquote>\n<p><strong>思路：</strong> 两个栈一个栈做队头（出元素），另一个栈做队尾（入元素）</p>\n<ul>\n<li>每次push只需要push到尾栈</li>\n<li>pop时如果头栈为空则将尾栈全部“倒入”头栈，如果头栈不为空取出栈顶元素返回，否则返回失败（此时队列为空）。</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tstack_head []<span class=\"type\">int</span></span><br><span class=\"line\">\tstack_tail []<span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">()</span></span> MyQueue &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MyQueue&#123;</span><br><span class=\"line\">\t\tstack_head: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">\t\tstack_tail: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Push element x to the back of queue. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Push(x <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">\tthis.stack_tail = <span class=\"built_in\">append</span>(this.stack_tail, x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(this *MyQueue)</span></span> tail2head()  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"built_in\">len</span>(this.stack_tail) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\tthis.stack_head = <span class=\"built_in\">append</span>(this.stack_head, this.stack_tail[i])</span><br><span class=\"line\">\t\tthis.stack_tail = this.stack_tail[:<span class=\"built_in\">len</span>(this.stack_tail) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Pop() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthis.tail2head()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tr := this.stack_head[<span class=\"built_in\">len</span>(this.stack_head) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\tthis.stack_head = this.stack_head[:<span class=\"built_in\">len</span>(this.stack_head) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Get the front element. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Peek() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthis.tail2head()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> this.stack_head[<span class=\"built_in\">len</span>(this.stack_head) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Returns whether the queue is empty. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Empty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(this.stack_head) == <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">len</span>(this.stack_tail) == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-1-2-逆波兰表达式求值\"><a href=\"#6-1-2-逆波兰表达式求值\" class=\"headerlink\" title=\"6.1.2 逆波兰表达式求值\"></a>6.1.2 逆波兰表达式求值</h3><p><a href=\"https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/\">LeetCode No.150</a></p>\n<blockquote>\n<p>问题描述：根据<a href=\"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437\"> 逆波兰表示法</a>，求表达式的值。<br>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>输入: [“2”, “1”, “+”, “3”, “*”]<br>输出: 9<br>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</p>\n</blockquote>\n<p><strong>思路</strong>：借助一个栈，如果是数值就入栈，如果是运算符就从栈顶取出两个元素计算，然后将结果入栈，最后栈中只剩一个元素就是结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">operate</span><span class=\"params\">(x, y <span class=\"type\">int</span>, op <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> op &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>: <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>: <span class=\"keyword\">return</span> x - y</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>: <span class=\"keyword\">return</span> x * y</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>: <span class=\"keyword\">return</span> x / y</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">evalRPN</span><span class=\"params\">(tokens []<span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tstack := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(tokens); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> tokens[i] &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>, <span class=\"string\">&quot;-&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">\t\t\tcur := operate(stack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">2</span>], stack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>], tokens[i])</span><br><span class=\"line\">\t\t\tstack = stack[:<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\tstack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>] = cur</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tnum, _ := strconv.Atoi(tokens[i])</span><br><span class=\"line\">\t\t\tstack = <span class=\"built_in\">append</span>(stack, num)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stack[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-1-3-中缀表达式生成逆波兰表达式\"><a href=\"#6-1-3-中缀表达式生成逆波兰表达式\" class=\"headerlink\" title=\"6.1.3 中缀表达式生成逆波兰表达式\"></a>6.1.3 中缀表达式生成逆波兰表达式</h3><ul>\n<li>借助一个符号栈和结果队列，具体过程见代码注释</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">is_operation</span><span class=\"params\">(b <span class=\"type\">byte</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b == <span class=\"string\">&#x27;+&#x27;</span> || b == <span class=\"string\">&#x27;-&#x27;</span> || b == <span class=\"string\">&#x27;*&#x27;</span> || b == <span class=\"string\">&#x27;/&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compare_priority</span><span class=\"params\">(a, b <span class=\"type\">byte</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a == <span class=\"string\">&#x27;+&#x27;</span> || a == <span class=\"string\">&#x27;-&#x27;</span>) &amp;&amp; (b == <span class=\"string\">&#x27;*&#x27;</span> || b == <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (b == <span class=\"string\">&#x27;+&#x27;</span> || b == <span class=\"string\">&#x27;-&#x27;</span>) &amp;&amp; (a == <span class=\"string\">&#x27;*&#x27;</span> || a == <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toRPN</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 运算符栈</span></span><br><span class=\"line\">\tops_stack := []<span class=\"type\">byte</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 结果队列</span></span><br><span class=\"line\">\tres_queue := []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s[i] == <span class=\"string\">&#x27;(&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到左括号直接入栈</span></span><br><span class=\"line\">\t\t\tops_stack = <span class=\"built_in\">append</span>(ops_stack, s[i])</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> s[i] == <span class=\"string\">&#x27;)&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到右括号，则将栈中的运算符依次弹出加入到结果队列，直到碰到左括号，然后将这对括号丢弃</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;(&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, <span class=\"type\">string</span>(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]))</span><br><span class=\"line\">\t\t\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> is_operation(s[i]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到运算符，当前运算符的优先级小于等于栈顶运算符的优先级，则依次将栈顶弹出加入到结果队列</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(ops_stack) &gt; <span class=\"number\">0</span> &amp;&amp; is_operation(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]) &amp;&amp;</span><br><span class=\"line\">\t\t\t\tcompare_priority(s[i], ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]) &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, <span class=\"type\">string</span>(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]))</span><br><span class=\"line\">\t\t\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tops_stack = <span class=\"built_in\">append</span>(ops_stack, s[i])</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> s[i] == <span class=\"string\">&#x27; &#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 跳过空字符</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到数字加入到结果队列</span></span><br><span class=\"line\">\t\t\tnum := <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ; i &lt; n &amp;&amp; s[i] &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class=\"string\">&#x27;9&#x27;</span>; i++ &#123;</span><br><span class=\"line\">\t\t\t\tnum = num * <span class=\"number\">10</span> + <span class=\"type\">int</span>(s[i] - <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\ti--</span><br><span class=\"line\">\t\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, strconv.Itoa(num))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 运算符栈中剩余的元素弹出添加到结果队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(ops_stack) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, <span class=\"type\">string</span>(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]))</span><br><span class=\"line\">\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res_queue</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-2-堆\"><a href=\"#6-2-堆\" class=\"headerlink\" title=\"6.2 堆\"></a>6.2 堆</h2><p><strong>定义：</strong>最大堆的堆顶为最大元素，最小堆同理</p>\n<h3 id=\"6-2-1-Golang实现堆类型\"><a href=\"#6-2-1-Golang实现堆类型\" class=\"headerlink\" title=\"6.2.1 Golang实现堆类型\"></a>6.2.1 Golang实现堆类型</h3><p>因为go本身没有实现堆类型，只提供了接口，使用时必须实现堆接口才能使用对应的堆方法，所以自己用golang的container&#x2F;heap接口实现一个通用的堆类型，创建堆需要一个比较函数作为参数<br><code>实现代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较函数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Comparator <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(a, b <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"comment\">// 堆元素类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Elements <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tes   []<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\tcmp Comparator</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 堆类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Heap <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\telements *Elements</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewHeap</span><span class=\"params\">(cmp Comparator)</span></span> *Heap &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Heap&#123;</span><br><span class=\"line\">\t\telements: &amp;Elements&#123;</span><br><span class=\"line\">\t\t\tes: <span class=\"built_in\">make</span>([]<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"number\">0</span>),</span><br><span class=\"line\">\t\t\tcmp: cmp,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆元素实现了container/heap接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Elements)</span></span> Len() <span class=\"type\">int</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(e.es) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Elements)</span></span> Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123; <span class=\"keyword\">return</span> e.cmp(e.es[i], e.es[j]) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Elements)</span></span> Swap(i, j <span class=\"type\">int</span>)      &#123; e.es[i], e.es[j] = e.es[j], e.es[i] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Elements)</span></span> Push(item <span class=\"keyword\">interface</span>&#123;&#125;) &#123; e.es = <span class=\"built_in\">append</span>(e.es, item) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Elements)</span></span> Pop() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\tlength := <span class=\"built_in\">len</span>(e.es)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> length == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttop := e.es[length - <span class=\"number\">1</span>]</span><br><span class=\"line\">\te.es = e.es[:length - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> top</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> Push(i <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\theap.Push(h.elements, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆顶元素出堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> Pop() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> heap.Pop(h.elements)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看堆顶元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h Heap)</span></span> Top() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(h.elements.es) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h.elements.es[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取堆大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h Heap)</span></span> Len() <span class=\"type\">int</span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h.elements.Len()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CompareInt</span><span class=\"params\">(a, b <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a.(<span class=\"type\">int</span>) &gt; b.(<span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-2-数组中的第K个最大元素\"><a href=\"#6-2-2-数组中的第K个最大元素\" class=\"headerlink\" title=\"6.2.2 数组中的第K个最大元素\"></a>6.2.2 数组中的第K个最大元素</h3><p><a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\">LeetCode No.215</a></p>\n<blockquote>\n<p>问题描述：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素<br>输入: [3,2,1,5,6,4] 和 k &#x3D; 2<br>输出: 5</p>\n</blockquote>\n<p><strong>思路</strong>：使用最小堆，首先将前k个元素加入堆作为目前的最大的k个元素，然后遍历剩下的n-k个元素，如果堆顶元素比当前元素小，取出堆顶，将当前元素加入堆。最后堆顶的元素即为第k大的元素。<br><strong>时间复杂度</strong>：O(n*log(n))<br><strong>空间复杂度</strong>：O(k)</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(nums []<span class=\"type\">int</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\theap1:= NewHeap(CompareInt)</span><br><span class=\"line\">\t<span class=\"comment\">// 前k个元素建立大小为k的小顶堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; k; i++ &#123;</span><br><span class=\"line\">\t\theap1.Push(nums[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 遍历剩余的元素更新堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := k; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">\t\ttop := heap1.Top().(<span class=\"type\">int</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> top &gt; nums[i] &#123;</span><br><span class=\"line\">\t\t\theap1.Pop()</span><br><span class=\"line\">\t\t\theap1.Push(nums[i])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> heap1.Top().(<span class=\"type\">int</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"6-1-栈\"><a href=\"#6-1-栈\" class=\"headerlink\" title=\"6.1 栈\"></a>6.1 栈</h2><h3 id=\"6-1-1用两个栈实现一个队列\"><a href=\"#6-1-1用两个栈实现一个队列\" class=\"headerlink\" title=\"6.1.1用两个栈实现一个队列\"></a>6.1.1用两个栈实现一个队列</h3><p><a href=\"https://leetcode-cn.com/problems/implement-queue-using-stacks/\">LeetCode No.232</a></p>\n<blockquote>\n<p>题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：</p>\n</blockquote>\n<p><strong>思路：</strong> 两个栈一个栈做队头（出元素），另一个栈做队尾（入元素）</p>\n<ul>\n<li>每次push只需要push到尾栈</li>\n<li>pop时如果头栈为空则将尾栈全部“倒入”头栈，如果头栈不为空取出栈顶元素返回，否则返回失败（此时队列为空）。</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tstack_head []<span class=\"type\">int</span></span><br><span class=\"line\">\tstack_tail []<span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">()</span></span> MyQueue &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MyQueue&#123;</span><br><span class=\"line\">\t\tstack_head: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">\t\tstack_tail: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Push element x to the back of queue. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Push(x <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">\tthis.stack_tail = <span class=\"built_in\">append</span>(this.stack_tail, x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(this *MyQueue)</span></span> tail2head()  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"built_in\">len</span>(this.stack_tail) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\tthis.stack_head = <span class=\"built_in\">append</span>(this.stack_head, this.stack_tail[i])</span><br><span class=\"line\">\t\tthis.stack_tail = this.stack_tail[:<span class=\"built_in\">len</span>(this.stack_tail) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Pop() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthis.tail2head()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tr := this.stack_head[<span class=\"built_in\">len</span>(this.stack_head) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\tthis.stack_head = this.stack_head[:<span class=\"built_in\">len</span>(this.stack_head) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Get the front element. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Peek() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthis.tail2head()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> this.stack_head[<span class=\"built_in\">len</span>(this.stack_head) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Returns whether the queue is empty. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Empty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(this.stack_head) == <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">len</span>(this.stack_tail) == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-1-2-逆波兰表达式求值\"><a href=\"#6-1-2-逆波兰表达式求值\" class=\"headerlink\" title=\"6.1.2 逆波兰表达式求值\"></a>6.1.2 逆波兰表达式求值</h3><p><a href=\"https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/\">LeetCode No.150</a></p>\n<blockquote>\n<p>问题描述：根据<a href=\"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437\"> 逆波兰表示法</a>，求表达式的值。<br>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>输入: [“2”, “1”, “+”, “3”, “*”]<br>输出: 9<br>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</p>\n</blockquote>\n<p><strong>思路</strong>：借助一个栈，如果是数值就入栈，如果是运算符就从栈顶取出两个元素计算，然后将结果入栈，最后栈中只剩一个元素就是结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">operate</span><span class=\"params\">(x, y <span class=\"type\">int</span>, op <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> op &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>: <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>: <span class=\"keyword\">return</span> x - y</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>: <span class=\"keyword\">return</span> x * y</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>: <span class=\"keyword\">return</span> x / y</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">evalRPN</span><span class=\"params\">(tokens []<span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tstack := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(tokens); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> tokens[i] &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>, <span class=\"string\">&quot;-&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">\t\t\tcur := operate(stack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">2</span>], stack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>], tokens[i])</span><br><span class=\"line\">\t\t\tstack = stack[:<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\tstack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>] = cur</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tnum, _ := strconv.Atoi(tokens[i])</span><br><span class=\"line\">\t\t\tstack = <span class=\"built_in\">append</span>(stack, num)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stack[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-1-3-中缀表达式生成逆波兰表达式\"><a href=\"#6-1-3-中缀表达式生成逆波兰表达式\" class=\"headerlink\" title=\"6.1.3 中缀表达式生成逆波兰表达式\"></a>6.1.3 中缀表达式生成逆波兰表达式</h3><ul>\n<li>借助一个符号栈和结果队列，具体过程见代码注释</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">is_operation</span><span class=\"params\">(b <span class=\"type\">byte</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b == <span class=\"string\">&#x27;+&#x27;</span> || b == <span class=\"string\">&#x27;-&#x27;</span> || b == <span class=\"string\">&#x27;*&#x27;</span> || b == <span class=\"string\">&#x27;/&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compare_priority</span><span class=\"params\">(a, b <span class=\"type\">byte</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a == <span class=\"string\">&#x27;+&#x27;</span> || a == <span class=\"string\">&#x27;-&#x27;</span>) &amp;&amp; (b == <span class=\"string\">&#x27;*&#x27;</span> || b == <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (b == <span class=\"string\">&#x27;+&#x27;</span> || b == <span class=\"string\">&#x27;-&#x27;</span>) &amp;&amp; (a == <span class=\"string\">&#x27;*&#x27;</span> || a == <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toRPN</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 运算符栈</span></span><br><span class=\"line\">\tops_stack := []<span class=\"type\">byte</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 结果队列</span></span><br><span class=\"line\">\tres_queue := []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s[i] == <span class=\"string\">&#x27;(&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到左括号直接入栈</span></span><br><span class=\"line\">\t\t\tops_stack = <span class=\"built_in\">append</span>(ops_stack, s[i])</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> s[i] == <span class=\"string\">&#x27;)&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到右括号，则将栈中的运算符依次弹出加入到结果队列，直到碰到左括号，然后将这对括号丢弃</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;(&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, <span class=\"type\">string</span>(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]))</span><br><span class=\"line\">\t\t\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> is_operation(s[i]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到运算符，当前运算符的优先级小于等于栈顶运算符的优先级，则依次将栈顶弹出加入到结果队列</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(ops_stack) &gt; <span class=\"number\">0</span> &amp;&amp; is_operation(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]) &amp;&amp;</span><br><span class=\"line\">\t\t\t\tcompare_priority(s[i], ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]) &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, <span class=\"type\">string</span>(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]))</span><br><span class=\"line\">\t\t\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tops_stack = <span class=\"built_in\">append</span>(ops_stack, s[i])</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> s[i] == <span class=\"string\">&#x27; &#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 跳过空字符</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到数字加入到结果队列</span></span><br><span class=\"line\">\t\t\tnum := <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ; i &lt; n &amp;&amp; s[i] &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class=\"string\">&#x27;9&#x27;</span>; i++ &#123;</span><br><span class=\"line\">\t\t\t\tnum = num * <span class=\"number\">10</span> + <span class=\"type\">int</span>(s[i] - <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\ti--</span><br><span class=\"line\">\t\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, strconv.Itoa(num))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 运算符栈中剩余的元素弹出添加到结果队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(ops_stack) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, <span class=\"type\">string</span>(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]))</span><br><span class=\"line\">\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res_queue</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-2-堆\"><a href=\"#6-2-堆\" class=\"headerlink\" title=\"6.2 堆\"></a>6.2 堆</h2><p><strong>定义：</strong>最大堆的堆顶为最大元素，最小堆同理</p>\n<h3 id=\"6-2-1-Golang实现堆类型\"><a href=\"#6-2-1-Golang实现堆类型\" class=\"headerlink\" title=\"6.2.1 Golang实现堆类型\"></a>6.2.1 Golang实现堆类型</h3><p>因为go本身没有实现堆类型，只提供了接口，使用时必须实现堆接口才能使用对应的堆方法，所以自己用golang的container&#x2F;heap接口实现一个通用的堆类型，创建堆需要一个比较函数作为参数<br><code>实现代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较函数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Comparator <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(a, b <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"comment\">// 堆元素类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Elements <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tes   []<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\tcmp Comparator</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 堆类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Heap <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\telements *Elements</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewHeap</span><span class=\"params\">(cmp Comparator)</span></span> *Heap &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Heap&#123;</span><br><span class=\"line\">\t\telements: &amp;Elements&#123;</span><br><span class=\"line\">\t\t\tes: <span class=\"built_in\">make</span>([]<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"number\">0</span>),</span><br><span class=\"line\">\t\t\tcmp: cmp,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆元素实现了container/heap接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Elements)</span></span> Len() <span class=\"type\">int</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(e.es) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Elements)</span></span> Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123; <span class=\"keyword\">return</span> e.cmp(e.es[i], e.es[j]) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Elements)</span></span> Swap(i, j <span class=\"type\">int</span>)      &#123; e.es[i], e.es[j] = e.es[j], e.es[i] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Elements)</span></span> Push(item <span class=\"keyword\">interface</span>&#123;&#125;) &#123; e.es = <span class=\"built_in\">append</span>(e.es, item) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Elements)</span></span> Pop() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\tlength := <span class=\"built_in\">len</span>(e.es)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> length == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttop := e.es[length - <span class=\"number\">1</span>]</span><br><span class=\"line\">\te.es = e.es[:length - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> top</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> Push(i <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\theap.Push(h.elements, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆顶元素出堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> Pop() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> heap.Pop(h.elements)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看堆顶元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h Heap)</span></span> Top() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(h.elements.es) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h.elements.es[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取堆大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h Heap)</span></span> Len() <span class=\"type\">int</span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h.elements.Len()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CompareInt</span><span class=\"params\">(a, b <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a.(<span class=\"type\">int</span>) &gt; b.(<span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-2-数组中的第K个最大元素\"><a href=\"#6-2-2-数组中的第K个最大元素\" class=\"headerlink\" title=\"6.2.2 数组中的第K个最大元素\"></a>6.2.2 数组中的第K个最大元素</h3><p><a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\">LeetCode No.215</a></p>\n<blockquote>\n<p>问题描述：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素<br>输入: [3,2,1,5,6,4] 和 k &#x3D; 2<br>输出: 5</p>\n</blockquote>\n<p><strong>思路</strong>：使用最小堆，首先将前k个元素加入堆作为目前的最大的k个元素，然后遍历剩下的n-k个元素，如果堆顶元素比当前元素小，取出堆顶，将当前元素加入堆。最后堆顶的元素即为第k大的元素。<br><strong>时间复杂度</strong>：O(n*log(n))<br><strong>空间复杂度</strong>：O(k)</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(nums []<span class=\"type\">int</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\theap1:= NewHeap(CompareInt)</span><br><span class=\"line\">\t<span class=\"comment\">// 前k个元素建立大小为k的小顶堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; k; i++ &#123;</span><br><span class=\"line\">\t\theap1.Push(nums[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 遍历剩余的元素更新堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := k; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">\t\ttop := heap1.Top().(<span class=\"type\">int</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> top &gt; nums[i] &#123;</span><br><span class=\"line\">\t\t\theap1.Pop()</span><br><span class=\"line\">\t\t\theap1.Push(nums[i])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> heap1.Top().(<span class=\"type\">int</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(1): 双指针","date":"2023-03-19T13:41:00.000Z","_content":"\n双指针通常用在有序数组，链表的数据结构上，根据题目条件移动对应的指针。比如判断子串、链表是否有环的问题。\n\n## 1.1 最长子串\n[LeetCode No.524](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)\n\n> 题目描述：给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串\n输入:\ns = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]\n输出: \n\"apple\"\n\n**思路：本题主要思路是要将删除s中某些字符后和target匹配转化为判断是target是否为s的子串**\n**判断是否为子串：**使用双指针，如果当前字符相等，两个指针同时+1，否则只有母字符串的指针+1，最后判断目标字符传的指针是否等于其长度即可。\n[参考原文](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md)\n\n`示例代码：`\n```go\nfunc is_substr(s, target string) bool {\n\tj := 0\n\tfor i := 0; i < len(s) && j < len(target); i++ {\n\t\tif s[i] == target[j] {\n\t\t\tj++\n\t\t}\n\t}\n\treturn j == len(target)\n}\n\nfunc findLongestWord(s string, dictionary []string) string {\n\tvar longest string\n\tfor _, cur := range dictionary {\n\t\t// 如果当前字符串是s的子串，当当前字符串长度大于目前结果 或 长度相等但是当前串字典序排在前面时更新目前结果\n\t\tif is_substr(s, cur) && (len(cur) > len(longest) || len(cur) == len(longest) && cur < longest) {\n\t\t\tlongest = cur\n\t\t}\n\t}\n\treturn longest\n}\n```\n\n## 1.2 两数之和\n[LeetCode No.167](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)\n\n> 题目描述：给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。\n输入：numbers = [2,7,11,15], target = 9\n输出：[1,2]\n\n**思路：**因为输入数组有序，那么可以用左右两个指针，初始位于两端，判断当前两数和如果大于target，那么right指针减一，如果小于target，left加一，如果等于就返回。\n\n`示例代码:`\n```go\nfunc twoSum(numbers []int, target int) []int {\n    for left, right := 0, len(numbers) - 1; left < right; {\n        cur := numbers[left] + numbers[right]\n        if cur == target {\n            return []int{left+1, right+1}\n        }\n        if cur < target {\n            left++\n        } else {\n            right--\n        }\n    }\n    return []int{}\n}\n```\n\n## 1.3 判断链表是否存在环\n[LeetCode No.141](https://leetcode-cn.com/problems/linked-list-cycle/description/)\n\n> 题目描述：给定一个链表，判断链表中是否有环。\n\n**思路：**经典解法使用快慢指针，如果存在环两个指针一定会相遇，注意指针空的判断，避免出现野指针。\n\n`示例代码：`\n```go\nfunc hasCycle(head *ListNode) bool {\n\tif head == nil || head.Next == nil {\n\t\treturn false\n\t}\n\tfaster, slower := head.Next.Next, head.Next\n\tfor faster != nil && faster.Next != nil && slower != nil {\n\t\tif faster == slower {\n\t\t\treturn true\n\t\t}\n\t\tfaster = faster.Next.Next\n\t\tslower = slower.Next\n\t}\n\treturn false\n}\n```\n\n## 1.4 接雨水\n[LeetCode No.42](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n> 题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n**思路：**当前柱子能接的雨水数为其左右最高的柱子的较小值减当前柱子的高度\n\n方法1：先求出每个柱子i左边的最大高度left_max[i]，右边最大高度right_max[i]，然后遍历一次计算。时间复杂度T = O(3n)\n\n`示例代码：`\n```go\nfunc trap(height []int) int {\n    res, n := 0, len(height)\n    if n == 0 {\n        return res\n    }\n    left_max, right_max := make([]int, n), make([]int, n)\n    left_max[0], right_max[n - 1] = height[0], height[n - 1]\n    for i := 1; i < n; i++ {\n        left_max[i] = max(left_max[i - 1], height[i])\n    }\n    for i := n - 2; i >= 0; i-- {\n        right_max[i] = max(right_max[i + 1], height[i])\n    }\n    for i := 0; i < n; i++ {\n        res += min(right_max[i], left_max[i]) - height[i]\n    }\n    return res\n}\n```\n\n方法2：只需遍历一次的双指针解法，两个指针最终在最高点相遇。\n\n`示例代码：`\n```go\nfunc trap(height []int) int {\n    res, left, right := 0, 0, len(height) - 1\n    if right < 0 {\n        return res\n    }\n    left_max, right_max := 0, 0\n    for left < right {\n        if height[left] > height[right] {\n            right_max = max(right_max, height[right])\n            res += right_max - height[right]\n            right--\n        } else {\n            left_max = max(left_max, height[left])\n            res += left_max - height[left]\n            left++\n        }\n    }\n    return res\n}\n```\n","source":"_posts/2023/03-19-算法-1-双指针.md","raw":"---\ntitle: '算法(1): 双指针'\ndate: 2023-03-19 21:41:00\ncategories:\n- [算法]\ntags:\n- leetcode\n---\n\n双指针通常用在有序数组，链表的数据结构上，根据题目条件移动对应的指针。比如判断子串、链表是否有环的问题。\n\n## 1.1 最长子串\n[LeetCode No.524](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)\n\n> 题目描述：给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串\n输入:\ns = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]\n输出: \n\"apple\"\n\n**思路：本题主要思路是要将删除s中某些字符后和target匹配转化为判断是target是否为s的子串**\n**判断是否为子串：**使用双指针，如果当前字符相等，两个指针同时+1，否则只有母字符串的指针+1，最后判断目标字符传的指针是否等于其长度即可。\n[参考原文](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md)\n\n`示例代码：`\n```go\nfunc is_substr(s, target string) bool {\n\tj := 0\n\tfor i := 0; i < len(s) && j < len(target); i++ {\n\t\tif s[i] == target[j] {\n\t\t\tj++\n\t\t}\n\t}\n\treturn j == len(target)\n}\n\nfunc findLongestWord(s string, dictionary []string) string {\n\tvar longest string\n\tfor _, cur := range dictionary {\n\t\t// 如果当前字符串是s的子串，当当前字符串长度大于目前结果 或 长度相等但是当前串字典序排在前面时更新目前结果\n\t\tif is_substr(s, cur) && (len(cur) > len(longest) || len(cur) == len(longest) && cur < longest) {\n\t\t\tlongest = cur\n\t\t}\n\t}\n\treturn longest\n}\n```\n\n## 1.2 两数之和\n[LeetCode No.167](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)\n\n> 题目描述：给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。\n输入：numbers = [2,7,11,15], target = 9\n输出：[1,2]\n\n**思路：**因为输入数组有序，那么可以用左右两个指针，初始位于两端，判断当前两数和如果大于target，那么right指针减一，如果小于target，left加一，如果等于就返回。\n\n`示例代码:`\n```go\nfunc twoSum(numbers []int, target int) []int {\n    for left, right := 0, len(numbers) - 1; left < right; {\n        cur := numbers[left] + numbers[right]\n        if cur == target {\n            return []int{left+1, right+1}\n        }\n        if cur < target {\n            left++\n        } else {\n            right--\n        }\n    }\n    return []int{}\n}\n```\n\n## 1.3 判断链表是否存在环\n[LeetCode No.141](https://leetcode-cn.com/problems/linked-list-cycle/description/)\n\n> 题目描述：给定一个链表，判断链表中是否有环。\n\n**思路：**经典解法使用快慢指针，如果存在环两个指针一定会相遇，注意指针空的判断，避免出现野指针。\n\n`示例代码：`\n```go\nfunc hasCycle(head *ListNode) bool {\n\tif head == nil || head.Next == nil {\n\t\treturn false\n\t}\n\tfaster, slower := head.Next.Next, head.Next\n\tfor faster != nil && faster.Next != nil && slower != nil {\n\t\tif faster == slower {\n\t\t\treturn true\n\t\t}\n\t\tfaster = faster.Next.Next\n\t\tslower = slower.Next\n\t}\n\treturn false\n}\n```\n\n## 1.4 接雨水\n[LeetCode No.42](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n> 题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n**思路：**当前柱子能接的雨水数为其左右最高的柱子的较小值减当前柱子的高度\n\n方法1：先求出每个柱子i左边的最大高度left_max[i]，右边最大高度right_max[i]，然后遍历一次计算。时间复杂度T = O(3n)\n\n`示例代码：`\n```go\nfunc trap(height []int) int {\n    res, n := 0, len(height)\n    if n == 0 {\n        return res\n    }\n    left_max, right_max := make([]int, n), make([]int, n)\n    left_max[0], right_max[n - 1] = height[0], height[n - 1]\n    for i := 1; i < n; i++ {\n        left_max[i] = max(left_max[i - 1], height[i])\n    }\n    for i := n - 2; i >= 0; i-- {\n        right_max[i] = max(right_max[i + 1], height[i])\n    }\n    for i := 0; i < n; i++ {\n        res += min(right_max[i], left_max[i]) - height[i]\n    }\n    return res\n}\n```\n\n方法2：只需遍历一次的双指针解法，两个指针最终在最高点相遇。\n\n`示例代码：`\n```go\nfunc trap(height []int) int {\n    res, left, right := 0, 0, len(height) - 1\n    if right < 0 {\n        return res\n    }\n    left_max, right_max := 0, 0\n    for left < right {\n        if height[left] > height[right] {\n            right_max = max(right_max, height[right])\n            res += right_max - height[right]\n            right--\n        } else {\n            left_max = max(left_max, height[left])\n            res += left_max - height[left]\n            left++\n        }\n    }\n    return res\n}\n```\n","slug":"算法-1-双指针","published":1,"updated":"2023-03-19T14:29:50.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj17b000ihtfibvkr75sx","content":"<p>双指针通常用在有序数组，链表的数据结构上，根据题目条件移动对应的指针。比如判断子串、链表是否有环的问题。</p>\n<h2 id=\"1-1-最长子串\"><a href=\"#1-1-最长子串\" class=\"headerlink\" title=\"1.1 最长子串\"></a>1.1 最长子串</h2><p><a href=\"https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/\">LeetCode No.524</a></p>\n<blockquote>\n<p>题目描述：给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串<br>输入:<br>s &#x3D; “abpcplea”, d &#x3D; [“ale”,”apple”,”monkey”,”plea”]<br>输出:<br>“apple”</p>\n</blockquote>\n<p><strong>思路：本题主要思路是要将删除s中某些字符后和target匹配转化为判断是target是否为s的子串</strong><br><strong>判断是否为子串：</strong>使用双指针，如果当前字符相等，两个指针同时+1，否则只有母字符串的指针+1，最后判断目标字符传的指针是否等于其长度即可。<br><a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md\">参考原文</a></p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">is_substr</span><span class=\"params\">(s, target <span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\tj := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s) &amp;&amp; j &lt; <span class=\"built_in\">len</span>(target); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s[i] == target[j] &#123;</span><br><span class=\"line\">\t\t\tj++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> j == <span class=\"built_in\">len</span>(target)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findLongestWord</span><span class=\"params\">(s <span class=\"type\">string</span>, dictionary []<span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> longest <span class=\"type\">string</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, cur := <span class=\"keyword\">range</span> dictionary &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果当前字符串是s的子串，当当前字符串长度大于目前结果 或 长度相等但是当前串字典序排在前面时更新目前结果</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> is_substr(s, cur) &amp;&amp; (<span class=\"built_in\">len</span>(cur) &gt; <span class=\"built_in\">len</span>(longest) || <span class=\"built_in\">len</span>(cur) == <span class=\"built_in\">len</span>(longest) &amp;&amp; cur &lt; longest) &#123;</span><br><span class=\"line\">\t\t\tlongest = cur</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> longest</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-两数之和\"><a href=\"#1-2-两数之和\" class=\"headerlink\" title=\"1.2 两数之和\"></a>1.2 两数之和</h2><p><a href=\"https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\">LeetCode No.167</a></p>\n<blockquote>\n<p>题目描述：给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。<br>输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[1,2]</p>\n</blockquote>\n<p><strong>思路：</strong>因为输入数组有序，那么可以用左右两个指针，初始位于两端，判断当前两数和如果大于target，那么right指针减一，如果小于target，left加一，如果等于就返回。</p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(numbers []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> left, right := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(numbers) - <span class=\"number\">1</span>; left &lt; right; &#123;</span><br><span class=\"line\">        cur := numbers[left] + numbers[right]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == target &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;left+<span class=\"number\">1</span>, right+<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur &lt; target &#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-判断链表是否存在环\"><a href=\"#1-3-判断链表是否存在环\" class=\"headerlink\" title=\"1.3 判断链表是否存在环\"></a>1.3 判断链表是否存在环</h2><p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/description/\">LeetCode No.141</a></p>\n<blockquote>\n<p>题目描述：给定一个链表，判断链表中是否有环。</p>\n</blockquote>\n<p><strong>思路：</strong>经典解法使用快慢指针，如果存在环两个指针一定会相遇，注意指针空的判断，避免出现野指针。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hasCycle</span><span class=\"params\">(head *ListNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfaster, slower := head.Next.Next, head.Next</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> faster != <span class=\"literal\">nil</span> &amp;&amp; faster.Next != <span class=\"literal\">nil</span> &amp;&amp; slower != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> faster == slower &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfaster = faster.Next.Next</span><br><span class=\"line\">\t\tslower = slower.Next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-接雨水\"><a href=\"#1-4-接雨水\" class=\"headerlink\" title=\"1.4 接雨水\"></a>1.4 接雨水</h2><p><a href=\"https://leetcode-cn.com/problems/trapping-rain-water/\">LeetCode No.42</a></p>\n<blockquote>\n<p>题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n</blockquote>\n<p><strong>思路：</strong>当前柱子能接的雨水数为其左右最高的柱子的较小值减当前柱子的高度</p>\n<p>方法1：先求出每个柱子i左边的最大高度left_max[i]，右边最大高度right_max[i]，然后遍历一次计算。时间复杂度T &#x3D; O(3n)</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">trap</span><span class=\"params\">(height []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    res, n := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(height)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left_max, right_max := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n), <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n)</span><br><span class=\"line\">    left_max[<span class=\"number\">0</span>], right_max[n - <span class=\"number\">1</span>] = height[<span class=\"number\">0</span>], height[n - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        left_max[i] = max(left_max[i - <span class=\"number\">1</span>], height[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := n - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">        right_max[i] = max(right_max[i + <span class=\"number\">1</span>], height[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        res += min(right_max[i], left_max[i]) - height[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法2：只需遍历一次的双指针解法，两个指针最终在最高点相遇。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">trap</span><span class=\"params\">(height []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    res, left, right := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(height) - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> right &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left_max, right_max := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> height[left] &gt; height[right] &#123;</span><br><span class=\"line\">            right_max = max(right_max, height[right])</span><br><span class=\"line\">            res += right_max - height[right]</span><br><span class=\"line\">            right--</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            left_max = max(left_max, height[left])</span><br><span class=\"line\">            res += left_max - height[left]</span><br><span class=\"line\">            left++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>双指针通常用在有序数组，链表的数据结构上，根据题目条件移动对应的指针。比如判断子串、链表是否有环的问题。</p>\n<h2 id=\"1-1-最长子串\"><a href=\"#1-1-最长子串\" class=\"headerlink\" title=\"1.1 最长子串\"></a>1.1 最长子串</h2><p><a href=\"https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/\">LeetCode No.524</a></p>\n<blockquote>\n<p>题目描述：给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串<br>输入:<br>s &#x3D; “abpcplea”, d &#x3D; [“ale”,”apple”,”monkey”,”plea”]<br>输出:<br>“apple”</p>\n</blockquote>\n<p><strong>思路：本题主要思路是要将删除s中某些字符后和target匹配转化为判断是target是否为s的子串</strong><br><strong>判断是否为子串：</strong>使用双指针，如果当前字符相等，两个指针同时+1，否则只有母字符串的指针+1，最后判断目标字符传的指针是否等于其长度即可。<br><a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md\">参考原文</a></p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">is_substr</span><span class=\"params\">(s, target <span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\tj := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s) &amp;&amp; j &lt; <span class=\"built_in\">len</span>(target); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s[i] == target[j] &#123;</span><br><span class=\"line\">\t\t\tj++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> j == <span class=\"built_in\">len</span>(target)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findLongestWord</span><span class=\"params\">(s <span class=\"type\">string</span>, dictionary []<span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> longest <span class=\"type\">string</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, cur := <span class=\"keyword\">range</span> dictionary &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果当前字符串是s的子串，当当前字符串长度大于目前结果 或 长度相等但是当前串字典序排在前面时更新目前结果</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> is_substr(s, cur) &amp;&amp; (<span class=\"built_in\">len</span>(cur) &gt; <span class=\"built_in\">len</span>(longest) || <span class=\"built_in\">len</span>(cur) == <span class=\"built_in\">len</span>(longest) &amp;&amp; cur &lt; longest) &#123;</span><br><span class=\"line\">\t\t\tlongest = cur</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> longest</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-两数之和\"><a href=\"#1-2-两数之和\" class=\"headerlink\" title=\"1.2 两数之和\"></a>1.2 两数之和</h2><p><a href=\"https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\">LeetCode No.167</a></p>\n<blockquote>\n<p>题目描述：给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。<br>输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[1,2]</p>\n</blockquote>\n<p><strong>思路：</strong>因为输入数组有序，那么可以用左右两个指针，初始位于两端，判断当前两数和如果大于target，那么right指针减一，如果小于target，left加一，如果等于就返回。</p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(numbers []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> left, right := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(numbers) - <span class=\"number\">1</span>; left &lt; right; &#123;</span><br><span class=\"line\">        cur := numbers[left] + numbers[right]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == target &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;left+<span class=\"number\">1</span>, right+<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur &lt; target &#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-判断链表是否存在环\"><a href=\"#1-3-判断链表是否存在环\" class=\"headerlink\" title=\"1.3 判断链表是否存在环\"></a>1.3 判断链表是否存在环</h2><p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/description/\">LeetCode No.141</a></p>\n<blockquote>\n<p>题目描述：给定一个链表，判断链表中是否有环。</p>\n</blockquote>\n<p><strong>思路：</strong>经典解法使用快慢指针，如果存在环两个指针一定会相遇，注意指针空的判断，避免出现野指针。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hasCycle</span><span class=\"params\">(head *ListNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfaster, slower := head.Next.Next, head.Next</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> faster != <span class=\"literal\">nil</span> &amp;&amp; faster.Next != <span class=\"literal\">nil</span> &amp;&amp; slower != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> faster == slower &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfaster = faster.Next.Next</span><br><span class=\"line\">\t\tslower = slower.Next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-接雨水\"><a href=\"#1-4-接雨水\" class=\"headerlink\" title=\"1.4 接雨水\"></a>1.4 接雨水</h2><p><a href=\"https://leetcode-cn.com/problems/trapping-rain-water/\">LeetCode No.42</a></p>\n<blockquote>\n<p>题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n</blockquote>\n<p><strong>思路：</strong>当前柱子能接的雨水数为其左右最高的柱子的较小值减当前柱子的高度</p>\n<p>方法1：先求出每个柱子i左边的最大高度left_max[i]，右边最大高度right_max[i]，然后遍历一次计算。时间复杂度T &#x3D; O(3n)</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">trap</span><span class=\"params\">(height []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    res, n := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(height)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left_max, right_max := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n), <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n)</span><br><span class=\"line\">    left_max[<span class=\"number\">0</span>], right_max[n - <span class=\"number\">1</span>] = height[<span class=\"number\">0</span>], height[n - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        left_max[i] = max(left_max[i - <span class=\"number\">1</span>], height[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := n - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">        right_max[i] = max(right_max[i + <span class=\"number\">1</span>], height[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        res += min(right_max[i], left_max[i]) - height[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法2：只需遍历一次的双指针解法，两个指针最终在最高点相遇。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">trap</span><span class=\"params\">(height []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    res, left, right := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(height) - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> right &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left_max, right_max := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> height[left] &gt; height[right] &#123;</span><br><span class=\"line\">            right_max = max(right_max, height[right])</span><br><span class=\"line\">            res += right_max - height[right]</span><br><span class=\"line\">            right--</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            left_max = max(left_max, height[left])</span><br><span class=\"line\">            res += left_max - height[left]</span><br><span class=\"line\">            left++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(2): 排序","date":"2023-03-19T13:43:50.000Z","_content":"## 2.1 快速排序\n> 题目描述：实现快速排序\n\n**思路**：采用交换法，选第一个数为基准数pivot，在pl <= pr的前提下，指针pl从基准数+1的位置向右走，直到碰到比pivot大的数，指针pr从最右边向左走，直到碰到比pivot小的数，交换arr[pl], arr[pr]，循环结束时pr = pl - 1，将基准数和pr交换。递归调用对基准数位置两边的区间调整。\n\n![](https://upload-images.jianshu.io/upload_images/14151453-a8e8b8d1195b3f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`示例代码：`\n```go\nfunc partition(arr []int, left, right int) int {\n\tpivot := arr[left]\n\tpl, pr := left + 1, right\n\tfor pl <= pr {\n\t\tfor ; pl <= pr && arr[pl] < pivot; pl++ {}\n\t\tfor ; pl <= pr && arr[pr] > pivot; pr-- {}\n\t\tif pl < pr {\n\t\t\tarr[pl], arr[pr] = arr[pr], arr[pl]\n\t\t}\n\t}\n\t// 结束时pr = pl -1\n\tarr[left], arr[pr] = arr[pr], arr[left]\n\treturn pr\n}\n\nfunc recursive(arr []int, left, right int)  {\n\tif left >= right {\n\t\treturn\n\t}\n\tmid := partition(arr, left, right)\n\trecursive(arr, left, mid - 1)\n\trecursive(arr, mid + 1, right)\n}\n\nfunc QuickSort(arr []int) []int {\n\trecursive(arr, 0, len(arr) - 1)\n\treturn arr\n}\n```\n","source":"_posts/2023/03-19-算法-2-排序.md","raw":"---\ntitle: '算法(2): 排序'\ndate: 2023-03-19 21:43:50\ncategories:\n- [算法]\ntags:\n- 快速排序\n---\n## 2.1 快速排序\n> 题目描述：实现快速排序\n\n**思路**：采用交换法，选第一个数为基准数pivot，在pl <= pr的前提下，指针pl从基准数+1的位置向右走，直到碰到比pivot大的数，指针pr从最右边向左走，直到碰到比pivot小的数，交换arr[pl], arr[pr]，循环结束时pr = pl - 1，将基准数和pr交换。递归调用对基准数位置两边的区间调整。\n\n![](https://upload-images.jianshu.io/upload_images/14151453-a8e8b8d1195b3f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`示例代码：`\n```go\nfunc partition(arr []int, left, right int) int {\n\tpivot := arr[left]\n\tpl, pr := left + 1, right\n\tfor pl <= pr {\n\t\tfor ; pl <= pr && arr[pl] < pivot; pl++ {}\n\t\tfor ; pl <= pr && arr[pr] > pivot; pr-- {}\n\t\tif pl < pr {\n\t\t\tarr[pl], arr[pr] = arr[pr], arr[pl]\n\t\t}\n\t}\n\t// 结束时pr = pl -1\n\tarr[left], arr[pr] = arr[pr], arr[left]\n\treturn pr\n}\n\nfunc recursive(arr []int, left, right int)  {\n\tif left >= right {\n\t\treturn\n\t}\n\tmid := partition(arr, left, right)\n\trecursive(arr, left, mid - 1)\n\trecursive(arr, mid + 1, right)\n}\n\nfunc QuickSort(arr []int) []int {\n\trecursive(arr, 0, len(arr) - 1)\n\treturn arr\n}\n```\n","slug":"算法-2-排序","published":1,"updated":"2023-03-19T13:50:13.288Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj17c000jhtfi6lvs0mpj","content":"<h2 id=\"2-1-快速排序\"><a href=\"#2-1-快速排序\" class=\"headerlink\" title=\"2.1 快速排序\"></a>2.1 快速排序</h2><blockquote>\n<p>题目描述：实现快速排序</p>\n</blockquote>\n<p><strong>思路</strong>：采用交换法，选第一个数为基准数pivot，在pl &lt;&#x3D; pr的前提下，指针pl从基准数+1的位置向右走，直到碰到比pivot大的数，指针pr从最右边向左走，直到碰到比pivot小的数，交换arr[pl], arr[pr]，循环结束时pr &#x3D; pl - 1，将基准数和pr交换。递归调用对基准数位置两边的区间调整。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-a8e8b8d1195b3f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-a8e8b8d1195b3f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">partition</span><span class=\"params\">(arr []<span class=\"type\">int</span>, left, right <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tpivot := arr[left]</span><br><span class=\"line\">\tpl, pr := left + <span class=\"number\">1</span>, right</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> pl &lt;= pr &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ; pl &lt;= pr &amp;&amp; arr[pl] &lt; pivot; pl++ &#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ; pl &lt;= pr &amp;&amp; arr[pr] &gt; pivot; pr-- &#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> pl &lt; pr &#123;</span><br><span class=\"line\">\t\t\tarr[pl], arr[pr] = arr[pr], arr[pl]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 结束时pr = pl -1</span></span><br><span class=\"line\">\tarr[left], arr[pr] = arr[pr], arr[left]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recursive</span><span class=\"params\">(arr []<span class=\"type\">int</span>, left, right <span class=\"type\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> left &gt;= right &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmid := partition(arr, left, right)</span><br><span class=\"line\">\trecursive(arr, left, mid - <span class=\"number\">1</span>)</span><br><span class=\"line\">\trecursive(arr, mid + <span class=\"number\">1</span>, right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">QuickSort</span><span class=\"params\">(arr []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\trecursive(arr, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(arr) - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"2-1-快速排序\"><a href=\"#2-1-快速排序\" class=\"headerlink\" title=\"2.1 快速排序\"></a>2.1 快速排序</h2><blockquote>\n<p>题目描述：实现快速排序</p>\n</blockquote>\n<p><strong>思路</strong>：采用交换法，选第一个数为基准数pivot，在pl &lt;&#x3D; pr的前提下，指针pl从基准数+1的位置向右走，直到碰到比pivot大的数，指针pr从最右边向左走，直到碰到比pivot小的数，交换arr[pl], arr[pr]，循环结束时pr &#x3D; pl - 1，将基准数和pr交换。递归调用对基准数位置两边的区间调整。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-a8e8b8d1195b3f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">partition</span><span class=\"params\">(arr []<span class=\"type\">int</span>, left, right <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tpivot := arr[left]</span><br><span class=\"line\">\tpl, pr := left + <span class=\"number\">1</span>, right</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> pl &lt;= pr &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ; pl &lt;= pr &amp;&amp; arr[pl] &lt; pivot; pl++ &#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ; pl &lt;= pr &amp;&amp; arr[pr] &gt; pivot; pr-- &#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> pl &lt; pr &#123;</span><br><span class=\"line\">\t\t\tarr[pl], arr[pr] = arr[pr], arr[pl]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 结束时pr = pl -1</span></span><br><span class=\"line\">\tarr[left], arr[pr] = arr[pr], arr[left]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recursive</span><span class=\"params\">(arr []<span class=\"type\">int</span>, left, right <span class=\"type\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> left &gt;= right &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmid := partition(arr, left, right)</span><br><span class=\"line\">\trecursive(arr, left, mid - <span class=\"number\">1</span>)</span><br><span class=\"line\">\trecursive(arr, mid + <span class=\"number\">1</span>, right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">QuickSort</span><span class=\"params\">(arr []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\trecursive(arr, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(arr) - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(3): 二分查找","date":"2023-03-19T13:51:01.000Z","_content":"\n二分查找是一种在有序列表中查找元素的高效方法，时间复杂度（logN），二分查找思路和时间都比较简单，但是实际问题中的细节不可忽视。\n### 3.1 搜索插入位置\n[LeetCode No.35](https://leetcode-cn.com/problems/search-insert-position/)\n\n> 问题描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置，你可以假设数组中无重复元素。\n\n**思路**：按照二分查找法，定义low，high两个指针，结束条件为low > high，如果目标值不存在返回low的位置就是要插入的位置。\n\n`示例代码：`\n```go\nfunc searchInsert(nums []int, target int) int {\n\tl, h := 0, len(nums) - 1\n\tvar m int\n\tfor l <= h {\n\t\tm = h + l >> 1\n\t\tif nums[m] == target {\n\t\t\treturn m\n\t\t}\n\t\tif nums[m] > target {\n\t\t\th = m - 1\n\t\t} else {\n\t\t\tl = m + 1\n\t\t}\n\t}\n\treturn l\n}\n```\n\n### 3.2 搜索旋转排序数组\n[LeetCode No.33](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n\n> 问题描述：整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1\n\n**思路**：进行二分之后的mid位置元素位置可能有两种情况：左边元素的所有元素是有序的，或右边的所有元素是有序的。\n![](https://upload-images.jianshu.io/upload_images/14151453-16f62cfda81d1fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 如果是左边有序，则nums[mid] > nums[low]，反之是右边有序\n- 在知道是那边有序后即可根据边界和target来选择去左半区还是右半区搜索\n\n`示例代码：`\n```go\nfunc search(nums []int, target int) int {\n\tlow, high := 0, len(nums) - 1\n\tfor low <= high {\n\t\tmid := (low + high) / 2\n\t\tif nums[mid] == target {\n\t\t\treturn mid\n\t\t}\n\t\tif nums[mid] >= nums[low] {\n\t\t\tif target < nums[mid] && target >= nums[low] {\n\t\t\t\thigh = mid - 1\n\t\t\t} else {\n\t\t\t\tlow = mid + 1\n\t\t\t}\n\t\t} else {\n\t\t\tif target > nums[mid] && target <= nums[high] {\n\t\t\t\tlow = mid + 1\n\t\t\t} else {\n\t\t\t\thigh = mid - 1\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n### 3.3 排序数组中查找元素的第一个和最后一个位置（有重复元素）\n[LeetCode No.34](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n> 问题描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置，如果数组中不存在目标值 target，返回 [-1, -1]。\n\n**思路**：找到最左边的target位置和target+1最左边的位置-1，要找最左边的target，那么当nums[mid] >= target时都要继续往左半区搜索。\n\n`示例代码：`\n```go\nfunc searchRange(nums []int, target int) []int {\n\tledge := search(nums, target)\n\tif ledge == len(nums) || nums[ledge] != target {\n\t\treturn []int{-1, -1}\n\t}\n\tredge := search(nums, target + 1) - 1\n\treturn []int{ledge, redge}\n}\n\nfunc search(nums []int, target int) int  {\n\tl, r := 0, len(nums) - 1\n\tfor l <= r {\n\t\tmid := (l + r) / 2\n\t\tif nums[mid] >= target {\n\t\t\tr = mid - 1\n\t\t\tif l > r && nums[mid] == target {\n\t\t\t\treturn mid\n\t\t\t}\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t}\n\treturn l\n}\n```\n","source":"_posts/2023/03-19-算法-3-二分查找.md","raw":"---\ntitle: '算法(3): 二分查找'\ndate: 2023-03-19 21:51:01\ncategories:\n- [算法]\ntags:\n- 二分查找\n- leetcode\n---\n\n二分查找是一种在有序列表中查找元素的高效方法，时间复杂度（logN），二分查找思路和时间都比较简单，但是实际问题中的细节不可忽视。\n### 3.1 搜索插入位置\n[LeetCode No.35](https://leetcode-cn.com/problems/search-insert-position/)\n\n> 问题描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置，你可以假设数组中无重复元素。\n\n**思路**：按照二分查找法，定义low，high两个指针，结束条件为low > high，如果目标值不存在返回low的位置就是要插入的位置。\n\n`示例代码：`\n```go\nfunc searchInsert(nums []int, target int) int {\n\tl, h := 0, len(nums) - 1\n\tvar m int\n\tfor l <= h {\n\t\tm = h + l >> 1\n\t\tif nums[m] == target {\n\t\t\treturn m\n\t\t}\n\t\tif nums[m] > target {\n\t\t\th = m - 1\n\t\t} else {\n\t\t\tl = m + 1\n\t\t}\n\t}\n\treturn l\n}\n```\n\n### 3.2 搜索旋转排序数组\n[LeetCode No.33](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n\n> 问题描述：整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1\n\n**思路**：进行二分之后的mid位置元素位置可能有两种情况：左边元素的所有元素是有序的，或右边的所有元素是有序的。\n![](https://upload-images.jianshu.io/upload_images/14151453-16f62cfda81d1fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 如果是左边有序，则nums[mid] > nums[low]，反之是右边有序\n- 在知道是那边有序后即可根据边界和target来选择去左半区还是右半区搜索\n\n`示例代码：`\n```go\nfunc search(nums []int, target int) int {\n\tlow, high := 0, len(nums) - 1\n\tfor low <= high {\n\t\tmid := (low + high) / 2\n\t\tif nums[mid] == target {\n\t\t\treturn mid\n\t\t}\n\t\tif nums[mid] >= nums[low] {\n\t\t\tif target < nums[mid] && target >= nums[low] {\n\t\t\t\thigh = mid - 1\n\t\t\t} else {\n\t\t\t\tlow = mid + 1\n\t\t\t}\n\t\t} else {\n\t\t\tif target > nums[mid] && target <= nums[high] {\n\t\t\t\tlow = mid + 1\n\t\t\t} else {\n\t\t\t\thigh = mid - 1\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n### 3.3 排序数组中查找元素的第一个和最后一个位置（有重复元素）\n[LeetCode No.34](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n> 问题描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置，如果数组中不存在目标值 target，返回 [-1, -1]。\n\n**思路**：找到最左边的target位置和target+1最左边的位置-1，要找最左边的target，那么当nums[mid] >= target时都要继续往左半区搜索。\n\n`示例代码：`\n```go\nfunc searchRange(nums []int, target int) []int {\n\tledge := search(nums, target)\n\tif ledge == len(nums) || nums[ledge] != target {\n\t\treturn []int{-1, -1}\n\t}\n\tredge := search(nums, target + 1) - 1\n\treturn []int{ledge, redge}\n}\n\nfunc search(nums []int, target int) int  {\n\tl, r := 0, len(nums) - 1\n\tfor l <= r {\n\t\tmid := (l + r) / 2\n\t\tif nums[mid] >= target {\n\t\t\tr = mid - 1\n\t\t\tif l > r && nums[mid] == target {\n\t\t\t\treturn mid\n\t\t\t}\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t}\n\treturn l\n}\n```\n","slug":"算法-3-二分查找","published":1,"updated":"2023-03-19T13:51:59.644Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj17e000nhtfi7io97kj0","content":"<p>二分查找是一种在有序列表中查找元素的高效方法，时间复杂度（logN），二分查找思路和时间都比较简单，但是实际问题中的细节不可忽视。</p>\n<h3 id=\"3-1-搜索插入位置\"><a href=\"#3-1-搜索插入位置\" class=\"headerlink\" title=\"3.1 搜索插入位置\"></a>3.1 搜索插入位置</h3><p><a href=\"https://leetcode-cn.com/problems/search-insert-position/\">LeetCode No.35</a></p>\n<blockquote>\n<p>问题描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置，你可以假设数组中无重复元素。</p>\n</blockquote>\n<p><strong>思路</strong>：按照二分查找法，定义low，high两个指针，结束条件为low &gt; high，如果目标值不存在返回low的位置就是要插入的位置。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchInsert</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tl, h := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> m <span class=\"type\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l &lt;= h &#123;</span><br><span class=\"line\">\t\tm = h + l &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[m] == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> m</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[m] &gt; target &#123;</span><br><span class=\"line\">\t\t\th = m - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tl = m + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-搜索旋转排序数组\"><a href=\"#3-2-搜索旋转排序数组\" class=\"headerlink\" title=\"3.2 搜索旋转排序数组\"></a>3.2 搜索旋转排序数组</h3><p><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\">LeetCode No.33</a></p>\n<blockquote>\n<p>问题描述：整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1</p>\n</blockquote>\n<p><strong>思路</strong>：进行二分之后的mid位置元素位置可能有两种情况：左边元素的所有元素是有序的，或右边的所有元素是有序的。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-16f62cfda81d1fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-16f62cfda81d1fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<ul>\n<li>如果是左边有序，则nums[mid] &gt; nums[low]，反之是右边有序</li>\n<li>在知道是那边有序后即可根据边界和target来选择去左半区还是右半区搜索</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tlow, high := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> low &lt;= high &#123;</span><br><span class=\"line\">\t\tmid := (low + high) / <span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> mid</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] &gt;= nums[low] &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> target &lt; nums[mid] &amp;&amp; target &gt;= nums[low] &#123;</span><br><span class=\"line\">\t\t\t\thigh = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tlow = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> target &gt; nums[mid] &amp;&amp; target &lt;= nums[high] &#123;</span><br><span class=\"line\">\t\t\t\tlow = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\thigh = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-排序数组中查找元素的第一个和最后一个位置（有重复元素）\"><a href=\"#3-3-排序数组中查找元素的第一个和最后一个位置（有重复元素）\" class=\"headerlink\" title=\"3.3 排序数组中查找元素的第一个和最后一个位置（有重复元素）\"></a>3.3 排序数组中查找元素的第一个和最后一个位置（有重复元素）</h3><p><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\">LeetCode No.34</a></p>\n<blockquote>\n<p>问题描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置，如果数组中不存在目标值 target，返回 [-1, -1]。</p>\n</blockquote>\n<p><strong>思路</strong>：找到最左边的target位置和target+1最左边的位置-1，要找最左边的target，那么当nums[mid] &gt;&#x3D; target时都要继续往左半区搜索。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchRange</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tledge := search(nums, target)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ledge == <span class=\"built_in\">len</span>(nums) || nums[ledge] != target &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tredge := search(nums, target + <span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;ledge, redge&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span>  &#123;</span><br><span class=\"line\">\tl, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l &lt;= r &#123;</span><br><span class=\"line\">\t\tmid := (l + r) / <span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] &gt;= target &#123;</span><br><span class=\"line\">\t\t\tr = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> l &gt; r &amp;&amp; nums[mid] == target &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> mid</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tl = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>二分查找是一种在有序列表中查找元素的高效方法，时间复杂度（logN），二分查找思路和时间都比较简单，但是实际问题中的细节不可忽视。</p>\n<h3 id=\"3-1-搜索插入位置\"><a href=\"#3-1-搜索插入位置\" class=\"headerlink\" title=\"3.1 搜索插入位置\"></a>3.1 搜索插入位置</h3><p><a href=\"https://leetcode-cn.com/problems/search-insert-position/\">LeetCode No.35</a></p>\n<blockquote>\n<p>问题描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置，你可以假设数组中无重复元素。</p>\n</blockquote>\n<p><strong>思路</strong>：按照二分查找法，定义low，high两个指针，结束条件为low &gt; high，如果目标值不存在返回low的位置就是要插入的位置。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchInsert</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tl, h := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> m <span class=\"type\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l &lt;= h &#123;</span><br><span class=\"line\">\t\tm = h + l &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[m] == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> m</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[m] &gt; target &#123;</span><br><span class=\"line\">\t\t\th = m - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tl = m + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-搜索旋转排序数组\"><a href=\"#3-2-搜索旋转排序数组\" class=\"headerlink\" title=\"3.2 搜索旋转排序数组\"></a>3.2 搜索旋转排序数组</h3><p><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\">LeetCode No.33</a></p>\n<blockquote>\n<p>问题描述：整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1</p>\n</blockquote>\n<p><strong>思路</strong>：进行二分之后的mid位置元素位置可能有两种情况：左边元素的所有元素是有序的，或右边的所有元素是有序的。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-16f62cfda81d1fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<ul>\n<li>如果是左边有序，则nums[mid] &gt; nums[low]，反之是右边有序</li>\n<li>在知道是那边有序后即可根据边界和target来选择去左半区还是右半区搜索</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tlow, high := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> low &lt;= high &#123;</span><br><span class=\"line\">\t\tmid := (low + high) / <span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> mid</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] &gt;= nums[low] &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> target &lt; nums[mid] &amp;&amp; target &gt;= nums[low] &#123;</span><br><span class=\"line\">\t\t\t\thigh = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tlow = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> target &gt; nums[mid] &amp;&amp; target &lt;= nums[high] &#123;</span><br><span class=\"line\">\t\t\t\tlow = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\thigh = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-排序数组中查找元素的第一个和最后一个位置（有重复元素）\"><a href=\"#3-3-排序数组中查找元素的第一个和最后一个位置（有重复元素）\" class=\"headerlink\" title=\"3.3 排序数组中查找元素的第一个和最后一个位置（有重复元素）\"></a>3.3 排序数组中查找元素的第一个和最后一个位置（有重复元素）</h3><p><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\">LeetCode No.34</a></p>\n<blockquote>\n<p>问题描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置，如果数组中不存在目标值 target，返回 [-1, -1]。</p>\n</blockquote>\n<p><strong>思路</strong>：找到最左边的target位置和target+1最左边的位置-1，要找最左边的target，那么当nums[mid] &gt;&#x3D; target时都要继续往左半区搜索。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchRange</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tledge := search(nums, target)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ledge == <span class=\"built_in\">len</span>(nums) || nums[ledge] != target &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tredge := search(nums, target + <span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;ledge, redge&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span>  &#123;</span><br><span class=\"line\">\tl, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l &lt;= r &#123;</span><br><span class=\"line\">\t\tmid := (l + r) / <span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] &gt;= target &#123;</span><br><span class=\"line\">\t\t\tr = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> l &gt; r &amp;&amp; nums[mid] == target &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> mid</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tl = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(4): 搜索","date":"2023-03-19T13:52:31.000Z","_content":"\n## 3.1 深度优先DFS\n> 问题1：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n![image.png](https://upload-images.jianshu.io/upload_images/14151453-d06c5120f4a6ffc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nInput: \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n\n思路：深度优先搜索，从根节点到每个叶子节点的所有路径即结果，深度为子串的长度\n\n`示例代码:`\n```go\nvar (\n\tletterMap = []string{\n\t\t\" \",    //0\n\t\t\"\",     //1\n\t\t\"abc\",  //2\n\t\t\"def\",  //3\n\t\t\"ghi\",  //4\n\t\t\"jkl\",  //5\n\t\t\"mno\",  //6\n\t\t\"pqrs\", //7\n\t\t\"tuv\",  //8\n\t\t\"wxyz\", //9\n\t}\n\tres   = []string{}\n)\n\nfunc letterCombinations(digits string) []string {\n\tif digits == \"\" {\n\t\treturn []string{}\n\t}\n    res = []string{}\n\tdfs(digits, 0, \"\")\n\treturn res\n}\n\nfunc dfs(digits string, i int, s string) {\n\tif i == len(digits) {\n\t\tres = append(res, s)\n\t\treturn\n\t}\n\tcurs := letterMap[digits[i] - '0']\n\tfor _, ch := range curs {\n\t\tdfs(digits, i+1, s + string(ch))\n\t}\n}\n```\n\n> 问题2：给定一个数组，要求在这个数组中找出 k 个数之和为 target 的所有组合。\nInput: nums = [1, 0, -1, 0, -2, 2], and target = 0.\nOutput:  [ [-1,  0, 0, 1], [-2, -1, 1, 2], [-2,  0, 0, 2] ]\n\n思路：深度优先搜索，层数为k。注意去重的处理。\n\n`示例代码:`\n```go\nimport \"sort\"\n\nvar res = [][]int{}\n\nfunc fourSum(nums []int, target int) [][]int {\n    if len(nums) == 0 {\n\t\treturn [][]int{}\n\t}\n    sort.Ints(nums)\n    res = [][]int{}\n\tr := []int{}\n\tdfs_sum(nums, 0, r, target)\n\treturn res\n}\n\nfunc dfs_sum(nums []int, i int, r []int, target int)  {\n    if i == 4 || 0 == len(nums) {\n        if len(r) >= 4 && r[0] + r[1] + r[2] + r[3] == target {\n            res = append(res, []int{r[0], r[1], r[2], r[3]})\n\t\t}\n\t\treturn\n\t}\n\tfor j := 0; j < len(nums); j++ {\n        if j > 0 && nums[j] == nums[j-1] {\n            continue\n        }\n        r = append(r, nums[j])\n        dfs_sum(nums[j+1:], i + 1, r, target)\n        if len(r) >= 1 {\n            r = r[:len(r)-1]\n        }\n\t}\n}\n```\n\n## 3.2 宽度优先搜索 BFS\n宽度优先搜索通常用在求最短路径，按层遍历，第一次满足要求的层数就是最短的路径。BFS需要借助队列来保存每一层的节点，访问过的节点要做标记避免重复访问。\n\n### 3.2.1 二进制矩阵中的最短路径\n[LeetCode No.1091](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)\n\n> 题目描述：给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：\n1 路径途经的所有单元格都的值都是 0 。\n2 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。\n畅通路径的长度 是该路径途经的单元格总数。\n\n**思路**：从左上角开始，遍历所有可以走的方向，BFS方式求到达右下角的最小层数。\n\n`示例代码：`\n```go\ntype Pos struct {\n\tx, y int\n}\n\nfunc shortestPathBinaryMatrix(grid [][]int) int {\n\tif len(grid) == 0 || len(grid[0]) == 0 {\n\t\treturn -1\n\t}\n\tM, N := len(grid), len(grid[0])\n\tdirection := []Pos{{1, -1}, {1, 0}, {1, 1}, {0, -1}, {0, 1}, {-1, -1}, {-1, 0}, {-1, 1}}\n\tQ := list.New()\n\t// 根节点入队\n\tQ.PushBack(Pos{0, 0})\n\tpath_len := 0\n\tfor Q.Len() != 0 {\n\t\t// 保存当前层的长度\n\t\tlevel_size := Q.Len()\n\t\tpath_len++\n\t\t// 依次处理当前层的所有节点\n\t\tfor i := 0; i < level_size; i++ {\n\t\t\tcur_pos := Q.Front().Value.(Pos)\n\t\t\tQ.Remove(Q.Front())\n\t\t\tif grid[cur_pos.x][cur_pos.y] == 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// 如果到达右下角返回结果\n\t\t\tif cur_pos.x == (M - 1) && cur_pos.y == (N - 1) {\n\t\t\t\treturn path_len\n\t\t\t}\n\t\t\t// 访问过的位置标记为1\n\t\t\tgrid[cur_pos.x][cur_pos.y] = 1\n\t\t\t// 遍历所有能走的方向，加入队列\n\t\t\tfor _, dr := range direction {\n\t\t\t\tnx, ny := cur_pos.x + dr.x, cur_pos.y + dr.y\n\t\t\t\tif nx < 0 || nx >= M || ny < 0 || ny >= N {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tQ.PushBack(Pos{nx, ny})\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n### 3.2.2 完全平方数\n[LeetCode No.279](https://leetcode-cn.com/problems/perfect-squares)\n\n> 题目描述：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n\n**思路**：转化为BFS问题模型，从1到根号n的所有平方数（1，4，9...）为每次所有可能的路径。从n开始遍历，当n=0时即为结果。\n\n`示例代码：`\n```go\nfunc numSquares(n int) int {\n\tnumsqs := []int{}\n\tfor i, ii := 1, 1; ii <= n; i, ii = i + 1, (i + 1) * (i + 1){\n\t\tnumsqs = append(numsqs, ii)\n\t}\n\tmark := map[int]bool{}\n\tQ := list.New()\n\tQ.PushBack(n)\n\tmark[n] = true\n\tans := 0\n\tfor Q.Len() != 0 {\n\t\tlv_size := Q.Len()\n\t\tans++\n\t\tfor i := 0; i < lv_size; i++ {\n\t\t\tcur := Q.Front().Value.(int)\n\t\t\tQ.Remove(Q.Front())\n\t\t\tfor _, nq := range numsqs {\n\t\t\t\tif cur == nq {\n\t\t\t\t\treturn ans\n\t\t\t\t}\n\t\t\t\tif cur < nq {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif mark[cur - nq] {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmark[cur - nq] = true\n\t\t\t\tQ.PushBack(cur - nq)\n\t\t\t}\n\t\t}\n\t}\n\treturn n\n}\n```\n","source":"_posts/2023/03-19-算法-4-搜索.md","raw":"---\ntitle: '算法(4): 搜索'\ndate: 2023-03-19 21:52:31\ncategories:\n- [算法]\ntags:\n- leetcode\n- 深度优先搜索\n- 广度优先搜索\n---\n\n## 3.1 深度优先DFS\n> 问题1：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n![image.png](https://upload-images.jianshu.io/upload_images/14151453-d06c5120f4a6ffc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nInput: \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n\n思路：深度优先搜索，从根节点到每个叶子节点的所有路径即结果，深度为子串的长度\n\n`示例代码:`\n```go\nvar (\n\tletterMap = []string{\n\t\t\" \",    //0\n\t\t\"\",     //1\n\t\t\"abc\",  //2\n\t\t\"def\",  //3\n\t\t\"ghi\",  //4\n\t\t\"jkl\",  //5\n\t\t\"mno\",  //6\n\t\t\"pqrs\", //7\n\t\t\"tuv\",  //8\n\t\t\"wxyz\", //9\n\t}\n\tres   = []string{}\n)\n\nfunc letterCombinations(digits string) []string {\n\tif digits == \"\" {\n\t\treturn []string{}\n\t}\n    res = []string{}\n\tdfs(digits, 0, \"\")\n\treturn res\n}\n\nfunc dfs(digits string, i int, s string) {\n\tif i == len(digits) {\n\t\tres = append(res, s)\n\t\treturn\n\t}\n\tcurs := letterMap[digits[i] - '0']\n\tfor _, ch := range curs {\n\t\tdfs(digits, i+1, s + string(ch))\n\t}\n}\n```\n\n> 问题2：给定一个数组，要求在这个数组中找出 k 个数之和为 target 的所有组合。\nInput: nums = [1, 0, -1, 0, -2, 2], and target = 0.\nOutput:  [ [-1,  0, 0, 1], [-2, -1, 1, 2], [-2,  0, 0, 2] ]\n\n思路：深度优先搜索，层数为k。注意去重的处理。\n\n`示例代码:`\n```go\nimport \"sort\"\n\nvar res = [][]int{}\n\nfunc fourSum(nums []int, target int) [][]int {\n    if len(nums) == 0 {\n\t\treturn [][]int{}\n\t}\n    sort.Ints(nums)\n    res = [][]int{}\n\tr := []int{}\n\tdfs_sum(nums, 0, r, target)\n\treturn res\n}\n\nfunc dfs_sum(nums []int, i int, r []int, target int)  {\n    if i == 4 || 0 == len(nums) {\n        if len(r) >= 4 && r[0] + r[1] + r[2] + r[3] == target {\n            res = append(res, []int{r[0], r[1], r[2], r[3]})\n\t\t}\n\t\treturn\n\t}\n\tfor j := 0; j < len(nums); j++ {\n        if j > 0 && nums[j] == nums[j-1] {\n            continue\n        }\n        r = append(r, nums[j])\n        dfs_sum(nums[j+1:], i + 1, r, target)\n        if len(r) >= 1 {\n            r = r[:len(r)-1]\n        }\n\t}\n}\n```\n\n## 3.2 宽度优先搜索 BFS\n宽度优先搜索通常用在求最短路径，按层遍历，第一次满足要求的层数就是最短的路径。BFS需要借助队列来保存每一层的节点，访问过的节点要做标记避免重复访问。\n\n### 3.2.1 二进制矩阵中的最短路径\n[LeetCode No.1091](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)\n\n> 题目描述：给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：\n1 路径途经的所有单元格都的值都是 0 。\n2 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。\n畅通路径的长度 是该路径途经的单元格总数。\n\n**思路**：从左上角开始，遍历所有可以走的方向，BFS方式求到达右下角的最小层数。\n\n`示例代码：`\n```go\ntype Pos struct {\n\tx, y int\n}\n\nfunc shortestPathBinaryMatrix(grid [][]int) int {\n\tif len(grid) == 0 || len(grid[0]) == 0 {\n\t\treturn -1\n\t}\n\tM, N := len(grid), len(grid[0])\n\tdirection := []Pos{{1, -1}, {1, 0}, {1, 1}, {0, -1}, {0, 1}, {-1, -1}, {-1, 0}, {-1, 1}}\n\tQ := list.New()\n\t// 根节点入队\n\tQ.PushBack(Pos{0, 0})\n\tpath_len := 0\n\tfor Q.Len() != 0 {\n\t\t// 保存当前层的长度\n\t\tlevel_size := Q.Len()\n\t\tpath_len++\n\t\t// 依次处理当前层的所有节点\n\t\tfor i := 0; i < level_size; i++ {\n\t\t\tcur_pos := Q.Front().Value.(Pos)\n\t\t\tQ.Remove(Q.Front())\n\t\t\tif grid[cur_pos.x][cur_pos.y] == 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// 如果到达右下角返回结果\n\t\t\tif cur_pos.x == (M - 1) && cur_pos.y == (N - 1) {\n\t\t\t\treturn path_len\n\t\t\t}\n\t\t\t// 访问过的位置标记为1\n\t\t\tgrid[cur_pos.x][cur_pos.y] = 1\n\t\t\t// 遍历所有能走的方向，加入队列\n\t\t\tfor _, dr := range direction {\n\t\t\t\tnx, ny := cur_pos.x + dr.x, cur_pos.y + dr.y\n\t\t\t\tif nx < 0 || nx >= M || ny < 0 || ny >= N {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tQ.PushBack(Pos{nx, ny})\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n### 3.2.2 完全平方数\n[LeetCode No.279](https://leetcode-cn.com/problems/perfect-squares)\n\n> 题目描述：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n\n**思路**：转化为BFS问题模型，从1到根号n的所有平方数（1，4，9...）为每次所有可能的路径。从n开始遍历，当n=0时即为结果。\n\n`示例代码：`\n```go\nfunc numSquares(n int) int {\n\tnumsqs := []int{}\n\tfor i, ii := 1, 1; ii <= n; i, ii = i + 1, (i + 1) * (i + 1){\n\t\tnumsqs = append(numsqs, ii)\n\t}\n\tmark := map[int]bool{}\n\tQ := list.New()\n\tQ.PushBack(n)\n\tmark[n] = true\n\tans := 0\n\tfor Q.Len() != 0 {\n\t\tlv_size := Q.Len()\n\t\tans++\n\t\tfor i := 0; i < lv_size; i++ {\n\t\t\tcur := Q.Front().Value.(int)\n\t\t\tQ.Remove(Q.Front())\n\t\t\tfor _, nq := range numsqs {\n\t\t\t\tif cur == nq {\n\t\t\t\t\treturn ans\n\t\t\t\t}\n\t\t\t\tif cur < nq {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif mark[cur - nq] {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmark[cur - nq] = true\n\t\t\t\tQ.PushBack(cur - nq)\n\t\t\t}\n\t\t}\n\t}\n\treturn n\n}\n```\n","slug":"算法-4-搜索","published":1,"updated":"2023-03-19T13:53:40.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj17e000phtfi3dcp63rz","content":"<h2 id=\"3-1-深度优先DFS\"><a href=\"#3-1-深度优先DFS\" class=\"headerlink\" title=\"3.1 深度优先DFS\"></a>3.1 深度优先DFS</h2><blockquote>\n<p>问题1：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-d06c5120f4a6ffc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-d06c5120f4a6ffc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" alt=\"image.png\"><br>Input: “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</p>\n</blockquote>\n<p>思路：深度优先搜索，从根节点到每个叶子节点的所有路径即结果，深度为子串的长度</p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tletterMap = []<span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot; &quot;</span>,    <span class=\"comment\">//0</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;&quot;</span>,     <span class=\"comment\">//1</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;abc&quot;</span>,  <span class=\"comment\">//2</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;def&quot;</span>,  <span class=\"comment\">//3</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;ghi&quot;</span>,  <span class=\"comment\">//4</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;jkl&quot;</span>,  <span class=\"comment\">//5</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;mno&quot;</span>,  <span class=\"comment\">//6</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pqrs&quot;</span>, <span class=\"comment\">//7</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;tuv&quot;</span>,  <span class=\"comment\">//8</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;wxyz&quot;</span>, <span class=\"comment\">//9</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres   = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(digits <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> digits == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    res = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\tdfs(digits, <span class=\"number\">0</span>, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(digits <span class=\"type\">string</span>, i <span class=\"type\">int</span>, s <span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i == <span class=\"built_in\">len</span>(digits) &#123;</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, s)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcurs := letterMap[digits[i] - <span class=\"string\">&#x27;0&#x27;</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, ch := <span class=\"keyword\">range</span> curs &#123;</span><br><span class=\"line\">\t\tdfs(digits, i+<span class=\"number\">1</span>, s + <span class=\"type\">string</span>(ch))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>问题2：给定一个数组，要求在这个数组中找出 k 个数之和为 target 的所有组合。<br>Input: nums &#x3D; [1, 0, -1, 0, -2, 2], and target &#x3D; 0.<br>Output:  [ [-1,  0, 0, 1], [-2, -1, 1, 2], [-2,  0, 0, 2] ]</p>\n</blockquote>\n<p>思路：深度优先搜索，层数为k。注意去重的处理。</p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;sort&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> res = [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fourSum</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(nums) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    sort.Ints(nums)</span><br><span class=\"line\">    res = [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\tr := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\tdfs_sum(nums, <span class=\"number\">0</span>, r, target)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs_sum</span><span class=\"params\">(nums []<span class=\"type\">int</span>, i <span class=\"type\">int</span>, r []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">4</span> || <span class=\"number\">0</span> == <span class=\"built_in\">len</span>(nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(r) &gt;= <span class=\"number\">4</span> &amp;&amp; r[<span class=\"number\">0</span>] + r[<span class=\"number\">1</span>] + r[<span class=\"number\">2</span>] + r[<span class=\"number\">3</span>] == target &#123;</span><br><span class=\"line\">            res = <span class=\"built_in\">append</span>(res, []<span class=\"type\">int</span>&#123;r[<span class=\"number\">0</span>], r[<span class=\"number\">1</span>], r[<span class=\"number\">2</span>], r[<span class=\"number\">3</span>]&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(nums); j++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> j &gt; <span class=\"number\">0</span> &amp;&amp; nums[j] == nums[j<span class=\"number\">-1</span>] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r = <span class=\"built_in\">append</span>(r, nums[j])</span><br><span class=\"line\">        dfs_sum(nums[j+<span class=\"number\">1</span>:], i + <span class=\"number\">1</span>, r, target)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(r) &gt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            r = r[:<span class=\"built_in\">len</span>(r)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-宽度优先搜索-BFS\"><a href=\"#3-2-宽度优先搜索-BFS\" class=\"headerlink\" title=\"3.2 宽度优先搜索 BFS\"></a>3.2 宽度优先搜索 BFS</h2><p>宽度优先搜索通常用在求最短路径，按层遍历，第一次满足要求的层数就是最短的路径。BFS需要借助队列来保存每一层的节点，访问过的节点要做标记避免重复访问。</p>\n<h3 id=\"3-2-1-二进制矩阵中的最短路径\"><a href=\"#3-2-1-二进制矩阵中的最短路径\" class=\"headerlink\" title=\"3.2.1 二进制矩阵中的最短路径\"></a>3.2.1 二进制矩阵中的最短路径</h3><p><a href=\"https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/\">LeetCode No.1091</a></p>\n<blockquote>\n<p>题目描述：给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：<br>1 路径途经的所有单元格都的值都是 0 。<br>2 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。<br>畅通路径的长度 是该路径途经的单元格总数。</p>\n</blockquote>\n<p><strong>思路</strong>：从左上角开始，遍历所有可以走的方向，BFS方式求到达右下角的最小层数。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Pos <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tx, y <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shortestPathBinaryMatrix</span><span class=\"params\">(grid [][]<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(grid) == <span class=\"number\">0</span> || <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>]) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tM, N := <span class=\"built_in\">len</span>(grid), <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">\tdirection := []Pos&#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;&#125;</span><br><span class=\"line\">\tQ := list.New()</span><br><span class=\"line\">\t<span class=\"comment\">// 根节点入队</span></span><br><span class=\"line\">\tQ.PushBack(Pos&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;)</span><br><span class=\"line\">\tpath_len := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> Q.Len() != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 保存当前层的长度</span></span><br><span class=\"line\">\t\tlevel_size := Q.Len()</span><br><span class=\"line\">\t\tpath_len++</span><br><span class=\"line\">\t\t<span class=\"comment\">// 依次处理当前层的所有节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; level_size; i++ &#123;</span><br><span class=\"line\">\t\t\tcur_pos := Q.Front().Value.(Pos)</span><br><span class=\"line\">\t\t\tQ.Remove(Q.Front())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> grid[cur_pos.x][cur_pos.y] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果到达右下角返回结果</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> cur_pos.x == (M - <span class=\"number\">1</span>) &amp;&amp; cur_pos.y == (N - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> path_len</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 访问过的位置标记为1</span></span><br><span class=\"line\">\t\t\tgrid[cur_pos.x][cur_pos.y] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遍历所有能走的方向，加入队列</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, dr := <span class=\"keyword\">range</span> direction &#123;</span><br><span class=\"line\">\t\t\t\tnx, ny := cur_pos.x + dr.x, cur_pos.y + dr.y</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> nx &lt; <span class=\"number\">0</span> || nx &gt;= M || ny &lt; <span class=\"number\">0</span> || ny &gt;= N &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tQ.PushBack(Pos&#123;nx, ny&#125;)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2-完全平方数\"><a href=\"#3-2-2-完全平方数\" class=\"headerlink\" title=\"3.2.2 完全平方数\"></a>3.2.2 完全平方数</h3><p><a href=\"https://leetcode-cn.com/problems/perfect-squares\">LeetCode No.279</a></p>\n<blockquote>\n<p>题目描述：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。<br>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。<br>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>\n</blockquote>\n<p><strong>思路</strong>：转化为BFS问题模型，从1到根号n的所有平方数（1，4，9…）为每次所有可能的路径。从n开始遍历，当n&#x3D;0时即为结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">numSquares</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tnumsqs := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, ii := <span class=\"number\">1</span>, <span class=\"number\">1</span>; ii &lt;= n; i, ii = i + <span class=\"number\">1</span>, (i + <span class=\"number\">1</span>) * (i + <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tnumsqs = <span class=\"built_in\">append</span>(numsqs, ii)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmark := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>&#123;&#125;</span><br><span class=\"line\">\tQ := list.New()</span><br><span class=\"line\">\tQ.PushBack(n)</span><br><span class=\"line\">\tmark[n] = <span class=\"literal\">true</span></span><br><span class=\"line\">\tans := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> Q.Len() != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tlv_size := Q.Len()</span><br><span class=\"line\">\t\tans++</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; lv_size; i++ &#123;</span><br><span class=\"line\">\t\t\tcur := Q.Front().Value.(<span class=\"type\">int</span>)</span><br><span class=\"line\">\t\t\tQ.Remove(Q.Front())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, nq := <span class=\"keyword\">range</span> numsqs &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> cur == nq &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> ans</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> cur &lt; nq &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> mark[cur - nq] &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tmark[cur - nq] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\tQ.PushBack(cur - nq)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"3-1-深度优先DFS\"><a href=\"#3-1-深度优先DFS\" class=\"headerlink\" title=\"3.1 深度优先DFS\"></a>3.1 深度优先DFS</h2><blockquote>\n<p>问题1：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-d06c5120f4a6ffc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>Input: “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</p>\n</blockquote>\n<p>思路：深度优先搜索，从根节点到每个叶子节点的所有路径即结果，深度为子串的长度</p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tletterMap = []<span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot; &quot;</span>,    <span class=\"comment\">//0</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;&quot;</span>,     <span class=\"comment\">//1</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;abc&quot;</span>,  <span class=\"comment\">//2</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;def&quot;</span>,  <span class=\"comment\">//3</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;ghi&quot;</span>,  <span class=\"comment\">//4</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;jkl&quot;</span>,  <span class=\"comment\">//5</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;mno&quot;</span>,  <span class=\"comment\">//6</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pqrs&quot;</span>, <span class=\"comment\">//7</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;tuv&quot;</span>,  <span class=\"comment\">//8</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;wxyz&quot;</span>, <span class=\"comment\">//9</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres   = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(digits <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> digits == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    res = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\tdfs(digits, <span class=\"number\">0</span>, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(digits <span class=\"type\">string</span>, i <span class=\"type\">int</span>, s <span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i == <span class=\"built_in\">len</span>(digits) &#123;</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, s)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcurs := letterMap[digits[i] - <span class=\"string\">&#x27;0&#x27;</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, ch := <span class=\"keyword\">range</span> curs &#123;</span><br><span class=\"line\">\t\tdfs(digits, i+<span class=\"number\">1</span>, s + <span class=\"type\">string</span>(ch))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>问题2：给定一个数组，要求在这个数组中找出 k 个数之和为 target 的所有组合。<br>Input: nums &#x3D; [1, 0, -1, 0, -2, 2], and target &#x3D; 0.<br>Output:  [ [-1,  0, 0, 1], [-2, -1, 1, 2], [-2,  0, 0, 2] ]</p>\n</blockquote>\n<p>思路：深度优先搜索，层数为k。注意去重的处理。</p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;sort&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> res = [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fourSum</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(nums) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    sort.Ints(nums)</span><br><span class=\"line\">    res = [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\tr := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\tdfs_sum(nums, <span class=\"number\">0</span>, r, target)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs_sum</span><span class=\"params\">(nums []<span class=\"type\">int</span>, i <span class=\"type\">int</span>, r []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">4</span> || <span class=\"number\">0</span> == <span class=\"built_in\">len</span>(nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(r) &gt;= <span class=\"number\">4</span> &amp;&amp; r[<span class=\"number\">0</span>] + r[<span class=\"number\">1</span>] + r[<span class=\"number\">2</span>] + r[<span class=\"number\">3</span>] == target &#123;</span><br><span class=\"line\">            res = <span class=\"built_in\">append</span>(res, []<span class=\"type\">int</span>&#123;r[<span class=\"number\">0</span>], r[<span class=\"number\">1</span>], r[<span class=\"number\">2</span>], r[<span class=\"number\">3</span>]&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(nums); j++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> j &gt; <span class=\"number\">0</span> &amp;&amp; nums[j] == nums[j<span class=\"number\">-1</span>] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r = <span class=\"built_in\">append</span>(r, nums[j])</span><br><span class=\"line\">        dfs_sum(nums[j+<span class=\"number\">1</span>:], i + <span class=\"number\">1</span>, r, target)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(r) &gt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            r = r[:<span class=\"built_in\">len</span>(r)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-宽度优先搜索-BFS\"><a href=\"#3-2-宽度优先搜索-BFS\" class=\"headerlink\" title=\"3.2 宽度优先搜索 BFS\"></a>3.2 宽度优先搜索 BFS</h2><p>宽度优先搜索通常用在求最短路径，按层遍历，第一次满足要求的层数就是最短的路径。BFS需要借助队列来保存每一层的节点，访问过的节点要做标记避免重复访问。</p>\n<h3 id=\"3-2-1-二进制矩阵中的最短路径\"><a href=\"#3-2-1-二进制矩阵中的最短路径\" class=\"headerlink\" title=\"3.2.1 二进制矩阵中的最短路径\"></a>3.2.1 二进制矩阵中的最短路径</h3><p><a href=\"https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/\">LeetCode No.1091</a></p>\n<blockquote>\n<p>题目描述：给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：<br>1 路径途经的所有单元格都的值都是 0 。<br>2 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。<br>畅通路径的长度 是该路径途经的单元格总数。</p>\n</blockquote>\n<p><strong>思路</strong>：从左上角开始，遍历所有可以走的方向，BFS方式求到达右下角的最小层数。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Pos <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tx, y <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shortestPathBinaryMatrix</span><span class=\"params\">(grid [][]<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(grid) == <span class=\"number\">0</span> || <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>]) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tM, N := <span class=\"built_in\">len</span>(grid), <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">\tdirection := []Pos&#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;&#125;</span><br><span class=\"line\">\tQ := list.New()</span><br><span class=\"line\">\t<span class=\"comment\">// 根节点入队</span></span><br><span class=\"line\">\tQ.PushBack(Pos&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;)</span><br><span class=\"line\">\tpath_len := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> Q.Len() != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 保存当前层的长度</span></span><br><span class=\"line\">\t\tlevel_size := Q.Len()</span><br><span class=\"line\">\t\tpath_len++</span><br><span class=\"line\">\t\t<span class=\"comment\">// 依次处理当前层的所有节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; level_size; i++ &#123;</span><br><span class=\"line\">\t\t\tcur_pos := Q.Front().Value.(Pos)</span><br><span class=\"line\">\t\t\tQ.Remove(Q.Front())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> grid[cur_pos.x][cur_pos.y] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果到达右下角返回结果</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> cur_pos.x == (M - <span class=\"number\">1</span>) &amp;&amp; cur_pos.y == (N - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> path_len</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 访问过的位置标记为1</span></span><br><span class=\"line\">\t\t\tgrid[cur_pos.x][cur_pos.y] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遍历所有能走的方向，加入队列</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, dr := <span class=\"keyword\">range</span> direction &#123;</span><br><span class=\"line\">\t\t\t\tnx, ny := cur_pos.x + dr.x, cur_pos.y + dr.y</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> nx &lt; <span class=\"number\">0</span> || nx &gt;= M || ny &lt; <span class=\"number\">0</span> || ny &gt;= N &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tQ.PushBack(Pos&#123;nx, ny&#125;)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2-完全平方数\"><a href=\"#3-2-2-完全平方数\" class=\"headerlink\" title=\"3.2.2 完全平方数\"></a>3.2.2 完全平方数</h3><p><a href=\"https://leetcode-cn.com/problems/perfect-squares\">LeetCode No.279</a></p>\n<blockquote>\n<p>题目描述：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。<br>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。<br>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>\n</blockquote>\n<p><strong>思路</strong>：转化为BFS问题模型，从1到根号n的所有平方数（1，4，9…）为每次所有可能的路径。从n开始遍历，当n&#x3D;0时即为结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">numSquares</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tnumsqs := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, ii := <span class=\"number\">1</span>, <span class=\"number\">1</span>; ii &lt;= n; i, ii = i + <span class=\"number\">1</span>, (i + <span class=\"number\">1</span>) * (i + <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tnumsqs = <span class=\"built_in\">append</span>(numsqs, ii)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmark := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>&#123;&#125;</span><br><span class=\"line\">\tQ := list.New()</span><br><span class=\"line\">\tQ.PushBack(n)</span><br><span class=\"line\">\tmark[n] = <span class=\"literal\">true</span></span><br><span class=\"line\">\tans := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> Q.Len() != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tlv_size := Q.Len()</span><br><span class=\"line\">\t\tans++</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; lv_size; i++ &#123;</span><br><span class=\"line\">\t\t\tcur := Q.Front().Value.(<span class=\"type\">int</span>)</span><br><span class=\"line\">\t\t\tQ.Remove(Q.Front())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, nq := <span class=\"keyword\">range</span> numsqs &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> cur == nq &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> ans</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> cur &lt; nq &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> mark[cur - nq] &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tmark[cur - nq] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\tQ.PushBack(cur - nq)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(5): 分治/归并","date":"2023-03-19T13:54:37.000Z","_content":"\n分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。\n\n## 5.1 不同的二叉搜索树\n[LeetCode No.95](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n> 问题描述：给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。\n\n**思路**：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1...n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。\n\n`示例代码：`\n```go\nfunc generateTrees(n int) []*TreeNode {\n\treturn _generateTrees(1, n)\n}\n\nfunc _generateTrees(start, end int) []*TreeNode {\n\tif start > end {\n\t\treturn []*TreeNode{nil}\n\t}\n\tres := []*TreeNode{}\n\tfor i := start; i <= end; i++ {\n\t\tleft := _generateTrees(start, i - 1)\n\t\tright := _generateTrees(i + 1, end)\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\ttmp := &TreeNode{\n\t\t\t\t\tVal: i,\n\t\t\t\t\tLeft: l,\n\t\t\t\t\tRight: r,\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n\n## 5.2 为运算表达式设计优先级\n[LeetCode No.241](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)\n\n> 题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。\n\n**思路**：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。\n\n`示例代码：`\n```go\nfunc diffWaysToCompute(expression string) []int {\n\tnum, err := strconv.Atoi(expression)\n\t// 如果为纯数字，直接返回数字\n\tif err == nil {\n\t\treturn []int{num}\n\t}\n\tres := []int{}\n\tfor i, ch := range expression {\n\t\t// 跳过非运算符\n\t\tif ch != '+' && ch != '-' && ch != '*' {\n\t\t\tcontinue\n\t\t}\n\t\t// 计算运算符左右两边子表达式的结果\n\t\tleft := diffWaysToCompute(expression[ : i])\n\t\tright := diffWaysToCompute(expression[i + 1 : ])\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\tvar tmp int\n\t\t\t\tswitch ch {\n\t\t\t\tcase '+': tmp = l + r\n\t\t\t\tcase '-': tmp = l - r\n\t\t\t\tcase '*': tmp = l * r\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n","source":"_posts/2023/03-19-算法-5-分治-归并.md","raw":"---\ntitle: '算法(5): 分治/归并'\ndate: 2023-03-19 21:54:37\ncategories:\n- [算法]\ntags:\n- leetcode\n- 二叉搜索树\n---\n\n分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。\n\n## 5.1 不同的二叉搜索树\n[LeetCode No.95](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n> 问题描述：给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。\n\n**思路**：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1...n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。\n\n`示例代码：`\n```go\nfunc generateTrees(n int) []*TreeNode {\n\treturn _generateTrees(1, n)\n}\n\nfunc _generateTrees(start, end int) []*TreeNode {\n\tif start > end {\n\t\treturn []*TreeNode{nil}\n\t}\n\tres := []*TreeNode{}\n\tfor i := start; i <= end; i++ {\n\t\tleft := _generateTrees(start, i - 1)\n\t\tright := _generateTrees(i + 1, end)\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\ttmp := &TreeNode{\n\t\t\t\t\tVal: i,\n\t\t\t\t\tLeft: l,\n\t\t\t\t\tRight: r,\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n\n## 5.2 为运算表达式设计优先级\n[LeetCode No.241](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)\n\n> 题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。\n\n**思路**：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。\n\n`示例代码：`\n```go\nfunc diffWaysToCompute(expression string) []int {\n\tnum, err := strconv.Atoi(expression)\n\t// 如果为纯数字，直接返回数字\n\tif err == nil {\n\t\treturn []int{num}\n\t}\n\tres := []int{}\n\tfor i, ch := range expression {\n\t\t// 跳过非运算符\n\t\tif ch != '+' && ch != '-' && ch != '*' {\n\t\t\tcontinue\n\t\t}\n\t\t// 计算运算符左右两边子表达式的结果\n\t\tleft := diffWaysToCompute(expression[ : i])\n\t\tright := diffWaysToCompute(expression[i + 1 : ])\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\tvar tmp int\n\t\t\t\tswitch ch {\n\t\t\t\tcase '+': tmp = l + r\n\t\t\t\tcase '-': tmp = l - r\n\t\t\t\tcase '*': tmp = l * r\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n","slug":"算法-5-分治-归并","published":1,"updated":"2023-03-19T13:55:12.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj17g000thtfib2uj2sjy","content":"<p>分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。</p>\n<h2 id=\"5-1-不同的二叉搜索树\"><a href=\"#5-1-不同的二叉搜索树\" class=\"headerlink\" title=\"5.1 不同的二叉搜索树\"></a>5.1 不同的二叉搜索树</h2><p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\">LeetCode No.95</a></p>\n<blockquote>\n<p>问题描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>\n</blockquote>\n<p><strong>思路</strong>：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1…n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateTrees</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _generateTrees(<span class=\"number\">1</span>, n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> _<span class=\"title\">generateTrees</span><span class=\"params\">(start, end <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> start &gt; end &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []*TreeNode&#123;<span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []*TreeNode&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class=\"line\">\t\tleft := _generateTrees(start, i - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tright := _generateTrees(i + <span class=\"number\">1</span>, end)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\ttmp := &amp;TreeNode&#123;</span><br><span class=\"line\">\t\t\t\t\tVal: i,</span><br><span class=\"line\">\t\t\t\t\tLeft: l,</span><br><span class=\"line\">\t\t\t\t\tRight: r,</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-为运算表达式设计优先级\"><a href=\"#5-2-为运算表达式设计优先级\" class=\"headerlink\" title=\"5.2 为运算表达式设计优先级\"></a>5.2 为运算表达式设计优先级</h2><p><a href=\"https://leetcode-cn.com/problems/different-ways-to-add-parentheses/\">LeetCode No.241</a></p>\n<blockquote>\n<p>题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>\n</blockquote>\n<p><strong>思路</strong>：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">diffWaysToCompute</span><span class=\"params\">(expression <span class=\"type\">string</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tnum, err := strconv.Atoi(expression)</span><br><span class=\"line\">\t<span class=\"comment\">// 如果为纯数字，直接返回数字</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;num&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, ch := <span class=\"keyword\">range</span> expression &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 跳过非运算符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ch != <span class=\"string\">&#x27;+&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;-&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;*&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算运算符左右两边子表达式的结果</span></span><br><span class=\"line\">\t\tleft := diffWaysToCompute(expression[ : i])</span><br><span class=\"line\">\t\tright := diffWaysToCompute(expression[i + <span class=\"number\">1</span> : ])</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> tmp <span class=\"type\">int</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> ch &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: tmp = l + r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: tmp = l - r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: tmp = l * r</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。</p>\n<h2 id=\"5-1-不同的二叉搜索树\"><a href=\"#5-1-不同的二叉搜索树\" class=\"headerlink\" title=\"5.1 不同的二叉搜索树\"></a>5.1 不同的二叉搜索树</h2><p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\">LeetCode No.95</a></p>\n<blockquote>\n<p>问题描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>\n</blockquote>\n<p><strong>思路</strong>：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1…n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateTrees</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _generateTrees(<span class=\"number\">1</span>, n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> _<span class=\"title\">generateTrees</span><span class=\"params\">(start, end <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> start &gt; end &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []*TreeNode&#123;<span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []*TreeNode&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class=\"line\">\t\tleft := _generateTrees(start, i - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tright := _generateTrees(i + <span class=\"number\">1</span>, end)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\ttmp := &amp;TreeNode&#123;</span><br><span class=\"line\">\t\t\t\t\tVal: i,</span><br><span class=\"line\">\t\t\t\t\tLeft: l,</span><br><span class=\"line\">\t\t\t\t\tRight: r,</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-为运算表达式设计优先级\"><a href=\"#5-2-为运算表达式设计优先级\" class=\"headerlink\" title=\"5.2 为运算表达式设计优先级\"></a>5.2 为运算表达式设计优先级</h2><p><a href=\"https://leetcode-cn.com/problems/different-ways-to-add-parentheses/\">LeetCode No.241</a></p>\n<blockquote>\n<p>题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>\n</blockquote>\n<p><strong>思路</strong>：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">diffWaysToCompute</span><span class=\"params\">(expression <span class=\"type\">string</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tnum, err := strconv.Atoi(expression)</span><br><span class=\"line\">\t<span class=\"comment\">// 如果为纯数字，直接返回数字</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;num&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, ch := <span class=\"keyword\">range</span> expression &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 跳过非运算符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ch != <span class=\"string\">&#x27;+&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;-&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;*&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算运算符左右两边子表达式的结果</span></span><br><span class=\"line\">\t\tleft := diffWaysToCompute(expression[ : i])</span><br><span class=\"line\">\t\tright := diffWaysToCompute(expression[i + <span class=\"number\">1</span> : ])</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> tmp <span class=\"type\">int</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> ch &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: tmp = l + r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: tmp = l - r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: tmp = l * r</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(6): 贪心算法","date":"2023-03-19T13:55:40.000Z","_content":"\n分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。\n\n## 5.1 不同的二叉搜索树\n[LeetCode No.95](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n> 问题描述：给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。\n\n**思路**：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1...n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。\n\n`示例代码：`\n```go\nfunc generateTrees(n int) []*TreeNode {\n\treturn _generateTrees(1, n)\n}\n\nfunc _generateTrees(start, end int) []*TreeNode {\n\tif start > end {\n\t\treturn []*TreeNode{nil}\n\t}\n\tres := []*TreeNode{}\n\tfor i := start; i <= end; i++ {\n\t\tleft := _generateTrees(start, i - 1)\n\t\tright := _generateTrees(i + 1, end)\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\ttmp := &TreeNode{\n\t\t\t\t\tVal: i,\n\t\t\t\t\tLeft: l,\n\t\t\t\t\tRight: r,\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n\n## 5.2 为运算表达式设计优先级\n[LeetCode No.241](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)\n\n> 题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。\n\n**思路**：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。\n\n`示例代码：`\n```go\nfunc diffWaysToCompute(expression string) []int {\n\tnum, err := strconv.Atoi(expression)\n\t// 如果为纯数字，直接返回数字\n\tif err == nil {\n\t\treturn []int{num}\n\t}\n\tres := []int{}\n\tfor i, ch := range expression {\n\t\t// 跳过非运算符\n\t\tif ch != '+' && ch != '-' && ch != '*' {\n\t\t\tcontinue\n\t\t}\n\t\t// 计算运算符左右两边子表达式的结果\n\t\tleft := diffWaysToCompute(expression[ : i])\n\t\tright := diffWaysToCompute(expression[i + 1 : ])\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\tvar tmp int\n\t\t\t\tswitch ch {\n\t\t\t\tcase '+': tmp = l + r\n\t\t\t\tcase '-': tmp = l - r\n\t\t\t\tcase '*': tmp = l * r\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n","source":"_posts/2023/03-19-算法-6-贪心算法.md","raw":"---\ntitle: '算法(6): 贪心算法'\ndate: 2023-03-19 21:55:40\ncategories:\n- [算法]\ntags:\n- 贪心\n- leetcode\n---\n\n分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。\n\n## 5.1 不同的二叉搜索树\n[LeetCode No.95](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n> 问题描述：给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。\n\n**思路**：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1...n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。\n\n`示例代码：`\n```go\nfunc generateTrees(n int) []*TreeNode {\n\treturn _generateTrees(1, n)\n}\n\nfunc _generateTrees(start, end int) []*TreeNode {\n\tif start > end {\n\t\treturn []*TreeNode{nil}\n\t}\n\tres := []*TreeNode{}\n\tfor i := start; i <= end; i++ {\n\t\tleft := _generateTrees(start, i - 1)\n\t\tright := _generateTrees(i + 1, end)\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\ttmp := &TreeNode{\n\t\t\t\t\tVal: i,\n\t\t\t\t\tLeft: l,\n\t\t\t\t\tRight: r,\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n\n## 5.2 为运算表达式设计优先级\n[LeetCode No.241](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)\n\n> 题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。\n\n**思路**：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。\n\n`示例代码：`\n```go\nfunc diffWaysToCompute(expression string) []int {\n\tnum, err := strconv.Atoi(expression)\n\t// 如果为纯数字，直接返回数字\n\tif err == nil {\n\t\treturn []int{num}\n\t}\n\tres := []int{}\n\tfor i, ch := range expression {\n\t\t// 跳过非运算符\n\t\tif ch != '+' && ch != '-' && ch != '*' {\n\t\t\tcontinue\n\t\t}\n\t\t// 计算运算符左右两边子表达式的结果\n\t\tleft := diffWaysToCompute(expression[ : i])\n\t\tright := diffWaysToCompute(expression[i + 1 : ])\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\tvar tmp int\n\t\t\t\tswitch ch {\n\t\t\t\tcase '+': tmp = l + r\n\t\t\t\tcase '-': tmp = l - r\n\t\t\t\tcase '*': tmp = l * r\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n","slug":"算法-6-贪心算法","published":1,"updated":"2023-03-19T13:56:25.642Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj17g000whtfia8wj7it8","content":"<p>分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。</p>\n<h2 id=\"5-1-不同的二叉搜索树\"><a href=\"#5-1-不同的二叉搜索树\" class=\"headerlink\" title=\"5.1 不同的二叉搜索树\"></a>5.1 不同的二叉搜索树</h2><p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\">LeetCode No.95</a></p>\n<blockquote>\n<p>问题描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>\n</blockquote>\n<p><strong>思路</strong>：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1…n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateTrees</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _generateTrees(<span class=\"number\">1</span>, n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> _<span class=\"title\">generateTrees</span><span class=\"params\">(start, end <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> start &gt; end &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []*TreeNode&#123;<span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []*TreeNode&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class=\"line\">\t\tleft := _generateTrees(start, i - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tright := _generateTrees(i + <span class=\"number\">1</span>, end)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\ttmp := &amp;TreeNode&#123;</span><br><span class=\"line\">\t\t\t\t\tVal: i,</span><br><span class=\"line\">\t\t\t\t\tLeft: l,</span><br><span class=\"line\">\t\t\t\t\tRight: r,</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-为运算表达式设计优先级\"><a href=\"#5-2-为运算表达式设计优先级\" class=\"headerlink\" title=\"5.2 为运算表达式设计优先级\"></a>5.2 为运算表达式设计优先级</h2><p><a href=\"https://leetcode-cn.com/problems/different-ways-to-add-parentheses/\">LeetCode No.241</a></p>\n<blockquote>\n<p>题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>\n</blockquote>\n<p><strong>思路</strong>：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">diffWaysToCompute</span><span class=\"params\">(expression <span class=\"type\">string</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tnum, err := strconv.Atoi(expression)</span><br><span class=\"line\">\t<span class=\"comment\">// 如果为纯数字，直接返回数字</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;num&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, ch := <span class=\"keyword\">range</span> expression &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 跳过非运算符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ch != <span class=\"string\">&#x27;+&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;-&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;*&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算运算符左右两边子表达式的结果</span></span><br><span class=\"line\">\t\tleft := diffWaysToCompute(expression[ : i])</span><br><span class=\"line\">\t\tright := diffWaysToCompute(expression[i + <span class=\"number\">1</span> : ])</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> tmp <span class=\"type\">int</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> ch &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: tmp = l + r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: tmp = l - r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: tmp = l * r</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。</p>\n<h2 id=\"5-1-不同的二叉搜索树\"><a href=\"#5-1-不同的二叉搜索树\" class=\"headerlink\" title=\"5.1 不同的二叉搜索树\"></a>5.1 不同的二叉搜索树</h2><p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\">LeetCode No.95</a></p>\n<blockquote>\n<p>问题描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>\n</blockquote>\n<p><strong>思路</strong>：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1…n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateTrees</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _generateTrees(<span class=\"number\">1</span>, n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> _<span class=\"title\">generateTrees</span><span class=\"params\">(start, end <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> start &gt; end &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []*TreeNode&#123;<span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []*TreeNode&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class=\"line\">\t\tleft := _generateTrees(start, i - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tright := _generateTrees(i + <span class=\"number\">1</span>, end)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\ttmp := &amp;TreeNode&#123;</span><br><span class=\"line\">\t\t\t\t\tVal: i,</span><br><span class=\"line\">\t\t\t\t\tLeft: l,</span><br><span class=\"line\">\t\t\t\t\tRight: r,</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-为运算表达式设计优先级\"><a href=\"#5-2-为运算表达式设计优先级\" class=\"headerlink\" title=\"5.2 为运算表达式设计优先级\"></a>5.2 为运算表达式设计优先级</h2><p><a href=\"https://leetcode-cn.com/problems/different-ways-to-add-parentheses/\">LeetCode No.241</a></p>\n<blockquote>\n<p>题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>\n</blockquote>\n<p><strong>思路</strong>：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">diffWaysToCompute</span><span class=\"params\">(expression <span class=\"type\">string</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tnum, err := strconv.Atoi(expression)</span><br><span class=\"line\">\t<span class=\"comment\">// 如果为纯数字，直接返回数字</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;num&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, ch := <span class=\"keyword\">range</span> expression &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 跳过非运算符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ch != <span class=\"string\">&#x27;+&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;-&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;*&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算运算符左右两边子表达式的结果</span></span><br><span class=\"line\">\t\tleft := diffWaysToCompute(expression[ : i])</span><br><span class=\"line\">\t\tright := diffWaysToCompute(expression[i + <span class=\"number\">1</span> : ])</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> tmp <span class=\"type\">int</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> ch &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: tmp = l + r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: tmp = l - r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: tmp = l * r</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(7): 动态规划","date":"2023-03-19T13:56:37.000Z","_content":"\n- 动态规划的关键思想在于将问题转换成较小的子问题，然后根据子问题的结果总结出一个状态转移方程，最后得到整个问题的解\n\n### 7.1 打家劫舍\n[LeetCode No.198](https://leetcode-cn.com/problems/house-robber/)\n\n> 问题描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n**思路**：当设选第i个房屋，则不能选i-1，假设dp[i]表示前i个房屋能偷到的最高金额，则有 dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n`示例代码：`\n```go\nfunc rob(nums []int) int {\n    n := len(nums)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return nums[0]\n    }\n    dp := make([]int, n)\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n    ans := dp[1]\n    for i := 2; i < n; i++ {\n        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n        if ans < dp[i] {\n            ans = dp[i]\n        }\n    }\n    return ans\n}\n```\n\n### 7.1-1 打家劫舍2\n[LeetCode No.213](https://leetcode-cn.com/problems/house-robber-ii/)\n\n> 问题描述：房屋变成了环形排列，其他和7.1相同\n\n**思路**：环形排列后，第一个和最后一个不能同时偷，可以转化为[0, n-1]和[1, n]两个单排街道较大值。同时，可以看到第i个问题的最大值只和第i-1和i-2有关，可以只用两个值来保存前两个结果，降低空间复杂度。\n\n`示例代码：`\n```go\nfunc rob(nums []int) int {\n    n := len(nums)\n    if n == 1 {\n        return nums[0]\n    }\n    return max(dorob(nums[1:]), dorob(nums[:n-1]))\n}\n\nfunc dorob(nums []int) int {\n    n := len(nums)\n    if n == 1 {\n        return nums[0]\n    }\n    fisrt, second := nums[0], max(nums[0], nums[1])\n    ans := second\n    for i := 2; i < n; i++ {\n        fisrt, second = second, max(fisrt + nums[i], second)\n        if second > ans {\n            ans = second\n        }\n    }\n    return ans\n}\n```\n\n### 7.2 分割等和子集\n[LeetCode No.416](https://leetcode-cn.com/problems/partition-equal-subset-sum/)\n\n> 问题描述：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n输入: [1, 5, 11, 5]\n输出: true\n解释: 数组可以分割成 [1, 5, 5] 和 [11]\n\n**思路**：如果数组大小为奇数，结果必为false。然后该问题可以转化为背包大小为sum/2的0-1背包问题，如果恰好能装满则结果为true。\n\n`示例代码：`\n```go\nfunc canPartition(nums []int) bool {\n    sum := 0\n    for _, n := range nums {\n        sum += n\n    }\n    if sum % 2 != 0 {\n        return false\n    }\n    W := sum >> 1\n    dp := make(map[int]bool)\n    dp[0] = true\n    for _, n := range nums {\n        // 这里进行了空间优化，需要从后向前算，否则计算后面的时候前面的值已经改过，不是上一层的值了。\n        // dp[i][w] = dp[i - 1][w] || dp[i-1][w-v]\n        for i := W; i >= n; i-- {\n            dp[i] = dp[i] || dp[i - n]\n        }\n    }\n    return dp[W]\n}\n```\n\n### 7.3 青蛙过河\n[LeetCode No.403](https://leetcode-cn.com/problems/frog-jump/)\n\n> 题目描述：一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。\n给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。\n如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。\n**输入**：[0,1,3,5,6,8,12,17]\n总共有8个石子。\n第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,\n第三个石子在序号为3的单元格的位置， 以此定义整个数组...\n最后一个石子处于序号为17的单元格的位置。\n**输出**： true。即青蛙可以成功过河，按照如下方案跳跃： \n跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 \n跳2个单位到第4块石子, 然后跳3个单位到第6块石子, \n跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。\n\n**思路**：参考官方题解动态规划的方法，使用dmap[curpos] = {jumps}表示到达当前curpos可以由jumps集合的任意一个步长一次到达当前位置，对于dmap[0] = {0}，依次遍历每个石头的位置，对每个位置pos遍历jumps集合，对每个jump遍历k = [jump-1，jump+1]，如果当前位置跳k补可以到达某个石头的位置（dmap中的存在key=curpos+k），则将k添加到dmap[curpos+k]的集合。\n\n`示例代码：`\n```go\nfunc canCross(stones []int) bool {\n\t// 用集合模拟set，只需要键值当做集合的元素，value设为空结构\n\tdmap := make(map[int]map[int]struct{}, 0)\n\tdmap[0] = map[int]struct{}{0: {}}\n\tfor i := 1; i < len(stones); i++ {\n\t\tdmap[stones[i]] = map[int]struct{}{}\n\t}\n\tfor _, cur_pos := range stones {\n\t\tsteps := dmap[cur_pos]\n\t\tfor step, _ := range steps {\n\t\t\tfor k := step - 1; k <= step + 1; k++ {\n\t\t\t\tif _, ok := dmap[cur_pos + k]; ok == true && k > 0 {\n\t\t\t\t\tdmap[cur_pos + k][k] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn len(dmap[stones[len(stones) - 1]]) != 0\n}\n```\n\n### 7.4 编辑距离\n[LeetCode No.72](https://leetcode-cn.com/problems/edit-distance/)\n\n> 题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。\n\n**思路**：使用dp[i][j]表示从word1[:i]转换为word2[:j]需要的最少次数，对于任意一个单词为空，所需次数为另一个单词的长度，只能通过增或删来达到相同。对于dp[i][j]，dp[i-1][j]表示从word2中删除一个字符得到，dp[i][j - 1]表示从word1中增加一个字符得到，dp[i-1][j-1]表示从word1中修改一个字符得到，对于word1[i] == word2[j]则不需要修改。那么dp[i][j]只能为上述三种情况的最小值。所以有状态转移方程：\n- 当word1[i] == word2[j]时 dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1)\n- 当word1[i] != word2[j]时 dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1\n\n`示例代码：`\n```go\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc minDistance(word1 string, word2 string) int {\n\tLFROM, LTO := len(word1), len(word2)\n\tdp := make([][]int, LFROM + 1)\n\tfor i := 0; i <= LFROM; i++ {\n\t\tdp[i] = make([]int, LTO + 1)\n\t\tdp[i][0] = i\n\t}\n\tfor j := 0; j <= LTO; j++ {\n\t\tdp[0][j] = j\n\t}\n\tfor i := 1; i <= LFROM; i++ {\n\t\tfor j := 1; j <= LTO; j++ {\n\t\t\tif word1[i - 1] == word2[j - 1] {\n\t\t\t\tdp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1)\n\t\t\t} else {\n\t\t\t\tdp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[LFROM][LTO]\n}\n```\n","source":"_posts/2023/03-19-算法-7-动态规划.md","raw":"---\ntitle: '算法(7): 动态规划'\ndate: 2023-03-19 21:56:37\ncategories:\n- [算法]\ntags:\n- leetcode\n- 动态规划\n---\n\n- 动态规划的关键思想在于将问题转换成较小的子问题，然后根据子问题的结果总结出一个状态转移方程，最后得到整个问题的解\n\n### 7.1 打家劫舍\n[LeetCode No.198](https://leetcode-cn.com/problems/house-robber/)\n\n> 问题描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n**思路**：当设选第i个房屋，则不能选i-1，假设dp[i]表示前i个房屋能偷到的最高金额，则有 dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n`示例代码：`\n```go\nfunc rob(nums []int) int {\n    n := len(nums)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return nums[0]\n    }\n    dp := make([]int, n)\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n    ans := dp[1]\n    for i := 2; i < n; i++ {\n        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n        if ans < dp[i] {\n            ans = dp[i]\n        }\n    }\n    return ans\n}\n```\n\n### 7.1-1 打家劫舍2\n[LeetCode No.213](https://leetcode-cn.com/problems/house-robber-ii/)\n\n> 问题描述：房屋变成了环形排列，其他和7.1相同\n\n**思路**：环形排列后，第一个和最后一个不能同时偷，可以转化为[0, n-1]和[1, n]两个单排街道较大值。同时，可以看到第i个问题的最大值只和第i-1和i-2有关，可以只用两个值来保存前两个结果，降低空间复杂度。\n\n`示例代码：`\n```go\nfunc rob(nums []int) int {\n    n := len(nums)\n    if n == 1 {\n        return nums[0]\n    }\n    return max(dorob(nums[1:]), dorob(nums[:n-1]))\n}\n\nfunc dorob(nums []int) int {\n    n := len(nums)\n    if n == 1 {\n        return nums[0]\n    }\n    fisrt, second := nums[0], max(nums[0], nums[1])\n    ans := second\n    for i := 2; i < n; i++ {\n        fisrt, second = second, max(fisrt + nums[i], second)\n        if second > ans {\n            ans = second\n        }\n    }\n    return ans\n}\n```\n\n### 7.2 分割等和子集\n[LeetCode No.416](https://leetcode-cn.com/problems/partition-equal-subset-sum/)\n\n> 问题描述：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n输入: [1, 5, 11, 5]\n输出: true\n解释: 数组可以分割成 [1, 5, 5] 和 [11]\n\n**思路**：如果数组大小为奇数，结果必为false。然后该问题可以转化为背包大小为sum/2的0-1背包问题，如果恰好能装满则结果为true。\n\n`示例代码：`\n```go\nfunc canPartition(nums []int) bool {\n    sum := 0\n    for _, n := range nums {\n        sum += n\n    }\n    if sum % 2 != 0 {\n        return false\n    }\n    W := sum >> 1\n    dp := make(map[int]bool)\n    dp[0] = true\n    for _, n := range nums {\n        // 这里进行了空间优化，需要从后向前算，否则计算后面的时候前面的值已经改过，不是上一层的值了。\n        // dp[i][w] = dp[i - 1][w] || dp[i-1][w-v]\n        for i := W; i >= n; i-- {\n            dp[i] = dp[i] || dp[i - n]\n        }\n    }\n    return dp[W]\n}\n```\n\n### 7.3 青蛙过河\n[LeetCode No.403](https://leetcode-cn.com/problems/frog-jump/)\n\n> 题目描述：一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。\n给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。\n如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。\n**输入**：[0,1,3,5,6,8,12,17]\n总共有8个石子。\n第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,\n第三个石子在序号为3的单元格的位置， 以此定义整个数组...\n最后一个石子处于序号为17的单元格的位置。\n**输出**： true。即青蛙可以成功过河，按照如下方案跳跃： \n跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 \n跳2个单位到第4块石子, 然后跳3个单位到第6块石子, \n跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。\n\n**思路**：参考官方题解动态规划的方法，使用dmap[curpos] = {jumps}表示到达当前curpos可以由jumps集合的任意一个步长一次到达当前位置，对于dmap[0] = {0}，依次遍历每个石头的位置，对每个位置pos遍历jumps集合，对每个jump遍历k = [jump-1，jump+1]，如果当前位置跳k补可以到达某个石头的位置（dmap中的存在key=curpos+k），则将k添加到dmap[curpos+k]的集合。\n\n`示例代码：`\n```go\nfunc canCross(stones []int) bool {\n\t// 用集合模拟set，只需要键值当做集合的元素，value设为空结构\n\tdmap := make(map[int]map[int]struct{}, 0)\n\tdmap[0] = map[int]struct{}{0: {}}\n\tfor i := 1; i < len(stones); i++ {\n\t\tdmap[stones[i]] = map[int]struct{}{}\n\t}\n\tfor _, cur_pos := range stones {\n\t\tsteps := dmap[cur_pos]\n\t\tfor step, _ := range steps {\n\t\t\tfor k := step - 1; k <= step + 1; k++ {\n\t\t\t\tif _, ok := dmap[cur_pos + k]; ok == true && k > 0 {\n\t\t\t\t\tdmap[cur_pos + k][k] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn len(dmap[stones[len(stones) - 1]]) != 0\n}\n```\n\n### 7.4 编辑距离\n[LeetCode No.72](https://leetcode-cn.com/problems/edit-distance/)\n\n> 题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。\n\n**思路**：使用dp[i][j]表示从word1[:i]转换为word2[:j]需要的最少次数，对于任意一个单词为空，所需次数为另一个单词的长度，只能通过增或删来达到相同。对于dp[i][j]，dp[i-1][j]表示从word2中删除一个字符得到，dp[i][j - 1]表示从word1中增加一个字符得到，dp[i-1][j-1]表示从word1中修改一个字符得到，对于word1[i] == word2[j]则不需要修改。那么dp[i][j]只能为上述三种情况的最小值。所以有状态转移方程：\n- 当word1[i] == word2[j]时 dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1)\n- 当word1[i] != word2[j]时 dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1\n\n`示例代码：`\n```go\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc minDistance(word1 string, word2 string) int {\n\tLFROM, LTO := len(word1), len(word2)\n\tdp := make([][]int, LFROM + 1)\n\tfor i := 0; i <= LFROM; i++ {\n\t\tdp[i] = make([]int, LTO + 1)\n\t\tdp[i][0] = i\n\t}\n\tfor j := 0; j <= LTO; j++ {\n\t\tdp[0][j] = j\n\t}\n\tfor i := 1; i <= LFROM; i++ {\n\t\tfor j := 1; j <= LTO; j++ {\n\t\t\tif word1[i - 1] == word2[j - 1] {\n\t\t\t\tdp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1)\n\t\t\t} else {\n\t\t\t\tdp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[LFROM][LTO]\n}\n```\n","slug":"算法-7-动态规划","published":1,"updated":"2023-03-19T13:57:12.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj17j000zhtfi7t0l4ewz","content":"<ul>\n<li>动态规划的关键思想在于将问题转换成较小的子问题，然后根据子问题的结果总结出一个状态转移方程，最后得到整个问题的解</li>\n</ul>\n<h3 id=\"7-1-打家劫舍\"><a href=\"#7-1-打家劫舍\" class=\"headerlink\" title=\"7.1 打家劫舍\"></a>7.1 打家劫舍</h3><p><a href=\"https://leetcode-cn.com/problems/house-robber/\">LeetCode No.198</a></p>\n<blockquote>\n<p>问题描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<br>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>\n</blockquote>\n<p><strong>思路</strong>：当设选第i个房屋，则不能选i-1，假设dp[i]表示前i个房屋能偷到的最高金额，则有 dp[i] &#x3D; max(dp[i - 1], dp[i - 2] + nums[i])</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rob</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>], dp[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>], max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>])</span><br><span class=\"line\">    ans := dp[<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">2</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        dp[i] = max(dp[i - <span class=\"number\">2</span>] + nums[i], dp[i - <span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ans &lt; dp[i] &#123;</span><br><span class=\"line\">            ans = dp[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-1-打家劫舍2\"><a href=\"#7-1-1-打家劫舍2\" class=\"headerlink\" title=\"7.1-1 打家劫舍2\"></a>7.1-1 打家劫舍2</h3><p><a href=\"https://leetcode-cn.com/problems/house-robber-ii/\">LeetCode No.213</a></p>\n<blockquote>\n<p>问题描述：房屋变成了环形排列，其他和7.1相同</p>\n</blockquote>\n<p><strong>思路</strong>：环形排列后，第一个和最后一个不能同时偷，可以转化为[0, n-1]和[1, n]两个单排街道较大值。同时，可以看到第i个问题的最大值只和第i-1和i-2有关，可以只用两个值来保存前两个结果，降低空间复杂度。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rob</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(dorob(nums[<span class=\"number\">1</span>:]), dorob(nums[:n<span class=\"number\">-1</span>]))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dorob</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fisrt, second := nums[<span class=\"number\">0</span>], max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>])</span><br><span class=\"line\">    ans := second</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">2</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        fisrt, second = second, max(fisrt + nums[i], second)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> second &gt; ans &#123;</span><br><span class=\"line\">            ans = second</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-2-分割等和子集\"><a href=\"#7-2-分割等和子集\" class=\"headerlink\" title=\"7.2 分割等和子集\"></a>7.2 分割等和子集</h3><p><a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/\">LeetCode No.416</a></p>\n<blockquote>\n<p>问题描述：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>输入: [1, 5, 11, 5]<br>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11]</p>\n</blockquote>\n<p><strong>思路</strong>：如果数组大小为奇数，结果必为false。然后该问题可以转化为背包大小为sum&#x2F;2的0-1背包问题，如果恰好能装满则结果为true。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">canPartition</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    sum := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        sum += n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> sum % <span class=\"number\">2</span> != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    W := sum &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">    dp := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里进行了空间优化，需要从后向前算，否则计算后面的时候前面的值已经改过，不是上一层的值了。</span></span><br><span class=\"line\">        <span class=\"comment\">// dp[i][w] = dp[i - 1][w] || dp[i-1][w-v]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := W; i &gt;= n; i-- &#123;</span><br><span class=\"line\">            dp[i] = dp[i] || dp[i - n]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[W]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-3-青蛙过河\"><a href=\"#7-3-青蛙过河\" class=\"headerlink\" title=\"7.3 青蛙过河\"></a>7.3 青蛙过河</h3><p><a href=\"https://leetcode-cn.com/problems/frog-jump/\">LeetCode No.403</a></p>\n<blockquote>\n<p>题目描述：一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。<br>给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。<br>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。<br><strong>输入</strong>：[0,1,3,5,6,8,12,17]<br>总共有8个石子。<br>第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,<br>第三个石子在序号为3的单元格的位置， 以此定义整个数组…<br>最后一个石子处于序号为17的单元格的位置。<br><strong>输出</strong>： true。即青蛙可以成功过河，按照如下方案跳跃：<br>跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着<br>跳2个单位到第4块石子, 然后跳3个单位到第6块石子,<br>跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。</p>\n</blockquote>\n<p><strong>思路</strong>：参考官方题解动态规划的方法，使用dmap[curpos] &#x3D; {jumps}表示到达当前curpos可以由jumps集合的任意一个步长一次到达当前位置，对于dmap[0] &#x3D; {0}，依次遍历每个石头的位置，对每个位置pos遍历jumps集合，对每个jump遍历k &#x3D; [jump-1，jump+1]，如果当前位置跳k补可以到达某个石头的位置（dmap中的存在key&#x3D;curpos+k），则将k添加到dmap[curpos+k]的集合。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">canCross</span><span class=\"params\">(stones []<span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 用集合模拟set，只需要键值当做集合的元素，value设为空结构</span></span><br><span class=\"line\">\tdmap := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">\tdmap[<span class=\"number\">0</span>] = <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">struct</span>&#123;&#125;&#123;<span class=\"number\">0</span>: &#123;&#125;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">len</span>(stones); i++ &#123;</span><br><span class=\"line\">\t\tdmap[stones[i]] = <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, cur_pos := <span class=\"keyword\">range</span> stones &#123;</span><br><span class=\"line\">\t\tsteps := dmap[cur_pos]</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> step, _ := <span class=\"keyword\">range</span> steps &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> k := step - <span class=\"number\">1</span>; k &lt;= step + <span class=\"number\">1</span>; k++ &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> _, ok := dmap[cur_pos + k]; ok == <span class=\"literal\">true</span> &amp;&amp; k &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tdmap[cur_pos + k][k] = <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(dmap[stones[<span class=\"built_in\">len</span>(stones) - <span class=\"number\">1</span>]]) != <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-4-编辑距离\"><a href=\"#7-4-编辑距离\" class=\"headerlink\" title=\"7.4 编辑距离\"></a>7.4 编辑距离</h3><p><a href=\"https://leetcode-cn.com/problems/edit-distance/\">LeetCode No.72</a></p>\n<blockquote>\n<p>题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。</p>\n</blockquote>\n<p><strong>思路</strong>：使用dp[i][j]表示从word1[:i]转换为word2[:j]需要的最少次数，对于任意一个单词为空，所需次数为另一个单词的长度，只能通过增或删来达到相同。对于dp[i][j]，dp[i-1][j]表示从word2中删除一个字符得到，dp[i][j - 1]表示从word1中增加一个字符得到，dp[i-1][j-1]表示从word1中修改一个字符得到，对于word1[i] &#x3D;&#x3D; word2[j]则不需要修改。那么dp[i][j]只能为上述三种情况的最小值。所以有状态转移方程：</p>\n<ul>\n<li>当word1[i] &#x3D;&#x3D; word2[j]时 dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1)</li>\n<li>当word1[i] !&#x3D; word2[j]时 dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt; y &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minDistance</span><span class=\"params\">(word1 <span class=\"type\">string</span>, word2 <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tLFROM, LTO := <span class=\"built_in\">len</span>(word1), <span class=\"built_in\">len</span>(word2)</span><br><span class=\"line\">\tdp := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, LFROM + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;= LFROM; i++ &#123;</span><br><span class=\"line\">\t\tdp[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, LTO + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tdp[i][<span class=\"number\">0</span>] = i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt;= LTO; j++ &#123;</span><br><span class=\"line\">\t\tdp[<span class=\"number\">0</span>][j] = j</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= LFROM; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j := <span class=\"number\">1</span>; j &lt;= LTO; j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> word1[i - <span class=\"number\">1</span>] == word2[j - <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = min(dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], min(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]) + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = min(dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], min(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>])) + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[LFROM][LTO]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>动态规划的关键思想在于将问题转换成较小的子问题，然后根据子问题的结果总结出一个状态转移方程，最后得到整个问题的解</li>\n</ul>\n<h3 id=\"7-1-打家劫舍\"><a href=\"#7-1-打家劫舍\" class=\"headerlink\" title=\"7.1 打家劫舍\"></a>7.1 打家劫舍</h3><p><a href=\"https://leetcode-cn.com/problems/house-robber/\">LeetCode No.198</a></p>\n<blockquote>\n<p>问题描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<br>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>\n</blockquote>\n<p><strong>思路</strong>：当设选第i个房屋，则不能选i-1，假设dp[i]表示前i个房屋能偷到的最高金额，则有 dp[i] &#x3D; max(dp[i - 1], dp[i - 2] + nums[i])</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rob</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>], dp[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>], max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>])</span><br><span class=\"line\">    ans := dp[<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">2</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        dp[i] = max(dp[i - <span class=\"number\">2</span>] + nums[i], dp[i - <span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ans &lt; dp[i] &#123;</span><br><span class=\"line\">            ans = dp[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-1-打家劫舍2\"><a href=\"#7-1-1-打家劫舍2\" class=\"headerlink\" title=\"7.1-1 打家劫舍2\"></a>7.1-1 打家劫舍2</h3><p><a href=\"https://leetcode-cn.com/problems/house-robber-ii/\">LeetCode No.213</a></p>\n<blockquote>\n<p>问题描述：房屋变成了环形排列，其他和7.1相同</p>\n</blockquote>\n<p><strong>思路</strong>：环形排列后，第一个和最后一个不能同时偷，可以转化为[0, n-1]和[1, n]两个单排街道较大值。同时，可以看到第i个问题的最大值只和第i-1和i-2有关，可以只用两个值来保存前两个结果，降低空间复杂度。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rob</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(dorob(nums[<span class=\"number\">1</span>:]), dorob(nums[:n<span class=\"number\">-1</span>]))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dorob</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fisrt, second := nums[<span class=\"number\">0</span>], max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>])</span><br><span class=\"line\">    ans := second</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">2</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        fisrt, second = second, max(fisrt + nums[i], second)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> second &gt; ans &#123;</span><br><span class=\"line\">            ans = second</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-2-分割等和子集\"><a href=\"#7-2-分割等和子集\" class=\"headerlink\" title=\"7.2 分割等和子集\"></a>7.2 分割等和子集</h3><p><a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/\">LeetCode No.416</a></p>\n<blockquote>\n<p>问题描述：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>输入: [1, 5, 11, 5]<br>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11]</p>\n</blockquote>\n<p><strong>思路</strong>：如果数组大小为奇数，结果必为false。然后该问题可以转化为背包大小为sum&#x2F;2的0-1背包问题，如果恰好能装满则结果为true。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">canPartition</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    sum := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        sum += n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> sum % <span class=\"number\">2</span> != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    W := sum &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">    dp := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里进行了空间优化，需要从后向前算，否则计算后面的时候前面的值已经改过，不是上一层的值了。</span></span><br><span class=\"line\">        <span class=\"comment\">// dp[i][w] = dp[i - 1][w] || dp[i-1][w-v]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := W; i &gt;= n; i-- &#123;</span><br><span class=\"line\">            dp[i] = dp[i] || dp[i - n]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[W]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-3-青蛙过河\"><a href=\"#7-3-青蛙过河\" class=\"headerlink\" title=\"7.3 青蛙过河\"></a>7.3 青蛙过河</h3><p><a href=\"https://leetcode-cn.com/problems/frog-jump/\">LeetCode No.403</a></p>\n<blockquote>\n<p>题目描述：一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。<br>给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。<br>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。<br><strong>输入</strong>：[0,1,3,5,6,8,12,17]<br>总共有8个石子。<br>第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,<br>第三个石子在序号为3的单元格的位置， 以此定义整个数组…<br>最后一个石子处于序号为17的单元格的位置。<br><strong>输出</strong>： true。即青蛙可以成功过河，按照如下方案跳跃：<br>跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着<br>跳2个单位到第4块石子, 然后跳3个单位到第6块石子,<br>跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。</p>\n</blockquote>\n<p><strong>思路</strong>：参考官方题解动态规划的方法，使用dmap[curpos] &#x3D; {jumps}表示到达当前curpos可以由jumps集合的任意一个步长一次到达当前位置，对于dmap[0] &#x3D; {0}，依次遍历每个石头的位置，对每个位置pos遍历jumps集合，对每个jump遍历k &#x3D; [jump-1，jump+1]，如果当前位置跳k补可以到达某个石头的位置（dmap中的存在key&#x3D;curpos+k），则将k添加到dmap[curpos+k]的集合。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">canCross</span><span class=\"params\">(stones []<span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 用集合模拟set，只需要键值当做集合的元素，value设为空结构</span></span><br><span class=\"line\">\tdmap := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">\tdmap[<span class=\"number\">0</span>] = <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">struct</span>&#123;&#125;&#123;<span class=\"number\">0</span>: &#123;&#125;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">len</span>(stones); i++ &#123;</span><br><span class=\"line\">\t\tdmap[stones[i]] = <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, cur_pos := <span class=\"keyword\">range</span> stones &#123;</span><br><span class=\"line\">\t\tsteps := dmap[cur_pos]</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> step, _ := <span class=\"keyword\">range</span> steps &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> k := step - <span class=\"number\">1</span>; k &lt;= step + <span class=\"number\">1</span>; k++ &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> _, ok := dmap[cur_pos + k]; ok == <span class=\"literal\">true</span> &amp;&amp; k &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tdmap[cur_pos + k][k] = <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(dmap[stones[<span class=\"built_in\">len</span>(stones) - <span class=\"number\">1</span>]]) != <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-4-编辑距离\"><a href=\"#7-4-编辑距离\" class=\"headerlink\" title=\"7.4 编辑距离\"></a>7.4 编辑距离</h3><p><a href=\"https://leetcode-cn.com/problems/edit-distance/\">LeetCode No.72</a></p>\n<blockquote>\n<p>题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。</p>\n</blockquote>\n<p><strong>思路</strong>：使用dp[i][j]表示从word1[:i]转换为word2[:j]需要的最少次数，对于任意一个单词为空，所需次数为另一个单词的长度，只能通过增或删来达到相同。对于dp[i][j]，dp[i-1][j]表示从word2中删除一个字符得到，dp[i][j - 1]表示从word1中增加一个字符得到，dp[i-1][j-1]表示从word1中修改一个字符得到，对于word1[i] &#x3D;&#x3D; word2[j]则不需要修改。那么dp[i][j]只能为上述三种情况的最小值。所以有状态转移方程：</p>\n<ul>\n<li>当word1[i] &#x3D;&#x3D; word2[j]时 dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1)</li>\n<li>当word1[i] !&#x3D; word2[j]时 dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt; y &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minDistance</span><span class=\"params\">(word1 <span class=\"type\">string</span>, word2 <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tLFROM, LTO := <span class=\"built_in\">len</span>(word1), <span class=\"built_in\">len</span>(word2)</span><br><span class=\"line\">\tdp := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, LFROM + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;= LFROM; i++ &#123;</span><br><span class=\"line\">\t\tdp[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, LTO + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tdp[i][<span class=\"number\">0</span>] = i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt;= LTO; j++ &#123;</span><br><span class=\"line\">\t\tdp[<span class=\"number\">0</span>][j] = j</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= LFROM; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j := <span class=\"number\">1</span>; j &lt;= LTO; j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> word1[i - <span class=\"number\">1</span>] == word2[j - <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = min(dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], min(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]) + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = min(dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], min(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>])) + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[LFROM][LTO]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(8): LRU 策略","date":"2023-03-19T13:58:05.000Z","_content":"\n[LeetCode No.146 LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)\n\nLRU（Least Recent Used）策略：优先淘汰最近最少使用的数据，常用于缓存淘汰机制，如Linux系统的内存淘汰、Redis的缓存淘汰等。\n\n## 基于哈希表和双向链表实现LRU\n核心思路是，利用双向链表存储键值对，哈希表存储键在链表中对应的节点指针，如下图所示\n![](https://upload-images.jianshu.io/upload_images/14151453-0372ff8cff5afd07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样的好处是使访问和更新操作时间复杂度都在O(1)。\n\n### PUT操作\n- 判断哈希表中key是否已存在，如果存在为修改操作：\n  1. 将链表节点修改为新的键值对\n  2. 将节点移到头部\n- 如果不存在为新增操作，此时如果容量已满，需要淘汰数据\n  1. 取出链表尾节点，删除哈希表中对应key\n  2. 删除链表尾节点\n  3. 在链表头部添加新的节点\n  4. 将新的链表头节点加到哈希表\n- 如果容量没有满，直接添加节点，执行上述步骤3、4即可\n\n### GET操作\n- 判断哈希表中key是否存在，如果存在将节点移动到链表头部，返回对应的值\n- 如果不存在直接返回nil值\n\n### Go语言实现\n使用Go内建map类型和container包的list（双向链表）\n```go\nimport (\n\t\"container/list\"\n)\n\ntype Pair struct {\n\tkey int\n\tval int\n}\n\ntype LRUCache struct {\n\tcap int\n\tlist *list.List\n\tkv map[int]*list.Element\n}\n\n\nfunc Constructor(capacity int) LRUCache {\n\treturn LRUCache{\n\t\tcap: capacity,\n\t\tlist: list.New(),\n\t\tkv: make(map[int]*list.Element),\n\t}\n}\n\n\nfunc (this *LRUCache) Get(key int) int {\n\tif v, ok := this.kv[key]; ok == true {\n\t\tthis.list.MoveToFront(v)\n\t\treturn v.Value.(Pair).val\n\t} else {\n\t\treturn -1\n\t}\n}\n\n\nfunc (this *LRUCache) Put(key int, value int)  {\n\tif elem, ok := this.kv[key]; ok == true {\n\t\telem.Value = Pair{key: key, val: value}\n\t\tthis.list.MoveToFront(elem)\n\t\treturn\n\t}\n\tif this.list.Len() >= this.cap {\n\t\tdelete(this.kv, this.list.Back().Value.(Pair).key)\n\t\tthis.list.Remove(this.list.Back())\n\t}\n\tthis.list.PushFront(Pair{key: key, val: value})\n\tthis.kv[key] = this.list.Front()\n}\n```\n","source":"_posts/2023/03-19-算法-8-LRU-策略.md","raw":"---\ntitle: '算法(8): LRU 策略'\ndate: 2023-03-19 21:58:05\ncategories:\n- [算法]\ntags:\n- leetcode\n- LRU\n- 缓存\n---\n\n[LeetCode No.146 LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)\n\nLRU（Least Recent Used）策略：优先淘汰最近最少使用的数据，常用于缓存淘汰机制，如Linux系统的内存淘汰、Redis的缓存淘汰等。\n\n## 基于哈希表和双向链表实现LRU\n核心思路是，利用双向链表存储键值对，哈希表存储键在链表中对应的节点指针，如下图所示\n![](https://upload-images.jianshu.io/upload_images/14151453-0372ff8cff5afd07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样的好处是使访问和更新操作时间复杂度都在O(1)。\n\n### PUT操作\n- 判断哈希表中key是否已存在，如果存在为修改操作：\n  1. 将链表节点修改为新的键值对\n  2. 将节点移到头部\n- 如果不存在为新增操作，此时如果容量已满，需要淘汰数据\n  1. 取出链表尾节点，删除哈希表中对应key\n  2. 删除链表尾节点\n  3. 在链表头部添加新的节点\n  4. 将新的链表头节点加到哈希表\n- 如果容量没有满，直接添加节点，执行上述步骤3、4即可\n\n### GET操作\n- 判断哈希表中key是否存在，如果存在将节点移动到链表头部，返回对应的值\n- 如果不存在直接返回nil值\n\n### Go语言实现\n使用Go内建map类型和container包的list（双向链表）\n```go\nimport (\n\t\"container/list\"\n)\n\ntype Pair struct {\n\tkey int\n\tval int\n}\n\ntype LRUCache struct {\n\tcap int\n\tlist *list.List\n\tkv map[int]*list.Element\n}\n\n\nfunc Constructor(capacity int) LRUCache {\n\treturn LRUCache{\n\t\tcap: capacity,\n\t\tlist: list.New(),\n\t\tkv: make(map[int]*list.Element),\n\t}\n}\n\n\nfunc (this *LRUCache) Get(key int) int {\n\tif v, ok := this.kv[key]; ok == true {\n\t\tthis.list.MoveToFront(v)\n\t\treturn v.Value.(Pair).val\n\t} else {\n\t\treturn -1\n\t}\n}\n\n\nfunc (this *LRUCache) Put(key int, value int)  {\n\tif elem, ok := this.kv[key]; ok == true {\n\t\telem.Value = Pair{key: key, val: value}\n\t\tthis.list.MoveToFront(elem)\n\t\treturn\n\t}\n\tif this.list.Len() >= this.cap {\n\t\tdelete(this.kv, this.list.Back().Value.(Pair).key)\n\t\tthis.list.Remove(this.list.Back())\n\t}\n\tthis.list.PushFront(Pair{key: key, val: value})\n\tthis.kv[key] = this.list.Front()\n}\n```\n","slug":"算法-8-LRU-策略","published":1,"updated":"2023-03-19T14:00:33.583Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj17j0012htfie4t076a3","content":"<p><a href=\"https://leetcode-cn.com/problems/lru-cache/\">LeetCode No.146 LRU缓存机制</a></p>\n<p>LRU（Least Recent Used）策略：优先淘汰最近最少使用的数据，常用于缓存淘汰机制，如Linux系统的内存淘汰、Redis的缓存淘汰等。</p>\n<h2 id=\"基于哈希表和双向链表实现LRU\"><a href=\"#基于哈希表和双向链表实现LRU\" class=\"headerlink\" title=\"基于哈希表和双向链表实现LRU\"></a>基于哈希表和双向链表实现LRU</h2><p>核心思路是，利用双向链表存储键值对，哈希表存储键在链表中对应的节点指针，如下图所示<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-0372ff8cff5afd07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-0372ff8cff5afd07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>这样的好处是使访问和更新操作时间复杂度都在O(1)。</p>\n<h3 id=\"PUT操作\"><a href=\"#PUT操作\" class=\"headerlink\" title=\"PUT操作\"></a>PUT操作</h3><ul>\n<li>判断哈希表中key是否已存在，如果存在为修改操作：<ol>\n<li>将链表节点修改为新的键值对</li>\n<li>将节点移到头部</li>\n</ol>\n</li>\n<li>如果不存在为新增操作，此时如果容量已满，需要淘汰数据<ol>\n<li>取出链表尾节点，删除哈希表中对应key</li>\n<li>删除链表尾节点</li>\n<li>在链表头部添加新的节点</li>\n<li>将新的链表头节点加到哈希表</li>\n</ol>\n</li>\n<li>如果容量没有满，直接添加节点，执行上述步骤3、4即可</li>\n</ul>\n<h3 id=\"GET操作\"><a href=\"#GET操作\" class=\"headerlink\" title=\"GET操作\"></a>GET操作</h3><ul>\n<li>判断哈希表中key是否存在，如果存在将节点移动到链表头部，返回对应的值</li>\n<li>如果不存在直接返回nil值</li>\n</ul>\n<h3 id=\"Go语言实现\"><a href=\"#Go语言实现\" class=\"headerlink\" title=\"Go语言实现\"></a>Go语言实现</h3><p>使用Go内建map类型和container包的list（双向链表）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;container/list&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Pair <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tkey <span class=\"type\">int</span></span><br><span class=\"line\">\tval <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LRUCache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cap</span> <span class=\"type\">int</span></span><br><span class=\"line\">\tlist *list.List</span><br><span class=\"line\">\tkv <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*list.Element</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(capacity <span class=\"type\">int</span>)</span></span> LRUCache &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> LRUCache&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cap</span>: capacity,</span><br><span class=\"line\">\t\tlist: list.New(),</span><br><span class=\"line\">\t\tkv: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*list.Element),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Get(key <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v, ok := this.kv[key]; ok == <span class=\"literal\">true</span> &#123;</span><br><span class=\"line\">\t\tthis.list.MoveToFront(v)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v.Value.(Pair).val</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Put(key <span class=\"type\">int</span>, value <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> elem, ok := this.kv[key]; ok == <span class=\"literal\">true</span> &#123;</span><br><span class=\"line\">\t\telem.Value = Pair&#123;key: key, val: value&#125;</span><br><span class=\"line\">\t\tthis.list.MoveToFront(elem)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> this.list.Len() &gt;= this.<span class=\"built_in\">cap</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">delete</span>(this.kv, this.list.Back().Value.(Pair).key)</span><br><span class=\"line\">\t\tthis.list.Remove(this.list.Back())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis.list.PushFront(Pair&#123;key: key, val: value&#125;)</span><br><span class=\"line\">\tthis.kv[key] = this.list.Front()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://leetcode-cn.com/problems/lru-cache/\">LeetCode No.146 LRU缓存机制</a></p>\n<p>LRU（Least Recent Used）策略：优先淘汰最近最少使用的数据，常用于缓存淘汰机制，如Linux系统的内存淘汰、Redis的缓存淘汰等。</p>\n<h2 id=\"基于哈希表和双向链表实现LRU\"><a href=\"#基于哈希表和双向链表实现LRU\" class=\"headerlink\" title=\"基于哈希表和双向链表实现LRU\"></a>基于哈希表和双向链表实现LRU</h2><p>核心思路是，利用双向链表存储键值对，哈希表存储键在链表中对应的节点指针，如下图所示<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-0372ff8cff5afd07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>这样的好处是使访问和更新操作时间复杂度都在O(1)。</p>\n<h3 id=\"PUT操作\"><a href=\"#PUT操作\" class=\"headerlink\" title=\"PUT操作\"></a>PUT操作</h3><ul>\n<li>判断哈希表中key是否已存在，如果存在为修改操作：<ol>\n<li>将链表节点修改为新的键值对</li>\n<li>将节点移到头部</li>\n</ol>\n</li>\n<li>如果不存在为新增操作，此时如果容量已满，需要淘汰数据<ol>\n<li>取出链表尾节点，删除哈希表中对应key</li>\n<li>删除链表尾节点</li>\n<li>在链表头部添加新的节点</li>\n<li>将新的链表头节点加到哈希表</li>\n</ol>\n</li>\n<li>如果容量没有满，直接添加节点，执行上述步骤3、4即可</li>\n</ul>\n<h3 id=\"GET操作\"><a href=\"#GET操作\" class=\"headerlink\" title=\"GET操作\"></a>GET操作</h3><ul>\n<li>判断哈希表中key是否存在，如果存在将节点移动到链表头部，返回对应的值</li>\n<li>如果不存在直接返回nil值</li>\n</ul>\n<h3 id=\"Go语言实现\"><a href=\"#Go语言实现\" class=\"headerlink\" title=\"Go语言实现\"></a>Go语言实现</h3><p>使用Go内建map类型和container包的list（双向链表）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;container/list&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Pair <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tkey <span class=\"type\">int</span></span><br><span class=\"line\">\tval <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LRUCache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cap</span> <span class=\"type\">int</span></span><br><span class=\"line\">\tlist *list.List</span><br><span class=\"line\">\tkv <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*list.Element</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(capacity <span class=\"type\">int</span>)</span></span> LRUCache &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> LRUCache&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cap</span>: capacity,</span><br><span class=\"line\">\t\tlist: list.New(),</span><br><span class=\"line\">\t\tkv: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*list.Element),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Get(key <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v, ok := this.kv[key]; ok == <span class=\"literal\">true</span> &#123;</span><br><span class=\"line\">\t\tthis.list.MoveToFront(v)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v.Value.(Pair).val</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Put(key <span class=\"type\">int</span>, value <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> elem, ok := this.kv[key]; ok == <span class=\"literal\">true</span> &#123;</span><br><span class=\"line\">\t\telem.Value = Pair&#123;key: key, val: value&#125;</span><br><span class=\"line\">\t\tthis.list.MoveToFront(elem)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> this.list.Len() &gt;= this.<span class=\"built_in\">cap</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">delete</span>(this.kv, this.list.Back().Value.(Pair).key)</span><br><span class=\"line\">\t\tthis.list.Remove(this.list.Back())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis.list.PushFront(Pair&#123;key: key, val: value&#125;)</span><br><span class=\"line\">\tthis.kv[key] = this.list.Front()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"HTTPS原理详解","date":"2023-03-25T06:43:24.000Z","_content":"\nWeb应用存在HTTP和HTTPS两种通信方式，HTTP默认端口80，数据以明文传输，HTTPS默认端口443，数据加密传输。\n\n## HTTPS协议\nHTTPS实际上并不是一种新的网络协议，是HTTP的基础上加了SSL层，数据的加密就是在SSL层完成的。\n![](https://upload-images.jianshu.io/upload_images/14151453-4915c1ecfe442f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 数据传输方式\n\n### 明文传输\n客户端和服务器已明文方式传输数据，没有安全性，数据再传输过程中可能被劫持和篡改\n![](https://upload-images.jianshu.io/upload_images/14151453-af0efb8a2b3599db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 对称加密传输\n对称加密算法：双方使用同一秘钥对数据进行加解密（AES、DES）\n![](https://upload-images.jianshu.io/upload_images/14151453-046d2c536baae247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**特点**：\n- 如果不知道秘钥，是无法解出对应的明文，但是如果所有客户端都用相同的秘钥，相当于没有加密，坏人也可以作为一个用户拿到秘钥。\n- 加解密性能高\n\n一种改进的方案是每个客户端先协商一个加密算法和秘钥，不同客户端使用不同的算法和秘钥，这就坏人即使作为一个用户也不知道别的用户的秘钥。但是这种方式协商秘钥的过程是公开明文的，坏人也有办法窃取到秘钥的，仍然存在风险。\n\n### 非对称加密传输\n非对称加密算法：加密解密采用不同的秘钥，私钥加密后的密文，所有的公钥都可以解密，公钥加密后的密文只有私钥能解密。私钥通常只有一个人有，公钥可以公开发给所有人。（常见算法：RSA）\n![](https://upload-images.jianshu.io/upload_images/14151453-eefe11cf0a2b22f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n**特点**：\n- 只要把私钥保存在服务器，公钥发给客户端，那么客户端向服务器发送的数据就是安全的，但是服务器向客户端发送的数据坏人也可以通过公钥解密\n- 加解密消耗的时间较长，传输效率会降低\n\n### HTTPS（对称加密+非对称加密）\n![](https://upload-images.jianshu.io/upload_images/14151453-9a21634026ce4d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**特点**：\n- 使用非对称加密传输协商一个对称加密算法和秘钥\n- 使用对称加密算法对数据加密传输\n- 数据双向安全，且效率较高\n\n## CA机构和数字证书\n从前面可以看到，协商阶段时候用非对称加密，客户端一开始就要持有公钥，那么客户端如何安全的获取公钥呢？\n如果服务端直接将公钥发给客户端，中间可能被坏人劫持，返回一个假公钥，客户端使用假公钥进行加密后请求，坏人就可以使用假私钥解出明文，篡改内容后再使用真公钥加密后请求到服务器，这时服务器拿到的是被篡改后的数据。\n![](https://upload-images.jianshu.io/upload_images/14151453-fb5c49e4b5019e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n数字证书和CA机构就是用来保证服务器安全的发送公钥给客户端的。\n**校验过程**\n1. 读取证书中的所有者，有效期等信息进行校验\n2. 查找系统内置的受信任证书发布机构CA，与服务器下发的证书中的CA对比，校验是否是合法机构颁发\n3. 如果找不到，浏览器报错警告证书不可信\n4. 如果找到了：\n- 对证书里的数字签名使用公钥解密得到明文的hash摘要\n- 浏览器使用相同的hash算法计算明文的hash值，将这个值与上述计算的摘要对比验证证书的合法性。\n\n## 总结\n一个完整的HTTPS请求流程如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-06d256f8dff32472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 参考\n【1】[【掘金】深入理解HTTPS工作原理](https://juejin.cn/post/6844903830916694030)\n","source":"_posts/2023/03-25-HTTPS原理详解.md","raw":"---\ntitle: HTTPS原理详解\ndate: 2023-03-25 14:43:24\ncategories:\n- [计算机网络]\ntags:\n- HTTPS\n---\n\nWeb应用存在HTTP和HTTPS两种通信方式，HTTP默认端口80，数据以明文传输，HTTPS默认端口443，数据加密传输。\n\n## HTTPS协议\nHTTPS实际上并不是一种新的网络协议，是HTTP的基础上加了SSL层，数据的加密就是在SSL层完成的。\n![](https://upload-images.jianshu.io/upload_images/14151453-4915c1ecfe442f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 数据传输方式\n\n### 明文传输\n客户端和服务器已明文方式传输数据，没有安全性，数据再传输过程中可能被劫持和篡改\n![](https://upload-images.jianshu.io/upload_images/14151453-af0efb8a2b3599db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 对称加密传输\n对称加密算法：双方使用同一秘钥对数据进行加解密（AES、DES）\n![](https://upload-images.jianshu.io/upload_images/14151453-046d2c536baae247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**特点**：\n- 如果不知道秘钥，是无法解出对应的明文，但是如果所有客户端都用相同的秘钥，相当于没有加密，坏人也可以作为一个用户拿到秘钥。\n- 加解密性能高\n\n一种改进的方案是每个客户端先协商一个加密算法和秘钥，不同客户端使用不同的算法和秘钥，这就坏人即使作为一个用户也不知道别的用户的秘钥。但是这种方式协商秘钥的过程是公开明文的，坏人也有办法窃取到秘钥的，仍然存在风险。\n\n### 非对称加密传输\n非对称加密算法：加密解密采用不同的秘钥，私钥加密后的密文，所有的公钥都可以解密，公钥加密后的密文只有私钥能解密。私钥通常只有一个人有，公钥可以公开发给所有人。（常见算法：RSA）\n![](https://upload-images.jianshu.io/upload_images/14151453-eefe11cf0a2b22f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n**特点**：\n- 只要把私钥保存在服务器，公钥发给客户端，那么客户端向服务器发送的数据就是安全的，但是服务器向客户端发送的数据坏人也可以通过公钥解密\n- 加解密消耗的时间较长，传输效率会降低\n\n### HTTPS（对称加密+非对称加密）\n![](https://upload-images.jianshu.io/upload_images/14151453-9a21634026ce4d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**特点**：\n- 使用非对称加密传输协商一个对称加密算法和秘钥\n- 使用对称加密算法对数据加密传输\n- 数据双向安全，且效率较高\n\n## CA机构和数字证书\n从前面可以看到，协商阶段时候用非对称加密，客户端一开始就要持有公钥，那么客户端如何安全的获取公钥呢？\n如果服务端直接将公钥发给客户端，中间可能被坏人劫持，返回一个假公钥，客户端使用假公钥进行加密后请求，坏人就可以使用假私钥解出明文，篡改内容后再使用真公钥加密后请求到服务器，这时服务器拿到的是被篡改后的数据。\n![](https://upload-images.jianshu.io/upload_images/14151453-fb5c49e4b5019e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n数字证书和CA机构就是用来保证服务器安全的发送公钥给客户端的。\n**校验过程**\n1. 读取证书中的所有者，有效期等信息进行校验\n2. 查找系统内置的受信任证书发布机构CA，与服务器下发的证书中的CA对比，校验是否是合法机构颁发\n3. 如果找不到，浏览器报错警告证书不可信\n4. 如果找到了：\n- 对证书里的数字签名使用公钥解密得到明文的hash摘要\n- 浏览器使用相同的hash算法计算明文的hash值，将这个值与上述计算的摘要对比验证证书的合法性。\n\n## 总结\n一个完整的HTTPS请求流程如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-06d256f8dff32472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 参考\n【1】[【掘金】深入理解HTTPS工作原理](https://juejin.cn/post/6844903830916694030)\n","slug":"HTTPS原理详解","published":1,"updated":"2023-03-25T06:58:23.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj17k0015htfi9ocee1l6","content":"<p>Web应用存在HTTP和HTTPS两种通信方式，HTTP默认端口80，数据以明文传输，HTTPS默认端口443，数据加密传输。</p>\n<h2 id=\"HTTPS协议\"><a href=\"#HTTPS协议\" class=\"headerlink\" title=\"HTTPS协议\"></a>HTTPS协议</h2><p>HTTPS实际上并不是一种新的网络协议，是HTTP的基础上加了SSL层，数据的加密就是在SSL层完成的。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-4915c1ecfe442f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-4915c1ecfe442f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h2 id=\"数据传输方式\"><a href=\"#数据传输方式\" class=\"headerlink\" title=\"数据传输方式\"></a>数据传输方式</h2><h3 id=\"明文传输\"><a href=\"#明文传输\" class=\"headerlink\" title=\"明文传输\"></a>明文传输</h3><p>客户端和服务器已明文方式传输数据，没有安全性，数据再传输过程中可能被劫持和篡改<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-af0efb8a2b3599db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-af0efb8a2b3599db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h3 id=\"对称加密传输\"><a href=\"#对称加密传输\" class=\"headerlink\" title=\"对称加密传输\"></a>对称加密传输</h3><p>对称加密算法：双方使用同一秘钥对数据进行加解密（AES、DES）<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-046d2c536baae247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-046d2c536baae247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br><strong>特点</strong>：</p>\n<ul>\n<li>如果不知道秘钥，是无法解出对应的明文，但是如果所有客户端都用相同的秘钥，相当于没有加密，坏人也可以作为一个用户拿到秘钥。</li>\n<li>加解密性能高</li>\n</ul>\n<p>一种改进的方案是每个客户端先协商一个加密算法和秘钥，不同客户端使用不同的算法和秘钥，这就坏人即使作为一个用户也不知道别的用户的秘钥。但是这种方式协商秘钥的过程是公开明文的，坏人也有办法窃取到秘钥的，仍然存在风险。</p>\n<h3 id=\"非对称加密传输\"><a href=\"#非对称加密传输\" class=\"headerlink\" title=\"非对称加密传输\"></a>非对称加密传输</h3><p>非对称加密算法：加密解密采用不同的秘钥，私钥加密后的密文，所有的公钥都可以解密，公钥加密后的密文只有私钥能解密。私钥通常只有一个人有，公钥可以公开发给所有人。（常见算法：RSA）<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-eefe11cf0a2b22f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-eefe11cf0a2b22f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>只要把私钥保存在服务器，公钥发给客户端，那么客户端向服务器发送的数据就是安全的，但是服务器向客户端发送的数据坏人也可以通过公钥解密</li>\n<li>加解密消耗的时间较长，传输效率会降低</li>\n</ul>\n<h3 id=\"HTTPS（对称加密-非对称加密）\"><a href=\"#HTTPS（对称加密-非对称加密）\" class=\"headerlink\" title=\"HTTPS（对称加密+非对称加密）\"></a>HTTPS（对称加密+非对称加密）</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-9a21634026ce4d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-9a21634026ce4d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>使用非对称加密传输协商一个对称加密算法和秘钥</li>\n<li>使用对称加密算法对数据加密传输</li>\n<li>数据双向安全，且效率较高</li>\n</ul>\n<h2 id=\"CA机构和数字证书\"><a href=\"#CA机构和数字证书\" class=\"headerlink\" title=\"CA机构和数字证书\"></a>CA机构和数字证书</h2><p>从前面可以看到，协商阶段时候用非对称加密，客户端一开始就要持有公钥，那么客户端如何安全的获取公钥呢？<br>如果服务端直接将公钥发给客户端，中间可能被坏人劫持，返回一个假公钥，客户端使用假公钥进行加密后请求，坏人就可以使用假私钥解出明文，篡改内容后再使用真公钥加密后请求到服务器，这时服务器拿到的是被篡改后的数据。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-fb5c49e4b5019e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-fb5c49e4b5019e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>数字证书和CA机构就是用来保证服务器安全的发送公钥给客户端的。<br><strong>校验过程</strong></p>\n<ol>\n<li>读取证书中的所有者，有效期等信息进行校验</li>\n<li>查找系统内置的受信任证书发布机构CA，与服务器下发的证书中的CA对比，校验是否是合法机构颁发</li>\n<li>如果找不到，浏览器报错警告证书不可信</li>\n<li>如果找到了：</li>\n</ol>\n<ul>\n<li>对证书里的数字签名使用公钥解密得到明文的hash摘要</li>\n<li>浏览器使用相同的hash算法计算明文的hash值，将这个值与上述计算的摘要对比验证证书的合法性。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一个完整的HTTPS请求流程如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-06d256f8dff32472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-06d256f8dff32472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://juejin.cn/post/6844903830916694030\">【掘金】深入理解HTTPS工作原理</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Web应用存在HTTP和HTTPS两种通信方式，HTTP默认端口80，数据以明文传输，HTTPS默认端口443，数据加密传输。</p>\n<h2 id=\"HTTPS协议\"><a href=\"#HTTPS协议\" class=\"headerlink\" title=\"HTTPS协议\"></a>HTTPS协议</h2><p>HTTPS实际上并不是一种新的网络协议，是HTTP的基础上加了SSL层，数据的加密就是在SSL层完成的。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-4915c1ecfe442f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h2 id=\"数据传输方式\"><a href=\"#数据传输方式\" class=\"headerlink\" title=\"数据传输方式\"></a>数据传输方式</h2><h3 id=\"明文传输\"><a href=\"#明文传输\" class=\"headerlink\" title=\"明文传输\"></a>明文传输</h3><p>客户端和服务器已明文方式传输数据，没有安全性，数据再传输过程中可能被劫持和篡改<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-af0efb8a2b3599db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h3 id=\"对称加密传输\"><a href=\"#对称加密传输\" class=\"headerlink\" title=\"对称加密传输\"></a>对称加密传输</h3><p>对称加密算法：双方使用同一秘钥对数据进行加解密（AES、DES）<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-046d2c536baae247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br><strong>特点</strong>：</p>\n<ul>\n<li>如果不知道秘钥，是无法解出对应的明文，但是如果所有客户端都用相同的秘钥，相当于没有加密，坏人也可以作为一个用户拿到秘钥。</li>\n<li>加解密性能高</li>\n</ul>\n<p>一种改进的方案是每个客户端先协商一个加密算法和秘钥，不同客户端使用不同的算法和秘钥，这就坏人即使作为一个用户也不知道别的用户的秘钥。但是这种方式协商秘钥的过程是公开明文的，坏人也有办法窃取到秘钥的，仍然存在风险。</p>\n<h3 id=\"非对称加密传输\"><a href=\"#非对称加密传输\" class=\"headerlink\" title=\"非对称加密传输\"></a>非对称加密传输</h3><p>非对称加密算法：加密解密采用不同的秘钥，私钥加密后的密文，所有的公钥都可以解密，公钥加密后的密文只有私钥能解密。私钥通常只有一个人有，公钥可以公开发给所有人。（常见算法：RSA）<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-eefe11cf0a2b22f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>只要把私钥保存在服务器，公钥发给客户端，那么客户端向服务器发送的数据就是安全的，但是服务器向客户端发送的数据坏人也可以通过公钥解密</li>\n<li>加解密消耗的时间较长，传输效率会降低</li>\n</ul>\n<h3 id=\"HTTPS（对称加密-非对称加密）\"><a href=\"#HTTPS（对称加密-非对称加密）\" class=\"headerlink\" title=\"HTTPS（对称加密+非对称加密）\"></a>HTTPS（对称加密+非对称加密）</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-9a21634026ce4d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>使用非对称加密传输协商一个对称加密算法和秘钥</li>\n<li>使用对称加密算法对数据加密传输</li>\n<li>数据双向安全，且效率较高</li>\n</ul>\n<h2 id=\"CA机构和数字证书\"><a href=\"#CA机构和数字证书\" class=\"headerlink\" title=\"CA机构和数字证书\"></a>CA机构和数字证书</h2><p>从前面可以看到，协商阶段时候用非对称加密，客户端一开始就要持有公钥，那么客户端如何安全的获取公钥呢？<br>如果服务端直接将公钥发给客户端，中间可能被坏人劫持，返回一个假公钥，客户端使用假公钥进行加密后请求，坏人就可以使用假私钥解出明文，篡改内容后再使用真公钥加密后请求到服务器，这时服务器拿到的是被篡改后的数据。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-fb5c49e4b5019e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>数字证书和CA机构就是用来保证服务器安全的发送公钥给客户端的。<br><strong>校验过程</strong></p>\n<ol>\n<li>读取证书中的所有者，有效期等信息进行校验</li>\n<li>查找系统内置的受信任证书发布机构CA，与服务器下发的证书中的CA对比，校验是否是合法机构颁发</li>\n<li>如果找不到，浏览器报错警告证书不可信</li>\n<li>如果找到了：</li>\n</ol>\n<ul>\n<li>对证书里的数字签名使用公钥解密得到明文的hash摘要</li>\n<li>浏览器使用相同的hash算法计算明文的hash值，将这个值与上述计算的摘要对比验证证书的合法性。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一个完整的HTTPS请求流程如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-06d256f8dff32472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://juejin.cn/post/6844903830916694030\">【掘金】深入理解HTTPS工作原理</a></p>\n"},{"title":"Session和Cookie","date":"2023-03-25T06:43:05.000Z","_content":"\n我们知道HTTP协议是无状态的，那么在Web开发中如何做好用户的整个浏览过程的控制，最经典的解决方案就是使用Cookie和Session。\nCookie是客户端的机制，把用户数据缓存在客户端，而Session是服务端的机制，每个用户都会被分配一个唯一的SessionID，可以通过url传输或保存在客户端的Cookie中，也可以将Session保存在数据库中，比如Redis中。\n\n## Session和Cookie是怎么来的？\n假如你在浏览器上从来没有登录过GitHub，当你第一次登录的时候需要输入用户名和密码进行验证，通过验证后会调到个人首页，那么在登录成功后你点击你的某个代码仓库的时候服务器如何验证你的身份呢？因为HTTP协议是无状态的，服务器并不知道你上次已经验证过了，一种方法是每次请求都带上用户名和密码，这显然会导致用户体验极差。那么就需要再客户端或服务器上保存身份信息了，于是Cookie和Session就产生了。\n\n### Cookie\n\n#### Cookie原理\nCookie就是本地计算机保存一些用户操作的历史信息，用户再次访问时在HTTP请求头中带上Cookie信息，服务端就可以对其进行验证。\n![](https://upload-images.jianshu.io/upload_images/14151453-e9dd7894922a2adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 数据内容\nCookie本质上是由浏览器管理存储在客户端的一小段文本，Chrome浏览器可以使用EditThisCookie插件来管理Cookie，如下图所示。\n![](https://upload-images.jianshu.io/upload_images/14151453-ae9b877211f0b906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 会话Cookie和持久Cookie\n- 会话Cookie：Cookie是有有效期的，如果不设置过期时间，则表示这个Cookie的生命周期从创建到浏览器关闭为止，只要关闭浏览器Cookie就消失了，相当于数据保存在内存中，进程结束就丢失了\n- 持久Cookie：如果设置了过期时间，浏览器会把Cookie数据保存到磁盘上，关闭浏览器再次打开依然有效，直到Cookie过期，浏览器通常都使用的持久Cookie。\n\n### Session\n\n#### Session原理\nSession是服务器用来保存用户操作的历史信息的，使用SessionID来标识Session，SessionID由服务器产生，保证随机性和唯一性，相当于一个随机秘钥，避免在传输中暴露用户真实密码，但是服务器仍要将请求对Session进行对应，需要借助Cookie保存客户端的标识（SessionID）。\n![](https://upload-images.jianshu.io/upload_images/14151453-849911fdca5ee4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当服务器需要对某个请求创建Session的时候，首先检查这个客户端的请求是否包含了SessionID，如果已经包含则表示次客户端之前已经创建过，只需要根据SessionID查询对应的Session。如果请求没有携带SessionID，则会生成一个Session和对应的SessionID，同时在本次响应中返回SessionID。\n\n## 参考\n【1】[build-web-application-with-golang](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md)\n","source":"_posts/2023/03-25-Session和Cookie.md","raw":"---\ntitle: Session和Cookie\ndate: 2023-03-25 14:43:05\ncategories:\n- [计算机网络]\ntags:\n- Session\n- Cookie\n---\n\n我们知道HTTP协议是无状态的，那么在Web开发中如何做好用户的整个浏览过程的控制，最经典的解决方案就是使用Cookie和Session。\nCookie是客户端的机制，把用户数据缓存在客户端，而Session是服务端的机制，每个用户都会被分配一个唯一的SessionID，可以通过url传输或保存在客户端的Cookie中，也可以将Session保存在数据库中，比如Redis中。\n\n## Session和Cookie是怎么来的？\n假如你在浏览器上从来没有登录过GitHub，当你第一次登录的时候需要输入用户名和密码进行验证，通过验证后会调到个人首页，那么在登录成功后你点击你的某个代码仓库的时候服务器如何验证你的身份呢？因为HTTP协议是无状态的，服务器并不知道你上次已经验证过了，一种方法是每次请求都带上用户名和密码，这显然会导致用户体验极差。那么就需要再客户端或服务器上保存身份信息了，于是Cookie和Session就产生了。\n\n### Cookie\n\n#### Cookie原理\nCookie就是本地计算机保存一些用户操作的历史信息，用户再次访问时在HTTP请求头中带上Cookie信息，服务端就可以对其进行验证。\n![](https://upload-images.jianshu.io/upload_images/14151453-e9dd7894922a2adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 数据内容\nCookie本质上是由浏览器管理存储在客户端的一小段文本，Chrome浏览器可以使用EditThisCookie插件来管理Cookie，如下图所示。\n![](https://upload-images.jianshu.io/upload_images/14151453-ae9b877211f0b906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 会话Cookie和持久Cookie\n- 会话Cookie：Cookie是有有效期的，如果不设置过期时间，则表示这个Cookie的生命周期从创建到浏览器关闭为止，只要关闭浏览器Cookie就消失了，相当于数据保存在内存中，进程结束就丢失了\n- 持久Cookie：如果设置了过期时间，浏览器会把Cookie数据保存到磁盘上，关闭浏览器再次打开依然有效，直到Cookie过期，浏览器通常都使用的持久Cookie。\n\n### Session\n\n#### Session原理\nSession是服务器用来保存用户操作的历史信息的，使用SessionID来标识Session，SessionID由服务器产生，保证随机性和唯一性，相当于一个随机秘钥，避免在传输中暴露用户真实密码，但是服务器仍要将请求对Session进行对应，需要借助Cookie保存客户端的标识（SessionID）。\n![](https://upload-images.jianshu.io/upload_images/14151453-849911fdca5ee4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当服务器需要对某个请求创建Session的时候，首先检查这个客户端的请求是否包含了SessionID，如果已经包含则表示次客户端之前已经创建过，只需要根据SessionID查询对应的Session。如果请求没有携带SessionID，则会生成一个Session和对应的SessionID，同时在本次响应中返回SessionID。\n\n## 参考\n【1】[build-web-application-with-golang](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md)\n","slug":"Session和Cookie","published":1,"updated":"2023-03-25T06:58:16.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj17m0018htfihaxs5lor","content":"<p>我们知道HTTP协议是无状态的，那么在Web开发中如何做好用户的整个浏览过程的控制，最经典的解决方案就是使用Cookie和Session。<br>Cookie是客户端的机制，把用户数据缓存在客户端，而Session是服务端的机制，每个用户都会被分配一个唯一的SessionID，可以通过url传输或保存在客户端的Cookie中，也可以将Session保存在数据库中，比如Redis中。</p>\n<h2 id=\"Session和Cookie是怎么来的？\"><a href=\"#Session和Cookie是怎么来的？\" class=\"headerlink\" title=\"Session和Cookie是怎么来的？\"></a>Session和Cookie是怎么来的？</h2><p>假如你在浏览器上从来没有登录过GitHub，当你第一次登录的时候需要输入用户名和密码进行验证，通过验证后会调到个人首页，那么在登录成功后你点击你的某个代码仓库的时候服务器如何验证你的身份呢？因为HTTP协议是无状态的，服务器并不知道你上次已经验证过了，一种方法是每次请求都带上用户名和密码，这显然会导致用户体验极差。那么就需要再客户端或服务器上保存身份信息了，于是Cookie和Session就产生了。</p>\n<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><h4 id=\"Cookie原理\"><a href=\"#Cookie原理\" class=\"headerlink\" title=\"Cookie原理\"></a>Cookie原理</h4><p>Cookie就是本地计算机保存一些用户操作的历史信息，用户再次访问时在HTTP请求头中带上Cookie信息，服务端就可以对其进行验证。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-e9dd7894922a2adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-e9dd7894922a2adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h4 id=\"数据内容\"><a href=\"#数据内容\" class=\"headerlink\" title=\"数据内容\"></a>数据内容</h4><p>Cookie本质上是由浏览器管理存储在客户端的一小段文本，Chrome浏览器可以使用EditThisCookie插件来管理Cookie，如下图所示。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-ae9b877211f0b906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-ae9b877211f0b906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h4 id=\"会话Cookie和持久Cookie\"><a href=\"#会话Cookie和持久Cookie\" class=\"headerlink\" title=\"会话Cookie和持久Cookie\"></a>会话Cookie和持久Cookie</h4><ul>\n<li>会话Cookie：Cookie是有有效期的，如果不设置过期时间，则表示这个Cookie的生命周期从创建到浏览器关闭为止，只要关闭浏览器Cookie就消失了，相当于数据保存在内存中，进程结束就丢失了</li>\n<li>持久Cookie：如果设置了过期时间，浏览器会把Cookie数据保存到磁盘上，关闭浏览器再次打开依然有效，直到Cookie过期，浏览器通常都使用的持久Cookie。</li>\n</ul>\n<h3 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h3><h4 id=\"Session原理\"><a href=\"#Session原理\" class=\"headerlink\" title=\"Session原理\"></a>Session原理</h4><p>Session是服务器用来保存用户操作的历史信息的，使用SessionID来标识Session，SessionID由服务器产生，保证随机性和唯一性，相当于一个随机秘钥，避免在传输中暴露用户真实密码，但是服务器仍要将请求对Session进行对应，需要借助Cookie保存客户端的标识（SessionID）。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-849911fdca5ee4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-849911fdca5ee4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>当服务器需要对某个请求创建Session的时候，首先检查这个客户端的请求是否包含了SessionID，如果已经包含则表示次客户端之前已经创建过，只需要根据SessionID查询对应的Session。如果请求没有携带SessionID，则会生成一个Session和对应的SessionID，同时在本次响应中返回SessionID。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md\">build-web-application-with-golang</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们知道HTTP协议是无状态的，那么在Web开发中如何做好用户的整个浏览过程的控制，最经典的解决方案就是使用Cookie和Session。<br>Cookie是客户端的机制，把用户数据缓存在客户端，而Session是服务端的机制，每个用户都会被分配一个唯一的SessionID，可以通过url传输或保存在客户端的Cookie中，也可以将Session保存在数据库中，比如Redis中。</p>\n<h2 id=\"Session和Cookie是怎么来的？\"><a href=\"#Session和Cookie是怎么来的？\" class=\"headerlink\" title=\"Session和Cookie是怎么来的？\"></a>Session和Cookie是怎么来的？</h2><p>假如你在浏览器上从来没有登录过GitHub，当你第一次登录的时候需要输入用户名和密码进行验证，通过验证后会调到个人首页，那么在登录成功后你点击你的某个代码仓库的时候服务器如何验证你的身份呢？因为HTTP协议是无状态的，服务器并不知道你上次已经验证过了，一种方法是每次请求都带上用户名和密码，这显然会导致用户体验极差。那么就需要再客户端或服务器上保存身份信息了，于是Cookie和Session就产生了。</p>\n<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><h4 id=\"Cookie原理\"><a href=\"#Cookie原理\" class=\"headerlink\" title=\"Cookie原理\"></a>Cookie原理</h4><p>Cookie就是本地计算机保存一些用户操作的历史信息，用户再次访问时在HTTP请求头中带上Cookie信息，服务端就可以对其进行验证。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-e9dd7894922a2adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h4 id=\"数据内容\"><a href=\"#数据内容\" class=\"headerlink\" title=\"数据内容\"></a>数据内容</h4><p>Cookie本质上是由浏览器管理存储在客户端的一小段文本，Chrome浏览器可以使用EditThisCookie插件来管理Cookie，如下图所示。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-ae9b877211f0b906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h4 id=\"会话Cookie和持久Cookie\"><a href=\"#会话Cookie和持久Cookie\" class=\"headerlink\" title=\"会话Cookie和持久Cookie\"></a>会话Cookie和持久Cookie</h4><ul>\n<li>会话Cookie：Cookie是有有效期的，如果不设置过期时间，则表示这个Cookie的生命周期从创建到浏览器关闭为止，只要关闭浏览器Cookie就消失了，相当于数据保存在内存中，进程结束就丢失了</li>\n<li>持久Cookie：如果设置了过期时间，浏览器会把Cookie数据保存到磁盘上，关闭浏览器再次打开依然有效，直到Cookie过期，浏览器通常都使用的持久Cookie。</li>\n</ul>\n<h3 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h3><h4 id=\"Session原理\"><a href=\"#Session原理\" class=\"headerlink\" title=\"Session原理\"></a>Session原理</h4><p>Session是服务器用来保存用户操作的历史信息的，使用SessionID来标识Session，SessionID由服务器产生，保证随机性和唯一性，相当于一个随机秘钥，避免在传输中暴露用户真实密码，但是服务器仍要将请求对Session进行对应，需要借助Cookie保存客户端的标识（SessionID）。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-849911fdca5ee4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>当服务器需要对某个请求创建Session的时候，首先检查这个客户端的请求是否包含了SessionID，如果已经包含则表示次客户端之前已经创建过，只需要根据SessionID查询对应的Session。如果请求没有携带SessionID，则会生成一个Session和对应的SessionID，同时在本次响应中返回SessionID。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md\">build-web-application-with-golang</a></p>\n"},{"title":"TCP是如何实现可靠传输的？","date":"2023-03-25T06:43:37.000Z","_content":"\n在计算机网络的经典五层协议中，TCP属于运输层，实现了进程间的通信，保证了数据的可靠传输，属于计算机网络协议族中最重要的协议之一，那么TCP是如何实现可靠数据传输的呢？\n## 底层实现\n运输层的进程间通信是通过socket实现的，socket是一个抽象的概念，在Linux系统中以文件的形式存在。网络层通过IP来区分主机，运输层则增加了端口的概念来区分进程。TCP协议中使用目标IP、目标端口、源IP、源端口来定义一个socket，只需要在运输层的报文头部附加上这些信息，目标主机就会知道数据要发送那个socket，对应监听该socket的进程就可以收到数据进行处理。\n\n## TCP报文格式\nTCP报文包括首部和数据部分，首部附加了TCP报文的信息，首部长度固定部分为20字节，还有40字节的可选部分，具体如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-cdbb73e6c3f47d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中几个关键字段的作用如下：\n- 源端口和目的端口：分别16个字节（表示范围0-65535），用来区分主机上的进程\n- 序号：TCP连接中的每个字节都编一个序号，表示本报文的第一个字节在整个数据包中的偏移位置\n- 确认号：期望收到对方的下一个报文段的数据的第一个字节的序号\n- 数据偏移：首部长度，4字节为单位\n- 标志位\n  - ACK：ACK=1表示接收发向发送方发的确认报文\n  - SYN：同步SYN=1表示是一个连接请求或连接接受报文\n  - FIN：FIN=1表示发送方已经发送完毕，可以断开连接\n- 窗口：发送方接收缓冲区剩下的字节数\n- 校验和：检验报文在网络传输过程中是否发生了变化\n- 选项字段：\n  - 窗口扩大选项，用于流量控制\n  - 时间戳选项\n  - 选择确认选项，由于接收方收到了不连续的报文，告知发送方目前收到的数据报范围（两个4字节的边界表示）\n\n## 可靠传输原理\n网络层只管尽可能将数据从一个主机发送到另一个主机，并不保证数据可靠到达，由于网络环境总是不稳定的，可能存在丢包、差错等请求，TCP则通过一系列的机制在运输层保证了数据的可靠传输。\n网络传输可能发生的异常情况和解决方法：\n- 丢包：超时重传\n- 差错：校验码来检验数据正确收到\n\n### 停止等待协议\n要实现可靠传输，最简单的方法就是发送方发送一个报文，接收方收到报文后发送确认报文表示我收到了，你可以发下一个了，传输模型如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-60467e00e08bd710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这种方式保证可靠传输称为停止等待协议，这种方式缺点也很明显，效率非常低。\n\n### 连续ARQ协议\n为了提高传输效率，充分利用带宽，发送方会连续的发送数据包，如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-3e2aee42126ae328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n客户端不等收到前一个包的确认报文就开始不断的发下一个包，这样可以充分利用网络带宽，提高传输效率，但是于此同时也带来了另外的问题，那么TCP是如何解决这些问题的？\n\n#### 确认报文冗余\n**累计确认**：网络中充斥着大量的发送包和确认回复报文，这些数据只是为了确认报文到达，并不是实际需要传输的数据。是不是一定要每一个报文都要发一个回复确认的报文呢，TCP采用了累计确认的方法：接收方在累计收到了一定量的数据包后发送一个确认报文告诉发送方在此之前的数据包都已经收到了，这样便可以减少确认报文的数量，提高带宽利用率。\n\n#### 丢包的处理\n**GBN（回退n步）**：如果发生丢包的情况，在连续ARQ中，如果接受方收到了123 567个字节，编号为4字节的包丢失了，按照累计确认只能发送3的确认回复，567都要丢掉，因为发送发会进行重传。\n\n**选择确认ACK**：在TCP报文头部的选项字段部分设置已收到的报文，每一段用两个边界来确定，比如上述情况可以用[1,3]和[5,7]来表示，客户端就会根据选项只重传丢失的数据段。\n\n#### 滑动窗口\n因为接收方读数据的能力有限，发送发不能一直发送报文直到把缓冲区所有数据发送完，这样会导致接收方无法接收丢弃掉数据包，发送方收不到确认认为超时又会继续重传，产生了大量无用数据的重传。对此情况TCP使用滑动窗口来解决，基本模型如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-06581f647ab4c35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 发送方根据接受方缓冲区的大小，设置自己可发送窗口大小，处于窗口内的数据表示可以发送，之外的数据不能发送\n- 当窗口内的未确认数据收到确认回复时，整个窗口往前移动，知道发送完所有数据\n\n滑动窗口机制实现了TCP的**流量控制**，不至于发送太快导致太多的数据丢弃和重传。\n\n## 拥塞控制\n为了避免网络过分拥挤导致丢包严重，传输效率低，TCP实现了拥塞控制机制，拥塞控制的解决办法本质上是流量控制，控制发送方发送的速度，而上文提到流量控制是通过滑动窗口来实现的，所以最终也是通过调整发送方的滑动窗口大小来实现的。\n\n拥塞控制的几个重要的概念：慢启动、拥塞避免、快恢复、快重传\n\n### Reno算法模型\n![](https://upload-images.jianshu.io/upload_images/14151453-2ca1f629fb91be2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 慢启动：最开始的时候把窗口设置为较小的值，然后每轮变成两倍（虽然叫慢启动，但其实是指数增长）\n- 拥塞避免：当窗口大小达到初始阈值ssthresh，每轮窗口大小增加1（试探网络最大的负载能力）\n- 如果发生了超时，表示极可能发生了拥塞，此时直接执行慢启动，尽可能让网络中的报文先接收，以尽快恢复网络状况。\n- 快重传：如果收到三个重复的ACK，表示中间有段数据丢包了，发送方无需等待计时器到达超时时间，立即进行重传丢失的报文段。\n- 快恢复：连续收到了三个重复ACK，说明网络情况还不是很拥堵，此时将窗口初始的阈值减半，然后执行拥塞避免，这个过程称为快恢复。\n\nReno算法是比较常见的TCP实现的拥塞控制算法，其他拥塞算法还有Tahoe（已废弃不用）、New Reno等，通过拥塞控制算法可以很大程度避免网络拥挤。\n\n## 参考\n【书籍】计算机网络：自顶向下方法\n【码农有道】[这一篇TCP总结请收下](https://mp.weixin.qq.com/s/B1Qttaejav4UzPn0GNoOHw)\n","source":"_posts/2023/03-25-TCP是如何实现可靠传输的？.md","raw":"---\ntitle: TCP是如何实现可靠传输的？\ndate: 2023-03-25 14:43:37\ncategories:\n- [计算机网络]\ntags:\n- TCP\n---\n\n在计算机网络的经典五层协议中，TCP属于运输层，实现了进程间的通信，保证了数据的可靠传输，属于计算机网络协议族中最重要的协议之一，那么TCP是如何实现可靠数据传输的呢？\n## 底层实现\n运输层的进程间通信是通过socket实现的，socket是一个抽象的概念，在Linux系统中以文件的形式存在。网络层通过IP来区分主机，运输层则增加了端口的概念来区分进程。TCP协议中使用目标IP、目标端口、源IP、源端口来定义一个socket，只需要在运输层的报文头部附加上这些信息，目标主机就会知道数据要发送那个socket，对应监听该socket的进程就可以收到数据进行处理。\n\n## TCP报文格式\nTCP报文包括首部和数据部分，首部附加了TCP报文的信息，首部长度固定部分为20字节，还有40字节的可选部分，具体如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-cdbb73e6c3f47d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中几个关键字段的作用如下：\n- 源端口和目的端口：分别16个字节（表示范围0-65535），用来区分主机上的进程\n- 序号：TCP连接中的每个字节都编一个序号，表示本报文的第一个字节在整个数据包中的偏移位置\n- 确认号：期望收到对方的下一个报文段的数据的第一个字节的序号\n- 数据偏移：首部长度，4字节为单位\n- 标志位\n  - ACK：ACK=1表示接收发向发送方发的确认报文\n  - SYN：同步SYN=1表示是一个连接请求或连接接受报文\n  - FIN：FIN=1表示发送方已经发送完毕，可以断开连接\n- 窗口：发送方接收缓冲区剩下的字节数\n- 校验和：检验报文在网络传输过程中是否发生了变化\n- 选项字段：\n  - 窗口扩大选项，用于流量控制\n  - 时间戳选项\n  - 选择确认选项，由于接收方收到了不连续的报文，告知发送方目前收到的数据报范围（两个4字节的边界表示）\n\n## 可靠传输原理\n网络层只管尽可能将数据从一个主机发送到另一个主机，并不保证数据可靠到达，由于网络环境总是不稳定的，可能存在丢包、差错等请求，TCP则通过一系列的机制在运输层保证了数据的可靠传输。\n网络传输可能发生的异常情况和解决方法：\n- 丢包：超时重传\n- 差错：校验码来检验数据正确收到\n\n### 停止等待协议\n要实现可靠传输，最简单的方法就是发送方发送一个报文，接收方收到报文后发送确认报文表示我收到了，你可以发下一个了，传输模型如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-60467e00e08bd710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这种方式保证可靠传输称为停止等待协议，这种方式缺点也很明显，效率非常低。\n\n### 连续ARQ协议\n为了提高传输效率，充分利用带宽，发送方会连续的发送数据包，如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-3e2aee42126ae328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n客户端不等收到前一个包的确认报文就开始不断的发下一个包，这样可以充分利用网络带宽，提高传输效率，但是于此同时也带来了另外的问题，那么TCP是如何解决这些问题的？\n\n#### 确认报文冗余\n**累计确认**：网络中充斥着大量的发送包和确认回复报文，这些数据只是为了确认报文到达，并不是实际需要传输的数据。是不是一定要每一个报文都要发一个回复确认的报文呢，TCP采用了累计确认的方法：接收方在累计收到了一定量的数据包后发送一个确认报文告诉发送方在此之前的数据包都已经收到了，这样便可以减少确认报文的数量，提高带宽利用率。\n\n#### 丢包的处理\n**GBN（回退n步）**：如果发生丢包的情况，在连续ARQ中，如果接受方收到了123 567个字节，编号为4字节的包丢失了，按照累计确认只能发送3的确认回复，567都要丢掉，因为发送发会进行重传。\n\n**选择确认ACK**：在TCP报文头部的选项字段部分设置已收到的报文，每一段用两个边界来确定，比如上述情况可以用[1,3]和[5,7]来表示，客户端就会根据选项只重传丢失的数据段。\n\n#### 滑动窗口\n因为接收方读数据的能力有限，发送发不能一直发送报文直到把缓冲区所有数据发送完，这样会导致接收方无法接收丢弃掉数据包，发送方收不到确认认为超时又会继续重传，产生了大量无用数据的重传。对此情况TCP使用滑动窗口来解决，基本模型如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-06581f647ab4c35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 发送方根据接受方缓冲区的大小，设置自己可发送窗口大小，处于窗口内的数据表示可以发送，之外的数据不能发送\n- 当窗口内的未确认数据收到确认回复时，整个窗口往前移动，知道发送完所有数据\n\n滑动窗口机制实现了TCP的**流量控制**，不至于发送太快导致太多的数据丢弃和重传。\n\n## 拥塞控制\n为了避免网络过分拥挤导致丢包严重，传输效率低，TCP实现了拥塞控制机制，拥塞控制的解决办法本质上是流量控制，控制发送方发送的速度，而上文提到流量控制是通过滑动窗口来实现的，所以最终也是通过调整发送方的滑动窗口大小来实现的。\n\n拥塞控制的几个重要的概念：慢启动、拥塞避免、快恢复、快重传\n\n### Reno算法模型\n![](https://upload-images.jianshu.io/upload_images/14151453-2ca1f629fb91be2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 慢启动：最开始的时候把窗口设置为较小的值，然后每轮变成两倍（虽然叫慢启动，但其实是指数增长）\n- 拥塞避免：当窗口大小达到初始阈值ssthresh，每轮窗口大小增加1（试探网络最大的负载能力）\n- 如果发生了超时，表示极可能发生了拥塞，此时直接执行慢启动，尽可能让网络中的报文先接收，以尽快恢复网络状况。\n- 快重传：如果收到三个重复的ACK，表示中间有段数据丢包了，发送方无需等待计时器到达超时时间，立即进行重传丢失的报文段。\n- 快恢复：连续收到了三个重复ACK，说明网络情况还不是很拥堵，此时将窗口初始的阈值减半，然后执行拥塞避免，这个过程称为快恢复。\n\nReno算法是比较常见的TCP实现的拥塞控制算法，其他拥塞算法还有Tahoe（已废弃不用）、New Reno等，通过拥塞控制算法可以很大程度避免网络拥挤。\n\n## 参考\n【书籍】计算机网络：自顶向下方法\n【码农有道】[这一篇TCP总结请收下](https://mp.weixin.qq.com/s/B1Qttaejav4UzPn0GNoOHw)\n","slug":"TCP是如何实现可靠传输的？","published":1,"updated":"2023-03-25T06:58:47.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj17n001ahtfi0lje1olr","content":"<p>在计算机网络的经典五层协议中，TCP属于运输层，实现了进程间的通信，保证了数据的可靠传输，属于计算机网络协议族中最重要的协议之一，那么TCP是如何实现可靠数据传输的呢？</p>\n<h2 id=\"底层实现\"><a href=\"#底层实现\" class=\"headerlink\" title=\"底层实现\"></a>底层实现</h2><p>运输层的进程间通信是通过socket实现的，socket是一个抽象的概念，在Linux系统中以文件的形式存在。网络层通过IP来区分主机，运输层则增加了端口的概念来区分进程。TCP协议中使用目标IP、目标端口、源IP、源端口来定义一个socket，只需要在运输层的报文头部附加上这些信息，目标主机就会知道数据要发送那个socket，对应监听该socket的进程就可以收到数据进行处理。</p>\n<h2 id=\"TCP报文格式\"><a href=\"#TCP报文格式\" class=\"headerlink\" title=\"TCP报文格式\"></a>TCP报文格式</h2><p>TCP报文包括首部和数据部分，首部附加了TCP报文的信息，首部长度固定部分为20字节，还有40字节的可选部分，具体如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-cdbb73e6c3f47d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-cdbb73e6c3f47d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>其中几个关键字段的作用如下：</p>\n<ul>\n<li>源端口和目的端口：分别16个字节（表示范围0-65535），用来区分主机上的进程</li>\n<li>序号：TCP连接中的每个字节都编一个序号，表示本报文的第一个字节在整个数据包中的偏移位置</li>\n<li>确认号：期望收到对方的下一个报文段的数据的第一个字节的序号</li>\n<li>数据偏移：首部长度，4字节为单位</li>\n<li>标志位<ul>\n<li>ACK：ACK&#x3D;1表示接收发向发送方发的确认报文</li>\n<li>SYN：同步SYN&#x3D;1表示是一个连接请求或连接接受报文</li>\n<li>FIN：FIN&#x3D;1表示发送方已经发送完毕，可以断开连接</li>\n</ul>\n</li>\n<li>窗口：发送方接收缓冲区剩下的字节数</li>\n<li>校验和：检验报文在网络传输过程中是否发生了变化</li>\n<li>选项字段：<ul>\n<li>窗口扩大选项，用于流量控制</li>\n<li>时间戳选项</li>\n<li>选择确认选项，由于接收方收到了不连续的报文，告知发送方目前收到的数据报范围（两个4字节的边界表示）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"可靠传输原理\"><a href=\"#可靠传输原理\" class=\"headerlink\" title=\"可靠传输原理\"></a>可靠传输原理</h2><p>网络层只管尽可能将数据从一个主机发送到另一个主机，并不保证数据可靠到达，由于网络环境总是不稳定的，可能存在丢包、差错等请求，TCP则通过一系列的机制在运输层保证了数据的可靠传输。<br>网络传输可能发生的异常情况和解决方法：</p>\n<ul>\n<li>丢包：超时重传</li>\n<li>差错：校验码来检验数据正确收到</li>\n</ul>\n<h3 id=\"停止等待协议\"><a href=\"#停止等待协议\" class=\"headerlink\" title=\"停止等待协议\"></a>停止等待协议</h3><p>要实现可靠传输，最简单的方法就是发送方发送一个报文，接收方收到报文后发送确认报文表示我收到了，你可以发下一个了，传输模型如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-60467e00e08bd710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-60467e00e08bd710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>这种方式保证可靠传输称为停止等待协议，这种方式缺点也很明显，效率非常低。</p>\n<h3 id=\"连续ARQ协议\"><a href=\"#连续ARQ协议\" class=\"headerlink\" title=\"连续ARQ协议\"></a>连续ARQ协议</h3><p>为了提高传输效率，充分利用带宽，发送方会连续的发送数据包，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-3e2aee42126ae328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-3e2aee42126ae328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>客户端不等收到前一个包的确认报文就开始不断的发下一个包，这样可以充分利用网络带宽，提高传输效率，但是于此同时也带来了另外的问题，那么TCP是如何解决这些问题的？</p>\n<h4 id=\"确认报文冗余\"><a href=\"#确认报文冗余\" class=\"headerlink\" title=\"确认报文冗余\"></a>确认报文冗余</h4><p><strong>累计确认</strong>：网络中充斥着大量的发送包和确认回复报文，这些数据只是为了确认报文到达，并不是实际需要传输的数据。是不是一定要每一个报文都要发一个回复确认的报文呢，TCP采用了累计确认的方法：接收方在累计收到了一定量的数据包后发送一个确认报文告诉发送方在此之前的数据包都已经收到了，这样便可以减少确认报文的数量，提高带宽利用率。</p>\n<h4 id=\"丢包的处理\"><a href=\"#丢包的处理\" class=\"headerlink\" title=\"丢包的处理\"></a>丢包的处理</h4><p><strong>GBN（回退n步）</strong>：如果发生丢包的情况，在连续ARQ中，如果接受方收到了123 567个字节，编号为4字节的包丢失了，按照累计确认只能发送3的确认回复，567都要丢掉，因为发送发会进行重传。</p>\n<p><strong>选择确认ACK</strong>：在TCP报文头部的选项字段部分设置已收到的报文，每一段用两个边界来确定，比如上述情况可以用[1,3]和[5,7]来表示，客户端就会根据选项只重传丢失的数据段。</p>\n<h4 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h4><p>因为接收方读数据的能力有限，发送发不能一直发送报文直到把缓冲区所有数据发送完，这样会导致接收方无法接收丢弃掉数据包，发送方收不到确认认为超时又会继续重传，产生了大量无用数据的重传。对此情况TCP使用滑动窗口来解决，基本模型如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-06581f647ab4c35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-06581f647ab4c35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<ul>\n<li>发送方根据接受方缓冲区的大小，设置自己可发送窗口大小，处于窗口内的数据表示可以发送，之外的数据不能发送</li>\n<li>当窗口内的未确认数据收到确认回复时，整个窗口往前移动，知道发送完所有数据</li>\n</ul>\n<p>滑动窗口机制实现了TCP的<strong>流量控制</strong>，不至于发送太快导致太多的数据丢弃和重传。</p>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h2><p>为了避免网络过分拥挤导致丢包严重，传输效率低，TCP实现了拥塞控制机制，拥塞控制的解决办法本质上是流量控制，控制发送方发送的速度，而上文提到流量控制是通过滑动窗口来实现的，所以最终也是通过调整发送方的滑动窗口大小来实现的。</p>\n<p>拥塞控制的几个重要的概念：慢启动、拥塞避免、快恢复、快重传</p>\n<h3 id=\"Reno算法模型\"><a href=\"#Reno算法模型\" class=\"headerlink\" title=\"Reno算法模型\"></a>Reno算法模型</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-2ca1f629fb91be2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-2ca1f629fb91be2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<ul>\n<li>慢启动：最开始的时候把窗口设置为较小的值，然后每轮变成两倍（虽然叫慢启动，但其实是指数增长）</li>\n<li>拥塞避免：当窗口大小达到初始阈值ssthresh，每轮窗口大小增加1（试探网络最大的负载能力）</li>\n<li>如果发生了超时，表示极可能发生了拥塞，此时直接执行慢启动，尽可能让网络中的报文先接收，以尽快恢复网络状况。</li>\n<li>快重传：如果收到三个重复的ACK，表示中间有段数据丢包了，发送方无需等待计时器到达超时时间，立即进行重传丢失的报文段。</li>\n<li>快恢复：连续收到了三个重复ACK，说明网络情况还不是很拥堵，此时将窗口初始的阈值减半，然后执行拥塞避免，这个过程称为快恢复。</li>\n</ul>\n<p>Reno算法是比较常见的TCP实现的拥塞控制算法，其他拥塞算法还有Tahoe（已废弃不用）、New Reno等，通过拥塞控制算法可以很大程度避免网络拥挤。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【书籍】计算机网络：自顶向下方法<br>【码农有道】<a href=\"https://mp.weixin.qq.com/s/B1Qttaejav4UzPn0GNoOHw\">这一篇TCP总结请收下</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在计算机网络的经典五层协议中，TCP属于运输层，实现了进程间的通信，保证了数据的可靠传输，属于计算机网络协议族中最重要的协议之一，那么TCP是如何实现可靠数据传输的呢？</p>\n<h2 id=\"底层实现\"><a href=\"#底层实现\" class=\"headerlink\" title=\"底层实现\"></a>底层实现</h2><p>运输层的进程间通信是通过socket实现的，socket是一个抽象的概念，在Linux系统中以文件的形式存在。网络层通过IP来区分主机，运输层则增加了端口的概念来区分进程。TCP协议中使用目标IP、目标端口、源IP、源端口来定义一个socket，只需要在运输层的报文头部附加上这些信息，目标主机就会知道数据要发送那个socket，对应监听该socket的进程就可以收到数据进行处理。</p>\n<h2 id=\"TCP报文格式\"><a href=\"#TCP报文格式\" class=\"headerlink\" title=\"TCP报文格式\"></a>TCP报文格式</h2><p>TCP报文包括首部和数据部分，首部附加了TCP报文的信息，首部长度固定部分为20字节，还有40字节的可选部分，具体如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-cdbb73e6c3f47d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>其中几个关键字段的作用如下：</p>\n<ul>\n<li>源端口和目的端口：分别16个字节（表示范围0-65535），用来区分主机上的进程</li>\n<li>序号：TCP连接中的每个字节都编一个序号，表示本报文的第一个字节在整个数据包中的偏移位置</li>\n<li>确认号：期望收到对方的下一个报文段的数据的第一个字节的序号</li>\n<li>数据偏移：首部长度，4字节为单位</li>\n<li>标志位<ul>\n<li>ACK：ACK&#x3D;1表示接收发向发送方发的确认报文</li>\n<li>SYN：同步SYN&#x3D;1表示是一个连接请求或连接接受报文</li>\n<li>FIN：FIN&#x3D;1表示发送方已经发送完毕，可以断开连接</li>\n</ul>\n</li>\n<li>窗口：发送方接收缓冲区剩下的字节数</li>\n<li>校验和：检验报文在网络传输过程中是否发生了变化</li>\n<li>选项字段：<ul>\n<li>窗口扩大选项，用于流量控制</li>\n<li>时间戳选项</li>\n<li>选择确认选项，由于接收方收到了不连续的报文，告知发送方目前收到的数据报范围（两个4字节的边界表示）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"可靠传输原理\"><a href=\"#可靠传输原理\" class=\"headerlink\" title=\"可靠传输原理\"></a>可靠传输原理</h2><p>网络层只管尽可能将数据从一个主机发送到另一个主机，并不保证数据可靠到达，由于网络环境总是不稳定的，可能存在丢包、差错等请求，TCP则通过一系列的机制在运输层保证了数据的可靠传输。<br>网络传输可能发生的异常情况和解决方法：</p>\n<ul>\n<li>丢包：超时重传</li>\n<li>差错：校验码来检验数据正确收到</li>\n</ul>\n<h3 id=\"停止等待协议\"><a href=\"#停止等待协议\" class=\"headerlink\" title=\"停止等待协议\"></a>停止等待协议</h3><p>要实现可靠传输，最简单的方法就是发送方发送一个报文，接收方收到报文后发送确认报文表示我收到了，你可以发下一个了，传输模型如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-60467e00e08bd710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>这种方式保证可靠传输称为停止等待协议，这种方式缺点也很明显，效率非常低。</p>\n<h3 id=\"连续ARQ协议\"><a href=\"#连续ARQ协议\" class=\"headerlink\" title=\"连续ARQ协议\"></a>连续ARQ协议</h3><p>为了提高传输效率，充分利用带宽，发送方会连续的发送数据包，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-3e2aee42126ae328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>客户端不等收到前一个包的确认报文就开始不断的发下一个包，这样可以充分利用网络带宽，提高传输效率，但是于此同时也带来了另外的问题，那么TCP是如何解决这些问题的？</p>\n<h4 id=\"确认报文冗余\"><a href=\"#确认报文冗余\" class=\"headerlink\" title=\"确认报文冗余\"></a>确认报文冗余</h4><p><strong>累计确认</strong>：网络中充斥着大量的发送包和确认回复报文，这些数据只是为了确认报文到达，并不是实际需要传输的数据。是不是一定要每一个报文都要发一个回复确认的报文呢，TCP采用了累计确认的方法：接收方在累计收到了一定量的数据包后发送一个确认报文告诉发送方在此之前的数据包都已经收到了，这样便可以减少确认报文的数量，提高带宽利用率。</p>\n<h4 id=\"丢包的处理\"><a href=\"#丢包的处理\" class=\"headerlink\" title=\"丢包的处理\"></a>丢包的处理</h4><p><strong>GBN（回退n步）</strong>：如果发生丢包的情况，在连续ARQ中，如果接受方收到了123 567个字节，编号为4字节的包丢失了，按照累计确认只能发送3的确认回复，567都要丢掉，因为发送发会进行重传。</p>\n<p><strong>选择确认ACK</strong>：在TCP报文头部的选项字段部分设置已收到的报文，每一段用两个边界来确定，比如上述情况可以用[1,3]和[5,7]来表示，客户端就会根据选项只重传丢失的数据段。</p>\n<h4 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h4><p>因为接收方读数据的能力有限，发送发不能一直发送报文直到把缓冲区所有数据发送完，这样会导致接收方无法接收丢弃掉数据包，发送方收不到确认认为超时又会继续重传，产生了大量无用数据的重传。对此情况TCP使用滑动窗口来解决，基本模型如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-06581f647ab4c35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<ul>\n<li>发送方根据接受方缓冲区的大小，设置自己可发送窗口大小，处于窗口内的数据表示可以发送，之外的数据不能发送</li>\n<li>当窗口内的未确认数据收到确认回复时，整个窗口往前移动，知道发送完所有数据</li>\n</ul>\n<p>滑动窗口机制实现了TCP的<strong>流量控制</strong>，不至于发送太快导致太多的数据丢弃和重传。</p>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h2><p>为了避免网络过分拥挤导致丢包严重，传输效率低，TCP实现了拥塞控制机制，拥塞控制的解决办法本质上是流量控制，控制发送方发送的速度，而上文提到流量控制是通过滑动窗口来实现的，所以最终也是通过调整发送方的滑动窗口大小来实现的。</p>\n<p>拥塞控制的几个重要的概念：慢启动、拥塞避免、快恢复、快重传</p>\n<h3 id=\"Reno算法模型\"><a href=\"#Reno算法模型\" class=\"headerlink\" title=\"Reno算法模型\"></a>Reno算法模型</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-2ca1f629fb91be2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<ul>\n<li>慢启动：最开始的时候把窗口设置为较小的值，然后每轮变成两倍（虽然叫慢启动，但其实是指数增长）</li>\n<li>拥塞避免：当窗口大小达到初始阈值ssthresh，每轮窗口大小增加1（试探网络最大的负载能力）</li>\n<li>如果发生了超时，表示极可能发生了拥塞，此时直接执行慢启动，尽可能让网络中的报文先接收，以尽快恢复网络状况。</li>\n<li>快重传：如果收到三个重复的ACK，表示中间有段数据丢包了，发送方无需等待计时器到达超时时间，立即进行重传丢失的报文段。</li>\n<li>快恢复：连续收到了三个重复ACK，说明网络情况还不是很拥堵，此时将窗口初始的阈值减半，然后执行拥塞避免，这个过程称为快恢复。</li>\n</ul>\n<p>Reno算法是比较常见的TCP实现的拥塞控制算法，其他拥塞算法还有Tahoe（已废弃不用）、New Reno等，通过拥塞控制算法可以很大程度避免网络拥挤。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【书籍】计算机网络：自顶向下方法<br>【码农有道】<a href=\"https://mp.weixin.qq.com/s/B1Qttaejav4UzPn0GNoOHw\">这一篇TCP总结请收下</a></p>\n"},{"title":"什么是WebSocket？","date":"2023-03-25T06:42:47.000Z","_content":"\n## 基本概念\nWebSocket是一种网络通信协议，是HTML5新增的特性，实现了基于浏览器的远程socket，使浏览器和服务器可以进行全双工通信，大部分浏览器都对此做了支持。\nWebSocket的URL格式形如：ws://localhost:80/、wss://localhost:443/\n\n## 为什么有了HTTP协议还要WebSocket\nHTTP协议采用的是客户端（浏览器）轮询的方式，即客户端发送请求，服务端做出响应，为了获取最新的数据，需要不断的轮询发出HTTP请求，占用大量带宽。\nWebSocket采用了一些特殊的报头，使得浏览器和服务器只需要通过“握手”建立一条连接通道后，此链接保持活跃状态，之后的客户端和服务器的通信都使用这个连接，解决了Web实时性的问题，相比于HTTP有一下好处：\n- 一个Web客户端只建立一个TCP连接\n- WebSocket服务端可以主动推送（push）数据到Web客户端\n- 有更加轻量级的头，减少了数据传输量\n\n## WebSocket原理\n![](https://upload-images.jianshu.io/upload_images/14151453-83f761a12847fa76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 建立连接\nWebSocket建立连接必须由浏览器发起，是一个标准的HTTP请求，如下图所示\n![](https://upload-images.jianshu.io/upload_images/14151453-0f3bd32d35e06362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 请求\n1. 请求地址以`ws://`开头\n2. 请求头`Upgrade: websocket`和`Connection:Upgrade`表示要将这个连接转换为WebSocket连接\n3. `Sec-WebSocket-Key`用于标识连接，是一个base64编码的字符串\n4. `Sec-WebSocket-Version`指定了WebSocket协议版本\n\n#### 响应\n1. 响应状态码`101`表示本次连接的HTTP协议将被更改\n2. `Upgrade: websocket`表示更改后的协议是WebSocket\n3. `Sec-WebSocket-Accept`通过如下方式计算：\n- 对请求头的`Sec-WebSocket-Key`字符串加上一个固定的字符串，例如：\n`H+VLjR1wb4JQ62TmabK87g==258EAFA5-E914-47DA-95CA-C5AB0DC85B11`\n- 然后对该字符串用sha1算法散列出二进制值，再对其进行base64加密，例如：\n`ccJoRDcGOFzCVrIwpX/qF3BoIN0=`\n\n### 数据格式\nWebSocket的协议比较简单，在第一次handshake通过之后，连接建立成功，之后的通讯数据都是以\"\\x00\"开头，以\"\\xFF\"结尾，对客户端来说这个是透明的，WebSocket的实现组件会对原始数据掐头去尾。\n\n### 特点\n1. 建立在TCP协议只上，服务端比较容易实现\n2. 于HTTP协议有良好的兼容性，默认端口也是80和443，握手阶段使用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器\n3. 数据格式轻量，通信高效且节省带宽\n4. 支持传输文本数据和二进制数据\n5. 没有同源限制，客户端可以与任意服务器通信\n6. 也支持加密传输，WS+SSL，URL形如`wss://`\n\n## Go语言实现\ngo的标准SDK中没有支持WebSocket，但是官方维护的net子包中支持\n`go get golang.org/x/net/websocket`\n### 客户端\n```html\n<!DOCTYPE html>\n<html>\n<head></head>\n<body>\n<script type=\"text/javascript\">\n    var sock = null;\n    var wsuri = \"ws://127.0.0.1:7777\";\n\n    window.onload = function() {\n\n        console.log(\"onload\");\n\n        sock = new WebSocket(wsuri);\n\n        sock.onopen = function() {\n            console.log(\"connected to \" + wsuri);\n        }\n\n        sock.onclose = function(e) {\n            console.log(\"connection closed (\" + e.code + \")\");\n        }\n\n        sock.onmessage = function(e) {\n            console.log(\"message received: \" + e.data);\n        }\n    };\n\n    function send() {\n        var msg = document.getElementById('message').value;\n        sock.send(msg);\n    };\n</script>\n<h1>WebSocket Echo Test</h1>\n<form>\n    <p>\n        Message: <input id=\"message\" type=\"text\" value=\"Hello, world!\">\n    </p>\n</form>\n<button onclick=\"send();\">Send Message</button>\n</body>\n</html>\n```\n客户端JavaScript代码，通过`new WebSocket(wsuri)`创建了一个WebSocket连接，握手成功后会触发onopen事件，客户端绑定了四个事件：\n- onopen：建立连接后触发\n- onmessage：收到消息后触发\n- onerror：发生错误时触发\n- onclose：关闭连接时触发\n\n### 服务端\n```go\npackage main\n\nimport (\n\t\"golang.org/x/net/websocket\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc handleEcho(ws *websocket.Conn) {\n\tvar err error\n\n\tfor {\n\t\tvar reply string\n\n\t\tif err = websocket.Message.Receive(ws, &reply); err != nil {\n\t\t\tlog.Println(\"[server] Can't receive\")\n\t\t\tbreak\n\t\t}\n\t\tlog.Println(\"[server] Received from client:\", reply)\n\n\t\tmsg := \"welcome: \" + reply\n\t\tif err = websocket.Message.Send(ws, msg); err != nil {\n\t\t\tlog.Println(\"[server] Can't Send\")\n\t\t\tbreak\n\t\t}\n\t\tlog.Println(\"[server] Send to client:\", msg)\n\t}\n}\n\nfunc main() {\n\thttp.Handle(\"/\", websocket.Handler(handleEcho))\n\tlog.Println(\"[server] listen in 127.0.0.1:7777\")\n\tif err := http.ListenAndServe(\":7777\", nil); err != nil {\n\t\tlog.Fatal(\"[server] ListenAndServe:\", err)\n\t}\n}\n\n```\n运行后在客户端页面点击Send Message按钮，可以看到服务端如下响应：\n![](https://upload-images.jianshu.io/upload_images/14151453-e2ef3c1cb34f117d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 参考资料\n【1】[build-web-application-with-golang](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.2.md)\n【2】[廖雪峰：WebSocket](https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096)\n【3】[阮一峰：WebSocket教程](https://www.ruanyifeng.com/blog/2017/05/websocket.html)\n","source":"_posts/2023/03-25-什么是WebSocket？.md","raw":"---\ntitle: 什么是WebSocket？\ndate: 2023-03-25 14:42:47\ncategories:\n- [计算机网络]\ntags:\n- \"WebSocket\"\n---\n\n## 基本概念\nWebSocket是一种网络通信协议，是HTML5新增的特性，实现了基于浏览器的远程socket，使浏览器和服务器可以进行全双工通信，大部分浏览器都对此做了支持。\nWebSocket的URL格式形如：ws://localhost:80/、wss://localhost:443/\n\n## 为什么有了HTTP协议还要WebSocket\nHTTP协议采用的是客户端（浏览器）轮询的方式，即客户端发送请求，服务端做出响应，为了获取最新的数据，需要不断的轮询发出HTTP请求，占用大量带宽。\nWebSocket采用了一些特殊的报头，使得浏览器和服务器只需要通过“握手”建立一条连接通道后，此链接保持活跃状态，之后的客户端和服务器的通信都使用这个连接，解决了Web实时性的问题，相比于HTTP有一下好处：\n- 一个Web客户端只建立一个TCP连接\n- WebSocket服务端可以主动推送（push）数据到Web客户端\n- 有更加轻量级的头，减少了数据传输量\n\n## WebSocket原理\n![](https://upload-images.jianshu.io/upload_images/14151453-83f761a12847fa76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 建立连接\nWebSocket建立连接必须由浏览器发起，是一个标准的HTTP请求，如下图所示\n![](https://upload-images.jianshu.io/upload_images/14151453-0f3bd32d35e06362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 请求\n1. 请求地址以`ws://`开头\n2. 请求头`Upgrade: websocket`和`Connection:Upgrade`表示要将这个连接转换为WebSocket连接\n3. `Sec-WebSocket-Key`用于标识连接，是一个base64编码的字符串\n4. `Sec-WebSocket-Version`指定了WebSocket协议版本\n\n#### 响应\n1. 响应状态码`101`表示本次连接的HTTP协议将被更改\n2. `Upgrade: websocket`表示更改后的协议是WebSocket\n3. `Sec-WebSocket-Accept`通过如下方式计算：\n- 对请求头的`Sec-WebSocket-Key`字符串加上一个固定的字符串，例如：\n`H+VLjR1wb4JQ62TmabK87g==258EAFA5-E914-47DA-95CA-C5AB0DC85B11`\n- 然后对该字符串用sha1算法散列出二进制值，再对其进行base64加密，例如：\n`ccJoRDcGOFzCVrIwpX/qF3BoIN0=`\n\n### 数据格式\nWebSocket的协议比较简单，在第一次handshake通过之后，连接建立成功，之后的通讯数据都是以\"\\x00\"开头，以\"\\xFF\"结尾，对客户端来说这个是透明的，WebSocket的实现组件会对原始数据掐头去尾。\n\n### 特点\n1. 建立在TCP协议只上，服务端比较容易实现\n2. 于HTTP协议有良好的兼容性，默认端口也是80和443，握手阶段使用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器\n3. 数据格式轻量，通信高效且节省带宽\n4. 支持传输文本数据和二进制数据\n5. 没有同源限制，客户端可以与任意服务器通信\n6. 也支持加密传输，WS+SSL，URL形如`wss://`\n\n## Go语言实现\ngo的标准SDK中没有支持WebSocket，但是官方维护的net子包中支持\n`go get golang.org/x/net/websocket`\n### 客户端\n```html\n<!DOCTYPE html>\n<html>\n<head></head>\n<body>\n<script type=\"text/javascript\">\n    var sock = null;\n    var wsuri = \"ws://127.0.0.1:7777\";\n\n    window.onload = function() {\n\n        console.log(\"onload\");\n\n        sock = new WebSocket(wsuri);\n\n        sock.onopen = function() {\n            console.log(\"connected to \" + wsuri);\n        }\n\n        sock.onclose = function(e) {\n            console.log(\"connection closed (\" + e.code + \")\");\n        }\n\n        sock.onmessage = function(e) {\n            console.log(\"message received: \" + e.data);\n        }\n    };\n\n    function send() {\n        var msg = document.getElementById('message').value;\n        sock.send(msg);\n    };\n</script>\n<h1>WebSocket Echo Test</h1>\n<form>\n    <p>\n        Message: <input id=\"message\" type=\"text\" value=\"Hello, world!\">\n    </p>\n</form>\n<button onclick=\"send();\">Send Message</button>\n</body>\n</html>\n```\n客户端JavaScript代码，通过`new WebSocket(wsuri)`创建了一个WebSocket连接，握手成功后会触发onopen事件，客户端绑定了四个事件：\n- onopen：建立连接后触发\n- onmessage：收到消息后触发\n- onerror：发生错误时触发\n- onclose：关闭连接时触发\n\n### 服务端\n```go\npackage main\n\nimport (\n\t\"golang.org/x/net/websocket\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc handleEcho(ws *websocket.Conn) {\n\tvar err error\n\n\tfor {\n\t\tvar reply string\n\n\t\tif err = websocket.Message.Receive(ws, &reply); err != nil {\n\t\t\tlog.Println(\"[server] Can't receive\")\n\t\t\tbreak\n\t\t}\n\t\tlog.Println(\"[server] Received from client:\", reply)\n\n\t\tmsg := \"welcome: \" + reply\n\t\tif err = websocket.Message.Send(ws, msg); err != nil {\n\t\t\tlog.Println(\"[server] Can't Send\")\n\t\t\tbreak\n\t\t}\n\t\tlog.Println(\"[server] Send to client:\", msg)\n\t}\n}\n\nfunc main() {\n\thttp.Handle(\"/\", websocket.Handler(handleEcho))\n\tlog.Println(\"[server] listen in 127.0.0.1:7777\")\n\tif err := http.ListenAndServe(\":7777\", nil); err != nil {\n\t\tlog.Fatal(\"[server] ListenAndServe:\", err)\n\t}\n}\n\n```\n运行后在客户端页面点击Send Message按钮，可以看到服务端如下响应：\n![](https://upload-images.jianshu.io/upload_images/14151453-e2ef3c1cb34f117d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 参考资料\n【1】[build-web-application-with-golang](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.2.md)\n【2】[廖雪峰：WebSocket](https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096)\n【3】[阮一峰：WebSocket教程](https://www.ruanyifeng.com/blog/2017/05/websocket.html)\n","slug":"什么是WebSocket？","published":1,"updated":"2023-03-25T06:58:29.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj17n001dhtfi2c583bzk","content":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>WebSocket是一种网络通信协议，是HTML5新增的特性，实现了基于浏览器的远程socket，使浏览器和服务器可以进行全双工通信，大部分浏览器都对此做了支持。<br>WebSocket的URL格式形如：ws:&#x2F;&#x2F;localhost:80&#x2F;、wss:&#x2F;&#x2F;localhost:443&#x2F;</p>\n<h2 id=\"为什么有了HTTP协议还要WebSocket\"><a href=\"#为什么有了HTTP协议还要WebSocket\" class=\"headerlink\" title=\"为什么有了HTTP协议还要WebSocket\"></a>为什么有了HTTP协议还要WebSocket</h2><p>HTTP协议采用的是客户端（浏览器）轮询的方式，即客户端发送请求，服务端做出响应，为了获取最新的数据，需要不断的轮询发出HTTP请求，占用大量带宽。<br>WebSocket采用了一些特殊的报头，使得浏览器和服务器只需要通过“握手”建立一条连接通道后，此链接保持活跃状态，之后的客户端和服务器的通信都使用这个连接，解决了Web实时性的问题，相比于HTTP有一下好处：</p>\n<ul>\n<li>一个Web客户端只建立一个TCP连接</li>\n<li>WebSocket服务端可以主动推送（push）数据到Web客户端</li>\n<li>有更加轻量级的头，减少了数据传输量</li>\n</ul>\n<h2 id=\"WebSocket原理\"><a href=\"#WebSocket原理\" class=\"headerlink\" title=\"WebSocket原理\"></a>WebSocket原理</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-83f761a12847fa76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-83f761a12847fa76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h3 id=\"建立连接\"><a href=\"#建立连接\" class=\"headerlink\" title=\"建立连接\"></a>建立连接</h3><p>WebSocket建立连接必须由浏览器发起，是一个标准的HTTP请求，如下图所示<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-0f3bd32d35e06362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-0f3bd32d35e06362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h4 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h4><ol>\n<li>请求地址以<code>ws://</code>开头</li>\n<li>请求头<code>Upgrade: websocket</code>和<code>Connection:Upgrade</code>表示要将这个连接转换为WebSocket连接</li>\n<li><code>Sec-WebSocket-Key</code>用于标识连接，是一个base64编码的字符串</li>\n<li><code>Sec-WebSocket-Version</code>指定了WebSocket协议版本</li>\n</ol>\n<h4 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h4><ol>\n<li>响应状态码<code>101</code>表示本次连接的HTTP协议将被更改</li>\n<li><code>Upgrade: websocket</code>表示更改后的协议是WebSocket</li>\n<li><code>Sec-WebSocket-Accept</code>通过如下方式计算：</li>\n</ol>\n<ul>\n<li>对请求头的<code>Sec-WebSocket-Key</code>字符串加上一个固定的字符串，例如：<br><code>H+VLjR1wb4JQ62TmabK87g==258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code></li>\n<li>然后对该字符串用sha1算法散列出二进制值，再对其进行base64加密，例如：<br><code>ccJoRDcGOFzCVrIwpX/qF3BoIN0=</code></li>\n</ul>\n<h3 id=\"数据格式\"><a href=\"#数据格式\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h3><p>WebSocket的协议比较简单，在第一次handshake通过之后，连接建立成功，之后的通讯数据都是以”\\x00”开头，以”\\xFF”结尾，对客户端来说这个是透明的，WebSocket的实现组件会对原始数据掐头去尾。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>建立在TCP协议只上，服务端比较容易实现</li>\n<li>于HTTP协议有良好的兼容性，默认端口也是80和443，握手阶段使用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器</li>\n<li>数据格式轻量，通信高效且节省带宽</li>\n<li>支持传输文本数据和二进制数据</li>\n<li>没有同源限制，客户端可以与任意服务器通信</li>\n<li>也支持加密传输，WS+SSL，URL形如<code>wss://</code></li>\n</ol>\n<h2 id=\"Go语言实现\"><a href=\"#Go语言实现\" class=\"headerlink\" title=\"Go语言实现\"></a>Go语言实现</h2><p>go的标准SDK中没有支持WebSocket，但是官方维护的net子包中支持<br><code>go get golang.org/x/net/websocket</code></p>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> sock = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> wsuri = <span class=\"string\">&quot;ws://127.0.0.1:7777&quot;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">window</span>.<span class=\"property\">onload</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;onload&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock = <span class=\"keyword\">new</span> <span class=\"title class_\">WebSocket</span>(wsuri);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"property\">onopen</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;connected to &quot;</span> + wsuri);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"property\">onclose</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;connection closed (&quot;</span> + e.<span class=\"property\">code</span> + <span class=\"string\">&quot;)&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"property\">onmessage</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;message received: &quot;</span> + e.<span class=\"property\">data</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">function</span> <span class=\"title function_\">send</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">var</span> msg = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;message&#x27;</span>).<span class=\"property\">value</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"title function_\">send</span>(msg);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>WebSocket Echo Test<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        Message: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;message&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Hello, world!&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;send();&quot;</span>&gt;</span>Send Message<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>客户端JavaScript代码，通过<code>new WebSocket(wsuri)</code>创建了一个WebSocket连接，握手成功后会触发onopen事件，客户端绑定了四个事件：</p>\n<ul>\n<li>onopen：建立连接后触发</li>\n<li>onmessage：收到消息后触发</li>\n<li>onerror：发生错误时触发</li>\n<li>onclose：关闭连接时触发</li>\n</ul>\n<h3 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;golang.org/x/net/websocket&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleEcho</span><span class=\"params\">(ws *websocket.Conn)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> reply <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err = websocket.Message.Receive(ws, &amp;reply); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[server] Can&#x27;t receive&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlog.Println(<span class=\"string\">&quot;[server] Received from client:&quot;</span>, reply)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmsg := <span class=\"string\">&quot;welcome: &quot;</span> + reply</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err = websocket.Message.Send(ws, msg); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[server] Can&#x27;t Send&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlog.Println(<span class=\"string\">&quot;[server] Send to client:&quot;</span>, msg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.Handle(<span class=\"string\">&quot;/&quot;</span>, websocket.Handler(handleEcho))</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;[server] listen in 127.0.0.1:7777&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := http.ListenAndServe(<span class=\"string\">&quot;:7777&quot;</span>, <span class=\"literal\">nil</span>); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(<span class=\"string\">&quot;[server] ListenAndServe:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行后在客户端页面点击Send Message按钮，可以看到服务端如下响应：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-e2ef3c1cb34f117d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-e2ef3c1cb34f117d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>【1】<a href=\"https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.2.md\">build-web-application-with-golang</a><br>【2】<a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096\">廖雪峰：WebSocket</a><br>【3】<a href=\"https://www.ruanyifeng.com/blog/2017/05/websocket.html\">阮一峰：WebSocket教程</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>WebSocket是一种网络通信协议，是HTML5新增的特性，实现了基于浏览器的远程socket，使浏览器和服务器可以进行全双工通信，大部分浏览器都对此做了支持。<br>WebSocket的URL格式形如：ws:&#x2F;&#x2F;localhost:80&#x2F;、wss:&#x2F;&#x2F;localhost:443&#x2F;</p>\n<h2 id=\"为什么有了HTTP协议还要WebSocket\"><a href=\"#为什么有了HTTP协议还要WebSocket\" class=\"headerlink\" title=\"为什么有了HTTP协议还要WebSocket\"></a>为什么有了HTTP协议还要WebSocket</h2><p>HTTP协议采用的是客户端（浏览器）轮询的方式，即客户端发送请求，服务端做出响应，为了获取最新的数据，需要不断的轮询发出HTTP请求，占用大量带宽。<br>WebSocket采用了一些特殊的报头，使得浏览器和服务器只需要通过“握手”建立一条连接通道后，此链接保持活跃状态，之后的客户端和服务器的通信都使用这个连接，解决了Web实时性的问题，相比于HTTP有一下好处：</p>\n<ul>\n<li>一个Web客户端只建立一个TCP连接</li>\n<li>WebSocket服务端可以主动推送（push）数据到Web客户端</li>\n<li>有更加轻量级的头，减少了数据传输量</li>\n</ul>\n<h2 id=\"WebSocket原理\"><a href=\"#WebSocket原理\" class=\"headerlink\" title=\"WebSocket原理\"></a>WebSocket原理</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-83f761a12847fa76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h3 id=\"建立连接\"><a href=\"#建立连接\" class=\"headerlink\" title=\"建立连接\"></a>建立连接</h3><p>WebSocket建立连接必须由浏览器发起，是一个标准的HTTP请求，如下图所示<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-0f3bd32d35e06362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h4 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h4><ol>\n<li>请求地址以<code>ws://</code>开头</li>\n<li>请求头<code>Upgrade: websocket</code>和<code>Connection:Upgrade</code>表示要将这个连接转换为WebSocket连接</li>\n<li><code>Sec-WebSocket-Key</code>用于标识连接，是一个base64编码的字符串</li>\n<li><code>Sec-WebSocket-Version</code>指定了WebSocket协议版本</li>\n</ol>\n<h4 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h4><ol>\n<li>响应状态码<code>101</code>表示本次连接的HTTP协议将被更改</li>\n<li><code>Upgrade: websocket</code>表示更改后的协议是WebSocket</li>\n<li><code>Sec-WebSocket-Accept</code>通过如下方式计算：</li>\n</ol>\n<ul>\n<li>对请求头的<code>Sec-WebSocket-Key</code>字符串加上一个固定的字符串，例如：<br><code>H+VLjR1wb4JQ62TmabK87g==258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code></li>\n<li>然后对该字符串用sha1算法散列出二进制值，再对其进行base64加密，例如：<br><code>ccJoRDcGOFzCVrIwpX/qF3BoIN0=</code></li>\n</ul>\n<h3 id=\"数据格式\"><a href=\"#数据格式\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h3><p>WebSocket的协议比较简单，在第一次handshake通过之后，连接建立成功，之后的通讯数据都是以”\\x00”开头，以”\\xFF”结尾，对客户端来说这个是透明的，WebSocket的实现组件会对原始数据掐头去尾。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>建立在TCP协议只上，服务端比较容易实现</li>\n<li>于HTTP协议有良好的兼容性，默认端口也是80和443，握手阶段使用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器</li>\n<li>数据格式轻量，通信高效且节省带宽</li>\n<li>支持传输文本数据和二进制数据</li>\n<li>没有同源限制，客户端可以与任意服务器通信</li>\n<li>也支持加密传输，WS+SSL，URL形如<code>wss://</code></li>\n</ol>\n<h2 id=\"Go语言实现\"><a href=\"#Go语言实现\" class=\"headerlink\" title=\"Go语言实现\"></a>Go语言实现</h2><p>go的标准SDK中没有支持WebSocket，但是官方维护的net子包中支持<br><code>go get golang.org/x/net/websocket</code></p>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> sock = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> wsuri = <span class=\"string\">&quot;ws://127.0.0.1:7777&quot;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">window</span>.<span class=\"property\">onload</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;onload&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock = <span class=\"keyword\">new</span> <span class=\"title class_\">WebSocket</span>(wsuri);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"property\">onopen</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;connected to &quot;</span> + wsuri);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"property\">onclose</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;connection closed (&quot;</span> + e.<span class=\"property\">code</span> + <span class=\"string\">&quot;)&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"property\">onmessage</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;message received: &quot;</span> + e.<span class=\"property\">data</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">function</span> <span class=\"title function_\">send</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">var</span> msg = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;message&#x27;</span>).<span class=\"property\">value</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"title function_\">send</span>(msg);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>WebSocket Echo Test<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        Message: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;message&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Hello, world!&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;send();&quot;</span>&gt;</span>Send Message<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>客户端JavaScript代码，通过<code>new WebSocket(wsuri)</code>创建了一个WebSocket连接，握手成功后会触发onopen事件，客户端绑定了四个事件：</p>\n<ul>\n<li>onopen：建立连接后触发</li>\n<li>onmessage：收到消息后触发</li>\n<li>onerror：发生错误时触发</li>\n<li>onclose：关闭连接时触发</li>\n</ul>\n<h3 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;golang.org/x/net/websocket&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleEcho</span><span class=\"params\">(ws *websocket.Conn)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> reply <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err = websocket.Message.Receive(ws, &amp;reply); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[server] Can&#x27;t receive&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlog.Println(<span class=\"string\">&quot;[server] Received from client:&quot;</span>, reply)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmsg := <span class=\"string\">&quot;welcome: &quot;</span> + reply</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err = websocket.Message.Send(ws, msg); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[server] Can&#x27;t Send&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlog.Println(<span class=\"string\">&quot;[server] Send to client:&quot;</span>, msg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.Handle(<span class=\"string\">&quot;/&quot;</span>, websocket.Handler(handleEcho))</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;[server] listen in 127.0.0.1:7777&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := http.ListenAndServe(<span class=\"string\">&quot;:7777&quot;</span>, <span class=\"literal\">nil</span>); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(<span class=\"string\">&quot;[server] ListenAndServe:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行后在客户端页面点击Send Message按钮，可以看到服务端如下响应：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-e2ef3c1cb34f117d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>【1】<a href=\"https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.2.md\">build-web-application-with-golang</a><br>【2】<a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096\">廖雪峰：WebSocket</a><br>【3】<a href=\"https://www.ruanyifeng.com/blog/2017/05/websocket.html\">阮一峰：WebSocket教程</a></p>\n"},{"title":"计算机网络基础概述","date":"2023-03-25T05:58:26.000Z","_content":"\n## 网络\n\n### 网络层\n\n### 传输层\n\n- TCP、UDP\n\n\t- 特点\n\n\t\t- UDP：无连接，尽最大可能交付数据，面向报文，支持一对一、一对多、多对一、多对多的交互通信，不可靠（快、实时性好）\n\n\t\t\t- DNS、TFTP\n\n\t\t- TCP：面向连接，可靠交付，有流量控制、拥塞控制，全双工通信，面向字节流，只能点对点（一对一）\n\n\t\t\t- HTTP、FTP、TELENT、SMTP\n\n\t- TCP三次握手\n\n\t\t- 防止失效的连接请求到达服务器，导致服务器打开无用的连接\n\n\t- TCP四次挥手\n\n\t\t- TIME_WAIT=2MSL\n\n\t\t\t- 确保最后一个确认报文能到达，因为如果丢失会重传\n\t\t\t- 让本次连接产生的所有报文都从网络中消失\n\n\t- TCP可靠传输\n\n\t\t- 超时重传RTT\n\n\t- TCP滑动窗口\n\t- TCP流量控制\n\n\t\t- 控制发送方速率，保证接收方来得及接收（通过确认报文的窗口字段控制发送方窗口大小）\n\n\t- TCP拥塞控制\n\n\t\t- 慢启动、拥塞避免、快重传、快恢复\n\n### 应用层\n\n- DNS\n\n\t- UDP+TCP\n\n- DHCP\n\n\t- 动态主机配置\n\n- Web页面请求过程\n\n\t- 1. DHCP配置主机信息\n\t- 2. ARP解析MAC地址\n\t- 3. DNS解析域名\n\t- 4. HTTP请求页面\n\n\t\t- 三次握手建立连接\n\t\t- 开始通信\n\n## Socket\n\n### 阻塞式I/O\n\n- 直到数据从内核缓冲区复制到应用进程缓冲区才返回（cpu并不会阻塞，其他进程还可以执行，cpu利用率较高）\n\n### 非阻塞式I/O\n\n- 应用进程执行系统调用后内核返回一个错误码，需要轮询来获知IO操作是否完成（CPU利用率低）\n\n### I/O多路复用\n\n- select、poll等待数据，当监听的某个套接字可读，再使用recvfrom把数据从内核复制到进程中\n\n\t- select\n\n\t\t- 会修改fd，默认只能监听少于1024个，轮询\n\n\t- poll\n\n\t\t- 提供了更多的事件类型，对fd的重复利用更高\n\n\t- epoll\n\n\t\t- 比上述两种更加灵活，对多线程更友好\n\n\t\t\t- epoll_create\n\n\t\t\t\t- 创建一个epoll句柄\n\n\t\t\t- epoll_ctl\n\n\t\t\t\t- 为fd注册事件并绑定一个回调函数，当设备就绪callback把fd加入就绪队列（列表）\n\n\t\t\t- epoll_wait\n\n\t\t\t\t- 轮询就绪队列（schedule_timeout()）\n\n### 信号驱动I/O\n\n- sigaction系统调用，当数据到达时内核会向进程发送SIGIO信号，收到信号后调用recvfrom（相比轮询的非阻塞I/O模型CPU利用率更高）\n\n### 异步I/O\n\n- aio_read系统调用，内核会在数据复制完成后向应用进程发送信号（注意和信号驱动I/O的区别）\n\n## HTTP\n\n### HTTP状态码\n\n- 1xx：信息性\n- 2xx：成功\n- 3xx：重定向\n\n\t- 301：永久重定向，会缓存\n\t- 302：临时重定向，不缓存，有url劫持问题\n\n- 4xx：客户端错误，服务端无法处理的请求\n- 5xx：服务器错误\n\n### Cookie\n\n- 客户端保存状态\n\n### Session\n\n- 服务器保存状态\n\n### HTTPS\n\n- HTTP+SSL\n- 使用非对称加密协商对称加密使用的Secretkey\n- 使用Secretkey对称加密数据\n- 使用数字证书保证公钥的正确性\n\n### HTTP2.0\n\n- 二进制分帧层\n- 服务端推送\n- 首部压缩\n\n[【参考文章】GitHub-CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes)\n","source":"_posts/2023/03-25-计算机网络基础概述.md","raw":"---\ntitle: 计算机网络基础概述\ndate: 2023-03-25 13:58:26\ncategories:\n- [计算机网络]\ntags:\n---\n\n## 网络\n\n### 网络层\n\n### 传输层\n\n- TCP、UDP\n\n\t- 特点\n\n\t\t- UDP：无连接，尽最大可能交付数据，面向报文，支持一对一、一对多、多对一、多对多的交互通信，不可靠（快、实时性好）\n\n\t\t\t- DNS、TFTP\n\n\t\t- TCP：面向连接，可靠交付，有流量控制、拥塞控制，全双工通信，面向字节流，只能点对点（一对一）\n\n\t\t\t- HTTP、FTP、TELENT、SMTP\n\n\t- TCP三次握手\n\n\t\t- 防止失效的连接请求到达服务器，导致服务器打开无用的连接\n\n\t- TCP四次挥手\n\n\t\t- TIME_WAIT=2MSL\n\n\t\t\t- 确保最后一个确认报文能到达，因为如果丢失会重传\n\t\t\t- 让本次连接产生的所有报文都从网络中消失\n\n\t- TCP可靠传输\n\n\t\t- 超时重传RTT\n\n\t- TCP滑动窗口\n\t- TCP流量控制\n\n\t\t- 控制发送方速率，保证接收方来得及接收（通过确认报文的窗口字段控制发送方窗口大小）\n\n\t- TCP拥塞控制\n\n\t\t- 慢启动、拥塞避免、快重传、快恢复\n\n### 应用层\n\n- DNS\n\n\t- UDP+TCP\n\n- DHCP\n\n\t- 动态主机配置\n\n- Web页面请求过程\n\n\t- 1. DHCP配置主机信息\n\t- 2. ARP解析MAC地址\n\t- 3. DNS解析域名\n\t- 4. HTTP请求页面\n\n\t\t- 三次握手建立连接\n\t\t- 开始通信\n\n## Socket\n\n### 阻塞式I/O\n\n- 直到数据从内核缓冲区复制到应用进程缓冲区才返回（cpu并不会阻塞，其他进程还可以执行，cpu利用率较高）\n\n### 非阻塞式I/O\n\n- 应用进程执行系统调用后内核返回一个错误码，需要轮询来获知IO操作是否完成（CPU利用率低）\n\n### I/O多路复用\n\n- select、poll等待数据，当监听的某个套接字可读，再使用recvfrom把数据从内核复制到进程中\n\n\t- select\n\n\t\t- 会修改fd，默认只能监听少于1024个，轮询\n\n\t- poll\n\n\t\t- 提供了更多的事件类型，对fd的重复利用更高\n\n\t- epoll\n\n\t\t- 比上述两种更加灵活，对多线程更友好\n\n\t\t\t- epoll_create\n\n\t\t\t\t- 创建一个epoll句柄\n\n\t\t\t- epoll_ctl\n\n\t\t\t\t- 为fd注册事件并绑定一个回调函数，当设备就绪callback把fd加入就绪队列（列表）\n\n\t\t\t- epoll_wait\n\n\t\t\t\t- 轮询就绪队列（schedule_timeout()）\n\n### 信号驱动I/O\n\n- sigaction系统调用，当数据到达时内核会向进程发送SIGIO信号，收到信号后调用recvfrom（相比轮询的非阻塞I/O模型CPU利用率更高）\n\n### 异步I/O\n\n- aio_read系统调用，内核会在数据复制完成后向应用进程发送信号（注意和信号驱动I/O的区别）\n\n## HTTP\n\n### HTTP状态码\n\n- 1xx：信息性\n- 2xx：成功\n- 3xx：重定向\n\n\t- 301：永久重定向，会缓存\n\t- 302：临时重定向，不缓存，有url劫持问题\n\n- 4xx：客户端错误，服务端无法处理的请求\n- 5xx：服务器错误\n\n### Cookie\n\n- 客户端保存状态\n\n### Session\n\n- 服务器保存状态\n\n### HTTPS\n\n- HTTP+SSL\n- 使用非对称加密协商对称加密使用的Secretkey\n- 使用Secretkey对称加密数据\n- 使用数字证书保证公钥的正确性\n\n### HTTP2.0\n\n- 二进制分帧层\n- 服务端推送\n- 首部压缩\n\n[【参考文章】GitHub-CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes)\n","slug":"计算机网络基础概述","published":1,"updated":"2023-03-25T06:58:34.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnmj18c003vhtfi5a27fklh","content":"<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h3><h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h3><ul>\n<li><p>TCP、UDP</p>\n<ul>\n<li><p>特点</p>\n<ul>\n<li><p>UDP：无连接，尽最大可能交付数据，面向报文，支持一对一、一对多、多对一、多对多的交互通信，不可靠（快、实时性好）</p>\n<ul>\n<li>DNS、TFTP</li>\n</ul>\n</li>\n<li><p>TCP：面向连接，可靠交付，有流量控制、拥塞控制，全双工通信，面向字节流，只能点对点（一对一）</p>\n<ul>\n<li>HTTP、FTP、TELENT、SMTP</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>TCP三次握手</p>\n<ul>\n<li>防止失效的连接请求到达服务器，导致服务器打开无用的连接</li>\n</ul>\n</li>\n<li><p>TCP四次挥手</p>\n<ul>\n<li><p>TIME_WAIT&#x3D;2MSL</p>\n<ul>\n<li>确保最后一个确认报文能到达，因为如果丢失会重传</li>\n<li>让本次连接产生的所有报文都从网络中消失</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>TCP可靠传输</p>\n<ul>\n<li>超时重传RTT</li>\n</ul>\n</li>\n<li><p>TCP滑动窗口</p>\n</li>\n<li><p>TCP流量控制</p>\n<ul>\n<li>控制发送方速率，保证接收方来得及接收（通过确认报文的窗口字段控制发送方窗口大小）</li>\n</ul>\n</li>\n<li><p>TCP拥塞控制</p>\n<ul>\n<li>慢启动、拥塞避免、快重传、快恢复</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h3><ul>\n<li><p>DNS</p>\n<ul>\n<li>UDP+TCP</li>\n</ul>\n</li>\n<li><p>DHCP</p>\n<ul>\n<li>动态主机配置</li>\n</ul>\n</li>\n<li><p>Web页面请求过程</p>\n<ul>\n<li><ol>\n<li>DHCP配置主机信息</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>ARP解析MAC地址</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>DNS解析域名</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>HTTP请求页面</li>\n</ol>\n<ul>\n<li>三次握手建立连接</li>\n<li>开始通信</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h2><h3 id=\"阻塞式I-x2F-O\"><a href=\"#阻塞式I-x2F-O\" class=\"headerlink\" title=\"阻塞式I&#x2F;O\"></a>阻塞式I&#x2F;O</h3><ul>\n<li>直到数据从内核缓冲区复制到应用进程缓冲区才返回（cpu并不会阻塞，其他进程还可以执行，cpu利用率较高）</li>\n</ul>\n<h3 id=\"非阻塞式I-x2F-O\"><a href=\"#非阻塞式I-x2F-O\" class=\"headerlink\" title=\"非阻塞式I&#x2F;O\"></a>非阻塞式I&#x2F;O</h3><ul>\n<li>应用进程执行系统调用后内核返回一个错误码，需要轮询来获知IO操作是否完成（CPU利用率低）</li>\n</ul>\n<h3 id=\"I-x2F-O多路复用\"><a href=\"#I-x2F-O多路复用\" class=\"headerlink\" title=\"I&#x2F;O多路复用\"></a>I&#x2F;O多路复用</h3><ul>\n<li><p>select、poll等待数据，当监听的某个套接字可读，再使用recvfrom把数据从内核复制到进程中</p>\n<ul>\n<li><p>select</p>\n<ul>\n<li>会修改fd，默认只能监听少于1024个，轮询</li>\n</ul>\n</li>\n<li><p>poll</p>\n<ul>\n<li>提供了更多的事件类型，对fd的重复利用更高</li>\n</ul>\n</li>\n<li><p>epoll</p>\n<ul>\n<li><p>比上述两种更加灵活，对多线程更友好</p>\n<ul>\n<li><p>epoll_create</p>\n<ul>\n<li>创建一个epoll句柄</li>\n</ul>\n</li>\n<li><p>epoll_ctl</p>\n<ul>\n<li>为fd注册事件并绑定一个回调函数，当设备就绪callback把fd加入就绪队列（列表）</li>\n</ul>\n</li>\n<li><p>epoll_wait</p>\n<ul>\n<li>轮询就绪队列（schedule_timeout()）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"信号驱动I-x2F-O\"><a href=\"#信号驱动I-x2F-O\" class=\"headerlink\" title=\"信号驱动I&#x2F;O\"></a>信号驱动I&#x2F;O</h3><ul>\n<li>sigaction系统调用，当数据到达时内核会向进程发送SIGIO信号，收到信号后调用recvfrom（相比轮询的非阻塞I&#x2F;O模型CPU利用率更高）</li>\n</ul>\n<h3 id=\"异步I-x2F-O\"><a href=\"#异步I-x2F-O\" class=\"headerlink\" title=\"异步I&#x2F;O\"></a>异步I&#x2F;O</h3><ul>\n<li>aio_read系统调用，内核会在数据复制完成后向应用进程发送信号（注意和信号驱动I&#x2F;O的区别）</li>\n</ul>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><ul>\n<li><p>1xx：信息性</p>\n</li>\n<li><p>2xx：成功</p>\n</li>\n<li><p>3xx：重定向</p>\n<ul>\n<li>301：永久重定向，会缓存</li>\n<li>302：临时重定向，不缓存，有url劫持问题</li>\n</ul>\n</li>\n<li><p>4xx：客户端错误，服务端无法处理的请求</p>\n</li>\n<li><p>5xx：服务器错误</p>\n</li>\n</ul>\n<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><ul>\n<li>客户端保存状态</li>\n</ul>\n<h3 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h3><ul>\n<li>服务器保存状态</li>\n</ul>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><ul>\n<li>HTTP+SSL</li>\n<li>使用非对称加密协商对称加密使用的Secretkey</li>\n<li>使用Secretkey对称加密数据</li>\n<li>使用数字证书保证公钥的正确性</li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><ul>\n<li>二进制分帧层</li>\n<li>服务端推送</li>\n<li>首部压缩</li>\n</ul>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">【参考文章】GitHub-CyC2018&#x2F;CS-Notes</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h3><h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h3><ul>\n<li><p>TCP、UDP</p>\n<ul>\n<li><p>特点</p>\n<ul>\n<li><p>UDP：无连接，尽最大可能交付数据，面向报文，支持一对一、一对多、多对一、多对多的交互通信，不可靠（快、实时性好）</p>\n<ul>\n<li>DNS、TFTP</li>\n</ul>\n</li>\n<li><p>TCP：面向连接，可靠交付，有流量控制、拥塞控制，全双工通信，面向字节流，只能点对点（一对一）</p>\n<ul>\n<li>HTTP、FTP、TELENT、SMTP</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>TCP三次握手</p>\n<ul>\n<li>防止失效的连接请求到达服务器，导致服务器打开无用的连接</li>\n</ul>\n</li>\n<li><p>TCP四次挥手</p>\n<ul>\n<li><p>TIME_WAIT&#x3D;2MSL</p>\n<ul>\n<li>确保最后一个确认报文能到达，因为如果丢失会重传</li>\n<li>让本次连接产生的所有报文都从网络中消失</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>TCP可靠传输</p>\n<ul>\n<li>超时重传RTT</li>\n</ul>\n</li>\n<li><p>TCP滑动窗口</p>\n</li>\n<li><p>TCP流量控制</p>\n<ul>\n<li>控制发送方速率，保证接收方来得及接收（通过确认报文的窗口字段控制发送方窗口大小）</li>\n</ul>\n</li>\n<li><p>TCP拥塞控制</p>\n<ul>\n<li>慢启动、拥塞避免、快重传、快恢复</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h3><ul>\n<li><p>DNS</p>\n<ul>\n<li>UDP+TCP</li>\n</ul>\n</li>\n<li><p>DHCP</p>\n<ul>\n<li>动态主机配置</li>\n</ul>\n</li>\n<li><p>Web页面请求过程</p>\n<ul>\n<li><ol>\n<li>DHCP配置主机信息</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>ARP解析MAC地址</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>DNS解析域名</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>HTTP请求页面</li>\n</ol>\n<ul>\n<li>三次握手建立连接</li>\n<li>开始通信</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h2><h3 id=\"阻塞式I-x2F-O\"><a href=\"#阻塞式I-x2F-O\" class=\"headerlink\" title=\"阻塞式I&#x2F;O\"></a>阻塞式I&#x2F;O</h3><ul>\n<li>直到数据从内核缓冲区复制到应用进程缓冲区才返回（cpu并不会阻塞，其他进程还可以执行，cpu利用率较高）</li>\n</ul>\n<h3 id=\"非阻塞式I-x2F-O\"><a href=\"#非阻塞式I-x2F-O\" class=\"headerlink\" title=\"非阻塞式I&#x2F;O\"></a>非阻塞式I&#x2F;O</h3><ul>\n<li>应用进程执行系统调用后内核返回一个错误码，需要轮询来获知IO操作是否完成（CPU利用率低）</li>\n</ul>\n<h3 id=\"I-x2F-O多路复用\"><a href=\"#I-x2F-O多路复用\" class=\"headerlink\" title=\"I&#x2F;O多路复用\"></a>I&#x2F;O多路复用</h3><ul>\n<li><p>select、poll等待数据，当监听的某个套接字可读，再使用recvfrom把数据从内核复制到进程中</p>\n<ul>\n<li><p>select</p>\n<ul>\n<li>会修改fd，默认只能监听少于1024个，轮询</li>\n</ul>\n</li>\n<li><p>poll</p>\n<ul>\n<li>提供了更多的事件类型，对fd的重复利用更高</li>\n</ul>\n</li>\n<li><p>epoll</p>\n<ul>\n<li><p>比上述两种更加灵活，对多线程更友好</p>\n<ul>\n<li><p>epoll_create</p>\n<ul>\n<li>创建一个epoll句柄</li>\n</ul>\n</li>\n<li><p>epoll_ctl</p>\n<ul>\n<li>为fd注册事件并绑定一个回调函数，当设备就绪callback把fd加入就绪队列（列表）</li>\n</ul>\n</li>\n<li><p>epoll_wait</p>\n<ul>\n<li>轮询就绪队列（schedule_timeout()）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"信号驱动I-x2F-O\"><a href=\"#信号驱动I-x2F-O\" class=\"headerlink\" title=\"信号驱动I&#x2F;O\"></a>信号驱动I&#x2F;O</h3><ul>\n<li>sigaction系统调用，当数据到达时内核会向进程发送SIGIO信号，收到信号后调用recvfrom（相比轮询的非阻塞I&#x2F;O模型CPU利用率更高）</li>\n</ul>\n<h3 id=\"异步I-x2F-O\"><a href=\"#异步I-x2F-O\" class=\"headerlink\" title=\"异步I&#x2F;O\"></a>异步I&#x2F;O</h3><ul>\n<li>aio_read系统调用，内核会在数据复制完成后向应用进程发送信号（注意和信号驱动I&#x2F;O的区别）</li>\n</ul>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><ul>\n<li><p>1xx：信息性</p>\n</li>\n<li><p>2xx：成功</p>\n</li>\n<li><p>3xx：重定向</p>\n<ul>\n<li>301：永久重定向，会缓存</li>\n<li>302：临时重定向，不缓存，有url劫持问题</li>\n</ul>\n</li>\n<li><p>4xx：客户端错误，服务端无法处理的请求</p>\n</li>\n<li><p>5xx：服务器错误</p>\n</li>\n</ul>\n<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><ul>\n<li>客户端保存状态</li>\n</ul>\n<h3 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h3><ul>\n<li>服务器保存状态</li>\n</ul>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><ul>\n<li>HTTP+SSL</li>\n<li>使用非对称加密协商对称加密使用的Secretkey</li>\n<li>使用Secretkey对称加密数据</li>\n<li>使用数字证书保证公钥的正确性</li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><ul>\n<li>二进制分帧层</li>\n<li>服务端推送</li>\n<li>首部压缩</li>\n</ul>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">【参考文章】GitHub-CyC2018&#x2F;CS-Notes</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clfnmj16w0001htfi4vki430r","category_id":"clfnmj1720004htfi2rb98hji","_id":"clfnmj17b000ghtfi9qhd95fg"},{"post_id":"clfnmj16z0003htfi2lthgtz6","category_id":"clfnmj1720004htfi2rb98hji","_id":"clfnmj17d000khtfibwffg5r6"},{"post_id":"clfnmj1740007htfihs2y1184","category_id":"clfnmj17b000fhtfihdg976ai","_id":"clfnmj17g000uhtfi5qcmc104"},{"post_id":"clfnmj1760009htfibrqw4ekc","category_id":"clfnmj17b000fhtfihdg976ai","_id":"clfnmj17j0010htfi36jrh9s4"},{"post_id":"clfnmj177000ahtfihx9degr6","category_id":"clfnmj17b000fhtfihdg976ai","_id":"clfnmj17l0016htfih1w772w3"},{"post_id":"clfnmj179000dhtfify4ib4mh","category_id":"clfnmj17b000fhtfihdg976ai","_id":"clfnmj17n001bhtfihedp2xoo"},{"post_id":"clfnmj17a000ehtfi4p2500xf","category_id":"clfnmj17b000fhtfihdg976ai","_id":"clfnmj17o001ghtfi6kof4siz"},{"post_id":"clfnmj17b000ihtfibvkr75sx","category_id":"clfnmj17m0019htfid7mratia","_id":"clfnmj17p001khtfifwnp0l7g"},{"post_id":"clfnmj17c000jhtfi6lvs0mpj","category_id":"clfnmj17m0019htfid7mratia","_id":"clfnmj17q001ohtfihl5s0vu0"},{"post_id":"clfnmj17e000nhtfi7io97kj0","category_id":"clfnmj17m0019htfid7mratia","_id":"clfnmj17q001shtfi5nbaec7k"},{"post_id":"clfnmj17e000phtfi3dcp63rz","category_id":"clfnmj17m0019htfid7mratia","_id":"clfnmj17r001vhtfi4l262q4f"},{"post_id":"clfnmj17g000thtfib2uj2sjy","category_id":"clfnmj17m0019htfid7mratia","_id":"clfnmj17r001zhtfi28xw53t2"},{"post_id":"clfnmj17g000whtfia8wj7it8","category_id":"clfnmj17m0019htfid7mratia","_id":"clfnmj17s0024htfi678ogy2w"},{"post_id":"clfnmj17j000zhtfi7t0l4ewz","category_id":"clfnmj17m0019htfid7mratia","_id":"clfnmj17t0028htficeyjhetm"},{"post_id":"clfnmj17j0012htfie4t076a3","category_id":"clfnmj17m0019htfid7mratia","_id":"clfnmj17t002chtfign255onx"},{"post_id":"clfnmj17k0015htfi9ocee1l6","category_id":"clfnmj17t0026htfihzt2g5kg","_id":"clfnmj17u002fhtfi8p2vbu0q"},{"post_id":"clfnmj17m0018htfihaxs5lor","category_id":"clfnmj17t0026htfihzt2g5kg","_id":"clfnmj17v002ihtfiavemd7q9"},{"post_id":"clfnmj17n001ahtfi0lje1olr","category_id":"clfnmj17t0026htfihzt2g5kg","_id":"clfnmj17v002khtfi1akpgax7"},{"post_id":"clfnmj17n001dhtfi2c583bzk","category_id":"clfnmj17t0026htfihzt2g5kg","_id":"clfnmj17v002ohtfi9num8r84"},{"post_id":"clfnmj18c003vhtfi5a27fklh","category_id":"clfnmj17t0026htfihzt2g5kg","_id":"clfnmj18d003whtfi1x6r2pd7"}],"PostTag":[{"post_id":"clfnmj16w0001htfi4vki430r","tag_id":"clfnmj1730005htfihradazet","_id":"clfnmj17e000ohtfi4xoy5w1h"},{"post_id":"clfnmj16w0001htfi4vki430r","tag_id":"clfnmj178000chtfield5d37o","_id":"clfnmj17f000rhtfih44davxq"},{"post_id":"clfnmj16w0001htfi4vki430r","tag_id":"clfnmj17b000hhtfi6p3ic475","_id":"clfnmj17g000vhtfi3fp254mo"},{"post_id":"clfnmj16z0003htfi2lthgtz6","tag_id":"clfnmj1730005htfihradazet","_id":"clfnmj17j0011htfid1k81xwv"},{"post_id":"clfnmj16z0003htfi2lthgtz6","tag_id":"clfnmj17f000shtfiamdv4zvk","_id":"clfnmj17k0014htfi21oz4os5"},{"post_id":"clfnmj1740007htfihs2y1184","tag_id":"clfnmj17i000yhtfig6x9h2ut","_id":"clfnmj17o001ehtfibn500dqj"},{"post_id":"clfnmj1740007htfihs2y1184","tag_id":"clfnmj17l0017htfi1y668awh","_id":"clfnmj17o001hhtfi30ba9tmu"},{"post_id":"clfnmj1760009htfibrqw4ekc","tag_id":"clfnmj17n001chtfib4qx3096","_id":"clfnmj17p001mhtfi71nw1mkw"},{"post_id":"clfnmj1760009htfibrqw4ekc","tag_id":"clfnmj17l0017htfi1y668awh","_id":"clfnmj17q001phtficsch3f4n"},{"post_id":"clfnmj177000ahtfihx9degr6","tag_id":"clfnmj17p001lhtfi5izbfqfc","_id":"clfnmj17r001yhtfi2vtb14ku"},{"post_id":"clfnmj177000ahtfihx9degr6","tag_id":"clfnmj17q001qhtfibjtp3mdi","_id":"clfnmj17s0020htfihwbb93ds"},{"post_id":"clfnmj177000ahtfihx9degr6","tag_id":"clfnmj17l0017htfi1y668awh","_id":"clfnmj17s0023htfi23qo05gb"},{"post_id":"clfnmj179000dhtfify4ib4mh","tag_id":"clfnmj17r001whtfievk97n61","_id":"clfnmj17t0027htfi08gi9v5f"},{"post_id":"clfnmj179000dhtfify4ib4mh","tag_id":"clfnmj17l0017htfi1y668awh","_id":"clfnmj17t0029htfibv0f2xyi"},{"post_id":"clfnmj17a000ehtfi4p2500xf","tag_id":"clfnmj17s0025htfi21op8xs5","_id":"clfnmj17v002lhtfi7yql94f3"},{"post_id":"clfnmj17a000ehtfi4p2500xf","tag_id":"clfnmj17t002ahtfi8iefbfsx","_id":"clfnmj17v002mhtfi6hui9ay6"},{"post_id":"clfnmj17a000ehtfi4p2500xf","tag_id":"clfnmj17u002ehtfi7t85aai2","_id":"clfnmj17v002phtfi9h6h2j8y"},{"post_id":"clfnmj17a000ehtfi4p2500xf","tag_id":"clfnmj17l0017htfi1y668awh","_id":"clfnmj17w002qhtfi9f496bgl"},{"post_id":"clfnmj17b000ihtfibvkr75sx","tag_id":"clfnmj17l0017htfi1y668awh","_id":"clfnmj17w002shtfifgd81jhf"},{"post_id":"clfnmj17c000jhtfi6lvs0mpj","tag_id":"clfnmj17v002nhtfi1tqved4d","_id":"clfnmj17w002thtficgt746t9"},{"post_id":"clfnmj17e000nhtfi7io97kj0","tag_id":"clfnmj17w002rhtfihxsk3q0b","_id":"clfnmj17w002whtfi6bekgyod"},{"post_id":"clfnmj17e000nhtfi7io97kj0","tag_id":"clfnmj17l0017htfi1y668awh","_id":"clfnmj17w002xhtfiap4z9qxx"},{"post_id":"clfnmj17e000phtfi3dcp63rz","tag_id":"clfnmj17l0017htfi1y668awh","_id":"clfnmj17x0031htfi8xccaqe1"},{"post_id":"clfnmj17e000phtfi3dcp63rz","tag_id":"clfnmj17w002yhtfi4dvk9iox","_id":"clfnmj17x0032htfifrkidwy1"},{"post_id":"clfnmj17e000phtfi3dcp63rz","tag_id":"clfnmj17x002zhtficzgzf5yn","_id":"clfnmj17y0034htfi0kvl5l2v"},{"post_id":"clfnmj17g000thtfib2uj2sjy","tag_id":"clfnmj17l0017htfi1y668awh","_id":"clfnmj17z0036htfihaxv0md8"},{"post_id":"clfnmj17g000thtfib2uj2sjy","tag_id":"clfnmj17x0033htfif13bg3ss","_id":"clfnmj17z0037htfi5w538vju"},{"post_id":"clfnmj17g000whtfia8wj7it8","tag_id":"clfnmj17y0035htfibbyn459l","_id":"clfnmj180003ahtfi4woffby2"},{"post_id":"clfnmj17g000whtfia8wj7it8","tag_id":"clfnmj17l0017htfi1y668awh","_id":"clfnmj180003bhtfihgcfbbxr"},{"post_id":"clfnmj17j000zhtfi7t0l4ewz","tag_id":"clfnmj17l0017htfi1y668awh","_id":"clfnmj181003ehtfi3h3c2tc4"},{"post_id":"clfnmj17j000zhtfi7t0l4ewz","tag_id":"clfnmj180003chtfid39dfdd3","_id":"clfnmj181003fhtfiffub7dt7"},{"post_id":"clfnmj17j0012htfie4t076a3","tag_id":"clfnmj17l0017htfi1y668awh","_id":"clfnmj182003jhtfih0lg1mpf"},{"post_id":"clfnmj17j0012htfie4t076a3","tag_id":"clfnmj181003ghtfi7gj06ofb","_id":"clfnmj182003khtfi769r2kdp"},{"post_id":"clfnmj17j0012htfie4t076a3","tag_id":"clfnmj181003hhtfi73xwhqnm","_id":"clfnmj182003mhtfid8dzdv9n"},{"post_id":"clfnmj17k0015htfi9ocee1l6","tag_id":"clfnmj181003ihtfi2supg7rc","_id":"clfnmj182003nhtfi389vfher"},{"post_id":"clfnmj17m0018htfihaxs5lor","tag_id":"clfnmj182003lhtfi2kxq5yj1","_id":"clfnmj183003qhtfi11d8g1u6"},{"post_id":"clfnmj17m0018htfihaxs5lor","tag_id":"clfnmj182003ohtfi59fq3via","_id":"clfnmj183003rhtfihkqqftla"},{"post_id":"clfnmj17n001ahtfi0lje1olr","tag_id":"clfnmj183003phtfigfh2ana2","_id":"clfnmj184003thtfigpr8ejru"},{"post_id":"clfnmj17n001dhtfi2c583bzk","tag_id":"clfnmj183003shtfidbew2hpq","_id":"clfnmj184003uhtfi6crlhik7"}],"Tag":[{"name":"Linux","_id":"clfnmj1730005htfihradazet"},{"name":"I/O模型","_id":"clfnmj178000chtfield5d37o"},{"name":"select/poll/epoll","_id":"clfnmj17b000hhtfi6p3ic475"},{"name":"守护进程","_id":"clfnmj17f000shtfiamdv4zvk"},{"name":"数组","_id":"clfnmj17i000yhtfig6x9h2ut"},{"name":"leetcode","_id":"clfnmj17l0017htfi1y668awh"},{"name":"字符串","_id":"clfnmj17n001chtfib4qx3096"},{"name":"树","_id":"clfnmj17p001lhtfi5izbfqfc"},{"name":"二叉树","_id":"clfnmj17q001qhtfibjtp3mdi"},{"name":"链表","_id":"clfnmj17r001whtfievk97n61"},{"name":"栈","_id":"clfnmj17s0025htfi21op8xs5"},{"name":"队列","_id":"clfnmj17t002ahtfi8iefbfsx"},{"name":"堆","_id":"clfnmj17u002ehtfi7t85aai2"},{"name":"快速排序","_id":"clfnmj17v002nhtfi1tqved4d"},{"name":"二分查找","_id":"clfnmj17w002rhtfihxsk3q0b"},{"name":"深度优先搜索","_id":"clfnmj17w002yhtfi4dvk9iox"},{"name":"广度优先搜索","_id":"clfnmj17x002zhtficzgzf5yn"},{"name":"二叉搜索树","_id":"clfnmj17x0033htfif13bg3ss"},{"name":"贪心","_id":"clfnmj17y0035htfibbyn459l"},{"name":"动态规划","_id":"clfnmj180003chtfid39dfdd3"},{"name":"LRU","_id":"clfnmj181003ghtfi7gj06ofb"},{"name":"缓存","_id":"clfnmj181003hhtfi73xwhqnm"},{"name":"HTTPS","_id":"clfnmj181003ihtfi2supg7rc"},{"name":"Session","_id":"clfnmj182003lhtfi2kxq5yj1"},{"name":"Cookie","_id":"clfnmj182003ohtfi59fq3via"},{"name":"TCP","_id":"clfnmj183003phtfigfh2ana2"},{"name":"WebSocket","_id":"clfnmj183003shtfidbew2hpq"}]}}