{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"node_modules/hexo-theme-volantis/source/css/Readme.md","path":"css/Readme.md","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/css/first.styl","path":"css/first.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/app.js","path":"js/app.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/search/hexo.js","path":"js/search/hexo.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/aplayer.js","path":"js/plugins/aplayer.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/parallax.js","path":"js/plugins/parallax.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/rightMenu.js","path":"js/plugins/rightMenu.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/rightMenus.js","path":"js/plugins/rightMenus.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/contributors.js","path":"js/plugins/tags/contributors.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/friends.js","path":"js/plugins/tags/friends.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/sites.js","path":"js/plugins/tags/sites.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.nojekyll","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1679328496466},{"_id":"source/CNAME","hash":"4abcec34201ece318489203a9b6c7510711d6fe3","modified":1679328488572},{"_id":"source/about/index.md","hash":"66c5b842c80d6fbb554aff0267352d00572effd6","modified":1678896023237},{"_id":"source/tags/index.md","hash":"ceab5572620c5bfc491d95fbe7c41cd7c38efb83","modified":1679208308655},{"_id":"source/categories/index.md","hash":"8432c770011786e35038abb0134e66564b9ef052","modified":1679208299152},{"_id":"source/friends/index.md","hash":"82e628bc7e4c0efe3fe96a8c5c76576e98f6c037","modified":1679208391862},{"_id":"source/_posts/2023/03-19-Linux-系统-I-O-模型及-select-poll-epoll-详解.md","hash":"4a6f019e99982114f0395621b7c807b61f9ab2d1","modified":1679234873184},{"_id":"source/_posts/2023/03-13-Linux进程管理-supervisor和nohup原理及使用.md","hash":"9589e3ee137be57063ade380b41db9475d0ace1f","modified":1679232880029},{"_id":"source/_posts/2023/03-19-数据结构-1-字符串.md","hash":"6e85efe0a0b63deccac7f2c54d25625b871fda53","modified":1679233844172},{"_id":"source/_posts/2023/03-19-数据结构-2-数组.md","hash":"6617e78e56160b11bd3564a86e99e87cd162963d","modified":1679236450345},{"_id":"source/_posts/2023/03-19-数据结构-4-树.md","hash":"e420726ef4f4d5c13c8262c06ddf378b74d77978","modified":1679235104657},{"_id":"source/_posts/2023/03-19-数据结构-5-栈-队列-堆.md","hash":"37004b3a86cf924306c067560fbae6c9eacdf30c","modified":1679235102479},{"_id":"source/_posts/2023/03-19-数据结构-3-链表.md","hash":"3f9d0ae00e6779e0c3aa85e49334058a7af1f997","modified":1679235106240},{"_id":"source/_posts/2023/03-19-算法-1-双指针.md","hash":"aee52409234924e337f9b7b49b92179723f75b1d","modified":1679236190124},{"_id":"source/_posts/2023/03-19-算法-2-排序.md","hash":"f8db5cb72373d47887c805b8bfd5a57787e1ede9","modified":1679233813288},{"_id":"source/_posts/2023/03-19-算法-3-二分查找.md","hash":"dbdb41e28321e2fea4137a16c2ac3340991a3e34","modified":1679233919644},{"_id":"source/_posts/2023/03-19-算法-4-搜索.md","hash":"182f1b86bdf5fd0d7b4328e22871ac5d7797f478","modified":1679234020173},{"_id":"source/_posts/2023/03-19-算法-6-贪心算法.md","hash":"ef2032ca91c8ad068c0878b039ab351fb0d5ec78","modified":1679234185642},{"_id":"source/_posts/2023/03-19-算法-5-分治-归并.md","hash":"c9e71ecaff8ea3ef8177aa93a2426895edaf0c82","modified":1679234112104},{"_id":"source/_posts/2023/03-19-算法-7-动态规划.md","hash":"417f3b2aa9baed3fa7f27a30ae7a903bbffdc657","modified":1679234232016},{"_id":"source/_posts/2023/03-19-算法-8-LRU-策略.md","hash":"c085fea88b4a9f1ada230ecf4249c6251848cba2","modified":1679234433583},{"_id":"source/_posts/2023/03-25-MySQL-ORDER-BY-如何实现排序的.md","hash":"2d7d06096426f5a42ec2f138af62d70c1b8bcd00","modified":1679728697890},{"_id":"source/_posts/2023/03-25-HTTPS原理详解.md","hash":"22500f11ad311b1bb2bf8859f24e2a3339d652e8","modified":1679727503210},{"_id":"source/_posts/2023/03-25-MySQL-中一条-SQL-语句是如何执行的？.md","hash":"adfe13b71d22dc7329af2dc16036257103823959","modified":1679728689590},{"_id":"source/_posts/2023/03-25-MySQL-和-NoSQL基础知识概述.md","hash":"d870239b23b5c81dae84d967142c131a52204cab","modified":1679728731284},{"_id":"source/_posts/2023/03-25-MySQL-索引原理详解.md","hash":"77db7cecdd7756665b339376d0ea9918942b4a3e","modified":1679728669471},{"_id":"source/_posts/2023/03-25-MySQL-脏页刷盘.md","hash":"7fc002135280317b0f391816c829e472b25879db","modified":1679728682317},{"_id":"source/_posts/2023/03-25-MySQL-连接错误问题解决.md","hash":"53cafeeea23afdc8af56a27044fbd553db4270b5","modified":1679728717329},{"_id":"source/_posts/2023/03-25-Redis-基础知识概述.md","hash":"28f6083293f32acca1b2a4c9ac4d4768cb16220e","modified":1679728633261},{"_id":"source/_posts/2023/03-25-Redis-热点-key-问题如何解决.md","hash":"fea17425080c1b3ce92925bd330f7f6bb543be34","modified":1679728102815},{"_id":"source/_posts/2023/03-25-Redis-集群架构.md","hash":"aa242d660f2d98ad7609b82ffad0753bd8b2bf79","modified":1679728074828},{"_id":"source/_posts/2023/03-25-Session和Cookie.md","hash":"a90f6899579a5bfb479935058982ea4596bde836","modified":1679727496825},{"_id":"source/_posts/2023/03-25-TCP是如何实现可靠传输的？.md","hash":"0b1e15a1d05df0c8be49ae5fcfb1d0038d94cb75","modified":1679727527366},{"_id":"source/_posts/2023/03-25-一致性哈希算法原理.md","hash":"fa9b53c1039d1615050d187c9ddb44028f5f69da","modified":1679729528770},{"_id":"source/_posts/2023/03-25-什么是WebSocket？.md","hash":"f76e0f7107114b8ec8ce26c90ef6cf027b9455df","modified":1679727509044},{"_id":"source/_posts/2023/03-25-从五个问题出发认识消息队列.md","hash":"9dcbdbca7fb1faebbf70732d8bb4fe7661fc19fb","modified":1679729284198},{"_id":"source/_posts/2023/03-25-分布式全局唯一-ID-生成方案有哪些？.md","hash":"ec4ee73413d43c6e2176eb6a4f69a9cd959dbf58","modified":1679729363961},{"_id":"source/_posts/2023/03-25-分布式系统基础知识概述.md","hash":"1077145cfbbe3dcc99dabec5ee7e69f46fd854ae","modified":1679729196365},{"_id":"source/_posts/2023/03-25-数据库和缓存数据一致性问题如何解决.md","hash":"255bf75551e5e9a9648c4d75a9cb4b6ccb7e6fbc","modified":1679729496643},{"_id":"source/_posts/2023/03-25-数据库基础知识概述.md","hash":"23994cb179efca84ac977bedbf85c305e3c65179","modified":1679729100729},{"_id":"source/_posts/2023/03-25-无处不在的微服务.md","hash":"4f56470c47cbf61fe39f0fdc16a06051215769fb","modified":1679729740565},{"_id":"source/_posts/2023/03-25-计算机网络基础概述.md","hash":"b99697fae03c696f4519dc7e90d1a301850a3276","modified":1679727514841},{"_id":"source/_posts/2023/03-25-限流算法有哪些.md","hash":"7a8ed0f7281164d1efd99b6d7a8a6049919ce3b0","modified":1679729408084},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/blank.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1678894222412},{"_id":"node_modules/hexo-theme-volantis/CHANGELOG.md","hash":"3ae7ef835db0043e093a89516154849e85ae9ce8","modified":1678894223366},{"_id":"node_modules/hexo-theme-volantis/LICENSE","hash":"13b0862f4ed1914abe887a47df2c3ca5adfa8f3f","modified":1678894222402},{"_id":"node_modules/hexo-theme-volantis/_config.yml","hash":"8f8e65ce2447e742da135b33a16b3ac3207ae4bf","modified":1678894225351},{"_id":"node_modules/hexo-theme-volantis/README.md","hash":"7c43923ced74698b0dfffb0ff1c53a70ad16e6fb","modified":1678894223366},{"_id":"node_modules/hexo-theme-volantis/languages/en.yml","hash":"cb84db341aeab91676b603cf47bba07c57474d94","modified":1678894225352},{"_id":"node_modules/hexo-theme-volantis/package.json","hash":"1a30bf176963bfb78ab5ccd18b52e5146a7456cb","modified":1678894223357},{"_id":"node_modules/hexo-theme-volantis/languages/zh-TW.yml","hash":"30df1cf6181375c4d05cb6dcfbdc0487ea39369c","modified":1678894226510},{"_id":"node_modules/hexo-theme-volantis/languages/zh-CN.yml","hash":"3cf7e00abc512c446f8506887ee02605f7e229dd","modified":1678894226506},{"_id":"node_modules/hexo-theme-volantis/layout/404.ejs","hash":"48e160ad704be637cafc433d2365fc0eb8bab8cb","modified":1678894222406},{"_id":"node_modules/hexo-theme-volantis/layout/_pre.ejs","hash":"3ac804505c282ff8b16858037c1d2bf9305c3063","modified":1678894222405},{"_id":"node_modules/hexo-theme-volantis/layout/archive.ejs","hash":"f99913b253f8ab22f81280a6ce5145bec3cd3de6","modified":1678894222410},{"_id":"node_modules/hexo-theme-volantis/layout/category.ejs","hash":"9ee883e5f73c05b3963770b74b63d7bb7e4e1ed5","modified":1678894222651},{"_id":"node_modules/hexo-theme-volantis/layout/docs.ejs","hash":"16917af05431c049aa103744a5fb2595d5848d4c","modified":1678894222658},{"_id":"node_modules/hexo-theme-volantis/layout/friends.ejs","hash":"d976c3d2180432319cc4deb503481f0c606811a6","modified":1678894222661},{"_id":"node_modules/hexo-theme-volantis/layout/index.ejs","hash":"8ea7d49272b068cd1a4037846c72eb37e9823512","modified":1678894222681},{"_id":"node_modules/hexo-theme-volantis/layout/layout.ejs","hash":"cd97c3e9b21549e8e18cd1bf3579d078391255a9","modified":1678894222687},{"_id":"node_modules/hexo-theme-volantis/layout/list.ejs","hash":"a85b2984717ee6d5058ec5635f3f287f45c3d4ba","modified":1678894222689},{"_id":"node_modules/hexo-theme-volantis/layout/page.ejs","hash":"16917af05431c049aa103744a5fb2595d5848d4c","modified":1678894222693},{"_id":"node_modules/hexo-theme-volantis/layout/tag.ejs","hash":"696e7b1c70b4438e6a8d925f99cbc4222dd4035d","modified":1678894223271},{"_id":"node_modules/hexo-theme-volantis/layout/post.ejs","hash":"16917af05431c049aa103744a5fb2595d5848d4c","modified":1678894222695},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/author.ejs","hash":"68e8f198c406b6946fbf0a0f756e8a334982ba84","modified":1678894222412},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/artalkcount.ejs","hash":"94c9e591e38ac00d6beafa44de4d29e70680c673","modified":1678894222411},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/category.ejs","hash":"e95b88bf5f8b11b4f886859cf634a72aa46c8650","modified":1678894222649},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/counter.ejs","hash":"1bd825605f3dacf685848b93a25269f49269b4d7","modified":1678894222653},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/music.ejs","hash":"2c1884e59131d47a82d2556ac28ef784b4ddaa10","modified":1678894222691},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/date.ejs","hash":"ba6c554dbc6c1870debb2b87c5fa25caa089be8f","modified":1678894222655},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/tags.ejs","hash":"24aae7e64ce05ddb13e793a181bfa74257a830e4","modified":1678894223273},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/share.ejs","hash":"0f3b1db92319734baa8da1636340839ed2d37a7b","modified":1678894223269},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/thumbnail.ejs","hash":"60045f2bf695b4be5ad3fd19db46890f1cdee68a","modified":1678894223278},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/updated.ejs","hash":"edf445ad8153419a5dc7c4ec4c8490967cd9d33d","modified":1678894223283},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/walinecount.ejs","hash":"a407ec847c8f0e224efd22b7234e2921cca1d5be","modified":1678894223284},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/wordcount.ejs","hash":"eebaab3821af95ee64d8d56f33ca6c9c60b9b6f0","modified":1678894223287},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/archive.ejs","hash":"d5f776437c108c72c002b11f1d23d30b50e0079a","modified":1678894222408},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/categories.ejs","hash":"c2bc61780cab948ef8ab5076511ebccacab1cd79","modified":1678894222649},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/article.ejs","hash":"11d61f5ce1bdc6f1fb1163e5e7a213fb5cbb6b53","modified":1678894222412},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/cover.ejs","hash":"b03a268d75dedeb8d6e29e3e352bd6cdf921545a","modified":1678894222654},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/footer.ejs","hash":"baec06d381d8358ee6762e4b0a67d27cd0c7a511","modified":1678894222661},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/header.ejs","hash":"06ce9cd8ad7e64e83cb52cda555fd73b1c6c2b52","modified":1678894222666},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/meta.ejs","hash":"ced9c966a9f4d84e485c325ef3551be218ddd033","modified":1678894222691},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/post.ejs","hash":"7d144c80f2980efaab6198512746c0c5d77f03db","modified":1678894222695},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/head.ejs","hash":"72471ce27235fb3c67c2961b65b41861b92a2463","modified":1679211214852},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/side.ejs","hash":"27f9df84585ffb24e2ba2423761f90f690c65787","modified":1678894223270},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/blogger.ejs","hash":"b1429acdd791cd5f00a0f0303bcd8674cf73ed52","modified":1678894222647},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/_pre.ejs","hash":"2f635098c719d9dbf0f23eeead370c6550d1ecff","modified":1678894222405},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/category.ejs","hash":"d8e7ad7e1418659208036a0a43cb4db2ee61abd7","modified":1678894222649},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/copyright.ejs","hash":"8e4929772970e58482f10e0867692cfcf59dee5d","modified":1678894222653},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/grid.ejs","hash":"7d266197f6037f32c33bd74741730c5558417402","modified":1678894222665},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/group.ejs","hash":"2eed9614049441b51e6819f393f80faf5441870b","modified":1678894222665},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/header.ejs","hash":"b132e332ddf12d1bb1d99480200561d8c38edd04","modified":1678894222667},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/lastupdate.ejs","hash":"c311ba4c8b255c45313dc1ab7ddafd99ec7fe8af","modified":1678894222681},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/list.ejs","hash":"0c9319e7e81d88c721b3fe9acf6171f81faade68","modified":1678894222689},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/load.ejs","hash":"b71e0617165d5db546d22297229d7f380091fd83","modified":1678894222690},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/music.ejs","hash":"2f560f3168e3811cd1d8d8a6bad9112932be9b04","modified":1678894222692},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/page.ejs","hash":"e6a20fb75a3e835a404dddd929db4d3762a367c0","modified":1678894222692},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/qrcode.ejs","hash":"128b7c6b4b2191ead4079688e55333bb97df0cdd","modified":1678894222696},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/references.ejs","hash":"08f2dbd23fc9835f4c24bdda4cf288593d61c25a","modified":1678894222697},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/related_posts.ejs","hash":"f7a514d1f3f5ae40c6fb55d61f8b2a0bba13401c","modified":1678894222697},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/tagcloud.ejs","hash":"a68ccb41f7b589f9076a750e77e17f178af3e9d0","modified":1678894223272},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/text.ejs","hash":"9302a6084c8f930532f7f8793b1b20ca1964473e","modified":1678894223275},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/toc.ejs","hash":"200bf0096d8965e5fb7039b261317c848e36be85","modified":1678894223282},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/webinfo.ejs","hash":"29b70c3e5882afa3045b1282d03f88d30ccf5e84","modified":1678894223284},{"_id":"node_modules/hexo-theme-volantis/scripts/filters/content-visibility.js","hash":"048a8f1b80e8999d5f7a37bb8c4dabdebbebabdc","modified":1678894223308},{"_id":"node_modules/hexo-theme-volantis/scripts/filters/replace.js","hash":"aa6fe807d7b24a60475ce8126a1be7b314cd26ba","modified":1678894223334},{"_id":"node_modules/hexo-theme-volantis/scripts/filters/img.js","hash":"160732831bec5baf89fa07a85fec5229c3cb9cd7","modified":1678894223321},{"_id":"node_modules/hexo-theme-volantis/scripts/filters/z-lazyload.js","hash":"df6c5b0a6eff5e655d2b8de85c646ba1e5a16535","modified":1678894223357},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/custom-files.js","hash":"8483fcdc7dbbfde40276dc3daa1ddc5e40380360","modified":1678894223313},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/first-style.js","hash":"ba2e2325a365704abae3f1d204b058731e21bfbf","modified":1678894223314},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/getList.js","hash":"595400c37b79599f779876808e0308ead7de0a32","modified":1678894223317},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/revisioned.js","hash":"57a9d91cd755f8100f149a0fe6cbb45d9c77e13c","modified":1678894223334},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/related-posts.js","hash":"cab8c291a8ff460b29b3248ac86827c143aca9ee","modified":1678894223333},{"_id":"node_modules/hexo-theme-volantis/scripts/events/index.js","hash":"af7aaa4431393889671853db03c8b684265eaa50","modified":1678894223322},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/btn.js","hash":"e9b6e26f106505cf14a72524ab5e8b5bc85f362a","modified":1678894223302},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/btns.js","hash":"648671420faa0ac00076a8c7bb011c908b83fd5a","modified":1678894223304},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/checkbox.js","hash":"0798edc6833d5978709ca5ed56aed33cea46e694","modified":1678894223306},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/contributors.js","hash":"a00573000e7ddf7a9d2f03f29fd62cb8a9752a48","modified":1678894223310},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/dropmenu.js","hash":"19176a6edf7acc6ad31c96961e59da526f200980","modified":1678894223313},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/fancybox.js","hash":"9eac73fa2d7d14ae585b302255270933641a4859","modified":1678894223313},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/folding.js","hash":"a809988c63f358e2ae903d905dc81ed80860bacd","modified":1678894223315},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/frame.js","hash":"e78834c005bda8f80ba86c78911b9db7566b878b","modified":1678894223315},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/friends.js","hash":"a902e1ac279014a30eda85e477c52144214cc66c","modified":1678894223316},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/ghcard.js","hash":"1ed7c1508180756ad4752769aa91289d37a7e23d","modified":1678894223318},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/image.js","hash":"63a4b3e1e3d661b6ab2b3fcfcfb657e3b632b9cb","modified":1678894223320},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/inline-labels.js","hash":"08fbdc0ea622270e1236a28778f875c8ad2e5516","modified":1678894223323},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/link.js","hash":"9dec9c65819d1135a7a248adaa26acbf24427cd0","modified":1678894223323},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/md.js","hash":"66d6b7c17638e778a8796d64cd42d0c622eba67e","modified":1678894223324},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/media.js","hash":"b3871bc024d7fce9500f31073d690c4cd33bce18","modified":1678894223325},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/note.js","hash":"ac86ba50da98d9546522feaca672259620b053d8","modified":1678894223327},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/pandown.js","hash":"4d6f6dab955106ade379d6c55603e1e7eb97a107","modified":1678894223330},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/site.js","hash":"dd23a06f2e8a3cc70730cf199a0661777532ff0b","modified":1678894223343},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/span.js","hash":"b825115f037386797efa1b0aee3a1df21629f243","modified":1678894223347},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/swiper.js","hash":"f0171f07f494c0b0f3f8af265344add15813a676","modified":1678894223353},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/table.js","hash":"ad82046fc64f932019d8a7b3e9a8ff07973a6c3b","modified":1678894223353},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/tabs.js","hash":"f0054f1c970cac728b3ad289a3c531c070c06896","modified":1678894223355},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/timeline.js","hash":"9b6b88ada712a8f3a04a825cf73a409f072ed045","modified":1678894223356},{"_id":"node_modules/hexo-theme-volantis/source/css/Readme.md","hash":"cf408308dcbc62f4fc2bd5aa38303b368cc88a7e","modified":1678894223369},{"_id":"node_modules/hexo-theme-volantis/source/css/first.styl","hash":"55fe35847a1d1d831eb71288c0233efb1dd8a630","modified":1678894223384},{"_id":"node_modules/hexo-theme-volantis/source/css/style.styl","hash":"00892839230a1b05a5f9d9350baacd67d894fc85","modified":1678894224272},{"_id":"node_modules/hexo-theme-volantis/source/js/app.js","hash":"fe351c107526d7f0aa127ea6feb7f90dcf161f16","modified":1678894223295},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/dock.ejs","hash":"7abe0c7080dfcec063b4f52e4ca569bf0510c7c1","modified":1678894222657},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/featured.ejs","hash":"7abe0c7080dfcec063b4f52e4ca569bf0510c7c1","modified":1678894222660},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/focus.ejs","hash":"7abe0c7080dfcec063b4f52e4ca569bf0510c7c1","modified":1678894222660},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/layout.ejs","hash":"39a463ce33ce6138d40055e72118941515ba2f63","modified":1678894222681},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/search.ejs","hash":"2f536370d1b51fa7c33798be21e690638f0df74e","modified":1678894223268},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/_ctrl.ejs","hash":"8dd82dc0d7cd59c55d9e1239ec80c0303a4069bf","modified":1678894222404},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/content-visibility-scroll-fix.ejs","hash":"8aa467244e0976efbdc80e28dd266b0ac0bd2dc7","modified":1678894222652},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/global.ejs","hash":"27a98869f648ff7aed5c290d900d4cf06e51f2f8","modified":1678894222662},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/index.ejs","hash":"782b9f2cf693d0a7094adac730a4d543335ea614","modified":1678894222667},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/toc.ejs","hash":"d71bac519593ac09e9e5c521e5999925e253f4b6","modified":1678894223280},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/index.ejs","hash":"462334ae298659214464f3a8af3da1c514cf76e1","modified":1678894222674},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/analytics/LCCounter.ejs","hash":"ecad85a3d5776614335783e13a9497b1538731a3","modified":1678894222689},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/analytics/script.ejs","hash":"a757c6fd89e11ab3e4cbd3e4cc02091a836fcd70","modified":1678894222698},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/aplayer/layout.ejs","hash":"51b4f54a165fbca56c9beec3ce19bc62f10097d9","modified":1678894222683},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/aplayer/script.ejs","hash":"dc0b773f0d26c660b36625fdbd17a2d8455e6095","modified":1678894222698},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/chat/index.ejs","hash":"56d2e577fbd08859e118cfb1d1b8d230850a3675","modified":1678894222678},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/index.ejs","hash":"3d781c01f494b89d1d31d3210c100c822787c9b7","modified":1678894222679},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/end-of-support/script.ejs","hash":"b415d8e5dfca4a47c199b1adeb220ff57eaec219","modified":1678894223246},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/github-api/script.ejs","hash":"8c414c5c39fb6c36c2a4881463f3dc3346cc9b46","modified":1678894223248},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/darkmode/script.ejs","hash":"742f0e0988741e3eb82bb0d99a081447b45a41b1","modified":1678894223243},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/highlight/script.ejs","hash":"06befe70f47454fbfaa95245fe4cdb8d4f6f9f3c","modified":1678894223253},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/lazyload/script.ejs","hash":"d80dd5864200d86bc6c43d0fd1efab6538e703cf","modified":1678894223254},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/nodewaves/script.ejs","hash":"f28854fba682c345424f6217525507f0a3e2b17d","modified":1678894223255},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/parallax/script.ejs","hash":"7c88aedd458b2c9df27e57db5c6ecb3090c58eba","modified":1678894223257},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/pjax/animate.ejs","hash":"050f626db44ef423e5f8689447197a37f7de6e27","modified":1678894222407},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/pjax/index.ejs","hash":"4daf9937293b6e2b4bf458d3e868da18900d2864","modified":1678894222680},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/pjax/pdata.ejs","hash":"eb90a00163519e6ed01a4f38380caf4dc2bd5049","modified":1678894222694},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/preload/script.ejs","hash":"1c3bf70b6df9da59c5554a921d7447e20684241d","modified":1678894223258},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/rightmenu/layout.ejs","hash":"aa49c2498e2e61dd4ac0d68db89a1bdee86a9208","modified":1678894222684},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/rightmenus/layout.ejs","hash":"31a1787705aa13d3e0eb1aacf76bc4db869cb37a","modified":1678894222686},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/scrollreveal/script.ejs","hash":"bfcd40a4c86a79d11b6ea9460f5bb6c3a60be48e","modified":1678894223260},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/share/layout.ejs","hash":"f46f00d5866082bb60137b5044ead669a062bc9f","modified":1678894222687},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/search/script.ejs","hash":"c6525e6d76b6e968a1803fe8aea076dfc23659a0","modified":1678894223264},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/slow-network/script.ejs","hash":"5a2f3eaadb6dbe4350e6d32094a0bad62ba240bc","modified":1678894223265},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/swiper/script.ejs","hash":"766ab47f4b26502fb71383ae442a1db629fe9e12","modified":1678894223267},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/head/autoCanonical.js","hash":"f3ea74759129c71041371a1d77c687eb6aa88d3a","modified":1678894223297},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/head/generate_preload_fontfamily.js","hash":"d37dbe38fa9125fdce99b2ef9e92582ed08eea82","modified":1678894223317},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/head/generate_seo.js","hash":"e0059a60cc5978be6792dcf795a2ece3a509f41a","modified":1678894223317},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/head/generate_title__keywords__description.js","hash":"179a07b7b2270398216a34d79595d98e30962b22","modified":1678894223317},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/index.js","hash":"bcb770787c77e39cdc156b7fd58cde8e00b79153","modified":1678894223323},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/check-configuration.js","hash":"08f383bd163383a157db177b77143c467de98a29","modified":1678894223305},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/check-environment.js","hash":"9d29a3f34ea715a0dc7cb5c2f76b5713d718e6e6","modified":1678894223305},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/config.js","hash":"8dafa15769d43693523e435fad10b85f614a0600","modified":1678894223307},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/render-stylus.js","hash":"36c2f32d2101eaa84041daf70393df6f3a3fa331","modified":1678894223334},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/stellar-tag-utils.js","hash":"8d62893faf26d15d2833f8090bd6257a7282f5e2","modified":1678894223348},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/AutoPrefixCSS.styl","hash":"c76f624d332c59b73c1d6b95b30b2afb560976eb","modified":1678894223372},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/Readme.md","hash":"77d9e986d24898b98eba2010185951fd1fb8b95c","modified":1678894223367},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/color.styl","hash":"02d9bbe630f33ec2c604cb8acdddbe28431fcb05","modified":1678894223377},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/effect.styl","hash":"47db4f84182194a8a233931424c9bc79c6cf0117","modified":1678894223383},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/fonts.styl","hash":"fa199b11b568a6b0d6fc4e87ef12ab36ac254966","modified":1678894223387},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/func.styl","hash":"430adedc7e6f57013e54d15e6f8dce21e9ea2579","modified":1678894223391},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/layout.styl","hash":"d1bdce2e7974b1feb585adcdf95e36a054a36ec4","modified":1678894224265},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/base_first.styl","hash":"2db7ec30d52473fa40bca89dcd29854498e8ca3e","modified":1678894223373},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/cover_first.styl","hash":"32f0e09eba832607165096c68f70698a75d685b5","modified":1678894223377},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/dark_first.styl","hash":"bcb419588c1972bd47869309dea43ff319440d33","modified":1678894223379},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/fontfamily_first.styl","hash":"5024a9162f4787ac4234d5b8549fad40dbecf865","modified":1678894223386},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/navbar_first.styl","hash":"e268d81dc78fdf9758d314cdc5cc087aec1c70e6","modified":1678894224267},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/search_first.styl","hash":"955c9eb68b90b97dba0bd27909347cfc91ce68c5","modified":1678894224270},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/index.styl","hash":"835b3640c257cd229b20c088536b053b92c9796c","modified":1678894224264},{"_id":"node_modules/hexo-theme-volantis/source/js/search/hexo.js","hash":"4b4ecb0c950b95bed02e0e1274aa50c4989553a3","modified":1678894223319},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/aplayer.js","hash":"95f2e47535c8d37e90cab7726d25845cf01ca477","modified":1678894223289},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/parallax.js","hash":"3c3210bde6e86d7d157c34c14796abe98cb1bbd0","modified":1678894223332},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/rightMenu.js","hash":"cb2f17ab10127065f7b9f5f87a49921d25b287e1","modified":1678894223339},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/rightMenus.js","hash":"877f548870ea7f63a46de071a120aaea96dd4a25","modified":1678894223340},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/_ctrl/cdnCtrl.ejs","hash":"8fe3924efab31cf8a6d7ad07a2985b01a2154acb","modified":1678894222652},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/_ctrl/coverCtrl.ejs","hash":"ee3f2108e61db024466b08beddb895ad97330f63","modified":1678894222654},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/artitalk/index.ejs","hash":"98fb39a1ac55b9af0c1501b051ac2698a3684686","modified":1678894222668},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/bbtalk/index.ejs","hash":"bd513c00f6d5fb57e504db7e89c3326d9f68dd88","modified":1678894222669},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/gitter/index.ejs","hash":"e90bf8daf46f34ca9b37049154dda6d1f155d037","modified":1678894222671},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/fcircle/index.ejs","hash":"2a220187916a0474a083a8f716c0a3b9a8f57548","modified":1678894222670},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/indent/index.ejs","hash":"7d112cde9b8d1785d8c541cde94361e0bfc60f30","modified":1678894222672},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/mathjax/index.ejs","hash":"91a412d8324fbacd7a340e4ad031b4e917a16f2f","modified":1678894222676},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/katex/index.ejs","hash":"159e21313df49ef1ab14122bfe7e02d2d4f6fcdf","modified":1678894222676},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/snackbar/index.ejs","hash":"bddb75f7112d2b438f462a6ebef79810ef5ac291","modified":1678894222677},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/chat/tidio/script.ejs","hash":"bb678b5e8a9fb87fc1c1e48914da3a1a052a8e02","modified":1678894222699},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/chat/gitter/script.ejs","hash":"e4f06c50c23d433a0e63fc703a35704c336ba090","modified":1678894222699},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/beaudar/script.ejs","hash":"285226000b8bff1f96b8b69da268a0af79d04b98","modified":1678894222730},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/discuss/script.ejs","hash":"b8a13e121923d31a5b6870be84c69e5587f4f0ce","modified":1678894222730},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/artalk/script.ejs","hash":"799633e92efc6abb5d0a9ded8b6db70948dcddad","modified":1678894222728},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/disqus/script.ejs","hash":"3a67befc560e6d0695f64c05d82c68ee9771a1a7","modified":1678894223204},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/disqusjs/script.ejs","hash":"569912aebbde81490e57ab2ce49e35bf678723f2","modified":1678894223214},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/gitalk/script.ejs","hash":"00a20cd4a398204b1193b0e9d3fac2c5f32daad3","modified":1678894223217},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/giscus/script.ejs","hash":"45fe8d3e47d2a990292426d14091cffa46301704","modified":1678894223215},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/isso/script.ejs","hash":"aa7c81e6df9b803966efe5eda8edbc85b924f34b","modified":1678894223220},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/hashover/script.ejs","hash":"7ecd8879c66b907da04093a465d346f6569cee83","modified":1678894223219},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/livere/script.ejs","hash":"54340ba16d4f46ed4f3c6f67ac7ba1a2e68be67a","modified":1678894223222},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/twikoo/script.ejs","hash":"c0fc694962e94a478b85ae7adb95917fc5f8f2c4","modified":1678894223224},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/utterances/script.ejs","hash":"afbb35e59b3b3af34627416ee47ecad1d564bdbc","modified":1678894223237},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/vssue/script.ejs","hash":"8171fdfbe668277942eaa55847ba646532d245eb","modified":1678894223239},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/waline/script.ejs","hash":"945fa1928c6bd1599134b8627b35d3dd7cd79013","modified":1678894223239},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/z-custom/script.ejs","hash":"e5cfe25fb88b7a3dd0c68e20b2e17d44eb2a1f04","modified":1678894223240},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/highlight/highlightjs/script.ejs","hash":"3ffdc0dea93efd49b23910fe7a295784c7053b97","modified":1678894223251},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/highlight/prismjs/script.ejs","hash":"1349c07f6a1f3efca0a00f483c918d091007d9b3","modified":1678894223252},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/blogposting.js","hash":"f8543b0460c9a5b23ee43d8ed49e018c1c627439","modified":1678894223298},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/breadcrumblist.js","hash":"df6316082af2df061f16bb01d5b5d3478f98c662","modified":1678894223299},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/config.js","hash":"e4c3c23e58f0bac72010f962d92da641445e748a","modified":1678894223307},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/index.js","hash":"41e4af773dfb4755752cb74a6d70e4b5b0c1ce4d","modified":1678894223323},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/organization.js","hash":"02c08f0362aec5d310b8c7e69823cd88ed49ea5e","modified":1678894223329},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/person.js","hash":"afca448311d62a44566d9471594a43495a6be6db","modified":1678894223333},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/website.js","hash":"556f28164d31b3898d06cb8f76472bc6547bb1db","modified":1678894223356},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_base/fontfamily_async.styl","hash":"48c006682b8f44681662e4b0f8d3ebfdf85add69","modified":1678894223386},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_base/base.styl","hash":"712eb4803dc595eb111ebd89546e6ed3fb1ec7ce","modified":1679227404421},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/archive.styl","hash":"a96709230abbc8d4fc40361b8fc02d4249abb4a1","modified":1678894223370},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/article.styl","hash":"8d9fe767bb92fc57681817f21af7b2cdc07b0dc3","modified":1679228928742},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/footer.styl","hash":"bb850b4707ee025e267e079fcf85484849cf4f41","modified":1678894223387},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/friends-simpleuser.styl","hash":"07c477e15bf75615faff5587cc82dbc6004a901a","modified":1678894223388},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/friends-traditional.styl","hash":"2da0419cd5874d03d7d5bafdb081beb6cb786608","modified":1678894223389},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/img.styl","hash":"55d79f07b717d3e28515b41401f656d1593be624","modified":1678894223397},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/loading.styl","hash":"56a2b9f46edd5b87e49d11647dc9396b0d833d54","modified":1678894224265},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/main.styl","hash":"d75ac5fd9ee7cddcbaa421d676c2ae0c4501b121","modified":1678894224266},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/pagination.styl","hash":"65dacf95771fc518a06cbf301f4c0b06201d7321","modified":1678894224268},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/md.styl","hash":"2e3e0f52e88065fa690cba07a8df2e94cbbf3e69","modified":1679228705261},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/posts.styl","hash":"31cf7bdbb44caa173f3dfd49d98157cb6be85c6f","modified":1678894224269},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/search.styl","hash":"ac9f4c4f6e1ac38757dfeae3483a55983e1491d0","modified":1678894224270},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/sidebar.styl","hash":"4b75b29b67b88ef5ee365535d521c3ee8256a1ea","modified":1678894224270},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/snackbar.styl","hash":"752a7fea5284a61fd9305d3b0fcaa43f2e64862f","modified":1678894224271},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/toc.styl","hash":"3346fbcbcbc2533997a8bf1fbbf801d9120b03ab","modified":1678894224274},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/video.styl","hash":"680e8cf8fc5d62913dad4ccd06135caad2bb3e92","modified":1678894224274},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/aplayer.styl","hash":"da809e1dde8adb9d1c98f0daeb52a2d920d497f7","modified":1678894223370},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/fontcolor.styl","hash":"fa13f91f8be68b62210048d1481c3b23e23f939b","modified":1678894223384},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/cursor.styl","hash":"bc055048c7d017be8cf25a3385f516656c96cf66","modified":1678894223377},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/index.styl","hash":"a18de4930b88f62e557e62e8fbb9e2ce550c5d49","modified":1678894224263},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/gitalk.styl","hash":"c4c9950fd6654f87ca4f481cf3065ca4069fac48","modified":1678894223394},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/mathjax.styl","hash":"11ee86571f31f9aa61dcc48b40977dcd974d76a4","modified":1678894224266},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/message.styl","hash":"995b46084664f2ed2cf025c1a208089ecfe1147e","modified":1678894224267},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/pjaxanimate.styl","hash":"86c80d1d1c8a02c0eb4c0b5d29ff41c9a5dd5ac3","modified":1678894224268},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/Readme.md","hash":"51986550e80990e1db23e2ee4165e5e4800e4b9f","modified":1678894223367},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/btns.styl","hash":"bf592cd78c146bb671217f106632b9e5bcc7c145","modified":1678894223374},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/checkbox.styl","hash":"8c62dd38914d939069d9222c54787a24cb5c31f7","modified":1678894223374},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/dropmenu.styl","hash":"a136ebb90bedef15c1d8b8d75e09b37c3873f5e8","modified":1678894223383},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/fancybox.styl","hash":"1b4709787f9bda8ce565aa9a4aaf7f1f58751b44","modified":1678894223383},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/folding.styl","hash":"253f13e60218e0d014a1df99933f5cdba507f3b1","modified":1678894223384},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/frame.styl","hash":"6ffbb29514781aa4fa7d7653706554ce33f4525b","modified":1678894223387},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/friends.styl","hash":"8f9e60b94c02197e4555f923d357017742bf8d7b","modified":1678894223390},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/ghcard.styl","hash":"58adb206695a704b1f40df42e2dc10e9e9055aeb","modified":1678894223391},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/image.styl","hash":"bb4b07841602592e421597ba8dd7110edec789d8","modified":1678894223397},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/link.styl","hash":"82cdcc537612eec3e1af40d00edf80b14116c191","modified":1678894224265},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/note.styl","hash":"005d3c55c2216d7c88661f79ad466ad89fad4784","modified":1678894224267},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/media.styl","hash":"576c9eede3a8f9ec2ba1a970e92a49154ec3acb3","modified":1678894224267},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/sites.styl","hash":"01593f3b8a233bc2c3193796707e4ed77df217bb","modified":1678894224270},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/swiper.styl","hash":"819385594f1825e26074ade900835a3f4031fe42","modified":1678894224272},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/span.styl","hash":"6e9f8b453244d9241d3fceed0a56e12c86a4b446","modified":1678894224272},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/table.styl","hash":"ef07ab4fe8a391ea9039fbe53333aaf58e3ce033","modified":1678894224273},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/tabs.styl","hash":"a2366f4fe1d9f06e47a7a994cfc80a1edbf6c535","modified":1678894224273},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/tag.json","hash":"506f87e397f258b097ba24ce16c33b5353bab462","modified":1678894223363},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/text.styl","hash":"b2c2f3946fb611ad052c61d7309098edbf494c86","modified":1678894224273},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/timeline.styl","hash":"f84f411a3b7dcdbfd4fb19ac4e0f91300c5e19be","modified":1678894224273},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/friends.js","hash":"7d53cf366638d0e254f7f26de01c8892710d1d23","modified":1678894223316},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/contributors.js","hash":"cf1af362cf73c83a28ae2651eb1daafaed2ec91f","modified":1678894223312},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/sites.js","hash":"47b0ff4a3ccea2da9b60023cb4288f979504b0c7","modified":1678894223347},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_dark/dark_async.styl","hash":"a5da6f0b232a767057321fa51e382fd2d86bd98d","modified":1678894223378},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_dark/dark_plugins.styl","hash":"c56c2271847809e21e4938d770577622aeb161aa","modified":1678894223381},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/index.styl","hash":"6c681c760fa63425e7564c0d68532bb5ac95690a","modified":1678894224263},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_rightmenu/reading.styl","hash":"cb01065424dbd32c79b973b06fcdbc1c72917bc6","modified":1678894224269},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_rightmenu/rightmenu.styl","hash":"ef456a92173c303b61015f3581450aa14f0d2b41","modified":1678894224269},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/highlightjs/color.styl","hash":"319ccc46d5d387ee14a22e0de1a518288331629b","modified":1678894223377},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/highlightjs/index.styl","hash":"38089b686a0cfdde555539c1c0c5b3fe402afada","modified":1678894224261},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/highlightjs/language.styl","hash":"4fade2fe067f557d3b420d0b9a9d88d18feb9a72","modified":1678894224264},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/prismjs/clipboard.styl","hash":"0f92935e3bb9732b6e1cc7f305577144f1fe99a8","modified":1678894223376},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/prismjs/index.styl","hash":"215face68fab1c31cfa8d4c21941c72efe54cb78","modified":1678894224263},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/highlightjs/clipboard.styl","hash":"6818ba853fd6a319ff4eb50d228b1d625db9a0fd","modified":1678894223375},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/prismjs/language.styl","hash":"3af7fae25a0e2c54f0aacb1d8cbe383d5c1e60a5","modified":1678894224264}],"Category":[{"name":"操作系统","_id":"clfnnpyvz0004vhfiap898yu3"},{"name":"数据结构","_id":"clfnnpyw7000fvhfi2grt5bng"},{"name":"算法","_id":"clfnnpywh0019vhfi8opr83m8"},{"name":"计算机网络","_id":"clfnnpywy002jvhfihuyfdckc"},{"name":"数据库","_id":"clfnnpyx0002ovhfif1guc9g5"},{"name":"缓存","_id":"clfnnpyx6003hvhficnm9eu7y"},{"name":"分布式系统","_id":"clfnnpyx8003zvhfias1ddhb2"},{"name":"微服务","_id":"clfnnpyxd004yvhfi8zv70r48"}],"Data":[],"Page":[{"title":"about","date":"2023-03-12T16:11:09.000Z","_content":"\n## 平平无奇","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-03-13 00:11:09\n---\n\n## 平平无奇","updated":"2023-03-15T16:00:23.237Z","path":"about/index.html","comments":1,"layout":"page","_id":"clfnnpyvs0000vhfigiztbqcl","content":"<h2 id=\"平平无奇\"><a href=\"#平平无奇\" class=\"headerlink\" title=\"平平无奇\"></a>平平无奇</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"平平无奇\"><a href=\"#平平无奇\" class=\"headerlink\" title=\"平平无奇\"></a>平平无奇</h2>"},{"title":"全部标签","date":"2023-03-19T05:57:02.000Z","layout":"tag","_content":"","source":"tags/index.md","raw":"---\ntitle: 全部标签\ndate: 2023-03-19 13:57:02\nlayout: tag\n---\n","updated":"2023-03-19T06:45:08.655Z","path":"tags/index.html","comments":1,"_id":"clfnnpyvy0002vhfielc11hmd","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"全部分类","date":"2023-03-19T05:56:46.000Z","layout":"category","_content":"\n","source":"categories/index.md","raw":"---\ntitle: 全部分类\ndate: 2023-03-19 13:56:46\nlayout: category\n---\n\n","updated":"2023-03-19T06:44:59.152Z","path":"categories/index.html","comments":1,"_id":"clfnnpyw10006vhfigbsidyib","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"friends","date":"2023-03-19T05:57:22.000Z","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2023-03-19 13:57:22\nlayout: friends\n---\n","updated":"2023-03-19T06:46:31.862Z","path":"friends/index.html","comments":1,"_id":"clfnnpyw20008vhfia60m2d7y","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Linux进程管理:supervisor和nohup原理及使用","date":"2023-03-13T00:49:37.000Z","_content":"\n## 原理\n\n### 守护进程（daemon）\n守护进程是一类在后台运行的特殊进程，用于执行特定的系统任务。他独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。Linux系统的大多数服务器就是通过守护进程实现的。\n常见的守护进程包括：\n- 系统日志进程syslogd\n- Web服务器httpd\n- 邮件服务器sendmail\n- 数据库服务器mysqld等\n\n守护进程一般在系统启动时开始运行，除非强行终止，否则会持续运行知道系统关机，通常以超级用户（root）权限运行。\n\n### 前台任务与后台任务\n假如有个简单的go的web服务器程序，使用如下方式启动，称为前台任务。独占了命令窗口，只有运行完了或手动终止（Ctrl+C），才能执行其他命令。\n![](https://upload-images.jianshu.io/upload_images/14151453-ec0b4b889fe10808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果以如下方式，在命令结尾加上符号`&`，启动的进程就会称为后台任务。\n![](https://upload-images.jianshu.io/upload_images/14151453-35d2076e46e71ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n后台任务又如下特点：\n- 继承当前session的标准输出(stdout)和标准错误(stderr)，因此如上图所示，后台任务的所有输出仍会同步的在命令行显示\n- 不再继承当前session的标准输入(stdin)，无法向这个任务输入指令，如果它试图读取标准输入，就会暂停执行（halt）\n\n### SIGHUP信号\n变为后台任务并不代表进程成为了守护进程，因为当session关闭后，后台任务就会终止。Linux系统终端session退出流程如下：\n1. 用户准备退出session\n2. 系统向改session发送`SIGHUP`信号\n3. session将`SIGHUP`信号发送给所有子进程\n4. 子进程收到`SIGHUP`信号后会自动退出\n\n## nohup\nnohup 是后台作业的意思， nohup运行的进程将会忽略终端信号运行。即后台运行一个命令。nohup COMMAND & 用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响它的运行。\n\n使用nohup命令的方式可以启动一个守护进程，如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-a2bafec78cb93512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nnohup命令对进程做了如下操作：\n- 忽略`SIGHUP`信号，因此当session关闭进程就不会退出\n- 关闭标准输入，该进程不再接收任何输入，即使运行在前台\n- 重定向标准输出和标准错误到文件nohup.out（默认情况，可以指定输出的文件）\n\nnohup不会自动把进程变为后台任务，所以必须加上`&`。\n\n## supervisor\nsupervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。\nsupervisor管理进程是通过fork/exec的方式把被管理的进程当做子进程来启动，用户只需要在配置文件中将要管理的进程进行配置。\n\n### 结构\nsupervisor主要由Supervisord、Supervisorctl、Web server和XML-RPC interface组成：\n- supervisord：主进程，负责管理进程的server，它会根据配置文件创建指定数量的应用程序的子进程，管理子进程的整个生命周期，对crash的进程重启，对进程变化发送事件通知等。同时通过内置web server和XML-RPC Interface可以轻松实现进程管理。\n- supervisorctl：管理client，用户通过命令行发送消息给supervisord，可以查看进程状态，加载配置文件，启停进程，查看进程标准输出和错误输出，远程操作等。\n- Web server：superviosr提供了web server功能，可通过web控制进程。\n- XML-RPC interface： XML-RPC接口，提供XML-RPC服务来对子进程进行管理和监控。\n\n### macOS环境安装使用\n\n#### 安装并启动\n```shell\n$ brew install supervisor\n$ brew services start supervisor\n```\n#### 创建配置目录和配置文件\n默认的配置文件路径为`/usr/local/etc/supervisord.conf`，查看该文件可以看到如下内容：\n```shell\n$ tail -n2 /usr/local/etc/supervisord.conf\n[include]\nfiles = /usr/local/etc/supervisor.d/*.ini\n```\n可以看到include了`/usr/local/etc/supervisor.d/`目录下的`.ini`文件，因此我们需要创建改目录，然后对要管理的进程或进程组创建对应的`.ini`格式的配置文件\n```shell\n$ mkdir -pv /usr/local/etc/supervisor.d\n$ vim /usr/local/etc/supervisor.d/myserver.ini\n```\n编辑配置文件内容如下：\n```shell\n[program:server]\nprocess_name=%(program_name)s_%(process_num)02d\ncommand=/usr/local/go/bin/go run /Users/harryzhang/go/src/server/server.go # 要执行的命令\nautostart=true # 系统开机自动启动\nautorestart=true # 进程终止自动重启\nuser=harryzhang # 用户\nnumprocs=1 # 启动进程数\nredirect_stderr=true # 是否将标准错误重定向到标准输出\nstdout_logfile=/Users/harryzhang/go/src/server/server.log # 指定标准输出保存的文件路径\n```\n\n#### 重启supervisor\n编辑好配置文件后重启supervisor就可以生效，可以使用supervisorctl命令查看和管理进程状态。\n```shell\n$ brew services restart supervisor\nStopping `supervisor`... (might take a while)\n==> Successfully stopped `supervisor` (label: homebrew.mxcl.supervisor)\n==> Successfully started `supervisor` (label: homebrew.mxcl.supervisor)\n\n$ supervisorctl status\nserver:server_00                 RUNNING   pid 41382, uptime 0:00:04\n```\n如果指定的命令执行没有异常，会看到进程已处于运行状态，如果没有处于运行状态，可以查看日志文件，可能为命令执行出错直接退出了。\n\n## 参考\n【1】[Linux 守护进程的启动方法](http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html)\n\n【2】[进程管理工具supervisor 和 nohup](https://segmentfault.com/a/1190000017370468)","source":"_posts/2023/03-13-Linux进程管理-supervisor和nohup原理及使用.md","raw":"---\ntitle: 'Linux进程管理:supervisor和nohup原理及使用'\ndate: 2023-03-13 08:49:37\ncategories:\n- 操作系统\ntags:\n- Linux\n- 守护进程\n---\n\n## 原理\n\n### 守护进程（daemon）\n守护进程是一类在后台运行的特殊进程，用于执行特定的系统任务。他独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。Linux系统的大多数服务器就是通过守护进程实现的。\n常见的守护进程包括：\n- 系统日志进程syslogd\n- Web服务器httpd\n- 邮件服务器sendmail\n- 数据库服务器mysqld等\n\n守护进程一般在系统启动时开始运行，除非强行终止，否则会持续运行知道系统关机，通常以超级用户（root）权限运行。\n\n### 前台任务与后台任务\n假如有个简单的go的web服务器程序，使用如下方式启动，称为前台任务。独占了命令窗口，只有运行完了或手动终止（Ctrl+C），才能执行其他命令。\n![](https://upload-images.jianshu.io/upload_images/14151453-ec0b4b889fe10808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果以如下方式，在命令结尾加上符号`&`，启动的进程就会称为后台任务。\n![](https://upload-images.jianshu.io/upload_images/14151453-35d2076e46e71ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n后台任务又如下特点：\n- 继承当前session的标准输出(stdout)和标准错误(stderr)，因此如上图所示，后台任务的所有输出仍会同步的在命令行显示\n- 不再继承当前session的标准输入(stdin)，无法向这个任务输入指令，如果它试图读取标准输入，就会暂停执行（halt）\n\n### SIGHUP信号\n变为后台任务并不代表进程成为了守护进程，因为当session关闭后，后台任务就会终止。Linux系统终端session退出流程如下：\n1. 用户准备退出session\n2. 系统向改session发送`SIGHUP`信号\n3. session将`SIGHUP`信号发送给所有子进程\n4. 子进程收到`SIGHUP`信号后会自动退出\n\n## nohup\nnohup 是后台作业的意思， nohup运行的进程将会忽略终端信号运行。即后台运行一个命令。nohup COMMAND & 用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响它的运行。\n\n使用nohup命令的方式可以启动一个守护进程，如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-a2bafec78cb93512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nnohup命令对进程做了如下操作：\n- 忽略`SIGHUP`信号，因此当session关闭进程就不会退出\n- 关闭标准输入，该进程不再接收任何输入，即使运行在前台\n- 重定向标准输出和标准错误到文件nohup.out（默认情况，可以指定输出的文件）\n\nnohup不会自动把进程变为后台任务，所以必须加上`&`。\n\n## supervisor\nsupervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。\nsupervisor管理进程是通过fork/exec的方式把被管理的进程当做子进程来启动，用户只需要在配置文件中将要管理的进程进行配置。\n\n### 结构\nsupervisor主要由Supervisord、Supervisorctl、Web server和XML-RPC interface组成：\n- supervisord：主进程，负责管理进程的server，它会根据配置文件创建指定数量的应用程序的子进程，管理子进程的整个生命周期，对crash的进程重启，对进程变化发送事件通知等。同时通过内置web server和XML-RPC Interface可以轻松实现进程管理。\n- supervisorctl：管理client，用户通过命令行发送消息给supervisord，可以查看进程状态，加载配置文件，启停进程，查看进程标准输出和错误输出，远程操作等。\n- Web server：superviosr提供了web server功能，可通过web控制进程。\n- XML-RPC interface： XML-RPC接口，提供XML-RPC服务来对子进程进行管理和监控。\n\n### macOS环境安装使用\n\n#### 安装并启动\n```shell\n$ brew install supervisor\n$ brew services start supervisor\n```\n#### 创建配置目录和配置文件\n默认的配置文件路径为`/usr/local/etc/supervisord.conf`，查看该文件可以看到如下内容：\n```shell\n$ tail -n2 /usr/local/etc/supervisord.conf\n[include]\nfiles = /usr/local/etc/supervisor.d/*.ini\n```\n可以看到include了`/usr/local/etc/supervisor.d/`目录下的`.ini`文件，因此我们需要创建改目录，然后对要管理的进程或进程组创建对应的`.ini`格式的配置文件\n```shell\n$ mkdir -pv /usr/local/etc/supervisor.d\n$ vim /usr/local/etc/supervisor.d/myserver.ini\n```\n编辑配置文件内容如下：\n```shell\n[program:server]\nprocess_name=%(program_name)s_%(process_num)02d\ncommand=/usr/local/go/bin/go run /Users/harryzhang/go/src/server/server.go # 要执行的命令\nautostart=true # 系统开机自动启动\nautorestart=true # 进程终止自动重启\nuser=harryzhang # 用户\nnumprocs=1 # 启动进程数\nredirect_stderr=true # 是否将标准错误重定向到标准输出\nstdout_logfile=/Users/harryzhang/go/src/server/server.log # 指定标准输出保存的文件路径\n```\n\n#### 重启supervisor\n编辑好配置文件后重启supervisor就可以生效，可以使用supervisorctl命令查看和管理进程状态。\n```shell\n$ brew services restart supervisor\nStopping `supervisor`... (might take a while)\n==> Successfully stopped `supervisor` (label: homebrew.mxcl.supervisor)\n==> Successfully started `supervisor` (label: homebrew.mxcl.supervisor)\n\n$ supervisorctl status\nserver:server_00                 RUNNING   pid 41382, uptime 0:00:04\n```\n如果指定的命令执行没有异常，会看到进程已处于运行状态，如果没有处于运行状态，可以查看日志文件，可能为命令执行出错直接退出了。\n\n## 参考\n【1】[Linux 守护进程的启动方法](http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html)\n\n【2】[进程管理工具supervisor 和 nohup](https://segmentfault.com/a/1190000017370468)","slug":"Linux进程管理-supervisor和nohup原理及使用","published":1,"updated":"2023-03-19T13:34:40.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyvu0001vhficq2e6e04","content":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"守护进程（daemon）\"><a href=\"#守护进程（daemon）\" class=\"headerlink\" title=\"守护进程（daemon）\"></a>守护进程（daemon）</h3><p>守护进程是一类在后台运行的特殊进程，用于执行特定的系统任务。他独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。Linux系统的大多数服务器就是通过守护进程实现的。<br>常见的守护进程包括：</p>\n<ul>\n<li>系统日志进程syslogd</li>\n<li>Web服务器httpd</li>\n<li>邮件服务器sendmail</li>\n<li>数据库服务器mysqld等</li>\n</ul>\n<p>守护进程一般在系统启动时开始运行，除非强行终止，否则会持续运行知道系统关机，通常以超级用户（root）权限运行。</p>\n<h3 id=\"前台任务与后台任务\"><a href=\"#前台任务与后台任务\" class=\"headerlink\" title=\"前台任务与后台任务\"></a>前台任务与后台任务</h3><p>假如有个简单的go的web服务器程序，使用如下方式启动，称为前台任务。独占了命令窗口，只有运行完了或手动终止（Ctrl+C），才能执行其他命令。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-ec0b4b889fe10808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-ec0b4b889fe10808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>如果以如下方式，在命令结尾加上符号<code>&amp;</code>，启动的进程就会称为后台任务。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-35d2076e46e71ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-35d2076e46e71ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>后台任务又如下特点：</p>\n<ul>\n<li>继承当前session的标准输出(stdout)和标准错误(stderr)，因此如上图所示，后台任务的所有输出仍会同步的在命令行显示</li>\n<li>不再继承当前session的标准输入(stdin)，无法向这个任务输入指令，如果它试图读取标准输入，就会暂停执行（halt）</li>\n</ul>\n<h3 id=\"SIGHUP信号\"><a href=\"#SIGHUP信号\" class=\"headerlink\" title=\"SIGHUP信号\"></a>SIGHUP信号</h3><p>变为后台任务并不代表进程成为了守护进程，因为当session关闭后，后台任务就会终止。Linux系统终端session退出流程如下：</p>\n<ol>\n<li>用户准备退出session</li>\n<li>系统向改session发送<code>SIGHUP</code>信号</li>\n<li>session将<code>SIGHUP</code>信号发送给所有子进程</li>\n<li>子进程收到<code>SIGHUP</code>信号后会自动退出</li>\n</ol>\n<h2 id=\"nohup\"><a href=\"#nohup\" class=\"headerlink\" title=\"nohup\"></a>nohup</h2><p>nohup 是后台作业的意思， nohup运行的进程将会忽略终端信号运行。即后台运行一个命令。nohup COMMAND &amp; 用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响它的运行。</p>\n<p>使用nohup命令的方式可以启动一个守护进程，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-a2bafec78cb93512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-a2bafec78cb93512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>nohup命令对进程做了如下操作：</p>\n<ul>\n<li>忽略<code>SIGHUP</code>信号，因此当session关闭进程就不会退出</li>\n<li>关闭标准输入，该进程不再接收任何输入，即使运行在前台</li>\n<li>重定向标准输出和标准错误到文件nohup.out（默认情况，可以指定输出的文件）</li>\n</ul>\n<p>nohup不会自动把进程变为后台任务，所以必须加上<code>&amp;</code>。</p>\n<h2 id=\"supervisor\"><a href=\"#supervisor\" class=\"headerlink\" title=\"supervisor\"></a>supervisor</h2><p>supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。<br>supervisor管理进程是通过fork&#x2F;exec的方式把被管理的进程当做子进程来启动，用户只需要在配置文件中将要管理的进程进行配置。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>supervisor主要由Supervisord、Supervisorctl、Web server和XML-RPC interface组成：</p>\n<ul>\n<li>supervisord：主进程，负责管理进程的server，它会根据配置文件创建指定数量的应用程序的子进程，管理子进程的整个生命周期，对crash的进程重启，对进程变化发送事件通知等。同时通过内置web server和XML-RPC Interface可以轻松实现进程管理。</li>\n<li>supervisorctl：管理client，用户通过命令行发送消息给supervisord，可以查看进程状态，加载配置文件，启停进程，查看进程标准输出和错误输出，远程操作等。</li>\n<li>Web server：superviosr提供了web server功能，可通过web控制进程。</li>\n<li>XML-RPC interface： XML-RPC接口，提供XML-RPC服务来对子进程进行管理和监控。</li>\n</ul>\n<h3 id=\"macOS环境安装使用\"><a href=\"#macOS环境安装使用\" class=\"headerlink\" title=\"macOS环境安装使用\"></a>macOS环境安装使用</h3><h4 id=\"安装并启动\"><a href=\"#安装并启动\" class=\"headerlink\" title=\"安装并启动\"></a>安装并启动</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">brew install supervisor</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">brew services start supervisor</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"创建配置目录和配置文件\"><a href=\"#创建配置目录和配置文件\" class=\"headerlink\" title=\"创建配置目录和配置文件\"></a>创建配置目录和配置文件</h4><p>默认的配置文件路径为<code>/usr/local/etc/supervisord.conf</code>，查看该文件可以看到如下内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">tail</span> -n2 /usr/local/etc/supervisord.conf</span></span><br><span class=\"line\">[include]</span><br><span class=\"line\">files = /usr/local/etc/supervisor.d/*.ini</span><br></pre></td></tr></table></figure>\n<p>可以看到include了<code>/usr/local/etc/supervisor.d/</code>目录下的<code>.ini</code>文件，因此我们需要创建改目录，然后对要管理的进程或进程组创建对应的<code>.ini</code>格式的配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">mkdir</span> -pv /usr/local/etc/supervisor.d</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">vim /usr/local/etc/supervisor.d/myserver.ini</span></span><br></pre></td></tr></table></figure>\n<p>编辑配置文件内容如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[program:server]</span><br><span class=\"line\">process_name=%(program_name)s_%(process_num)02d</span><br><span class=\"line\">command=/usr/local/go/bin/go run /Users/harryzhang/go/src/server/server.go # 要执行的命令</span><br><span class=\"line\">autostart=true # 系统开机自动启动</span><br><span class=\"line\">autorestart=true # 进程终止自动重启</span><br><span class=\"line\">user=harryzhang # 用户</span><br><span class=\"line\">numprocs=1 # 启动进程数</span><br><span class=\"line\">redirect_stderr=true # 是否将标准错误重定向到标准输出</span><br><span class=\"line\">stdout_logfile=/Users/harryzhang/go/src/server/server.log # 指定标准输出保存的文件路径</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重启supervisor\"><a href=\"#重启supervisor\" class=\"headerlink\" title=\"重启supervisor\"></a>重启supervisor</h4><p>编辑好配置文件后重启supervisor就可以生效，可以使用supervisorctl命令查看和管理进程状态。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">brew services restart supervisor</span></span><br><span class=\"line\">Stopping `supervisor`... (might take a while)</span><br><span class=\"line\">==&gt; Successfully stopped `supervisor` (label: homebrew.mxcl.supervisor)</span><br><span class=\"line\">==&gt; Successfully started `supervisor` (label: homebrew.mxcl.supervisor)</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">supervisorctl status</span></span><br><span class=\"line\">server:server_00                 RUNNING   pid 41382, uptime 0:00:04</span><br></pre></td></tr></table></figure>\n<p>如果指定的命令执行没有异常，会看到进程已处于运行状态，如果没有处于运行状态，可以查看日志文件，可能为命令执行出错直接退出了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html\">Linux 守护进程的启动方法</a></p>\n<p>【2】<a href=\"https://segmentfault.com/a/1190000017370468\">进程管理工具supervisor 和 nohup</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h3 id=\"守护进程（daemon）\"><a href=\"#守护进程（daemon）\" class=\"headerlink\" title=\"守护进程（daemon）\"></a>守护进程（daemon）</h3><p>守护进程是一类在后台运行的特殊进程，用于执行特定的系统任务。他独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。Linux系统的大多数服务器就是通过守护进程实现的。<br>常见的守护进程包括：</p>\n<ul>\n<li>系统日志进程syslogd</li>\n<li>Web服务器httpd</li>\n<li>邮件服务器sendmail</li>\n<li>数据库服务器mysqld等</li>\n</ul>\n<p>守护进程一般在系统启动时开始运行，除非强行终止，否则会持续运行知道系统关机，通常以超级用户（root）权限运行。</p>\n<h3 id=\"前台任务与后台任务\"><a href=\"#前台任务与后台任务\" class=\"headerlink\" title=\"前台任务与后台任务\"></a>前台任务与后台任务</h3><p>假如有个简单的go的web服务器程序，使用如下方式启动，称为前台任务。独占了命令窗口，只有运行完了或手动终止（Ctrl+C），才能执行其他命令。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-ec0b4b889fe10808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>如果以如下方式，在命令结尾加上符号<code>&amp;</code>，启动的进程就会称为后台任务。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-35d2076e46e71ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>后台任务又如下特点：</p>\n<ul>\n<li>继承当前session的标准输出(stdout)和标准错误(stderr)，因此如上图所示，后台任务的所有输出仍会同步的在命令行显示</li>\n<li>不再继承当前session的标准输入(stdin)，无法向这个任务输入指令，如果它试图读取标准输入，就会暂停执行（halt）</li>\n</ul>\n<h3 id=\"SIGHUP信号\"><a href=\"#SIGHUP信号\" class=\"headerlink\" title=\"SIGHUP信号\"></a>SIGHUP信号</h3><p>变为后台任务并不代表进程成为了守护进程，因为当session关闭后，后台任务就会终止。Linux系统终端session退出流程如下：</p>\n<ol>\n<li>用户准备退出session</li>\n<li>系统向改session发送<code>SIGHUP</code>信号</li>\n<li>session将<code>SIGHUP</code>信号发送给所有子进程</li>\n<li>子进程收到<code>SIGHUP</code>信号后会自动退出</li>\n</ol>\n<h2 id=\"nohup\"><a href=\"#nohup\" class=\"headerlink\" title=\"nohup\"></a>nohup</h2><p>nohup 是后台作业的意思， nohup运行的进程将会忽略终端信号运行。即后台运行一个命令。nohup COMMAND &amp; 用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响它的运行。</p>\n<p>使用nohup命令的方式可以启动一个守护进程，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-a2bafec78cb93512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>nohup命令对进程做了如下操作：</p>\n<ul>\n<li>忽略<code>SIGHUP</code>信号，因此当session关闭进程就不会退出</li>\n<li>关闭标准输入，该进程不再接收任何输入，即使运行在前台</li>\n<li>重定向标准输出和标准错误到文件nohup.out（默认情况，可以指定输出的文件）</li>\n</ul>\n<p>nohup不会自动把进程变为后台任务，所以必须加上<code>&amp;</code>。</p>\n<h2 id=\"supervisor\"><a href=\"#supervisor\" class=\"headerlink\" title=\"supervisor\"></a>supervisor</h2><p>supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。<br>supervisor管理进程是通过fork&#x2F;exec的方式把被管理的进程当做子进程来启动，用户只需要在配置文件中将要管理的进程进行配置。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p>supervisor主要由Supervisord、Supervisorctl、Web server和XML-RPC interface组成：</p>\n<ul>\n<li>supervisord：主进程，负责管理进程的server，它会根据配置文件创建指定数量的应用程序的子进程，管理子进程的整个生命周期，对crash的进程重启，对进程变化发送事件通知等。同时通过内置web server和XML-RPC Interface可以轻松实现进程管理。</li>\n<li>supervisorctl：管理client，用户通过命令行发送消息给supervisord，可以查看进程状态，加载配置文件，启停进程，查看进程标准输出和错误输出，远程操作等。</li>\n<li>Web server：superviosr提供了web server功能，可通过web控制进程。</li>\n<li>XML-RPC interface： XML-RPC接口，提供XML-RPC服务来对子进程进行管理和监控。</li>\n</ul>\n<h3 id=\"macOS环境安装使用\"><a href=\"#macOS环境安装使用\" class=\"headerlink\" title=\"macOS环境安装使用\"></a>macOS环境安装使用</h3><h4 id=\"安装并启动\"><a href=\"#安装并启动\" class=\"headerlink\" title=\"安装并启动\"></a>安装并启动</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">brew install supervisor</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">brew services start supervisor</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"创建配置目录和配置文件\"><a href=\"#创建配置目录和配置文件\" class=\"headerlink\" title=\"创建配置目录和配置文件\"></a>创建配置目录和配置文件</h4><p>默认的配置文件路径为<code>/usr/local/etc/supervisord.conf</code>，查看该文件可以看到如下内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">tail</span> -n2 /usr/local/etc/supervisord.conf</span></span><br><span class=\"line\">[include]</span><br><span class=\"line\">files = /usr/local/etc/supervisor.d/*.ini</span><br></pre></td></tr></table></figure>\n<p>可以看到include了<code>/usr/local/etc/supervisor.d/</code>目录下的<code>.ini</code>文件，因此我们需要创建改目录，然后对要管理的进程或进程组创建对应的<code>.ini</code>格式的配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">mkdir</span> -pv /usr/local/etc/supervisor.d</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">vim /usr/local/etc/supervisor.d/myserver.ini</span></span><br></pre></td></tr></table></figure>\n<p>编辑配置文件内容如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[program:server]</span><br><span class=\"line\">process_name=%(program_name)s_%(process_num)02d</span><br><span class=\"line\">command=/usr/local/go/bin/go run /Users/harryzhang/go/src/server/server.go # 要执行的命令</span><br><span class=\"line\">autostart=true # 系统开机自动启动</span><br><span class=\"line\">autorestart=true # 进程终止自动重启</span><br><span class=\"line\">user=harryzhang # 用户</span><br><span class=\"line\">numprocs=1 # 启动进程数</span><br><span class=\"line\">redirect_stderr=true # 是否将标准错误重定向到标准输出</span><br><span class=\"line\">stdout_logfile=/Users/harryzhang/go/src/server/server.log # 指定标准输出保存的文件路径</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重启supervisor\"><a href=\"#重启supervisor\" class=\"headerlink\" title=\"重启supervisor\"></a>重启supervisor</h4><p>编辑好配置文件后重启supervisor就可以生效，可以使用supervisorctl命令查看和管理进程状态。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">brew services restart supervisor</span></span><br><span class=\"line\">Stopping `supervisor`... (might take a while)</span><br><span class=\"line\">==&gt; Successfully stopped `supervisor` (label: homebrew.mxcl.supervisor)</span><br><span class=\"line\">==&gt; Successfully started `supervisor` (label: homebrew.mxcl.supervisor)</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">supervisorctl status</span></span><br><span class=\"line\">server:server_00                 RUNNING   pid 41382, uptime 0:00:04</span><br></pre></td></tr></table></figure>\n<p>如果指定的命令执行没有异常，会看到进程已处于运行状态，如果没有处于运行状态，可以查看日志文件，可能为命令执行出错直接退出了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html\">Linux 守护进程的启动方法</a></p>\n<p>【2】<a href=\"https://segmentfault.com/a/1190000017370468\">进程管理工具supervisor 和 nohup</a></p>\n"},{"title":"Linux 系统 I/O 模型及 select/poll/epoll 详解","date":"2023-03-19T14:06:15.000Z","_content":"\n## 基本概念说明\n理解Linux的IO模型之前，首先要了解一些基本概念，才能理解这些IO模型设计的依据\n\n### 用户空间和内核空间\n操作系统使用虚拟内存来映射物理内存，对于32位的操作系统来说，虚拟地址空间为4G（2^32）。操作系统的核心是内核，为了保护用户进程不能直接操作内核，保证内核安全，操作系统将虚拟地址空间划分为内核空间和用户空间。内核可以访问全部的地址空间，拥有访问底层硬件设备的权限，普通的应用程序需要访问硬件设备必须通过**系统调用**来实现。\n\n对于Linux系统来说，将虚拟内存的最高1G字节的空间作为内核空间仅供内核使用，低3G字节的空间供用户进程使用，称为用户空间。\n\n### 进程的状态\n- 就绪\n- 阻塞\n- 运行\n\n### 进程切换\n\n### 文件描述符fd\n\n###  缓存I/O\n又被称为标准I/O，大多数文件系统的默认I/O都是缓存I/O。在Linux系统的缓存I/O机制中，操作系统会将I/O的数据缓存在页缓存（内存）中，也就是数据先被拷贝到内核的缓冲区（内核地址空间），然后才会从内核缓冲区拷贝到应用程序的缓冲区（用户地址空间）。\n\n这种方式很明显的缺点就是数据传输过程中需要再应用程序地址空间和内核空间进行多次数据拷贝操作，这些操作带来的CPU以及内存的开销是非常大的。\n\n### 二I/O模式\n由于Linux系统采用的缓存I/O模式，对于一次I/O访问，以读操作举例，数据先会被拷贝到内核缓冲区，然后才会从内核缓冲区拷贝到应用程序的缓存区，当一个read系统调用发生的时候，会经历两个阶段：\n- 等待数据到来，进程处于阻塞状态\n- 当数据准备就绪后，将数据从内核拷贝到用户进程，进程处于运行状态\n\n正是因为这两个状态，Linux系统才产生了多种不同的网络I/O模式的方案\n\n## Linux系统I/O模型\n### 阻塞IO（blocking IO）\nLinux系统默认情况下所有socke都是blocking的，一个读操作流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-5b4abb97fad3f18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n以UDP socket为例，当用户进程调用了recvfrom系统调用，如果数据还没准备好，应用进程被阻塞，内核直到数据到来且将数据从内核缓冲区拷贝到了应用进程缓冲区，然后向用户进程返回结果，用户进程才解除block状态，重新运行起来。\n\n阻塞模行下只是阻塞了当前的应用进程，其他进程还可以执行，不消耗CPU时间，CPU的利用率较高。\n\n### 非阻塞IO（nonblocking IO）\nLinux可以设置socket为非阻塞的，非阻塞模式下执行一个读操作流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-485bfdc370909781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当用户进程发出recvfrom系统调用时，如果kernel中的数据还没准备好，recvfrom会立即返回一个error结果，不会阻塞用户进程，用户进程收到error时知道数据还没准备好，\b过一会再调用recvfrom，直到kernel中的数据准备好了，内核就立即将数据拷贝到用户内存然后返回ok，这个过程需要用户进程去轮询内核数据是否准备好。\n\n非阻塞模型下由于要处理更多的系统调用，因此CPU利用率比较低。\n\n### 信号驱动IO\n应用进程使用sigaction系统调用，内核立即返回，等到kernel数据准备好时会给用户进程发送一个信号，告诉用户进程可以进行IO操作了，然后用户进程再调用IO系统调用如recvfrom，将数据从内核缓冲区拷贝到应用进程。流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-1f14b7a7da55a2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n相比于轮询的方式，不需要多次系统调用轮询，信号驱动IO的CPU利用率更高。\n\n### 异步IO\n异步IO模型与其他模型最大的区别是，异步IO在系统调用返回的时候所有操作都已经完成，应用进程既不需要等待数据准备，也不需要在数据到来后等待数据从内核缓冲区拷贝到用户缓冲区，流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-95971297cce5bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在数据拷贝完成后，kernel会给用户进程发送一个信号告诉其read操作完成了。\n\n### IO多路复用\n是用select、poll等待数据，可以等待多个socket中的任一个变为可读，这一过程会被阻塞，当某个套接字数据到来时返回，之后再用recvfrom系统调用把数据从内核缓存区复制到用户进程，流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-8845990e0d75eb9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n流程类似阻塞IO，甚至比阻塞IO更差，多使用了一个系统调用，但是IO多路复用最大的特点是让单个进程能同时处理多个IO事件的能力，又被称为事件驱动IO，相比于多线程模型，IO复用模型不需要线程的创建、切换、销毁，系统开销更小，适合高并发的场景。\n\n####  select\nselect是IO多路复用模型的一种实现，当select函数返回后可以通过轮询fdset来找到就绪的socket。\n```c\nint select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)\n```\n\n优点是几乎所有平台都支持，缺点在于能够监听的fd数量有限，Linux系统上一般为1024，是写死在宏定义中的，要修改需要重新编译内核。而且每次都要把所有的fd在用户空间和内核空间拷贝，这个操作是比较耗时的。\n\n#### poll\npoll和select基本相同，不同的是poll没有最大fd数量限制（实际也会受到物理资源的限制，因为系统的fd数量是有限的），而且提供了更多的时间类型。\n```c\nint poll(struct pollfd *fds, unsigned int nfds, int timeout)\n```\n\n总结：select和poll都需要在返回后通过轮询的方式检查就绪的socket，事实上同时连的大量socket在一个时刻只有很少的处于就绪状态，因此随着监视的描述符数量的变多，其性能也会逐渐下降。\n\n#### epoll\nepoll是select和poll的改进版本，更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。\n```c\nint epoll_create(int size)\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)\n```\nepoll_create()用来创建一个epoll句柄。\nepoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个就绪链表中管理。\n epoll_wait() 可以从就绪链表中得到事件完成的描述符，因此进程不需要通过轮询来获得事件完成的描述符。\n\n##### LT模式（水平触发，默认）\n当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序可以不立即处理该事件，下次调用epoll_wait还会再次通知该事件，支持block和nonblocking socket。\n\n##### ET模式（边缘触发）\n当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序需要立即处理该事件，如果不立即处理，下次调用epoll_wait不会再次通知该事件。\n\nET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用nonblocking socket，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n#### 应用场景\n- select的timeout参数精度为微妙，而poll和epoll都是毫秒，会因此select更加适合对实时性要求比较高的场景\n\n- poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。\n\n- epoll适合高并发的场景，有大量描述符需要同时监听，并且最好是长连接。\n不适合监控的描述符状态变化频繁且短暂，因为epoll的描述符都存在内核中，每次对其状态修改都要通过epoll_ctl系统调用来实现，频繁的系统调用导致频繁在内核态和用户态切换，会大大降低性能。\n\n## 参考\n【segmentfault】[Linux IO模式及 select、poll、epoll详解](https://segmentfault.com/a/1190000003063859)\n【GitHub】[CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md#%E4%B8%80io-%E6%A8%A1%E5%9E%8B)","source":"_posts/2023/03-19-Linux-系统-I-O-模型及-select-poll-epoll-详解.md","raw":"---\ntitle: Linux 系统 I/O 模型及 select/poll/epoll 详解\ndate: 2023-03-19 22:06:15\ncategories:\n- 操作系统\ntags:\n- Linux\n- I/O模型\n- select/poll/epoll\n---\n\n## 基本概念说明\n理解Linux的IO模型之前，首先要了解一些基本概念，才能理解这些IO模型设计的依据\n\n### 用户空间和内核空间\n操作系统使用虚拟内存来映射物理内存，对于32位的操作系统来说，虚拟地址空间为4G（2^32）。操作系统的核心是内核，为了保护用户进程不能直接操作内核，保证内核安全，操作系统将虚拟地址空间划分为内核空间和用户空间。内核可以访问全部的地址空间，拥有访问底层硬件设备的权限，普通的应用程序需要访问硬件设备必须通过**系统调用**来实现。\n\n对于Linux系统来说，将虚拟内存的最高1G字节的空间作为内核空间仅供内核使用，低3G字节的空间供用户进程使用，称为用户空间。\n\n### 进程的状态\n- 就绪\n- 阻塞\n- 运行\n\n### 进程切换\n\n### 文件描述符fd\n\n###  缓存I/O\n又被称为标准I/O，大多数文件系统的默认I/O都是缓存I/O。在Linux系统的缓存I/O机制中，操作系统会将I/O的数据缓存在页缓存（内存）中，也就是数据先被拷贝到内核的缓冲区（内核地址空间），然后才会从内核缓冲区拷贝到应用程序的缓冲区（用户地址空间）。\n\n这种方式很明显的缺点就是数据传输过程中需要再应用程序地址空间和内核空间进行多次数据拷贝操作，这些操作带来的CPU以及内存的开销是非常大的。\n\n### 二I/O模式\n由于Linux系统采用的缓存I/O模式，对于一次I/O访问，以读操作举例，数据先会被拷贝到内核缓冲区，然后才会从内核缓冲区拷贝到应用程序的缓存区，当一个read系统调用发生的时候，会经历两个阶段：\n- 等待数据到来，进程处于阻塞状态\n- 当数据准备就绪后，将数据从内核拷贝到用户进程，进程处于运行状态\n\n正是因为这两个状态，Linux系统才产生了多种不同的网络I/O模式的方案\n\n## Linux系统I/O模型\n### 阻塞IO（blocking IO）\nLinux系统默认情况下所有socke都是blocking的，一个读操作流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-5b4abb97fad3f18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n以UDP socket为例，当用户进程调用了recvfrom系统调用，如果数据还没准备好，应用进程被阻塞，内核直到数据到来且将数据从内核缓冲区拷贝到了应用进程缓冲区，然后向用户进程返回结果，用户进程才解除block状态，重新运行起来。\n\n阻塞模行下只是阻塞了当前的应用进程，其他进程还可以执行，不消耗CPU时间，CPU的利用率较高。\n\n### 非阻塞IO（nonblocking IO）\nLinux可以设置socket为非阻塞的，非阻塞模式下执行一个读操作流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-485bfdc370909781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当用户进程发出recvfrom系统调用时，如果kernel中的数据还没准备好，recvfrom会立即返回一个error结果，不会阻塞用户进程，用户进程收到error时知道数据还没准备好，\b过一会再调用recvfrom，直到kernel中的数据准备好了，内核就立即将数据拷贝到用户内存然后返回ok，这个过程需要用户进程去轮询内核数据是否准备好。\n\n非阻塞模型下由于要处理更多的系统调用，因此CPU利用率比较低。\n\n### 信号驱动IO\n应用进程使用sigaction系统调用，内核立即返回，等到kernel数据准备好时会给用户进程发送一个信号，告诉用户进程可以进行IO操作了，然后用户进程再调用IO系统调用如recvfrom，将数据从内核缓冲区拷贝到应用进程。流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-1f14b7a7da55a2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n相比于轮询的方式，不需要多次系统调用轮询，信号驱动IO的CPU利用率更高。\n\n### 异步IO\n异步IO模型与其他模型最大的区别是，异步IO在系统调用返回的时候所有操作都已经完成，应用进程既不需要等待数据准备，也不需要在数据到来后等待数据从内核缓冲区拷贝到用户缓冲区，流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-95971297cce5bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在数据拷贝完成后，kernel会给用户进程发送一个信号告诉其read操作完成了。\n\n### IO多路复用\n是用select、poll等待数据，可以等待多个socket中的任一个变为可读，这一过程会被阻塞，当某个套接字数据到来时返回，之后再用recvfrom系统调用把数据从内核缓存区复制到用户进程，流程如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-8845990e0d75eb9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n流程类似阻塞IO，甚至比阻塞IO更差，多使用了一个系统调用，但是IO多路复用最大的特点是让单个进程能同时处理多个IO事件的能力，又被称为事件驱动IO，相比于多线程模型，IO复用模型不需要线程的创建、切换、销毁，系统开销更小，适合高并发的场景。\n\n####  select\nselect是IO多路复用模型的一种实现，当select函数返回后可以通过轮询fdset来找到就绪的socket。\n```c\nint select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)\n```\n\n优点是几乎所有平台都支持，缺点在于能够监听的fd数量有限，Linux系统上一般为1024，是写死在宏定义中的，要修改需要重新编译内核。而且每次都要把所有的fd在用户空间和内核空间拷贝，这个操作是比较耗时的。\n\n#### poll\npoll和select基本相同，不同的是poll没有最大fd数量限制（实际也会受到物理资源的限制，因为系统的fd数量是有限的），而且提供了更多的时间类型。\n```c\nint poll(struct pollfd *fds, unsigned int nfds, int timeout)\n```\n\n总结：select和poll都需要在返回后通过轮询的方式检查就绪的socket，事实上同时连的大量socket在一个时刻只有很少的处于就绪状态，因此随着监视的描述符数量的变多，其性能也会逐渐下降。\n\n#### epoll\nepoll是select和poll的改进版本，更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。\n```c\nint epoll_create(int size)\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)\n```\nepoll_create()用来创建一个epoll句柄。\nepoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个就绪链表中管理。\n epoll_wait() 可以从就绪链表中得到事件完成的描述符，因此进程不需要通过轮询来获得事件完成的描述符。\n\n##### LT模式（水平触发，默认）\n当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序可以不立即处理该事件，下次调用epoll_wait还会再次通知该事件，支持block和nonblocking socket。\n\n##### ET模式（边缘触发）\n当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序需要立即处理该事件，如果不立即处理，下次调用epoll_wait不会再次通知该事件。\n\nET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用nonblocking socket，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n#### 应用场景\n- select的timeout参数精度为微妙，而poll和epoll都是毫秒，会因此select更加适合对实时性要求比较高的场景\n\n- poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。\n\n- epoll适合高并发的场景，有大量描述符需要同时监听，并且最好是长连接。\n不适合监控的描述符状态变化频繁且短暂，因为epoll的描述符都存在内核中，每次对其状态修改都要通过epoll_ctl系统调用来实现，频繁的系统调用导致频繁在内核态和用户态切换，会大大降低性能。\n\n## 参考\n【segmentfault】[Linux IO模式及 select、poll、epoll详解](https://segmentfault.com/a/1190000003063859)\n【GitHub】[CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md#%E4%B8%80io-%E6%A8%A1%E5%9E%8B)","slug":"Linux-系统-I-O-模型及-select-poll-epoll-详解","published":1,"updated":"2023-03-19T14:07:53.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyvy0003vhfibywc7045","content":"<h2 id=\"基本概念说明\"><a href=\"#基本概念说明\" class=\"headerlink\" title=\"基本概念说明\"></a>基本概念说明</h2><p>理解Linux的IO模型之前，首先要了解一些基本概念，才能理解这些IO模型设计的依据</p>\n<h3 id=\"用户空间和内核空间\"><a href=\"#用户空间和内核空间\" class=\"headerlink\" title=\"用户空间和内核空间\"></a>用户空间和内核空间</h3><p>操作系统使用虚拟内存来映射物理内存，对于32位的操作系统来说，虚拟地址空间为4G（2^32）。操作系统的核心是内核，为了保护用户进程不能直接操作内核，保证内核安全，操作系统将虚拟地址空间划分为内核空间和用户空间。内核可以访问全部的地址空间，拥有访问底层硬件设备的权限，普通的应用程序需要访问硬件设备必须通过<strong>系统调用</strong>来实现。</p>\n<p>对于Linux系统来说，将虚拟内存的最高1G字节的空间作为内核空间仅供内核使用，低3G字节的空间供用户进程使用，称为用户空间。</p>\n<h3 id=\"进程的状态\"><a href=\"#进程的状态\" class=\"headerlink\" title=\"进程的状态\"></a>进程的状态</h3><ul>\n<li>就绪</li>\n<li>阻塞</li>\n<li>运行</li>\n</ul>\n<h3 id=\"进程切换\"><a href=\"#进程切换\" class=\"headerlink\" title=\"进程切换\"></a>进程切换</h3><h3 id=\"文件描述符fd\"><a href=\"#文件描述符fd\" class=\"headerlink\" title=\"文件描述符fd\"></a>文件描述符fd</h3><h3 id=\"缓存I-x2F-O\"><a href=\"#缓存I-x2F-O\" class=\"headerlink\" title=\"缓存I&#x2F;O\"></a>缓存I&#x2F;O</h3><p>又被称为标准I&#x2F;O，大多数文件系统的默认I&#x2F;O都是缓存I&#x2F;O。在Linux系统的缓存I&#x2F;O机制中，操作系统会将I&#x2F;O的数据缓存在页缓存（内存）中，也就是数据先被拷贝到内核的缓冲区（内核地址空间），然后才会从内核缓冲区拷贝到应用程序的缓冲区（用户地址空间）。</p>\n<p>这种方式很明显的缺点就是数据传输过程中需要再应用程序地址空间和内核空间进行多次数据拷贝操作，这些操作带来的CPU以及内存的开销是非常大的。</p>\n<h3 id=\"二I-x2F-O模式\"><a href=\"#二I-x2F-O模式\" class=\"headerlink\" title=\"二I&#x2F;O模式\"></a>二I&#x2F;O模式</h3><p>由于Linux系统采用的缓存I&#x2F;O模式，对于一次I&#x2F;O访问，以读操作举例，数据先会被拷贝到内核缓冲区，然后才会从内核缓冲区拷贝到应用程序的缓存区，当一个read系统调用发生的时候，会经历两个阶段：</p>\n<ul>\n<li>等待数据到来，进程处于阻塞状态</li>\n<li>当数据准备就绪后，将数据从内核拷贝到用户进程，进程处于运行状态</li>\n</ul>\n<p>正是因为这两个状态，Linux系统才产生了多种不同的网络I&#x2F;O模式的方案</p>\n<h2 id=\"Linux系统I-x2F-O模型\"><a href=\"#Linux系统I-x2F-O模型\" class=\"headerlink\" title=\"Linux系统I&#x2F;O模型\"></a>Linux系统I&#x2F;O模型</h2><h3 id=\"阻塞IO（blocking-IO）\"><a href=\"#阻塞IO（blocking-IO）\" class=\"headerlink\" title=\"阻塞IO（blocking IO）\"></a>阻塞IO（blocking IO）</h3><p>Linux系统默认情况下所有socke都是blocking的，一个读操作流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-5b4abb97fad3f18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-5b4abb97fad3f18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>以UDP socket为例，当用户进程调用了recvfrom系统调用，如果数据还没准备好，应用进程被阻塞，内核直到数据到来且将数据从内核缓冲区拷贝到了应用进程缓冲区，然后向用户进程返回结果，用户进程才解除block状态，重新运行起来。</p>\n<p>阻塞模行下只是阻塞了当前的应用进程，其他进程还可以执行，不消耗CPU时间，CPU的利用率较高。</p>\n<h3 id=\"非阻塞IO（nonblocking-IO）\"><a href=\"#非阻塞IO（nonblocking-IO）\" class=\"headerlink\" title=\"非阻塞IO（nonblocking IO）\"></a>非阻塞IO（nonblocking IO）</h3><p>Linux可以设置socket为非阻塞的，非阻塞模式下执行一个读操作流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-485bfdc370909781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-485bfdc370909781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>当用户进程发出recvfrom系统调用时，如果kernel中的数据还没准备好，recvfrom会立即返回一个error结果，不会阻塞用户进程，用户进程收到error时知道数据还没准备好，\b过一会再调用recvfrom，直到kernel中的数据准备好了，内核就立即将数据拷贝到用户内存然后返回ok，这个过程需要用户进程去轮询内核数据是否准备好。</p>\n<p>非阻塞模型下由于要处理更多的系统调用，因此CPU利用率比较低。</p>\n<h3 id=\"信号驱动IO\"><a href=\"#信号驱动IO\" class=\"headerlink\" title=\"信号驱动IO\"></a>信号驱动IO</h3><p>应用进程使用sigaction系统调用，内核立即返回，等到kernel数据准备好时会给用户进程发送一个信号，告诉用户进程可以进行IO操作了，然后用户进程再调用IO系统调用如recvfrom，将数据从内核缓冲区拷贝到应用进程。流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-1f14b7a7da55a2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-1f14b7a7da55a2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>相比于轮询的方式，不需要多次系统调用轮询，信号驱动IO的CPU利用率更高。</p>\n<h3 id=\"异步IO\"><a href=\"#异步IO\" class=\"headerlink\" title=\"异步IO\"></a>异步IO</h3><p>异步IO模型与其他模型最大的区别是，异步IO在系统调用返回的时候所有操作都已经完成，应用进程既不需要等待数据准备，也不需要在数据到来后等待数据从内核缓冲区拷贝到用户缓冲区，流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-95971297cce5bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-95971297cce5bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>在数据拷贝完成后，kernel会给用户进程发送一个信号告诉其read操作完成了。</p>\n<h3 id=\"IO多路复用\"><a href=\"#IO多路复用\" class=\"headerlink\" title=\"IO多路复用\"></a>IO多路复用</h3><p>是用select、poll等待数据，可以等待多个socket中的任一个变为可读，这一过程会被阻塞，当某个套接字数据到来时返回，之后再用recvfrom系统调用把数据从内核缓存区复制到用户进程，流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-8845990e0d75eb9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-8845990e0d75eb9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>流程类似阻塞IO，甚至比阻塞IO更差，多使用了一个系统调用，但是IO多路复用最大的特点是让单个进程能同时处理多个IO事件的能力，又被称为事件驱动IO，相比于多线程模型，IO复用模型不需要线程的创建、切换、销毁，系统开销更小，适合高并发的场景。</p>\n<h4 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h4><p>select是IO多路复用模型的一种实现，当select函数返回后可以通过轮询fdset来找到就绪的socket。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">select</span><span class=\"params\">(<span class=\"type\">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class=\"keyword\">struct</span> timeval *timeout)</span></span><br></pre></td></tr></table></figure>\n\n<p>优点是几乎所有平台都支持，缺点在于能够监听的fd数量有限，Linux系统上一般为1024，是写死在宏定义中的，要修改需要重新编译内核。而且每次都要把所有的fd在用户空间和内核空间拷贝，这个操作是比较耗时的。</p>\n<h4 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h4><p>poll和select基本相同，不同的是poll没有最大fd数量限制（实际也会受到物理资源的限制，因为系统的fd数量是有限的），而且提供了更多的时间类型。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> pollfd *fds, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> nfds, <span class=\"type\">int</span> timeout)</span></span><br></pre></td></tr></table></figure>\n\n<p>总结：select和poll都需要在返回后通过轮询的方式检查就绪的socket，事实上同时连的大量socket在一个时刻只有很少的处于就绪状态，因此随着监视的描述符数量的变多，其性能也会逐渐下降。</p>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>epoll是select和poll的改进版本，更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create</span><span class=\"params\">(<span class=\"type\">int</span> size)</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_ctl</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"type\">int</span> op, <span class=\"type\">int</span> fd, <span class=\"keyword\">struct</span> epoll_event *event)</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event * events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span></span><br></pre></td></tr></table></figure>\n<p>epoll_create()用来创建一个epoll句柄。<br>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I&#x2F;O 准备好的描述符加入到一个就绪链表中管理。<br> epoll_wait() 可以从就绪链表中得到事件完成的描述符，因此进程不需要通过轮询来获得事件完成的描述符。</p>\n<h5 id=\"LT模式（水平触发，默认）\"><a href=\"#LT模式（水平触发，默认）\" class=\"headerlink\" title=\"LT模式（水平触发，默认）\"></a>LT模式（水平触发，默认）</h5><p>当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序可以不立即处理该事件，下次调用epoll_wait还会再次通知该事件，支持block和nonblocking socket。</p>\n<h5 id=\"ET模式（边缘触发）\"><a href=\"#ET模式（边缘触发）\" class=\"headerlink\" title=\"ET模式（边缘触发）\"></a>ET模式（边缘触发）</h5><p>当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序需要立即处理该事件，如果不立即处理，下次调用epoll_wait不会再次通知该事件。</p>\n<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用nonblocking socket，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><ul>\n<li><p>select的timeout参数精度为微妙，而poll和epoll都是毫秒，会因此select更加适合对实时性要求比较高的场景</p>\n</li>\n<li><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>\n</li>\n<li><p>epoll适合高并发的场景，有大量描述符需要同时监听，并且最好是长连接。<br>不适合监控的描述符状态变化频繁且短暂，因为epoll的描述符都存在内核中，每次对其状态修改都要通过epoll_ctl系统调用来实现，频繁的系统调用导致频繁在内核态和用户态切换，会大大降低性能。</p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【segmentfault】<a href=\"https://segmentfault.com/a/1190000003063859\">Linux IO模式及 select、poll、epoll详解</a><br>【GitHub】<a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md#%E4%B8%80io-%E6%A8%A1%E5%9E%8B\">CyC2018&#x2F;CS-Notes</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本概念说明\"><a href=\"#基本概念说明\" class=\"headerlink\" title=\"基本概念说明\"></a>基本概念说明</h2><p>理解Linux的IO模型之前，首先要了解一些基本概念，才能理解这些IO模型设计的依据</p>\n<h3 id=\"用户空间和内核空间\"><a href=\"#用户空间和内核空间\" class=\"headerlink\" title=\"用户空间和内核空间\"></a>用户空间和内核空间</h3><p>操作系统使用虚拟内存来映射物理内存，对于32位的操作系统来说，虚拟地址空间为4G（2^32）。操作系统的核心是内核，为了保护用户进程不能直接操作内核，保证内核安全，操作系统将虚拟地址空间划分为内核空间和用户空间。内核可以访问全部的地址空间，拥有访问底层硬件设备的权限，普通的应用程序需要访问硬件设备必须通过<strong>系统调用</strong>来实现。</p>\n<p>对于Linux系统来说，将虚拟内存的最高1G字节的空间作为内核空间仅供内核使用，低3G字节的空间供用户进程使用，称为用户空间。</p>\n<h3 id=\"进程的状态\"><a href=\"#进程的状态\" class=\"headerlink\" title=\"进程的状态\"></a>进程的状态</h3><ul>\n<li>就绪</li>\n<li>阻塞</li>\n<li>运行</li>\n</ul>\n<h3 id=\"进程切换\"><a href=\"#进程切换\" class=\"headerlink\" title=\"进程切换\"></a>进程切换</h3><h3 id=\"文件描述符fd\"><a href=\"#文件描述符fd\" class=\"headerlink\" title=\"文件描述符fd\"></a>文件描述符fd</h3><h3 id=\"缓存I-x2F-O\"><a href=\"#缓存I-x2F-O\" class=\"headerlink\" title=\"缓存I&#x2F;O\"></a>缓存I&#x2F;O</h3><p>又被称为标准I&#x2F;O，大多数文件系统的默认I&#x2F;O都是缓存I&#x2F;O。在Linux系统的缓存I&#x2F;O机制中，操作系统会将I&#x2F;O的数据缓存在页缓存（内存）中，也就是数据先被拷贝到内核的缓冲区（内核地址空间），然后才会从内核缓冲区拷贝到应用程序的缓冲区（用户地址空间）。</p>\n<p>这种方式很明显的缺点就是数据传输过程中需要再应用程序地址空间和内核空间进行多次数据拷贝操作，这些操作带来的CPU以及内存的开销是非常大的。</p>\n<h3 id=\"二I-x2F-O模式\"><a href=\"#二I-x2F-O模式\" class=\"headerlink\" title=\"二I&#x2F;O模式\"></a>二I&#x2F;O模式</h3><p>由于Linux系统采用的缓存I&#x2F;O模式，对于一次I&#x2F;O访问，以读操作举例，数据先会被拷贝到内核缓冲区，然后才会从内核缓冲区拷贝到应用程序的缓存区，当一个read系统调用发生的时候，会经历两个阶段：</p>\n<ul>\n<li>等待数据到来，进程处于阻塞状态</li>\n<li>当数据准备就绪后，将数据从内核拷贝到用户进程，进程处于运行状态</li>\n</ul>\n<p>正是因为这两个状态，Linux系统才产生了多种不同的网络I&#x2F;O模式的方案</p>\n<h2 id=\"Linux系统I-x2F-O模型\"><a href=\"#Linux系统I-x2F-O模型\" class=\"headerlink\" title=\"Linux系统I&#x2F;O模型\"></a>Linux系统I&#x2F;O模型</h2><h3 id=\"阻塞IO（blocking-IO）\"><a href=\"#阻塞IO（blocking-IO）\" class=\"headerlink\" title=\"阻塞IO（blocking IO）\"></a>阻塞IO（blocking IO）</h3><p>Linux系统默认情况下所有socke都是blocking的，一个读操作流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-5b4abb97fad3f18d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>以UDP socket为例，当用户进程调用了recvfrom系统调用，如果数据还没准备好，应用进程被阻塞，内核直到数据到来且将数据从内核缓冲区拷贝到了应用进程缓冲区，然后向用户进程返回结果，用户进程才解除block状态，重新运行起来。</p>\n<p>阻塞模行下只是阻塞了当前的应用进程，其他进程还可以执行，不消耗CPU时间，CPU的利用率较高。</p>\n<h3 id=\"非阻塞IO（nonblocking-IO）\"><a href=\"#非阻塞IO（nonblocking-IO）\" class=\"headerlink\" title=\"非阻塞IO（nonblocking IO）\"></a>非阻塞IO（nonblocking IO）</h3><p>Linux可以设置socket为非阻塞的，非阻塞模式下执行一个读操作流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-485bfdc370909781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>当用户进程发出recvfrom系统调用时，如果kernel中的数据还没准备好，recvfrom会立即返回一个error结果，不会阻塞用户进程，用户进程收到error时知道数据还没准备好，\b过一会再调用recvfrom，直到kernel中的数据准备好了，内核就立即将数据拷贝到用户内存然后返回ok，这个过程需要用户进程去轮询内核数据是否准备好。</p>\n<p>非阻塞模型下由于要处理更多的系统调用，因此CPU利用率比较低。</p>\n<h3 id=\"信号驱动IO\"><a href=\"#信号驱动IO\" class=\"headerlink\" title=\"信号驱动IO\"></a>信号驱动IO</h3><p>应用进程使用sigaction系统调用，内核立即返回，等到kernel数据准备好时会给用户进程发送一个信号，告诉用户进程可以进行IO操作了，然后用户进程再调用IO系统调用如recvfrom，将数据从内核缓冲区拷贝到应用进程。流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-1f14b7a7da55a2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>相比于轮询的方式，不需要多次系统调用轮询，信号驱动IO的CPU利用率更高。</p>\n<h3 id=\"异步IO\"><a href=\"#异步IO\" class=\"headerlink\" title=\"异步IO\"></a>异步IO</h3><p>异步IO模型与其他模型最大的区别是，异步IO在系统调用返回的时候所有操作都已经完成，应用进程既不需要等待数据准备，也不需要在数据到来后等待数据从内核缓冲区拷贝到用户缓冲区，流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-95971297cce5bd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>在数据拷贝完成后，kernel会给用户进程发送一个信号告诉其read操作完成了。</p>\n<h3 id=\"IO多路复用\"><a href=\"#IO多路复用\" class=\"headerlink\" title=\"IO多路复用\"></a>IO多路复用</h3><p>是用select、poll等待数据，可以等待多个socket中的任一个变为可读，这一过程会被阻塞，当某个套接字数据到来时返回，之后再用recvfrom系统调用把数据从内核缓存区复制到用户进程，流程如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-8845990e0d75eb9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>流程类似阻塞IO，甚至比阻塞IO更差，多使用了一个系统调用，但是IO多路复用最大的特点是让单个进程能同时处理多个IO事件的能力，又被称为事件驱动IO，相比于多线程模型，IO复用模型不需要线程的创建、切换、销毁，系统开销更小，适合高并发的场景。</p>\n<h4 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h4><p>select是IO多路复用模型的一种实现，当select函数返回后可以通过轮询fdset来找到就绪的socket。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">select</span><span class=\"params\">(<span class=\"type\">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class=\"keyword\">struct</span> timeval *timeout)</span></span><br></pre></td></tr></table></figure>\n\n<p>优点是几乎所有平台都支持，缺点在于能够监听的fd数量有限，Linux系统上一般为1024，是写死在宏定义中的，要修改需要重新编译内核。而且每次都要把所有的fd在用户空间和内核空间拷贝，这个操作是比较耗时的。</p>\n<h4 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h4><p>poll和select基本相同，不同的是poll没有最大fd数量限制（实际也会受到物理资源的限制，因为系统的fd数量是有限的），而且提供了更多的时间类型。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> pollfd *fds, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> nfds, <span class=\"type\">int</span> timeout)</span></span><br></pre></td></tr></table></figure>\n\n<p>总结：select和poll都需要在返回后通过轮询的方式检查就绪的socket，事实上同时连的大量socket在一个时刻只有很少的处于就绪状态，因此随着监视的描述符数量的变多，其性能也会逐渐下降。</p>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>epoll是select和poll的改进版本，更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create</span><span class=\"params\">(<span class=\"type\">int</span> size)</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_ctl</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"type\">int</span> op, <span class=\"type\">int</span> fd, <span class=\"keyword\">struct</span> epoll_event *event)</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event * events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span></span><br></pre></td></tr></table></figure>\n<p>epoll_create()用来创建一个epoll句柄。<br>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I&#x2F;O 准备好的描述符加入到一个就绪链表中管理。<br> epoll_wait() 可以从就绪链表中得到事件完成的描述符，因此进程不需要通过轮询来获得事件完成的描述符。</p>\n<h5 id=\"LT模式（水平触发，默认）\"><a href=\"#LT模式（水平触发，默认）\" class=\"headerlink\" title=\"LT模式（水平触发，默认）\"></a>LT模式（水平触发，默认）</h5><p>当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序可以不立即处理该事件，下次调用epoll_wait还会再次通知该事件，支持block和nonblocking socket。</p>\n<h5 id=\"ET模式（边缘触发）\"><a href=\"#ET模式（边缘触发）\" class=\"headerlink\" title=\"ET模式（边缘触发）\"></a>ET模式（边缘触发）</h5><p>当epoll_wait检测到描述符IO事件发生并且通知给应用程序时，应用程序需要立即处理该事件，如果不立即处理，下次调用epoll_wait不会再次通知该事件。</p>\n<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用nonblocking socket，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><ul>\n<li><p>select的timeout参数精度为微妙，而poll和epoll都是毫秒，会因此select更加适合对实时性要求比较高的场景</p>\n</li>\n<li><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>\n</li>\n<li><p>epoll适合高并发的场景，有大量描述符需要同时监听，并且最好是长连接。<br>不适合监控的描述符状态变化频繁且短暂，因为epoll的描述符都存在内核中，每次对其状态修改都要通过epoll_ctl系统调用来实现，频繁的系统调用导致频繁在内核态和用户态切换，会大大降低性能。</p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【segmentfault】<a href=\"https://segmentfault.com/a/1190000003063859\">Linux IO模式及 select、poll、epoll详解</a><br>【GitHub】<a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md#%E4%B8%80io-%E6%A8%A1%E5%9E%8B\">CyC2018&#x2F;CS-Notes</a></p>\n"},{"title":"数据结构(1): 字符串","date":"2023-03-19T13:04:01.000Z","_content":"\n## 1.1 字符串移位\n> 问题：将字符的前k个字符移到字符串结尾。\nInput：“abcde”，2\nOutput：“cdeab”\n\n**三步翻转法**： 将字符串分为前k位和后（n-k）位两部分，将两部分分别翻转，最后再整体翻转即可。\n时间复杂度：T = O(n)\n[参考原文](https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.01.html)\n\n` 示例代码：`\n```go\n// 反转字符串\nfunc reverse(s string) string {\n\trunes := []rune(s)\n\tfor l, r := 0, len(runes) - 1; l < r; l, r = l + 1, r - 1 {\n\t\trunes[l], runes[r] = runes[r], runes[l]\n\t}\n\treturn string(runes)\n}\n\n// 三步反转法对字符串进行循环移位\nfunc shift_string(s string, k int) string {\n\trunes := []rune(s)\n\tls, rs := runes[:k], runes[k:]\n\trls := reverse(string(ls))\n\trrs := reverse(string(rs))\n\treturn reverse(rls + rrs)\n}\n```\n\n## 1.2 最长回文子串\n[LeetCode No.5](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n\n> 问题：找出一个子串包含的最长回文子串。\nInput: s = \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer.\n\n解法1：从某个子串向两边扩展，遍历找出最长的一个（需要考虑偶数个、奇数个字符的回文子串）\n\n`示例代码`\n```go\nfunc LongestPalindrome(s string) string {\n\trs := []rune(s)\n\tmx, st := 0, 0\n\ti, j, c := 0, 0, 0\n\tfor i = 0; i < len(rs); i++ {\n\t\t// 奇数个字符的回文子串\n\t\tfor j = 0; i - j >= 0 && i + j < len(rs); j++ {\n\t\t\tif rs[i - j] != rs[i + j] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc = 2 * j + 1\n\t\t}\n\t\tif c > mx {\n\t\t\tmx = c\n\t\t\tst = i - j + 1\n\t\t}\n\t\t// 偶数个字符的回文子串\n\t\tfor j = 0; (i - j) >= 0 && (i + j + 1) < len(rs); j++ {\n\t\t\tif rs[i - j] != rs[i + j + 1] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc = j * 2 + 2\n\t\t}\n\t\tif c > mx {\n\t\t\tmx = c\n\t\t\tst = i - j + 1\n\t\t}\n\t}\n\n\treturn string(rs[st: st + mx])\n}\n```\n解法2：马拉车算法\n具体思路[参考原文](https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0005.Longest-Palindromic-Substring/)\n\n`示例代码：`\n```go\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\nfunc LongestPalindrome1(s string) string {\n\tif len(s) < 2 {\n\t\treturn s\n\t}\n\tnews := make([]rune, len(s))\n\tnews[0] = '#'\n\tfor _, r := range s {\n\t\tnews = append(news, r)\n\t\tnews = append(news, '#')\n\t}\n\tdp := make([]int, len(news))\n\tmx, center, maxlen, maxst := 0, 0, 1, 0\n\tfor i := 0; i < len(news); i++ {\n\t\t// 算法核心转移方程\n\t\tif i < mx {\n\t\t\tdp[i] = min(mx - i, dp[2*center - i])\n\t\t}\n\n\t\t// 以i为中心，只接从距离i为d[i] + 1的位置扩散\n\t\tleft, right := i - (1 + dp[i]), i + (1+ dp[i])\n\t\tfor left >= 0 && right < len(news) && news[left] == news[right] {\n\t\t\tdp[i]++\n\t\t\tleft++\n\t\t\tright--\n\t\t}\n\t\t// 更新mx\n\t\tif i + dp[i] > mx {\n\t\t\tmx = i + dp[i]\n\t\t\tcenter = i\n\t\t}\n\t\t// 更新最大长度和对应在源字符串的起始位置\n\t\tif dp[i] > maxlen {\n\t\t\tmaxlen = dp[i]\n\t\t\tmaxst = (i - maxlen) / 2\n\t\t}\n\t}\n\treturn s[maxst : maxst + maxlen]\n}\n```\n\n## 1.3 字符串的全排列\n> 问题描述：输入一个字符串，打印出该字符串中字符的所有排列。\n例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串\nabc、acb、bac、bca、cab 和 cba。\n\n解法1：递归方法DFS搜索，想象成树\n![](https://upload-images.jianshu.io/upload_images/14151453-21cc1e0269c2e662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`示例代码:`\n```go\nvar res = []string{}\n\nfunc dfs_search(s string, lv int, cur string)  {\n\tif lv == 0 {\n\t\tres = append(res, cur)\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\t// 去掉当前字符，下一层在剩下的字符中挑\n\t\tdfs_search(s[:i] + s[i+1:], lv - 1, cur + string(s[i]))\n\t}\n}\n\nfunc FullPermutation(s string) []string  {\n\tres = []string{}\n\tdfs_search(s, len(s), \"\")\n\treturn res\n}\n```\n\n解法2：字典序排列，从当前字符串s生成刚好比他大的下一个字符串排列\n[参考原文](https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.06.html)\n\n1. 找到排列中最后一个升序的位置i\n2. 找到i后面最后一个比s[i]大的位置j\n3. 交换s[i]和s[j]\n4. 将i+1之后的字符串反转\n\n`示例代码:`\n```go\n// 字典序排列算法\nfunc next_permutation(s string) (bool, string)  {\n\trs := []rune(s)\n\ti, j := 0, 0\n\n\t// 找到最后一个升序的位置i\n\tfor i = len(rs) - 2; i >= 0 && rs[i] >= rs[i+1]; i-- {}\n\tif i < 0 {\n\t\treturn false, \"\"\n\t}\n\t// 找到i后面最后一个比rs[i]大的位置j\n\tfor j = len(rs) - 1; j > i && rs[j] <= rs[i]; j-- {}\n\t// 交换rs[i], s[j]\n\trs[i], rs[j] = rs[j], rs[i]\n\t// 反转rs[i+1:]\n\trev := reverse(string(rs[i + 1:]))\n\treturn true, string(rs[:i+1]) + rev\n}\n\nfunc DictOrderFullPermutation(s string) []string  {\n\tres := []string{}\n\tfor ok, next_str := true, s; ok; ok, next_str = next_permutation(next_str) {\n\t\tres = append(res, next_str)\n\t}\n\treturn res\n}\n```\n","source":"_posts/2023/03-19-数据结构-1-字符串.md","raw":"---\ntitle: '数据结构(1): 字符串'\ndate: 2023-03-19 21:04:01\ncategories:\n- [数据结构]\ntags:\n- 字符串\n- leetcode\n---\n\n## 1.1 字符串移位\n> 问题：将字符的前k个字符移到字符串结尾。\nInput：“abcde”，2\nOutput：“cdeab”\n\n**三步翻转法**： 将字符串分为前k位和后（n-k）位两部分，将两部分分别翻转，最后再整体翻转即可。\n时间复杂度：T = O(n)\n[参考原文](https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.01.html)\n\n` 示例代码：`\n```go\n// 反转字符串\nfunc reverse(s string) string {\n\trunes := []rune(s)\n\tfor l, r := 0, len(runes) - 1; l < r; l, r = l + 1, r - 1 {\n\t\trunes[l], runes[r] = runes[r], runes[l]\n\t}\n\treturn string(runes)\n}\n\n// 三步反转法对字符串进行循环移位\nfunc shift_string(s string, k int) string {\n\trunes := []rune(s)\n\tls, rs := runes[:k], runes[k:]\n\trls := reverse(string(ls))\n\trrs := reverse(string(rs))\n\treturn reverse(rls + rrs)\n}\n```\n\n## 1.2 最长回文子串\n[LeetCode No.5](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n\n> 问题：找出一个子串包含的最长回文子串。\nInput: s = \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer.\n\n解法1：从某个子串向两边扩展，遍历找出最长的一个（需要考虑偶数个、奇数个字符的回文子串）\n\n`示例代码`\n```go\nfunc LongestPalindrome(s string) string {\n\trs := []rune(s)\n\tmx, st := 0, 0\n\ti, j, c := 0, 0, 0\n\tfor i = 0; i < len(rs); i++ {\n\t\t// 奇数个字符的回文子串\n\t\tfor j = 0; i - j >= 0 && i + j < len(rs); j++ {\n\t\t\tif rs[i - j] != rs[i + j] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc = 2 * j + 1\n\t\t}\n\t\tif c > mx {\n\t\t\tmx = c\n\t\t\tst = i - j + 1\n\t\t}\n\t\t// 偶数个字符的回文子串\n\t\tfor j = 0; (i - j) >= 0 && (i + j + 1) < len(rs); j++ {\n\t\t\tif rs[i - j] != rs[i + j + 1] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc = j * 2 + 2\n\t\t}\n\t\tif c > mx {\n\t\t\tmx = c\n\t\t\tst = i - j + 1\n\t\t}\n\t}\n\n\treturn string(rs[st: st + mx])\n}\n```\n解法2：马拉车算法\n具体思路[参考原文](https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0005.Longest-Palindromic-Substring/)\n\n`示例代码：`\n```go\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\nfunc LongestPalindrome1(s string) string {\n\tif len(s) < 2 {\n\t\treturn s\n\t}\n\tnews := make([]rune, len(s))\n\tnews[0] = '#'\n\tfor _, r := range s {\n\t\tnews = append(news, r)\n\t\tnews = append(news, '#')\n\t}\n\tdp := make([]int, len(news))\n\tmx, center, maxlen, maxst := 0, 0, 1, 0\n\tfor i := 0; i < len(news); i++ {\n\t\t// 算法核心转移方程\n\t\tif i < mx {\n\t\t\tdp[i] = min(mx - i, dp[2*center - i])\n\t\t}\n\n\t\t// 以i为中心，只接从距离i为d[i] + 1的位置扩散\n\t\tleft, right := i - (1 + dp[i]), i + (1+ dp[i])\n\t\tfor left >= 0 && right < len(news) && news[left] == news[right] {\n\t\t\tdp[i]++\n\t\t\tleft++\n\t\t\tright--\n\t\t}\n\t\t// 更新mx\n\t\tif i + dp[i] > mx {\n\t\t\tmx = i + dp[i]\n\t\t\tcenter = i\n\t\t}\n\t\t// 更新最大长度和对应在源字符串的起始位置\n\t\tif dp[i] > maxlen {\n\t\t\tmaxlen = dp[i]\n\t\t\tmaxst = (i - maxlen) / 2\n\t\t}\n\t}\n\treturn s[maxst : maxst + maxlen]\n}\n```\n\n## 1.3 字符串的全排列\n> 问题描述：输入一个字符串，打印出该字符串中字符的所有排列。\n例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串\nabc、acb、bac、bca、cab 和 cba。\n\n解法1：递归方法DFS搜索，想象成树\n![](https://upload-images.jianshu.io/upload_images/14151453-21cc1e0269c2e662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`示例代码:`\n```go\nvar res = []string{}\n\nfunc dfs_search(s string, lv int, cur string)  {\n\tif lv == 0 {\n\t\tres = append(res, cur)\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\t// 去掉当前字符，下一层在剩下的字符中挑\n\t\tdfs_search(s[:i] + s[i+1:], lv - 1, cur + string(s[i]))\n\t}\n}\n\nfunc FullPermutation(s string) []string  {\n\tres = []string{}\n\tdfs_search(s, len(s), \"\")\n\treturn res\n}\n```\n\n解法2：字典序排列，从当前字符串s生成刚好比他大的下一个字符串排列\n[参考原文](https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.06.html)\n\n1. 找到排列中最后一个升序的位置i\n2. 找到i后面最后一个比s[i]大的位置j\n3. 交换s[i]和s[j]\n4. 将i+1之后的字符串反转\n\n`示例代码:`\n```go\n// 字典序排列算法\nfunc next_permutation(s string) (bool, string)  {\n\trs := []rune(s)\n\ti, j := 0, 0\n\n\t// 找到最后一个升序的位置i\n\tfor i = len(rs) - 2; i >= 0 && rs[i] >= rs[i+1]; i-- {}\n\tif i < 0 {\n\t\treturn false, \"\"\n\t}\n\t// 找到i后面最后一个比rs[i]大的位置j\n\tfor j = len(rs) - 1; j > i && rs[j] <= rs[i]; j-- {}\n\t// 交换rs[i], s[j]\n\trs[i], rs[j] = rs[j], rs[i]\n\t// 反转rs[i+1:]\n\trev := reverse(string(rs[i + 1:]))\n\treturn true, string(rs[:i+1]) + rev\n}\n\nfunc DictOrderFullPermutation(s string) []string  {\n\tres := []string{}\n\tfor ok, next_str := true, s; ok; ok, next_str = next_permutation(next_str) {\n\t\tres = append(res, next_str)\n\t}\n\treturn res\n}\n```\n","slug":"数据结构-1-字符串","published":1,"updated":"2023-03-19T13:50:44.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyw10007vhfiep8mgw3s","content":"<h2 id=\"1-1-字符串移位\"><a href=\"#1-1-字符串移位\" class=\"headerlink\" title=\"1.1 字符串移位\"></a>1.1 字符串移位</h2><blockquote>\n<p>问题：将字符的前k个字符移到字符串结尾。<br>Input：“abcde”，2<br>Output：“cdeab”</p>\n</blockquote>\n<p><strong>三步翻转法</strong>： 将字符串分为前k位和后（n-k）位两部分，将两部分分别翻转，最后再整体翻转即可。<br>时间复杂度：T &#x3D; O(n)<br><a href=\"https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.01.html\">参考原文</a></p>\n<p><code> 示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反转字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverse</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trunes := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(runes) - <span class=\"number\">1</span>; l &lt; r; l, r = l + <span class=\"number\">1</span>, r - <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\trunes[l], runes[r] = runes[r], runes[l]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">string</span>(runes)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 三步反转法对字符串进行循环移位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shift_string</span><span class=\"params\">(s <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trunes := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\tls, rs := runes[:k], runes[k:]</span><br><span class=\"line\">\trls := reverse(<span class=\"type\">string</span>(ls))</span><br><span class=\"line\">\trrs := reverse(<span class=\"type\">string</span>(rs))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> reverse(rls + rrs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-最长回文子串\"><a href=\"#1-2-最长回文子串\" class=\"headerlink\" title=\"1.2 最长回文子串\"></a>1.2 最长回文子串</h2><p><a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\">LeetCode No.5</a></p>\n<blockquote>\n<p>问题：找出一个子串包含的最长回文子串。<br>Input: s &#x3D; “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.</p>\n</blockquote>\n<p>解法1：从某个子串向两边扩展，遍历找出最长的一个（需要考虑偶数个、奇数个字符的回文子串）</p>\n<p><code>示例代码</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LongestPalindrome</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trs := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\tmx, st := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\ti, j, c := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(rs); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 奇数个字符的回文子串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j = <span class=\"number\">0</span>; i - j &gt;= <span class=\"number\">0</span> &amp;&amp; i + j &lt; <span class=\"built_in\">len</span>(rs); j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> rs[i - j] != rs[i + j] &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tc = <span class=\"number\">2</span> * j + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c &gt; mx &#123;</span><br><span class=\"line\">\t\t\tmx = c</span><br><span class=\"line\">\t\t\tst = i - j + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 偶数个字符的回文子串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j = <span class=\"number\">0</span>; (i - j) &gt;= <span class=\"number\">0</span> &amp;&amp; (i + j + <span class=\"number\">1</span>) &lt; <span class=\"built_in\">len</span>(rs); j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> rs[i - j] != rs[i + j + <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tc = j * <span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c &gt; mx &#123;</span><br><span class=\"line\">\t\t\tmx = c</span><br><span class=\"line\">\t\t\tst = i - j + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">string</span>(rs[st: st + mx])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解法2：马拉车算法<br>具体思路<a href=\"https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0005.Longest-Palindromic-Substring/\">参考原文</a></p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt; y &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LongestPalindrome1</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) &lt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnews := <span class=\"built_in\">make</span>([]<span class=\"type\">rune</span>, <span class=\"built_in\">len</span>(s))</span><br><span class=\"line\">\tnews[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;#&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\tnews = <span class=\"built_in\">append</span>(news, r)</span><br><span class=\"line\">\t\tnews = <span class=\"built_in\">append</span>(news, <span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(news))</span><br><span class=\"line\">\tmx, center, maxlen, maxst := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(news); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 算法核心转移方程</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &lt; mx &#123;</span><br><span class=\"line\">\t\t\tdp[i] = min(mx - i, dp[<span class=\"number\">2</span>*center - i])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 以i为中心，只接从距离i为d[i] + 1的位置扩散</span></span><br><span class=\"line\">\t\tleft, right := i - (<span class=\"number\">1</span> + dp[i]), i + (<span class=\"number\">1</span>+ dp[i])</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> left &gt;= <span class=\"number\">0</span> &amp;&amp; right &lt; <span class=\"built_in\">len</span>(news) &amp;&amp; news[left] == news[right] &#123;</span><br><span class=\"line\">\t\t\tdp[i]++</span><br><span class=\"line\">\t\t\tleft++</span><br><span class=\"line\">\t\t\tright--</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新mx</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i + dp[i] &gt; mx &#123;</span><br><span class=\"line\">\t\t\tmx = i + dp[i]</span><br><span class=\"line\">\t\t\tcenter = i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新最大长度和对应在源字符串的起始位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> dp[i] &gt; maxlen &#123;</span><br><span class=\"line\">\t\t\tmaxlen = dp[i]</span><br><span class=\"line\">\t\t\tmaxst = (i - maxlen) / <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s[maxst : maxst + maxlen]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-字符串的全排列\"><a href=\"#1-3-字符串的全排列\" class=\"headerlink\" title=\"1.3 字符串的全排列\"></a>1.3 字符串的全排列</h2><blockquote>\n<p>问题描述：输入一个字符串，打印出该字符串中字符的所有排列。<br>例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串<br>abc、acb、bac、bca、cab 和 cba。</p>\n</blockquote>\n<p>解法1：递归方法DFS搜索，想象成树<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-21cc1e0269c2e662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-21cc1e0269c2e662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs_search</span><span class=\"params\">(s <span class=\"type\">string</span>, lv <span class=\"type\">int</span>, cur <span class=\"type\">string</span>)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> lv == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, cur)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 去掉当前字符，下一层在剩下的字符中挑</span></span><br><span class=\"line\">\t\tdfs_search(s[:i] + s[i+<span class=\"number\">1</span>:], lv - <span class=\"number\">1</span>, cur + <span class=\"type\">string</span>(s[i]))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FullPermutation</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span>  &#123;</span><br><span class=\"line\">\tres = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\tdfs_search(s, <span class=\"built_in\">len</span>(s), <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解法2：字典序排列，从当前字符串s生成刚好比他大的下一个字符串排列<br><a href=\"https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.06.html\">参考原文</a></p>\n<ol>\n<li>找到排列中最后一个升序的位置i</li>\n<li>找到i后面最后一个比s[i]大的位置j</li>\n<li>交换s[i]和s[j]</li>\n<li>将i+1之后的字符串反转</li>\n</ol>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字典序排列算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">next_permutation</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> (<span class=\"type\">bool</span>, <span class=\"type\">string</span>)  &#123;</span><br><span class=\"line\">\trs := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\ti, j := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 找到最后一个升序的位置i</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i = <span class=\"built_in\">len</span>(rs) - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; rs[i] &gt;= rs[i+<span class=\"number\">1</span>]; i-- &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>, <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 找到i后面最后一个比rs[i]大的位置j</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j = <span class=\"built_in\">len</span>(rs) - <span class=\"number\">1</span>; j &gt; i &amp;&amp; rs[j] &lt;= rs[i]; j-- &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 交换rs[i], s[j]</span></span><br><span class=\"line\">\trs[i], rs[j] = rs[j], rs[i]</span><br><span class=\"line\">\t<span class=\"comment\">// 反转rs[i+1:]</span></span><br><span class=\"line\">\trev := reverse(<span class=\"type\">string</span>(rs[i + <span class=\"number\">1</span>:]))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>, <span class=\"type\">string</span>(rs[:i+<span class=\"number\">1</span>]) + rev</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DictOrderFullPermutation</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span>  &#123;</span><br><span class=\"line\">\tres := []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ok, next_str := <span class=\"literal\">true</span>, s; ok; ok, next_str = next_permutation(next_str) &#123;</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, next_str)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-1-字符串移位\"><a href=\"#1-1-字符串移位\" class=\"headerlink\" title=\"1.1 字符串移位\"></a>1.1 字符串移位</h2><blockquote>\n<p>问题：将字符的前k个字符移到字符串结尾。<br>Input：“abcde”，2<br>Output：“cdeab”</p>\n</blockquote>\n<p><strong>三步翻转法</strong>： 将字符串分为前k位和后（n-k）位两部分，将两部分分别翻转，最后再整体翻转即可。<br>时间复杂度：T &#x3D; O(n)<br><a href=\"https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.01.html\">参考原文</a></p>\n<p><code> 示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反转字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverse</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trunes := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(runes) - <span class=\"number\">1</span>; l &lt; r; l, r = l + <span class=\"number\">1</span>, r - <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\trunes[l], runes[r] = runes[r], runes[l]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">string</span>(runes)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 三步反转法对字符串进行循环移位</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shift_string</span><span class=\"params\">(s <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trunes := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\tls, rs := runes[:k], runes[k:]</span><br><span class=\"line\">\trls := reverse(<span class=\"type\">string</span>(ls))</span><br><span class=\"line\">\trrs := reverse(<span class=\"type\">string</span>(rs))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> reverse(rls + rrs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-最长回文子串\"><a href=\"#1-2-最长回文子串\" class=\"headerlink\" title=\"1.2 最长回文子串\"></a>1.2 最长回文子串</h2><p><a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\">LeetCode No.5</a></p>\n<blockquote>\n<p>问题：找出一个子串包含的最长回文子串。<br>Input: s &#x3D; “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.</p>\n</blockquote>\n<p>解法1：从某个子串向两边扩展，遍历找出最长的一个（需要考虑偶数个、奇数个字符的回文子串）</p>\n<p><code>示例代码</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LongestPalindrome</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\trs := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\tmx, st := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\ti, j, c := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(rs); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 奇数个字符的回文子串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j = <span class=\"number\">0</span>; i - j &gt;= <span class=\"number\">0</span> &amp;&amp; i + j &lt; <span class=\"built_in\">len</span>(rs); j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> rs[i - j] != rs[i + j] &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tc = <span class=\"number\">2</span> * j + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c &gt; mx &#123;</span><br><span class=\"line\">\t\t\tmx = c</span><br><span class=\"line\">\t\t\tst = i - j + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 偶数个字符的回文子串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j = <span class=\"number\">0</span>; (i - j) &gt;= <span class=\"number\">0</span> &amp;&amp; (i + j + <span class=\"number\">1</span>) &lt; <span class=\"built_in\">len</span>(rs); j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> rs[i - j] != rs[i + j + <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tc = j * <span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c &gt; mx &#123;</span><br><span class=\"line\">\t\t\tmx = c</span><br><span class=\"line\">\t\t\tst = i - j + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">string</span>(rs[st: st + mx])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解法2：马拉车算法<br>具体思路<a href=\"https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0005.Longest-Palindromic-Substring/\">参考原文</a></p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt; y &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LongestPalindrome1</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) &lt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnews := <span class=\"built_in\">make</span>([]<span class=\"type\">rune</span>, <span class=\"built_in\">len</span>(s))</span><br><span class=\"line\">\tnews[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;#&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\tnews = <span class=\"built_in\">append</span>(news, r)</span><br><span class=\"line\">\t\tnews = <span class=\"built_in\">append</span>(news, <span class=\"string\">&#x27;#&#x27;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"built_in\">len</span>(news))</span><br><span class=\"line\">\tmx, center, maxlen, maxst := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(news); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 算法核心转移方程</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &lt; mx &#123;</span><br><span class=\"line\">\t\t\tdp[i] = min(mx - i, dp[<span class=\"number\">2</span>*center - i])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 以i为中心，只接从距离i为d[i] + 1的位置扩散</span></span><br><span class=\"line\">\t\tleft, right := i - (<span class=\"number\">1</span> + dp[i]), i + (<span class=\"number\">1</span>+ dp[i])</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> left &gt;= <span class=\"number\">0</span> &amp;&amp; right &lt; <span class=\"built_in\">len</span>(news) &amp;&amp; news[left] == news[right] &#123;</span><br><span class=\"line\">\t\t\tdp[i]++</span><br><span class=\"line\">\t\t\tleft++</span><br><span class=\"line\">\t\t\tright--</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新mx</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i + dp[i] &gt; mx &#123;</span><br><span class=\"line\">\t\t\tmx = i + dp[i]</span><br><span class=\"line\">\t\t\tcenter = i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新最大长度和对应在源字符串的起始位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> dp[i] &gt; maxlen &#123;</span><br><span class=\"line\">\t\t\tmaxlen = dp[i]</span><br><span class=\"line\">\t\t\tmaxst = (i - maxlen) / <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s[maxst : maxst + maxlen]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-字符串的全排列\"><a href=\"#1-3-字符串的全排列\" class=\"headerlink\" title=\"1.3 字符串的全排列\"></a>1.3 字符串的全排列</h2><blockquote>\n<p>问题描述：输入一个字符串，打印出该字符串中字符的所有排列。<br>例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串<br>abc、acb、bac、bca、cab 和 cba。</p>\n</blockquote>\n<p>解法1：递归方法DFS搜索，想象成树<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-21cc1e0269c2e662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs_search</span><span class=\"params\">(s <span class=\"type\">string</span>, lv <span class=\"type\">int</span>, cur <span class=\"type\">string</span>)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> lv == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, cur)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 去掉当前字符，下一层在剩下的字符中挑</span></span><br><span class=\"line\">\t\tdfs_search(s[:i] + s[i+<span class=\"number\">1</span>:], lv - <span class=\"number\">1</span>, cur + <span class=\"type\">string</span>(s[i]))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FullPermutation</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span>  &#123;</span><br><span class=\"line\">\tres = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\tdfs_search(s, <span class=\"built_in\">len</span>(s), <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解法2：字典序排列，从当前字符串s生成刚好比他大的下一个字符串排列<br><a href=\"https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/01.06.html\">参考原文</a></p>\n<ol>\n<li>找到排列中最后一个升序的位置i</li>\n<li>找到i后面最后一个比s[i]大的位置j</li>\n<li>交换s[i]和s[j]</li>\n<li>将i+1之后的字符串反转</li>\n</ol>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字典序排列算法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">next_permutation</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> (<span class=\"type\">bool</span>, <span class=\"type\">string</span>)  &#123;</span><br><span class=\"line\">\trs := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">\ti, j := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 找到最后一个升序的位置i</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i = <span class=\"built_in\">len</span>(rs) - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; rs[i] &gt;= rs[i+<span class=\"number\">1</span>]; i-- &#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>, <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 找到i后面最后一个比rs[i]大的位置j</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j = <span class=\"built_in\">len</span>(rs) - <span class=\"number\">1</span>; j &gt; i &amp;&amp; rs[j] &lt;= rs[i]; j-- &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 交换rs[i], s[j]</span></span><br><span class=\"line\">\trs[i], rs[j] = rs[j], rs[i]</span><br><span class=\"line\">\t<span class=\"comment\">// 反转rs[i+1:]</span></span><br><span class=\"line\">\trev := reverse(<span class=\"type\">string</span>(rs[i + <span class=\"number\">1</span>:]))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>, <span class=\"type\">string</span>(rs[:i+<span class=\"number\">1</span>]) + rev</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DictOrderFullPermutation</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span>  &#123;</span><br><span class=\"line\">\tres := []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ok, next_str := <span class=\"literal\">true</span>, s; ok; ok, next_str = next_permutation(next_str) &#123;</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, next_str)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据结构(2): 数组","date":"2023-03-19T13:31:25.000Z","_content":"\n## 2.1 大于n/k次的元素\n[LeetCode No.229](https://leetcode-cn.com/problems/majority-element-ii/)\n\n> 题目描述：给一个整数数组，找出所有出现次数大于n/3的元素。\nInput: nums = [3,2,3]\nOutput: [3]\n\n**摩尔投票法**： 一般情况一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/k ⌋ 次的元素。n/k的众数最多只有k - 1个，原因：假设有k个众数，则 出现次数（⌊ n/k ⌋ +1） × \\times× 众数个数 k > n。\n\n思路：此题为例 k = 3, 则最多有2个出现次数大于n/3的元素，把此情景想像成在大会中投票选出两个候选者， 则有两个候选 n1 和n2。\n- 如果投n1（当前元素等于n1），则n1的票数 c1++;\n- 如果投n2（当前元素等于n2），则n2的票数c2++;\n- 如果n1,n2都不投（即当前值与n1，n2都不相等）,那么检查此时n1或n2的票数是否为0：\n  1. 如果为0,则当前元素成为新的候选人替代掉票数为0的人；\n  2. 如果n1,n2两个人的票数都不为0，那么n1,n2两个候选人的票数均减一；\n\n最后会有这么几种可能：有2个大于n/3，有1个大于n/3，有0个大于n/3，遍历结束后选出了两个候选人，但是这两个候选人是否满足> n/3，还需要再遍历一遍数组，找出两个候选人的具体票数，因为不一定有。\n[参考原文](https://blog.csdn.net/weixin_43946031/article/details/113856373)\n\n` 示例代码：`\n```go\nfunc majorityElement(nums []int) []int {\n    v1, c1, v2, c2 := 0, 0, 0, 0\n    for _, n := range nums {\n        if n == v1 {\n            c1++\n        } else if n == v2 {\n            c2++\n        } else {\n            if c1 == 0 {\n                v1 = n\n                c1++\n            } else if c2 == 0 {\n                v2 = n\n                c2++\n            } else {\n                c1--\n                c2-- \n            }\n        }\n    }\n    r := make([]int, 0)\n    c1, c2 = 0, 0\n    for _, n := range nums {\n        if n == v1 {\n            c1++\n        }\n        if n == v2 && v2 != v1 {\n            c2++\n        }\n    }\n    if c1 > len(nums) / 3 {\n        r = append(r, v1)\n    }\n    if c2 > len(nums) / 3 {\n        r = append(r, v2)\n    }\n    return r\n}\n```\n\n## 2.2 缺失的第一个正数\n[LeetCode No.41](https://leetcode-cn.com/problems/first-missing-positive/)\n\n> 题目描述：给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。\n进阶：实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案\n\n**思路：**长度为N的整数数组，没有出现的最小正整数一定在[1, N + 1]。\n\n方法1：最容易的做法用一个额外的哈希表记录出现的数字，然后从1遍历到N+1，根据hash表如果出现缺失就返回。但是该方法空间复杂度为O(n)。\n\n`示例代码：`\n```go\nfunc firstMissingPositive(nums []int) int {\n\tm := map[int]bool{}\n\tfor _, n := range nums {\n\t\tm[n] = true\n\t}\n\tfor i := 1; i <= len(nums); i++ {\n\t\tif m[i] == false {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn len(nums) + 1\n}\n```\n\n方法2：在原数组上建哈希表，因为结果只需要判断[1, N]的数，因此可以以负数当做标记（参考LeetCode官方题解）。\n- 将数组中所有小于等于 0 的数修改为 N+1\n- 遍历每一个数x，可能已经打过标记，因此原值为|x|，如果|x|在[1, N]范围，则给数组nums[|x| - 1]元素加上负号，已加过的不能再加。\n- 遍历数组检查，如果值非负数返回i + 1，全为负数返回N+1\n\n`示例代码:`\n```go\nfunc IntAbs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n\n// 只关注正整数，用\"-\"号做标记\nfunc firstMissingPositive(nums []int) int {\n\tn := len(nums)\n\t// 预处理，将元素全部变为整数\n\tfor i, v := range nums {\n\t\tif v <= 0 {\n\t\t\tnums[i] = n + 1\n\t\t}\n\t}\n\t// 打标记\n\tfor i := 0; i < n; i++ {\n\t\tx := IntAbs(nums[i])\n\t\tif x <= n && nums[x - 1] > 0 {\n\t\t\tnums[x - 1] *= -1\n\t\t}\n\t}\n\t// 检查标记\n\tfor i := 0; i < n; i++ {\n\t\tif nums[i] > 0 {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn n + 1\n}\n```\n\n方法3：置换，将数组恢复成形如[1, 2, ... , N]的形式，即nums[i-1]=i（参考LeetCode官方题解）。\n- 设v = nums[i], 如果nums[i] == nums [v-1]，则不需要置换，否则将nums[v-1]设为v，此时要先把nums[v-1]的值保存到nums[i]，此时v-1已经是正确的位置，但是i不一定是正确的位置，需要继续置换。\n- 检查每个位置的值是否正确，全部正确返回N+1，否则返回i+1\n\n`示例代码:`\n```go\nfunc firstMissingPositive(nums []int) int {\n\tn := len(nums)\n\tfor i, v := range nums {\n\t\tfor v > 0 && v < n + 1 && nums[i] != nums[v - 1] {\n\t\t\tnums[v - 1], nums[i] = v, nums[v - 1]\n\t\t\tv = nums[i]\n\t\t}\n\t}\n\tfor i, v := range nums {\n\t\tif v != i + 1 {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn n + 1\n}\n```\n","source":"_posts/2023/03-19-数据结构-2-数组.md","raw":"---\ntitle: '数据结构(2): 数组'\ndate: 2023-03-19 21:31:25\ncategories:\n- [数据结构]\ntags:\n- 数组\n- leetcode\n---\n\n## 2.1 大于n/k次的元素\n[LeetCode No.229](https://leetcode-cn.com/problems/majority-element-ii/)\n\n> 题目描述：给一个整数数组，找出所有出现次数大于n/3的元素。\nInput: nums = [3,2,3]\nOutput: [3]\n\n**摩尔投票法**： 一般情况一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/k ⌋ 次的元素。n/k的众数最多只有k - 1个，原因：假设有k个众数，则 出现次数（⌊ n/k ⌋ +1） × \\times× 众数个数 k > n。\n\n思路：此题为例 k = 3, 则最多有2个出现次数大于n/3的元素，把此情景想像成在大会中投票选出两个候选者， 则有两个候选 n1 和n2。\n- 如果投n1（当前元素等于n1），则n1的票数 c1++;\n- 如果投n2（当前元素等于n2），则n2的票数c2++;\n- 如果n1,n2都不投（即当前值与n1，n2都不相等）,那么检查此时n1或n2的票数是否为0：\n  1. 如果为0,则当前元素成为新的候选人替代掉票数为0的人；\n  2. 如果n1,n2两个人的票数都不为0，那么n1,n2两个候选人的票数均减一；\n\n最后会有这么几种可能：有2个大于n/3，有1个大于n/3，有0个大于n/3，遍历结束后选出了两个候选人，但是这两个候选人是否满足> n/3，还需要再遍历一遍数组，找出两个候选人的具体票数，因为不一定有。\n[参考原文](https://blog.csdn.net/weixin_43946031/article/details/113856373)\n\n` 示例代码：`\n```go\nfunc majorityElement(nums []int) []int {\n    v1, c1, v2, c2 := 0, 0, 0, 0\n    for _, n := range nums {\n        if n == v1 {\n            c1++\n        } else if n == v2 {\n            c2++\n        } else {\n            if c1 == 0 {\n                v1 = n\n                c1++\n            } else if c2 == 0 {\n                v2 = n\n                c2++\n            } else {\n                c1--\n                c2-- \n            }\n        }\n    }\n    r := make([]int, 0)\n    c1, c2 = 0, 0\n    for _, n := range nums {\n        if n == v1 {\n            c1++\n        }\n        if n == v2 && v2 != v1 {\n            c2++\n        }\n    }\n    if c1 > len(nums) / 3 {\n        r = append(r, v1)\n    }\n    if c2 > len(nums) / 3 {\n        r = append(r, v2)\n    }\n    return r\n}\n```\n\n## 2.2 缺失的第一个正数\n[LeetCode No.41](https://leetcode-cn.com/problems/first-missing-positive/)\n\n> 题目描述：给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。\n进阶：实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案\n\n**思路：**长度为N的整数数组，没有出现的最小正整数一定在[1, N + 1]。\n\n方法1：最容易的做法用一个额外的哈希表记录出现的数字，然后从1遍历到N+1，根据hash表如果出现缺失就返回。但是该方法空间复杂度为O(n)。\n\n`示例代码：`\n```go\nfunc firstMissingPositive(nums []int) int {\n\tm := map[int]bool{}\n\tfor _, n := range nums {\n\t\tm[n] = true\n\t}\n\tfor i := 1; i <= len(nums); i++ {\n\t\tif m[i] == false {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn len(nums) + 1\n}\n```\n\n方法2：在原数组上建哈希表，因为结果只需要判断[1, N]的数，因此可以以负数当做标记（参考LeetCode官方题解）。\n- 将数组中所有小于等于 0 的数修改为 N+1\n- 遍历每一个数x，可能已经打过标记，因此原值为|x|，如果|x|在[1, N]范围，则给数组nums[|x| - 1]元素加上负号，已加过的不能再加。\n- 遍历数组检查，如果值非负数返回i + 1，全为负数返回N+1\n\n`示例代码:`\n```go\nfunc IntAbs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n\n// 只关注正整数，用\"-\"号做标记\nfunc firstMissingPositive(nums []int) int {\n\tn := len(nums)\n\t// 预处理，将元素全部变为整数\n\tfor i, v := range nums {\n\t\tif v <= 0 {\n\t\t\tnums[i] = n + 1\n\t\t}\n\t}\n\t// 打标记\n\tfor i := 0; i < n; i++ {\n\t\tx := IntAbs(nums[i])\n\t\tif x <= n && nums[x - 1] > 0 {\n\t\t\tnums[x - 1] *= -1\n\t\t}\n\t}\n\t// 检查标记\n\tfor i := 0; i < n; i++ {\n\t\tif nums[i] > 0 {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn n + 1\n}\n```\n\n方法3：置换，将数组恢复成形如[1, 2, ... , N]的形式，即nums[i-1]=i（参考LeetCode官方题解）。\n- 设v = nums[i], 如果nums[i] == nums [v-1]，则不需要置换，否则将nums[v-1]设为v，此时要先把nums[v-1]的值保存到nums[i]，此时v-1已经是正确的位置，但是i不一定是正确的位置，需要继续置换。\n- 检查每个位置的值是否正确，全部正确返回N+1，否则返回i+1\n\n`示例代码:`\n```go\nfunc firstMissingPositive(nums []int) int {\n\tn := len(nums)\n\tfor i, v := range nums {\n\t\tfor v > 0 && v < n + 1 && nums[i] != nums[v - 1] {\n\t\t\tnums[v - 1], nums[i] = v, nums[v - 1]\n\t\t\tv = nums[i]\n\t\t}\n\t}\n\tfor i, v := range nums {\n\t\tif v != i + 1 {\n\t\t\treturn i + 1\n\t\t}\n\t}\n\treturn n + 1\n}\n```\n","slug":"数据结构-2-数组","published":1,"updated":"2023-03-19T14:34:10.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyw20009vhfigsjb5xyh","content":"<h2 id=\"2-1-大于n-x2F-k次的元素\"><a href=\"#2-1-大于n-x2F-k次的元素\" class=\"headerlink\" title=\"2.1 大于n&#x2F;k次的元素\"></a>2.1 大于n&#x2F;k次的元素</h2><p><a href=\"https://leetcode-cn.com/problems/majority-element-ii/\">LeetCode No.229</a></p>\n<blockquote>\n<p>题目描述：给一个整数数组，找出所有出现次数大于n&#x2F;3的元素。<br>Input: nums &#x3D; [3,2,3]<br>Output: [3]</p>\n</blockquote>\n<p><strong>摩尔投票法</strong>： 一般情况一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n&#x2F;k ⌋ 次的元素。n&#x2F;k的众数最多只有k - 1个，原因：假设有k个众数，则 出现次数（⌊ n&#x2F;k ⌋ +1） × \\times× 众数个数 k &gt; n。</p>\n<p>思路：此题为例 k &#x3D; 3, 则最多有2个出现次数大于n&#x2F;3的元素，把此情景想像成在大会中投票选出两个候选者， 则有两个候选 n1 和n2。</p>\n<ul>\n<li>如果投n1（当前元素等于n1），则n1的票数 c1++;</li>\n<li>如果投n2（当前元素等于n2），则n2的票数c2++;</li>\n<li>如果n1,n2都不投（即当前值与n1，n2都不相等）,那么检查此时n1或n2的票数是否为0：<ol>\n<li>如果为0,则当前元素成为新的候选人替代掉票数为0的人；</li>\n<li>如果n1,n2两个人的票数都不为0，那么n1,n2两个候选人的票数均减一；</li>\n</ol>\n</li>\n</ul>\n<p>最后会有这么几种可能：有2个大于n&#x2F;3，有1个大于n&#x2F;3，有0个大于n&#x2F;3，遍历结束后选出了两个候选人，但是这两个候选人是否满足&gt; n&#x2F;3，还需要再遍历一遍数组，找出两个候选人的具体票数，因为不一定有。<br><a href=\"https://blog.csdn.net/weixin_43946031/article/details/113856373\">参考原文</a></p>\n<p><code> 示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">majorityElement</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    v1, c1, v2, c2 := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == v1 &#123;</span><br><span class=\"line\">            c1++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> n == v2 &#123;</span><br><span class=\"line\">            c2++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c1 == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                v1 = n</span><br><span class=\"line\">                c1++</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> c2 == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                v2 = n</span><br><span class=\"line\">                c2++</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                c1--</span><br><span class=\"line\">                c2-- </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    c1, c2 = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == v1 &#123;</span><br><span class=\"line\">            c1++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == v2 &amp;&amp; v2 != v1 &#123;</span><br><span class=\"line\">            c2++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c1 &gt; <span class=\"built_in\">len</span>(nums) / <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        r = <span class=\"built_in\">append</span>(r, v1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c2 &gt; <span class=\"built_in\">len</span>(nums) / <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        r = <span class=\"built_in\">append</span>(r, v2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-缺失的第一个正数\"><a href=\"#2-2-缺失的第一个正数\" class=\"headerlink\" title=\"2.2 缺失的第一个正数\"></a>2.2 缺失的第一个正数</h2><p><a href=\"https://leetcode-cn.com/problems/first-missing-positive/\">LeetCode No.41</a></p>\n<blockquote>\n<p>题目描述：给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<br>进阶：实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案</p>\n</blockquote>\n<p><strong>思路：</strong>长度为N的整数数组，没有出现的最小正整数一定在[1, N + 1]。</p>\n<p>方法1：最容易的做法用一个额外的哈希表记录出现的数字，然后从1遍历到N+1，根据hash表如果出现缺失就返回。但是该方法空间复杂度为O(n)。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tm := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\tm[n] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> m[i] == <span class=\"literal\">false</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(nums) + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法2：在原数组上建哈希表，因为结果只需要判断[1, N]的数，因此可以以负数当做标记（参考LeetCode官方题解）。</p>\n<ul>\n<li>将数组中所有小于等于 0 的数修改为 N+1</li>\n<li>遍历每一个数x，可能已经打过标记，因此原值为|x|，如果|x|在[1, N]范围，则给数组nums[|x| - 1]元素加上负号，已加过的不能再加。</li>\n<li>遍历数组检查，如果值非负数返回i + 1，全为负数返回N+1</li>\n</ul>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IntAbs</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只关注正整数，用&quot;-&quot;号做标记</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">\t<span class=\"comment\">// 预处理，将元素全部变为整数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tnums[i] = n + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 打标记</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\tx := IntAbs(nums[i])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> x &lt;= n &amp;&amp; nums[x - <span class=\"number\">1</span>] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tnums[x - <span class=\"number\">1</span>] *= <span class=\"number\">-1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 检查标记</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[i] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法3：置换，将数组恢复成形如[1, 2, … , N]的形式，即nums[i-1]&#x3D;i（参考LeetCode官方题解）。</p>\n<ul>\n<li>设v &#x3D; nums[i], 如果nums[i] &#x3D;&#x3D; nums [v-1]，则不需要置换，否则将nums[v-1]设为v，此时要先把nums[v-1]的值保存到nums[i]，此时v-1已经是正确的位置，但是i不一定是正确的位置，需要继续置换。</li>\n<li>检查每个位置的值是否正确，全部正确返回N+1，否则返回i+1</li>\n</ul>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> v &gt; <span class=\"number\">0</span> &amp;&amp; v &lt; n + <span class=\"number\">1</span> &amp;&amp; nums[i] != nums[v - <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\tnums[v - <span class=\"number\">1</span>], nums[i] = v, nums[v - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\tv = nums[i]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v != i + <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"2-1-大于n-x2F-k次的元素\"><a href=\"#2-1-大于n-x2F-k次的元素\" class=\"headerlink\" title=\"2.1 大于n&#x2F;k次的元素\"></a>2.1 大于n&#x2F;k次的元素</h2><p><a href=\"https://leetcode-cn.com/problems/majority-element-ii/\">LeetCode No.229</a></p>\n<blockquote>\n<p>题目描述：给一个整数数组，找出所有出现次数大于n&#x2F;3的元素。<br>Input: nums &#x3D; [3,2,3]<br>Output: [3]</p>\n</blockquote>\n<p><strong>摩尔投票法</strong>： 一般情况一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n&#x2F;k ⌋ 次的元素。n&#x2F;k的众数最多只有k - 1个，原因：假设有k个众数，则 出现次数（⌊ n&#x2F;k ⌋ +1） × \\times× 众数个数 k &gt; n。</p>\n<p>思路：此题为例 k &#x3D; 3, 则最多有2个出现次数大于n&#x2F;3的元素，把此情景想像成在大会中投票选出两个候选者， 则有两个候选 n1 和n2。</p>\n<ul>\n<li>如果投n1（当前元素等于n1），则n1的票数 c1++;</li>\n<li>如果投n2（当前元素等于n2），则n2的票数c2++;</li>\n<li>如果n1,n2都不投（即当前值与n1，n2都不相等）,那么检查此时n1或n2的票数是否为0：<ol>\n<li>如果为0,则当前元素成为新的候选人替代掉票数为0的人；</li>\n<li>如果n1,n2两个人的票数都不为0，那么n1,n2两个候选人的票数均减一；</li>\n</ol>\n</li>\n</ul>\n<p>最后会有这么几种可能：有2个大于n&#x2F;3，有1个大于n&#x2F;3，有0个大于n&#x2F;3，遍历结束后选出了两个候选人，但是这两个候选人是否满足&gt; n&#x2F;3，还需要再遍历一遍数组，找出两个候选人的具体票数，因为不一定有。<br><a href=\"https://blog.csdn.net/weixin_43946031/article/details/113856373\">参考原文</a></p>\n<p><code> 示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">majorityElement</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    v1, c1, v2, c2 := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == v1 &#123;</span><br><span class=\"line\">            c1++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> n == v2 &#123;</span><br><span class=\"line\">            c2++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c1 == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                v1 = n</span><br><span class=\"line\">                c1++</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> c2 == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                v2 = n</span><br><span class=\"line\">                c2++</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                c1--</span><br><span class=\"line\">                c2-- </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    c1, c2 = <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == v1 &#123;</span><br><span class=\"line\">            c1++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n == v2 &amp;&amp; v2 != v1 &#123;</span><br><span class=\"line\">            c2++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c1 &gt; <span class=\"built_in\">len</span>(nums) / <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        r = <span class=\"built_in\">append</span>(r, v1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> c2 &gt; <span class=\"built_in\">len</span>(nums) / <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        r = <span class=\"built_in\">append</span>(r, v2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-缺失的第一个正数\"><a href=\"#2-2-缺失的第一个正数\" class=\"headerlink\" title=\"2.2 缺失的第一个正数\"></a>2.2 缺失的第一个正数</h2><p><a href=\"https://leetcode-cn.com/problems/first-missing-positive/\">LeetCode No.41</a></p>\n<blockquote>\n<p>题目描述：给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<br>进阶：实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案</p>\n</blockquote>\n<p><strong>思路：</strong>长度为N的整数数组，没有出现的最小正整数一定在[1, N + 1]。</p>\n<p>方法1：最容易的做法用一个额外的哈希表记录出现的数字，然后从1遍历到N+1，根据hash表如果出现缺失就返回。但是该方法空间复杂度为O(n)。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tm := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\tm[n] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> m[i] == <span class=\"literal\">false</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(nums) + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法2：在原数组上建哈希表，因为结果只需要判断[1, N]的数，因此可以以负数当做标记（参考LeetCode官方题解）。</p>\n<ul>\n<li>将数组中所有小于等于 0 的数修改为 N+1</li>\n<li>遍历每一个数x，可能已经打过标记，因此原值为|x|，如果|x|在[1, N]范围，则给数组nums[|x| - 1]元素加上负号，已加过的不能再加。</li>\n<li>遍历数组检查，如果值非负数返回i + 1，全为负数返回N+1</li>\n</ul>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IntAbs</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> -x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只关注正整数，用&quot;-&quot;号做标记</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">\t<span class=\"comment\">// 预处理，将元素全部变为整数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tnums[i] = n + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 打标记</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\tx := IntAbs(nums[i])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> x &lt;= n &amp;&amp; nums[x - <span class=\"number\">1</span>] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tnums[x - <span class=\"number\">1</span>] *= <span class=\"number\">-1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 检查标记</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[i] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法3：置换，将数组恢复成形如[1, 2, … , N]的形式，即nums[i-1]&#x3D;i（参考LeetCode官方题解）。</p>\n<ul>\n<li>设v &#x3D; nums[i], 如果nums[i] &#x3D;&#x3D; nums [v-1]，则不需要置换，否则将nums[v-1]设为v，此时要先把nums[v-1]的值保存到nums[i]，此时v-1已经是正确的位置，但是i不一定是正确的位置，需要继续置换。</li>\n<li>检查每个位置的值是否正确，全部正确返回N+1，否则返回i+1</li>\n</ul>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstMissingPositive</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> v &gt; <span class=\"number\">0</span> &amp;&amp; v &lt; n + <span class=\"number\">1</span> &amp;&amp; nums[i] != nums[v - <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\tnums[v - <span class=\"number\">1</span>], nums[i] = v, nums[v - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\tv = nums[i]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v != i + <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据结构(4): 树","date":"2023-03-19T13:36:55.000Z","_content":"\n### 4.1 根据前序与中序序列构造二叉树\n[LeetCode No.105](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n> 问题描述：根据一棵树的前序遍历与中序遍历构造二叉树。\n\n**思路**：根据二叉树的前序和中序（或后序和中序）的序列可唯一构造一棵二叉树，必须要有中序。前序遍历的第一个为根节点，找到根节点在中序中的位置，中序左边的节点都是根节点的左子树，右边的同理，然后可以用递归的方式求解。\n\n`示例代码：`\n```go\ntype TreeNode struct {\n  Val int\n  Left *TreeNode\n  Right *TreeNode\n}\n\nfunc index(nums []int, val int) int {\n\tfor i, v := range nums {\n\t\tif v == val {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\n\tif len(preorder) == 0 || len(inorder) == 0 {\n\t\treturn nil\n\t}\n\tif len(preorder) == 1 || len(inorder) == 1 {\n\t\treturn &TreeNode{\n\t\t\tVal: preorder[0],\n\t\t\tLeft: nil,\n\t\t\tRight: nil,\n\t\t}\n\t}\n\tval := preorder[0]\n\tpos := index(inorder, val)\n\troot := &TreeNode{\n\t\tVal: val,\n\t\tLeft: buildTree(preorder[1 : pos + 1], inorder[ : pos]),\n\t\tRight: buildTree(preorder[pos + 1 : ], inorder[pos + 1:]),\n\t}\n\treturn root\n}\n```\n","source":"_posts/2023/03-19-数据结构-4-树.md","raw":"---\ntitle: '数据结构(4): 树'\ndate: 2023-03-19 21:36:55\ncategories:\n- [数据结构]\ntags:\n- 树\n- 二叉树\n- leetcode\n---\n\n### 4.1 根据前序与中序序列构造二叉树\n[LeetCode No.105](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n> 问题描述：根据一棵树的前序遍历与中序遍历构造二叉树。\n\n**思路**：根据二叉树的前序和中序（或后序和中序）的序列可唯一构造一棵二叉树，必须要有中序。前序遍历的第一个为根节点，找到根节点在中序中的位置，中序左边的节点都是根节点的左子树，右边的同理，然后可以用递归的方式求解。\n\n`示例代码：`\n```go\ntype TreeNode struct {\n  Val int\n  Left *TreeNode\n  Right *TreeNode\n}\n\nfunc index(nums []int, val int) int {\n\tfor i, v := range nums {\n\t\tif v == val {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\n\tif len(preorder) == 0 || len(inorder) == 0 {\n\t\treturn nil\n\t}\n\tif len(preorder) == 1 || len(inorder) == 1 {\n\t\treturn &TreeNode{\n\t\t\tVal: preorder[0],\n\t\t\tLeft: nil,\n\t\t\tRight: nil,\n\t\t}\n\t}\n\tval := preorder[0]\n\tpos := index(inorder, val)\n\troot := &TreeNode{\n\t\tVal: val,\n\t\tLeft: buildTree(preorder[1 : pos + 1], inorder[ : pos]),\n\t\tRight: buildTree(preorder[pos + 1 : ], inorder[pos + 1:]),\n\t}\n\treturn root\n}\n```\n","slug":"数据结构-4-树","published":1,"updated":"2023-03-19T14:11:44.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyw3000avhfi6jf35wo8","content":"<h3 id=\"4-1-根据前序与中序序列构造二叉树\"><a href=\"#4-1-根据前序与中序序列构造二叉树\" class=\"headerlink\" title=\"4.1 根据前序与中序序列构造二叉树\"></a>4.1 根据前序与中序序列构造二叉树</h3><p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\">LeetCode No.105</a></p>\n<blockquote>\n<p>问题描述：根据一棵树的前序遍历与中序遍历构造二叉树。</p>\n</blockquote>\n<p><strong>思路</strong>：根据二叉树的前序和中序（或后序和中序）的序列可唯一构造一棵二叉树，必须要有中序。前序遍历的第一个为根节点，找到根节点在中序中的位置，中序左边的节点都是根节点的左子树，右边的同理，然后可以用递归的方式求解。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Val <span class=\"type\">int</span></span><br><span class=\"line\">  Left *TreeNode</span><br><span class=\"line\">  Right *TreeNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">index</span><span class=\"params\">(nums []<span class=\"type\">int</span>, val <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v == val &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildTree</span><span class=\"params\">(preorder []<span class=\"type\">int</span>, inorder []<span class=\"type\">int</span>)</span></span> *TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(preorder) == <span class=\"number\">0</span> || <span class=\"built_in\">len</span>(inorder) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(preorder) == <span class=\"number\">1</span> || <span class=\"built_in\">len</span>(inorder) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;TreeNode&#123;</span><br><span class=\"line\">\t\t\tVal: preorder[<span class=\"number\">0</span>],</span><br><span class=\"line\">\t\t\tLeft: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t\t\tRight: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tval := preorder[<span class=\"number\">0</span>]</span><br><span class=\"line\">\tpos := index(inorder, val)</span><br><span class=\"line\">\troot := &amp;TreeNode&#123;</span><br><span class=\"line\">\t\tVal: val,</span><br><span class=\"line\">\t\tLeft: buildTree(preorder[<span class=\"number\">1</span> : pos + <span class=\"number\">1</span>], inorder[ : pos]),</span><br><span class=\"line\">\t\tRight: buildTree(preorder[pos + <span class=\"number\">1</span> : ], inorder[pos + <span class=\"number\">1</span>:]),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"4-1-根据前序与中序序列构造二叉树\"><a href=\"#4-1-根据前序与中序序列构造二叉树\" class=\"headerlink\" title=\"4.1 根据前序与中序序列构造二叉树\"></a>4.1 根据前序与中序序列构造二叉树</h3><p><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\">LeetCode No.105</a></p>\n<blockquote>\n<p>问题描述：根据一棵树的前序遍历与中序遍历构造二叉树。</p>\n</blockquote>\n<p><strong>思路</strong>：根据二叉树的前序和中序（或后序和中序）的序列可唯一构造一棵二叉树，必须要有中序。前序遍历的第一个为根节点，找到根节点在中序中的位置，中序左边的节点都是根节点的左子树，右边的同理，然后可以用递归的方式求解。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Val <span class=\"type\">int</span></span><br><span class=\"line\">  Left *TreeNode</span><br><span class=\"line\">  Right *TreeNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">index</span><span class=\"params\">(nums []<span class=\"type\">int</span>, val <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v == val &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildTree</span><span class=\"params\">(preorder []<span class=\"type\">int</span>, inorder []<span class=\"type\">int</span>)</span></span> *TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(preorder) == <span class=\"number\">0</span> || <span class=\"built_in\">len</span>(inorder) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(preorder) == <span class=\"number\">1</span> || <span class=\"built_in\">len</span>(inorder) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;TreeNode&#123;</span><br><span class=\"line\">\t\t\tVal: preorder[<span class=\"number\">0</span>],</span><br><span class=\"line\">\t\t\tLeft: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t\t\tRight: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tval := preorder[<span class=\"number\">0</span>]</span><br><span class=\"line\">\tpos := index(inorder, val)</span><br><span class=\"line\">\troot := &amp;TreeNode&#123;</span><br><span class=\"line\">\t\tVal: val,</span><br><span class=\"line\">\t\tLeft: buildTree(preorder[<span class=\"number\">1</span> : pos + <span class=\"number\">1</span>], inorder[ : pos]),</span><br><span class=\"line\">\t\tRight: buildTree(preorder[pos + <span class=\"number\">1</span> : ], inorder[pos + <span class=\"number\">1</span>:]),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据结构(5): 栈|队列|堆","date":"2023-03-19T13:39:14.000Z","_content":"\n## 6.1 栈\n### 6.1.1用两个栈实现一个队列\n[LeetCode No.232](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n> 题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：\n\n**思路：** 两个栈一个栈做队头（出元素），另一个栈做队尾（入元素）\n- 每次push只需要push到尾栈\n- pop时如果头栈为空则将尾栈全部“倒入”头栈，如果头栈不为空取出栈顶元素返回，否则返回失败（此时队列为空）。\n\n`示例代码：`\n```go\ntype MyQueue struct {\n\tstack_head []int\n\tstack_tail []int\n}\n\n\n/** Initialize your data structure here. */\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tstack_head: make([]int, 0),\n\t\tstack_tail: make([]int, 0),\n\t}\n}\n\n\n/** Push element x to the back of queue. */\nfunc (this *MyQueue) Push(x int)  {\n\tthis.stack_tail = append(this.stack_tail, x)\n}\n\nfunc(this *MyQueue) tail2head()  {\n\tfor i := len(this.stack_tail) - 1; i >= 0; i-- {\n\t\tthis.stack_head = append(this.stack_head, this.stack_tail[i])\n\t\tthis.stack_tail = this.stack_tail[:len(this.stack_tail) - 1]\n\t}\n}\n\n/** Removes the element from in front of queue and returns that element. */\nfunc (this *MyQueue) Pop() int {\n\tif len(this.stack_head) == 0 {\n\t\tthis.tail2head()\n\t}\n\tif len(this.stack_head) > 0 {\n\t\tr := this.stack_head[len(this.stack_head) - 1]\n\t\tthis.stack_head = this.stack_head[:len(this.stack_head) - 1]\n\t\treturn r\n\t}\n\treturn -1\n}\n\n\n/** Get the front element. */\nfunc (this *MyQueue) Peek() int {\n\tif len(this.stack_head) == 0 {\n\t\tthis.tail2head()\n\t}\n\tif len(this.stack_head) > 0 {\n\t\treturn this.stack_head[len(this.stack_head) - 1]\n\t}\n\treturn -1\n}\n\n\n/** Returns whether the queue is empty. */\nfunc (this *MyQueue) Empty() bool {\n\treturn len(this.stack_head) == 0 && len(this.stack_tail) == 0\n}\n```\n\n### 6.1.2 逆波兰表达式求值\n[LeetCode No.150](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)\n> 问题描述：根据[ 逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437)，求表达式的值。\n有效的运算符包括 `+`, `-`, `*`, `/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n输入: [\"2\", \"1\", \"+\", \"3\", \"*\"]\n输出: 9\n解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n\n**思路**：借助一个栈，如果是数值就入栈，如果是运算符就从栈顶取出两个元素计算，然后将结果入栈，最后栈中只剩一个元素就是结果。\n\n`示例代码：`\n```go\nfunc operate(x, y int, op string) int {\n\tswitch op {\n\tcase \"+\": return x + y\n\tcase \"-\": return x - y\n\tcase \"*\": return x * y\n\tcase \"/\": return x / y\n\tdefault:\n\t\treturn 0\n\t}\n}\n\nfunc evalRPN(tokens []string) int {\n\tstack := []int{}\n\tfor i := 0; i < len(tokens); i++ {\n\t\tswitch tokens[i] {\n\t\tcase \"+\", \"-\", \"*\", \"/\":\n\t\t\tcur := operate(stack[len(stack) - 2], stack[len(stack) - 1], tokens[i])\n\t\t\tstack = stack[:len(stack) - 1]\n\t\t\tstack[len(stack) - 1] = cur\n\t\tdefault:\n\t\t\tnum, _ := strconv.Atoi(tokens[i])\n\t\t\tstack = append(stack, num)\n\t\t}\n\t}\n\treturn stack[0]\n}\n```\n\n### 6.1.3 中缀表达式生成逆波兰表达式\n- 借助一个符号栈和结果队列，具体过程见代码注释\n\n`示例代码：`\n```go\nfunc is_operation(b byte) bool {\n\treturn b == '+' || b == '-' || b == '*' || b == '/'\n}\n\nfunc compare_priority(a, b byte) int {\n\tif (a == '+' || a == '-') && (b == '*' || b == '/') {\n\t\treturn -1\n\t} else if (b == '+' || b == '-') && (a == '*' || a == '/') {\n\t\treturn 1\n\t} else {\n\t\treturn 0\n\t}\n}\n\nfunc toRPN(s string) []string {\n\t// 运算符栈\n\tops_stack := []byte{}\n\t// 结果队列\n\tres_queue := []string{}\n\tn := len(s)\n\tfor i := 0; i < n; i++ {\n\t\tif s[i] == '(' {\n\t\t\t// 遇到左括号直接入栈\n\t\t\tops_stack = append(ops_stack, s[i])\n\t\t} else if s[i] == ')' {\n\t\t\t// 遇到右括号，则将栈中的运算符依次弹出加入到结果队列，直到碰到左括号，然后将这对括号丢弃\n\t\t\tfor ops_stack[len(ops_stack) - 1] != '(' {\n\t\t\t\tres_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1]))\n\t\t\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t\t\t}\n\t\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t\t} else if is_operation(s[i]) {\n\t\t\t// 遇到运算符，当前运算符的优先级小于等于栈顶运算符的优先级，则依次将栈顶弹出加入到结果队列\n\t\t\tfor len(ops_stack) > 0 && is_operation(ops_stack[len(ops_stack) - 1]) &&\n\t\t\t\tcompare_priority(s[i], ops_stack[len(ops_stack) - 1]) <= 0 {\n\t\t\t\tres_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1]))\n\t\t\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t\t\t}\n\t\t\tops_stack = append(ops_stack, s[i])\n\t\t} else if s[i] == ' ' {\n\t\t\t// 跳过空字符\n\t\t\tcontinue\n\t\t} else {\n\t\t\t// 遇到数字加入到结果队列\n\t\t\tnum := 0\n\t\t\tfor ; i < n && s[i] >= '0' && s[i] <= '9'; i++ {\n\t\t\t\tnum = num * 10 + int(s[i] - '0')\n\t\t\t}\n\t\t\ti--\n\t\t\tres_queue = append(res_queue, strconv.Itoa(num))\n\t\t}\n\t}\n\t// 运算符栈中剩余的元素弹出添加到结果队列\n\tfor len(ops_stack) > 0 {\n\t\tres_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1]))\n\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t}\n\treturn res_queue\n}\n```\n\n## 6.2 堆\n**定义：**最大堆的堆顶为最大元素，最小堆同理\n### 6.2.1 Golang实现堆类型\n因为go本身没有实现堆类型，只提供了接口，使用时必须实现堆接口才能使用对应的堆方法，所以自己用golang的container/heap接口实现一个通用的堆类型，创建堆需要一个比较函数作为参数\n`实现代码：`\n```go\n// 比较函数类型\ntype Comparator func(a, b interface{}) bool\n// 堆元素类型\ntype Elements struct {\n\tes   []interface{}\n\tcmp Comparator\n}\n// 堆类型\ntype Heap struct {\n\telements *Elements\n}\n\n// 创建堆\nfunc NewHeap(cmp Comparator) *Heap {\n\treturn &Heap{\n\t\telements: &Elements{\n\t\t\tes: make([]interface{}, 0),\n\t\t\tcmp: cmp,\n\t\t},\n\t}\n}\n\n// 堆元素实现了container/heap接口\nfunc (e Elements) Len() int { return len(e.es) }\nfunc (e Elements) Less(i, j int) bool { return e.cmp(e.es[i], e.es[j]) }\nfunc (e Elements) Swap(i, j int)      { e.es[i], e.es[j] = e.es[j], e.es[i] }\n\nfunc (e *Elements) Push(item interface{}) { e.es = append(e.es, item) }\nfunc (e *Elements) Pop() interface{} {\n\tlength := len(e.es)\n\tif length == 0 {\n\t\treturn nil\n\t}\n\ttop := e.es[length - 1]\n\te.es = e.es[:length - 1]\n\treturn top\n}\n\n// 入堆\nfunc (h *Heap) Push(i interface{}) {\n\theap.Push(h.elements, i)\n}\n\n// 堆顶元素出堆\nfunc (h *Heap) Pop() interface{} {\n\treturn heap.Pop(h.elements)\n}\n\n// 查看堆顶元素\nfunc (h Heap) Top() interface{} {\n\tif len(h.elements.es) == 0 {\n\t\treturn nil\n\t}\n\treturn h.elements.es[0]\n}\n\n// 获取堆大小\nfunc (h Heap) Len() int  {\n\treturn h.elements.Len()\n}\n\nfunc CompareInt(a, b interface{}) bool {\n\tif a.(int) > b.(int) {\n\t\treturn true\n\t}\n\treturn false\n}\n```\n### 6.2.2 数组中的第K个最大元素\n[LeetCode No.215](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\n> 问题描述：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n\n**思路**：使用最小堆，首先将前k个元素加入堆作为目前的最大的k个元素，然后遍历剩下的n-k个元素，如果堆顶元素比当前元素小，取出堆顶，将当前元素加入堆。最后堆顶的元素即为第k大的元素。\n**时间复杂度**：O(n*log(n))\n**空间复杂度**：O(k)\n\n`示例代码：`\n```go\nfunc findKthLargest(nums []int, k int) int {\n\theap1:= NewHeap(CompareInt)\n\t// 前k个元素建立大小为k的小顶堆\n\tfor i := 0; i < k; i++ {\n\t\theap1.Push(nums[i])\n\t}\n\t// 遍历剩余的元素更新堆\n\tfor i := k; i < len(nums); i++ {\n\t\ttop := heap1.Top().(int)\n\t\tif top > nums[i] {\n\t\t\theap1.Pop()\n\t\t\theap1.Push(nums[i])\n\t\t}\n\t}\n\treturn heap1.Top().(int)\n}\n```\n","source":"_posts/2023/03-19-数据结构-5-栈-队列-堆.md","raw":"---\ntitle: '数据结构(5): 栈|队列|堆'\ndate: 2023-03-19 21:39:14\ncategories:\n- [数据结构]\ntags:\n- 栈\n- 队列\n- 堆\n- leetcode\n---\n\n## 6.1 栈\n### 6.1.1用两个栈实现一个队列\n[LeetCode No.232](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n> 题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：\n\n**思路：** 两个栈一个栈做队头（出元素），另一个栈做队尾（入元素）\n- 每次push只需要push到尾栈\n- pop时如果头栈为空则将尾栈全部“倒入”头栈，如果头栈不为空取出栈顶元素返回，否则返回失败（此时队列为空）。\n\n`示例代码：`\n```go\ntype MyQueue struct {\n\tstack_head []int\n\tstack_tail []int\n}\n\n\n/** Initialize your data structure here. */\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tstack_head: make([]int, 0),\n\t\tstack_tail: make([]int, 0),\n\t}\n}\n\n\n/** Push element x to the back of queue. */\nfunc (this *MyQueue) Push(x int)  {\n\tthis.stack_tail = append(this.stack_tail, x)\n}\n\nfunc(this *MyQueue) tail2head()  {\n\tfor i := len(this.stack_tail) - 1; i >= 0; i-- {\n\t\tthis.stack_head = append(this.stack_head, this.stack_tail[i])\n\t\tthis.stack_tail = this.stack_tail[:len(this.stack_tail) - 1]\n\t}\n}\n\n/** Removes the element from in front of queue and returns that element. */\nfunc (this *MyQueue) Pop() int {\n\tif len(this.stack_head) == 0 {\n\t\tthis.tail2head()\n\t}\n\tif len(this.stack_head) > 0 {\n\t\tr := this.stack_head[len(this.stack_head) - 1]\n\t\tthis.stack_head = this.stack_head[:len(this.stack_head) - 1]\n\t\treturn r\n\t}\n\treturn -1\n}\n\n\n/** Get the front element. */\nfunc (this *MyQueue) Peek() int {\n\tif len(this.stack_head) == 0 {\n\t\tthis.tail2head()\n\t}\n\tif len(this.stack_head) > 0 {\n\t\treturn this.stack_head[len(this.stack_head) - 1]\n\t}\n\treturn -1\n}\n\n\n/** Returns whether the queue is empty. */\nfunc (this *MyQueue) Empty() bool {\n\treturn len(this.stack_head) == 0 && len(this.stack_tail) == 0\n}\n```\n\n### 6.1.2 逆波兰表达式求值\n[LeetCode No.150](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)\n> 问题描述：根据[ 逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437)，求表达式的值。\n有效的运算符包括 `+`, `-`, `*`, `/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n输入: [\"2\", \"1\", \"+\", \"3\", \"*\"]\n输出: 9\n解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n\n**思路**：借助一个栈，如果是数值就入栈，如果是运算符就从栈顶取出两个元素计算，然后将结果入栈，最后栈中只剩一个元素就是结果。\n\n`示例代码：`\n```go\nfunc operate(x, y int, op string) int {\n\tswitch op {\n\tcase \"+\": return x + y\n\tcase \"-\": return x - y\n\tcase \"*\": return x * y\n\tcase \"/\": return x / y\n\tdefault:\n\t\treturn 0\n\t}\n}\n\nfunc evalRPN(tokens []string) int {\n\tstack := []int{}\n\tfor i := 0; i < len(tokens); i++ {\n\t\tswitch tokens[i] {\n\t\tcase \"+\", \"-\", \"*\", \"/\":\n\t\t\tcur := operate(stack[len(stack) - 2], stack[len(stack) - 1], tokens[i])\n\t\t\tstack = stack[:len(stack) - 1]\n\t\t\tstack[len(stack) - 1] = cur\n\t\tdefault:\n\t\t\tnum, _ := strconv.Atoi(tokens[i])\n\t\t\tstack = append(stack, num)\n\t\t}\n\t}\n\treturn stack[0]\n}\n```\n\n### 6.1.3 中缀表达式生成逆波兰表达式\n- 借助一个符号栈和结果队列，具体过程见代码注释\n\n`示例代码：`\n```go\nfunc is_operation(b byte) bool {\n\treturn b == '+' || b == '-' || b == '*' || b == '/'\n}\n\nfunc compare_priority(a, b byte) int {\n\tif (a == '+' || a == '-') && (b == '*' || b == '/') {\n\t\treturn -1\n\t} else if (b == '+' || b == '-') && (a == '*' || a == '/') {\n\t\treturn 1\n\t} else {\n\t\treturn 0\n\t}\n}\n\nfunc toRPN(s string) []string {\n\t// 运算符栈\n\tops_stack := []byte{}\n\t// 结果队列\n\tres_queue := []string{}\n\tn := len(s)\n\tfor i := 0; i < n; i++ {\n\t\tif s[i] == '(' {\n\t\t\t// 遇到左括号直接入栈\n\t\t\tops_stack = append(ops_stack, s[i])\n\t\t} else if s[i] == ')' {\n\t\t\t// 遇到右括号，则将栈中的运算符依次弹出加入到结果队列，直到碰到左括号，然后将这对括号丢弃\n\t\t\tfor ops_stack[len(ops_stack) - 1] != '(' {\n\t\t\t\tres_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1]))\n\t\t\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t\t\t}\n\t\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t\t} else if is_operation(s[i]) {\n\t\t\t// 遇到运算符，当前运算符的优先级小于等于栈顶运算符的优先级，则依次将栈顶弹出加入到结果队列\n\t\t\tfor len(ops_stack) > 0 && is_operation(ops_stack[len(ops_stack) - 1]) &&\n\t\t\t\tcompare_priority(s[i], ops_stack[len(ops_stack) - 1]) <= 0 {\n\t\t\t\tres_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1]))\n\t\t\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t\t\t}\n\t\t\tops_stack = append(ops_stack, s[i])\n\t\t} else if s[i] == ' ' {\n\t\t\t// 跳过空字符\n\t\t\tcontinue\n\t\t} else {\n\t\t\t// 遇到数字加入到结果队列\n\t\t\tnum := 0\n\t\t\tfor ; i < n && s[i] >= '0' && s[i] <= '9'; i++ {\n\t\t\t\tnum = num * 10 + int(s[i] - '0')\n\t\t\t}\n\t\t\ti--\n\t\t\tres_queue = append(res_queue, strconv.Itoa(num))\n\t\t}\n\t}\n\t// 运算符栈中剩余的元素弹出添加到结果队列\n\tfor len(ops_stack) > 0 {\n\t\tres_queue = append(res_queue, string(ops_stack[len(ops_stack) - 1]))\n\t\tops_stack = ops_stack[:len(ops_stack) - 1]\n\t}\n\treturn res_queue\n}\n```\n\n## 6.2 堆\n**定义：**最大堆的堆顶为最大元素，最小堆同理\n### 6.2.1 Golang实现堆类型\n因为go本身没有实现堆类型，只提供了接口，使用时必须实现堆接口才能使用对应的堆方法，所以自己用golang的container/heap接口实现一个通用的堆类型，创建堆需要一个比较函数作为参数\n`实现代码：`\n```go\n// 比较函数类型\ntype Comparator func(a, b interface{}) bool\n// 堆元素类型\ntype Elements struct {\n\tes   []interface{}\n\tcmp Comparator\n}\n// 堆类型\ntype Heap struct {\n\telements *Elements\n}\n\n// 创建堆\nfunc NewHeap(cmp Comparator) *Heap {\n\treturn &Heap{\n\t\telements: &Elements{\n\t\t\tes: make([]interface{}, 0),\n\t\t\tcmp: cmp,\n\t\t},\n\t}\n}\n\n// 堆元素实现了container/heap接口\nfunc (e Elements) Len() int { return len(e.es) }\nfunc (e Elements) Less(i, j int) bool { return e.cmp(e.es[i], e.es[j]) }\nfunc (e Elements) Swap(i, j int)      { e.es[i], e.es[j] = e.es[j], e.es[i] }\n\nfunc (e *Elements) Push(item interface{}) { e.es = append(e.es, item) }\nfunc (e *Elements) Pop() interface{} {\n\tlength := len(e.es)\n\tif length == 0 {\n\t\treturn nil\n\t}\n\ttop := e.es[length - 1]\n\te.es = e.es[:length - 1]\n\treturn top\n}\n\n// 入堆\nfunc (h *Heap) Push(i interface{}) {\n\theap.Push(h.elements, i)\n}\n\n// 堆顶元素出堆\nfunc (h *Heap) Pop() interface{} {\n\treturn heap.Pop(h.elements)\n}\n\n// 查看堆顶元素\nfunc (h Heap) Top() interface{} {\n\tif len(h.elements.es) == 0 {\n\t\treturn nil\n\t}\n\treturn h.elements.es[0]\n}\n\n// 获取堆大小\nfunc (h Heap) Len() int  {\n\treturn h.elements.Len()\n}\n\nfunc CompareInt(a, b interface{}) bool {\n\tif a.(int) > b.(int) {\n\t\treturn true\n\t}\n\treturn false\n}\n```\n### 6.2.2 数组中的第K个最大元素\n[LeetCode No.215](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\n> 问题描述：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n\n**思路**：使用最小堆，首先将前k个元素加入堆作为目前的最大的k个元素，然后遍历剩下的n-k个元素，如果堆顶元素比当前元素小，取出堆顶，将当前元素加入堆。最后堆顶的元素即为第k大的元素。\n**时间复杂度**：O(n*log(n))\n**空间复杂度**：O(k)\n\n`示例代码：`\n```go\nfunc findKthLargest(nums []int, k int) int {\n\theap1:= NewHeap(CompareInt)\n\t// 前k个元素建立大小为k的小顶堆\n\tfor i := 0; i < k; i++ {\n\t\theap1.Push(nums[i])\n\t}\n\t// 遍历剩余的元素更新堆\n\tfor i := k; i < len(nums); i++ {\n\t\ttop := heap1.Top().(int)\n\t\tif top > nums[i] {\n\t\t\theap1.Pop()\n\t\t\theap1.Push(nums[i])\n\t\t}\n\t}\n\treturn heap1.Top().(int)\n}\n```\n","slug":"数据结构-5-栈-队列-堆","published":1,"updated":"2023-03-19T14:11:42.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyw5000dvhfi3o1p9czu","content":"<h2 id=\"6-1-栈\"><a href=\"#6-1-栈\" class=\"headerlink\" title=\"6.1 栈\"></a>6.1 栈</h2><h3 id=\"6-1-1用两个栈实现一个队列\"><a href=\"#6-1-1用两个栈实现一个队列\" class=\"headerlink\" title=\"6.1.1用两个栈实现一个队列\"></a>6.1.1用两个栈实现一个队列</h3><p><a href=\"https://leetcode-cn.com/problems/implement-queue-using-stacks/\">LeetCode No.232</a></p>\n<blockquote>\n<p>题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：</p>\n</blockquote>\n<p><strong>思路：</strong> 两个栈一个栈做队头（出元素），另一个栈做队尾（入元素）</p>\n<ul>\n<li>每次push只需要push到尾栈</li>\n<li>pop时如果头栈为空则将尾栈全部“倒入”头栈，如果头栈不为空取出栈顶元素返回，否则返回失败（此时队列为空）。</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tstack_head []<span class=\"type\">int</span></span><br><span class=\"line\">\tstack_tail []<span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">()</span></span> MyQueue &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MyQueue&#123;</span><br><span class=\"line\">\t\tstack_head: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">\t\tstack_tail: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Push element x to the back of queue. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Push(x <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">\tthis.stack_tail = <span class=\"built_in\">append</span>(this.stack_tail, x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(this *MyQueue)</span></span> tail2head()  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"built_in\">len</span>(this.stack_tail) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\tthis.stack_head = <span class=\"built_in\">append</span>(this.stack_head, this.stack_tail[i])</span><br><span class=\"line\">\t\tthis.stack_tail = this.stack_tail[:<span class=\"built_in\">len</span>(this.stack_tail) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Pop() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthis.tail2head()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tr := this.stack_head[<span class=\"built_in\">len</span>(this.stack_head) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\tthis.stack_head = this.stack_head[:<span class=\"built_in\">len</span>(this.stack_head) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Get the front element. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Peek() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthis.tail2head()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> this.stack_head[<span class=\"built_in\">len</span>(this.stack_head) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Returns whether the queue is empty. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Empty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(this.stack_head) == <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">len</span>(this.stack_tail) == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-1-2-逆波兰表达式求值\"><a href=\"#6-1-2-逆波兰表达式求值\" class=\"headerlink\" title=\"6.1.2 逆波兰表达式求值\"></a>6.1.2 逆波兰表达式求值</h3><p><a href=\"https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/\">LeetCode No.150</a></p>\n<blockquote>\n<p>问题描述：根据<a href=\"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437\"> 逆波兰表示法</a>，求表达式的值。<br>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>输入: [“2”, “1”, “+”, “3”, “*”]<br>输出: 9<br>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</p>\n</blockquote>\n<p><strong>思路</strong>：借助一个栈，如果是数值就入栈，如果是运算符就从栈顶取出两个元素计算，然后将结果入栈，最后栈中只剩一个元素就是结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">operate</span><span class=\"params\">(x, y <span class=\"type\">int</span>, op <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> op &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>: <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>: <span class=\"keyword\">return</span> x - y</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>: <span class=\"keyword\">return</span> x * y</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>: <span class=\"keyword\">return</span> x / y</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">evalRPN</span><span class=\"params\">(tokens []<span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tstack := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(tokens); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> tokens[i] &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>, <span class=\"string\">&quot;-&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">\t\t\tcur := operate(stack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">2</span>], stack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>], tokens[i])</span><br><span class=\"line\">\t\t\tstack = stack[:<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\tstack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>] = cur</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tnum, _ := strconv.Atoi(tokens[i])</span><br><span class=\"line\">\t\t\tstack = <span class=\"built_in\">append</span>(stack, num)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stack[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-1-3-中缀表达式生成逆波兰表达式\"><a href=\"#6-1-3-中缀表达式生成逆波兰表达式\" class=\"headerlink\" title=\"6.1.3 中缀表达式生成逆波兰表达式\"></a>6.1.3 中缀表达式生成逆波兰表达式</h3><ul>\n<li>借助一个符号栈和结果队列，具体过程见代码注释</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">is_operation</span><span class=\"params\">(b <span class=\"type\">byte</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b == <span class=\"string\">&#x27;+&#x27;</span> || b == <span class=\"string\">&#x27;-&#x27;</span> || b == <span class=\"string\">&#x27;*&#x27;</span> || b == <span class=\"string\">&#x27;/&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compare_priority</span><span class=\"params\">(a, b <span class=\"type\">byte</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a == <span class=\"string\">&#x27;+&#x27;</span> || a == <span class=\"string\">&#x27;-&#x27;</span>) &amp;&amp; (b == <span class=\"string\">&#x27;*&#x27;</span> || b == <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (b == <span class=\"string\">&#x27;+&#x27;</span> || b == <span class=\"string\">&#x27;-&#x27;</span>) &amp;&amp; (a == <span class=\"string\">&#x27;*&#x27;</span> || a == <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toRPN</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 运算符栈</span></span><br><span class=\"line\">\tops_stack := []<span class=\"type\">byte</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 结果队列</span></span><br><span class=\"line\">\tres_queue := []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s[i] == <span class=\"string\">&#x27;(&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到左括号直接入栈</span></span><br><span class=\"line\">\t\t\tops_stack = <span class=\"built_in\">append</span>(ops_stack, s[i])</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> s[i] == <span class=\"string\">&#x27;)&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到右括号，则将栈中的运算符依次弹出加入到结果队列，直到碰到左括号，然后将这对括号丢弃</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;(&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, <span class=\"type\">string</span>(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]))</span><br><span class=\"line\">\t\t\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> is_operation(s[i]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到运算符，当前运算符的优先级小于等于栈顶运算符的优先级，则依次将栈顶弹出加入到结果队列</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(ops_stack) &gt; <span class=\"number\">0</span> &amp;&amp; is_operation(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]) &amp;&amp;</span><br><span class=\"line\">\t\t\t\tcompare_priority(s[i], ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]) &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, <span class=\"type\">string</span>(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]))</span><br><span class=\"line\">\t\t\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tops_stack = <span class=\"built_in\">append</span>(ops_stack, s[i])</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> s[i] == <span class=\"string\">&#x27; &#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 跳过空字符</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到数字加入到结果队列</span></span><br><span class=\"line\">\t\t\tnum := <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ; i &lt; n &amp;&amp; s[i] &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class=\"string\">&#x27;9&#x27;</span>; i++ &#123;</span><br><span class=\"line\">\t\t\t\tnum = num * <span class=\"number\">10</span> + <span class=\"type\">int</span>(s[i] - <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\ti--</span><br><span class=\"line\">\t\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, strconv.Itoa(num))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 运算符栈中剩余的元素弹出添加到结果队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(ops_stack) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, <span class=\"type\">string</span>(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]))</span><br><span class=\"line\">\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res_queue</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-2-堆\"><a href=\"#6-2-堆\" class=\"headerlink\" title=\"6.2 堆\"></a>6.2 堆</h2><p><strong>定义：</strong>最大堆的堆顶为最大元素，最小堆同理</p>\n<h3 id=\"6-2-1-Golang实现堆类型\"><a href=\"#6-2-1-Golang实现堆类型\" class=\"headerlink\" title=\"6.2.1 Golang实现堆类型\"></a>6.2.1 Golang实现堆类型</h3><p>因为go本身没有实现堆类型，只提供了接口，使用时必须实现堆接口才能使用对应的堆方法，所以自己用golang的container&#x2F;heap接口实现一个通用的堆类型，创建堆需要一个比较函数作为参数<br><code>实现代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较函数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Comparator <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(a, b <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"comment\">// 堆元素类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Elements <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tes   []<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\tcmp Comparator</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 堆类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Heap <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\telements *Elements</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewHeap</span><span class=\"params\">(cmp Comparator)</span></span> *Heap &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Heap&#123;</span><br><span class=\"line\">\t\telements: &amp;Elements&#123;</span><br><span class=\"line\">\t\t\tes: <span class=\"built_in\">make</span>([]<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"number\">0</span>),</span><br><span class=\"line\">\t\t\tcmp: cmp,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆元素实现了container/heap接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Elements)</span></span> Len() <span class=\"type\">int</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(e.es) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Elements)</span></span> Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123; <span class=\"keyword\">return</span> e.cmp(e.es[i], e.es[j]) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Elements)</span></span> Swap(i, j <span class=\"type\">int</span>)      &#123; e.es[i], e.es[j] = e.es[j], e.es[i] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Elements)</span></span> Push(item <span class=\"keyword\">interface</span>&#123;&#125;) &#123; e.es = <span class=\"built_in\">append</span>(e.es, item) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Elements)</span></span> Pop() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\tlength := <span class=\"built_in\">len</span>(e.es)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> length == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttop := e.es[length - <span class=\"number\">1</span>]</span><br><span class=\"line\">\te.es = e.es[:length - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> top</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> Push(i <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\theap.Push(h.elements, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆顶元素出堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> Pop() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> heap.Pop(h.elements)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看堆顶元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h Heap)</span></span> Top() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(h.elements.es) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h.elements.es[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取堆大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h Heap)</span></span> Len() <span class=\"type\">int</span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h.elements.Len()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CompareInt</span><span class=\"params\">(a, b <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a.(<span class=\"type\">int</span>) &gt; b.(<span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-2-数组中的第K个最大元素\"><a href=\"#6-2-2-数组中的第K个最大元素\" class=\"headerlink\" title=\"6.2.2 数组中的第K个最大元素\"></a>6.2.2 数组中的第K个最大元素</h3><p><a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\">LeetCode No.215</a></p>\n<blockquote>\n<p>问题描述：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素<br>输入: [3,2,1,5,6,4] 和 k &#x3D; 2<br>输出: 5</p>\n</blockquote>\n<p><strong>思路</strong>：使用最小堆，首先将前k个元素加入堆作为目前的最大的k个元素，然后遍历剩下的n-k个元素，如果堆顶元素比当前元素小，取出堆顶，将当前元素加入堆。最后堆顶的元素即为第k大的元素。<br><strong>时间复杂度</strong>：O(n*log(n))<br><strong>空间复杂度</strong>：O(k)</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(nums []<span class=\"type\">int</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\theap1:= NewHeap(CompareInt)</span><br><span class=\"line\">\t<span class=\"comment\">// 前k个元素建立大小为k的小顶堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; k; i++ &#123;</span><br><span class=\"line\">\t\theap1.Push(nums[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 遍历剩余的元素更新堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := k; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">\t\ttop := heap1.Top().(<span class=\"type\">int</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> top &gt; nums[i] &#123;</span><br><span class=\"line\">\t\t\theap1.Pop()</span><br><span class=\"line\">\t\t\theap1.Push(nums[i])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> heap1.Top().(<span class=\"type\">int</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"6-1-栈\"><a href=\"#6-1-栈\" class=\"headerlink\" title=\"6.1 栈\"></a>6.1 栈</h2><h3 id=\"6-1-1用两个栈实现一个队列\"><a href=\"#6-1-1用两个栈实现一个队列\" class=\"headerlink\" title=\"6.1.1用两个栈实现一个队列\"></a>6.1.1用两个栈实现一个队列</h3><p><a href=\"https://leetcode-cn.com/problems/implement-queue-using-stacks/\">LeetCode No.232</a></p>\n<blockquote>\n<p>题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（push、pop、peek、empty）：</p>\n</blockquote>\n<p><strong>思路：</strong> 两个栈一个栈做队头（出元素），另一个栈做队尾（入元素）</p>\n<ul>\n<li>每次push只需要push到尾栈</li>\n<li>pop时如果头栈为空则将尾栈全部“倒入”头栈，如果头栈不为空取出栈顶元素返回，否则返回失败（此时队列为空）。</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tstack_head []<span class=\"type\">int</span></span><br><span class=\"line\">\tstack_tail []<span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">()</span></span> MyQueue &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MyQueue&#123;</span><br><span class=\"line\">\t\tstack_head: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">\t\tstack_tail: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Push element x to the back of queue. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Push(x <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">\tthis.stack_tail = <span class=\"built_in\">append</span>(this.stack_tail, x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(this *MyQueue)</span></span> tail2head()  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"built_in\">len</span>(this.stack_tail) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\tthis.stack_head = <span class=\"built_in\">append</span>(this.stack_head, this.stack_tail[i])</span><br><span class=\"line\">\t\tthis.stack_tail = this.stack_tail[:<span class=\"built_in\">len</span>(this.stack_tail) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Pop() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthis.tail2head()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tr := this.stack_head[<span class=\"built_in\">len</span>(this.stack_head) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\tthis.stack_head = this.stack_head[:<span class=\"built_in\">len</span>(this.stack_head) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> r</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Get the front element. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Peek() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tthis.tail2head()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.stack_head) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> this.stack_head[<span class=\"built_in\">len</span>(this.stack_head) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Returns whether the queue is empty. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span></span> Empty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(this.stack_head) == <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">len</span>(this.stack_tail) == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-1-2-逆波兰表达式求值\"><a href=\"#6-1-2-逆波兰表达式求值\" class=\"headerlink\" title=\"6.1.2 逆波兰表达式求值\"></a>6.1.2 逆波兰表达式求值</h3><p><a href=\"https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/\">LeetCode No.150</a></p>\n<blockquote>\n<p>问题描述：根据<a href=\"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437\"> 逆波兰表示法</a>，求表达式的值。<br>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>输入: [“2”, “1”, “+”, “3”, “*”]<br>输出: 9<br>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</p>\n</blockquote>\n<p><strong>思路</strong>：借助一个栈，如果是数值就入栈，如果是运算符就从栈顶取出两个元素计算，然后将结果入栈，最后栈中只剩一个元素就是结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">operate</span><span class=\"params\">(x, y <span class=\"type\">int</span>, op <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> op &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>: <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>: <span class=\"keyword\">return</span> x - y</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>: <span class=\"keyword\">return</span> x * y</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>: <span class=\"keyword\">return</span> x / y</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">evalRPN</span><span class=\"params\">(tokens []<span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tstack := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(tokens); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> tokens[i] &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>, <span class=\"string\">&quot;-&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">\t\t\tcur := operate(stack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">2</span>], stack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>], tokens[i])</span><br><span class=\"line\">\t\t\tstack = stack[:<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\tstack[<span class=\"built_in\">len</span>(stack) - <span class=\"number\">1</span>] = cur</span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tnum, _ := strconv.Atoi(tokens[i])</span><br><span class=\"line\">\t\t\tstack = <span class=\"built_in\">append</span>(stack, num)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> stack[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-1-3-中缀表达式生成逆波兰表达式\"><a href=\"#6-1-3-中缀表达式生成逆波兰表达式\" class=\"headerlink\" title=\"6.1.3 中缀表达式生成逆波兰表达式\"></a>6.1.3 中缀表达式生成逆波兰表达式</h3><ul>\n<li>借助一个符号栈和结果队列，具体过程见代码注释</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">is_operation</span><span class=\"params\">(b <span class=\"type\">byte</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b == <span class=\"string\">&#x27;+&#x27;</span> || b == <span class=\"string\">&#x27;-&#x27;</span> || b == <span class=\"string\">&#x27;*&#x27;</span> || b == <span class=\"string\">&#x27;/&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compare_priority</span><span class=\"params\">(a, b <span class=\"type\">byte</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a == <span class=\"string\">&#x27;+&#x27;</span> || a == <span class=\"string\">&#x27;-&#x27;</span>) &amp;&amp; (b == <span class=\"string\">&#x27;*&#x27;</span> || b == <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (b == <span class=\"string\">&#x27;+&#x27;</span> || b == <span class=\"string\">&#x27;-&#x27;</span>) &amp;&amp; (a == <span class=\"string\">&#x27;*&#x27;</span> || a == <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toRPN</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 运算符栈</span></span><br><span class=\"line\">\tops_stack := []<span class=\"type\">byte</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 结果队列</span></span><br><span class=\"line\">\tres_queue := []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s[i] == <span class=\"string\">&#x27;(&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到左括号直接入栈</span></span><br><span class=\"line\">\t\t\tops_stack = <span class=\"built_in\">append</span>(ops_stack, s[i])</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> s[i] == <span class=\"string\">&#x27;)&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到右括号，则将栈中的运算符依次弹出加入到结果队列，直到碰到左括号，然后将这对括号丢弃</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;(&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, <span class=\"type\">string</span>(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]))</span><br><span class=\"line\">\t\t\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> is_operation(s[i]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到运算符，当前运算符的优先级小于等于栈顶运算符的优先级，则依次将栈顶弹出加入到结果队列</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(ops_stack) &gt; <span class=\"number\">0</span> &amp;&amp; is_operation(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]) &amp;&amp;</span><br><span class=\"line\">\t\t\t\tcompare_priority(s[i], ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]) &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, <span class=\"type\">string</span>(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]))</span><br><span class=\"line\">\t\t\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tops_stack = <span class=\"built_in\">append</span>(ops_stack, s[i])</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> s[i] == <span class=\"string\">&#x27; &#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 跳过空字符</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遇到数字加入到结果队列</span></span><br><span class=\"line\">\t\t\tnum := <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ; i &lt; n &amp;&amp; s[i] &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class=\"string\">&#x27;9&#x27;</span>; i++ &#123;</span><br><span class=\"line\">\t\t\t\tnum = num * <span class=\"number\">10</span> + <span class=\"type\">int</span>(s[i] - <span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\ti--</span><br><span class=\"line\">\t\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, strconv.Itoa(num))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 运算符栈中剩余的元素弹出添加到结果队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(ops_stack) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tres_queue = <span class=\"built_in\">append</span>(res_queue, <span class=\"type\">string</span>(ops_stack[<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]))</span><br><span class=\"line\">\t\tops_stack = ops_stack[:<span class=\"built_in\">len</span>(ops_stack) - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res_queue</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-2-堆\"><a href=\"#6-2-堆\" class=\"headerlink\" title=\"6.2 堆\"></a>6.2 堆</h2><p><strong>定义：</strong>最大堆的堆顶为最大元素，最小堆同理</p>\n<h3 id=\"6-2-1-Golang实现堆类型\"><a href=\"#6-2-1-Golang实现堆类型\" class=\"headerlink\" title=\"6.2.1 Golang实现堆类型\"></a>6.2.1 Golang实现堆类型</h3><p>因为go本身没有实现堆类型，只提供了接口，使用时必须实现堆接口才能使用对应的堆方法，所以自己用golang的container&#x2F;heap接口实现一个通用的堆类型，创建堆需要一个比较函数作为参数<br><code>实现代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较函数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Comparator <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(a, b <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span></span><br><span class=\"line\"><span class=\"comment\">// 堆元素类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Elements <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tes   []<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\tcmp Comparator</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 堆类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Heap <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\telements *Elements</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewHeap</span><span class=\"params\">(cmp Comparator)</span></span> *Heap &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Heap&#123;</span><br><span class=\"line\">\t\telements: &amp;Elements&#123;</span><br><span class=\"line\">\t\t\tes: <span class=\"built_in\">make</span>([]<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"number\">0</span>),</span><br><span class=\"line\">\t\t\tcmp: cmp,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆元素实现了container/heap接口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Elements)</span></span> Len() <span class=\"type\">int</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(e.es) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Elements)</span></span> Less(i, j <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123; <span class=\"keyword\">return</span> e.cmp(e.es[i], e.es[j]) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e Elements)</span></span> Swap(i, j <span class=\"type\">int</span>)      &#123; e.es[i], e.es[j] = e.es[j], e.es[i] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Elements)</span></span> Push(item <span class=\"keyword\">interface</span>&#123;&#125;) &#123; e.es = <span class=\"built_in\">append</span>(e.es, item) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Elements)</span></span> Pop() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\tlength := <span class=\"built_in\">len</span>(e.es)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> length == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttop := e.es[length - <span class=\"number\">1</span>]</span><br><span class=\"line\">\te.es = e.es[:length - <span class=\"number\">1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> top</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> Push(i <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\theap.Push(h.elements, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 堆顶元素出堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> Pop() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> heap.Pop(h.elements)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看堆顶元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h Heap)</span></span> Top() <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(h.elements.es) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h.elements.es[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取堆大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h Heap)</span></span> Len() <span class=\"type\">int</span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h.elements.Len()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CompareInt</span><span class=\"params\">(a, b <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a.(<span class=\"type\">int</span>) &gt; b.(<span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-2-数组中的第K个最大元素\"><a href=\"#6-2-2-数组中的第K个最大元素\" class=\"headerlink\" title=\"6.2.2 数组中的第K个最大元素\"></a>6.2.2 数组中的第K个最大元素</h3><p><a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\">LeetCode No.215</a></p>\n<blockquote>\n<p>问题描述：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素<br>输入: [3,2,1,5,6,4] 和 k &#x3D; 2<br>输出: 5</p>\n</blockquote>\n<p><strong>思路</strong>：使用最小堆，首先将前k个元素加入堆作为目前的最大的k个元素，然后遍历剩下的n-k个元素，如果堆顶元素比当前元素小，取出堆顶，将当前元素加入堆。最后堆顶的元素即为第k大的元素。<br><strong>时间复杂度</strong>：O(n*log(n))<br><strong>空间复杂度</strong>：O(k)</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findKthLargest</span><span class=\"params\">(nums []<span class=\"type\">int</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\theap1:= NewHeap(CompareInt)</span><br><span class=\"line\">\t<span class=\"comment\">// 前k个元素建立大小为k的小顶堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; k; i++ &#123;</span><br><span class=\"line\">\t\theap1.Push(nums[i])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 遍历剩余的元素更新堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := k; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">\t\ttop := heap1.Top().(<span class=\"type\">int</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> top &gt; nums[i] &#123;</span><br><span class=\"line\">\t\t\theap1.Pop()</span><br><span class=\"line\">\t\t\theap1.Push(nums[i])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> heap1.Top().(<span class=\"type\">int</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据结构(3): 链表","date":"2023-03-19T13:35:07.000Z","_content":"\n## 3.1 删除单向链表倒数第n个节点\n[LeetCode No.19](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)\n\n> 问题描述：删除单向链表倒数第n个节点（只遍历一次）\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\n**思路**：两个指针，p1先走n步，然后p1和p2再一起走，当p1到链表结尾，p2就是要删除的节点。注意处理可能删除的是头结点（n=length）或者不需要删除（n>length）的情况。\n**可以通过增加一个虚拟的头节点，避免对头节点的特殊处理。**\n\n`示例代码`\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    p1, p2 := head, head\n    i := 0\n    for ; i < n && p1 != nil ; i++ {\n        p1 = p1.Next\n    }\n    if p1 == nil {\n        if i < n {\n            // 不需要删除\n            return head\n        } else {\n            // 删除头节点\n            return head.Next\n        }\n    }\n    for p1.Next != nil {\n        p1 = p1.Next\n        p2 = p2.Next\n    }\n    t := p2.Next\n    if t != nil {\n        p2.Next = t.Next\n    }\n    return head\n}\n```\n\n## 3.2 K个一组翻转链表\n[LeetCode No.25](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\n\n> 题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n进阶：\n你可以设计一个只使用常数额外空间的算法来解决此问题吗？\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n\n**思路：** 先遍历一遍求出链表长度n，则需要翻转n/k组。使用一个虚拟头节点保存结果，每一轮翻转完将尾节保存，下一轮翻转结束后将上一轮的为节点的Next节点指向当前轮的头结点。\n\n`示例代码：`\n```go\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    n := 0\n    for p := head; p != nil; p = p.Next {\n        n++\n    }\n    reshead := &ListNode{}\n    var lasttail *ListNode\n    for i, p := 0, head; i <= n/k; i++ {\n        if i == n / k {\n            lasttail.Next = p\n            break\n        }\n        curhead, curtail := p, p\n        for j := 0; j < k; j++ {\n            tmp := p\n            p = p.Next\n            tmp.Next = curhead\n            curhead = tmp\n        }\n        if i == 0 {\n            reshead.Next = curhead\n        } else {\n            lasttail.Next = curhead\n        }\n        lasttail = curtail\n    }\n    return reshead.Next\n}\n```\n","source":"_posts/2023/03-19-数据结构-3-链表.md","raw":"---\ntitle: '数据结构(3): 链表'\ndate: 2023-03-19 21:35:07\ncategories:\n- [数据结构]\ntags:\n- 链表\n- leetcode\n---\n\n## 3.1 删除单向链表倒数第n个节点\n[LeetCode No.19](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)\n\n> 问题描述：删除单向链表倒数第n个节点（只遍历一次）\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\n**思路**：两个指针，p1先走n步，然后p1和p2再一起走，当p1到链表结尾，p2就是要删除的节点。注意处理可能删除的是头结点（n=length）或者不需要删除（n>length）的情况。\n**可以通过增加一个虚拟的头节点，避免对头节点的特殊处理。**\n\n`示例代码`\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode {\n    p1, p2 := head, head\n    i := 0\n    for ; i < n && p1 != nil ; i++ {\n        p1 = p1.Next\n    }\n    if p1 == nil {\n        if i < n {\n            // 不需要删除\n            return head\n        } else {\n            // 删除头节点\n            return head.Next\n        }\n    }\n    for p1.Next != nil {\n        p1 = p1.Next\n        p2 = p2.Next\n    }\n    t := p2.Next\n    if t != nil {\n        p2.Next = t.Next\n    }\n    return head\n}\n```\n\n## 3.2 K个一组翻转链表\n[LeetCode No.25](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)\n\n> 题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n进阶：\n你可以设计一个只使用常数额外空间的算法来解决此问题吗？\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n\n**思路：** 先遍历一遍求出链表长度n，则需要翻转n/k组。使用一个虚拟头节点保存结果，每一轮翻转完将尾节保存，下一轮翻转结束后将上一轮的为节点的Next节点指向当前轮的头结点。\n\n`示例代码：`\n```go\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    n := 0\n    for p := head; p != nil; p = p.Next {\n        n++\n    }\n    reshead := &ListNode{}\n    var lasttail *ListNode\n    for i, p := 0, head; i <= n/k; i++ {\n        if i == n / k {\n            lasttail.Next = p\n            break\n        }\n        curhead, curtail := p, p\n        for j := 0; j < k; j++ {\n            tmp := p\n            p = p.Next\n            tmp.Next = curhead\n            curhead = tmp\n        }\n        if i == 0 {\n            reshead.Next = curhead\n        } else {\n            lasttail.Next = curhead\n        }\n        lasttail = curtail\n    }\n    return reshead.Next\n}\n```\n","slug":"数据结构-3-链表","published":1,"updated":"2023-03-19T14:11:46.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyw6000evhfic6jv0khl","content":"<h2 id=\"3-1-删除单向链表倒数第n个节点\"><a href=\"#3-1-删除单向链表倒数第n个节点\" class=\"headerlink\" title=\"3.1 删除单向链表倒数第n个节点\"></a>3.1 删除单向链表倒数第n个节点</h2><p><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\">LeetCode No.19</a></p>\n<blockquote>\n<p>问题描述：删除单向链表倒数第n个节点（只遍历一次）<br>Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>Output: [1,2,3,5]</p>\n</blockquote>\n<p><strong>思路</strong>：两个指针，p1先走n步，然后p1和p2再一起走，当p1到链表结尾，p2就是要删除的节点。注意处理可能删除的是头结点（n&#x3D;length）或者不需要删除（n&gt;length）的情况。<br><strong>可以通过增加一个虚拟的头节点，避免对头节点的特殊处理。</strong></p>\n<p><code>示例代码</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(head *ListNode, n <span class=\"type\">int</span>)</span></span> *ListNode &#123;</span><br><span class=\"line\">    p1, p2 := head, head</span><br><span class=\"line\">    i := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ; i &lt; n &amp;&amp; p1 != <span class=\"literal\">nil</span> ; i++ &#123;</span><br><span class=\"line\">        p1 = p1.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> p1 == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; n &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不需要删除</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 删除头节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head.Next</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p1.Next != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        p1 = p1.Next</span><br><span class=\"line\">        p2 = p2.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    t := p2.Next</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        p2.Next = t.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-K个一组翻转链表\"><a href=\"#3-2-K个一组翻转链表\" class=\"headerlink\" title=\"3.2 K个一组翻转链表\"></a>3.2 K个一组翻转链表</h2><p><a href=\"https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\">LeetCode No.25</a></p>\n<blockquote>\n<p>题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>进阶：<br>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>\n</blockquote>\n<p><strong>思路：</strong> 先遍历一遍求出链表长度n，则需要翻转n&#x2F;k组。使用一个虚拟头节点保存结果，每一轮翻转完将尾节保存，下一轮翻转结束后将上一轮的为节点的Next节点指向当前轮的头结点。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(head *ListNode, k <span class=\"type\">int</span>)</span></span> *ListNode &#123;</span><br><span class=\"line\">    n := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> p := head; p != <span class=\"literal\">nil</span>; p = p.Next &#123;</span><br><span class=\"line\">        n++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reshead := &amp;ListNode&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lasttail *ListNode</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, p := <span class=\"number\">0</span>, head; i &lt;= n/k; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == n / k &#123;</span><br><span class=\"line\">            lasttail.Next = p</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        curhead, curtail := p, p</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; k; j++ &#123;</span><br><span class=\"line\">            tmp := p</span><br><span class=\"line\">            p = p.Next</span><br><span class=\"line\">            tmp.Next = curhead</span><br><span class=\"line\">            curhead = tmp</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            reshead.Next = curhead</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            lasttail.Next = curhead</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lasttail = curtail</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reshead.Next</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"3-1-删除单向链表倒数第n个节点\"><a href=\"#3-1-删除单向链表倒数第n个节点\" class=\"headerlink\" title=\"3.1 删除单向链表倒数第n个节点\"></a>3.1 删除单向链表倒数第n个节点</h2><p><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\">LeetCode No.19</a></p>\n<blockquote>\n<p>问题描述：删除单向链表倒数第n个节点（只遍历一次）<br>Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>Output: [1,2,3,5]</p>\n</blockquote>\n<p><strong>思路</strong>：两个指针，p1先走n步，然后p1和p2再一起走，当p1到链表结尾，p2就是要删除的节点。注意处理可能删除的是头结点（n&#x3D;length）或者不需要删除（n&gt;length）的情况。<br><strong>可以通过增加一个虚拟的头节点，避免对头节点的特殊处理。</strong></p>\n<p><code>示例代码</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(head *ListNode, n <span class=\"type\">int</span>)</span></span> *ListNode &#123;</span><br><span class=\"line\">    p1, p2 := head, head</span><br><span class=\"line\">    i := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> ; i &lt; n &amp;&amp; p1 != <span class=\"literal\">nil</span> ; i++ &#123;</span><br><span class=\"line\">        p1 = p1.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> p1 == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; n &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不需要删除</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 删除头节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head.Next</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p1.Next != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        p1 = p1.Next</span><br><span class=\"line\">        p2 = p2.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    t := p2.Next</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        p2.Next = t.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-K个一组翻转链表\"><a href=\"#3-2-K个一组翻转链表\" class=\"headerlink\" title=\"3.2 K个一组翻转链表\"></a>3.2 K个一组翻转链表</h2><p><a href=\"https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\">LeetCode No.25</a></p>\n<blockquote>\n<p>题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>进阶：<br>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>\n</blockquote>\n<p><strong>思路：</strong> 先遍历一遍求出链表长度n，则需要翻转n&#x2F;k组。使用一个虚拟头节点保存结果，每一轮翻转完将尾节保存，下一轮翻转结束后将上一轮的为节点的Next节点指向当前轮的头结点。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(head *ListNode, k <span class=\"type\">int</span>)</span></span> *ListNode &#123;</span><br><span class=\"line\">    n := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> p := head; p != <span class=\"literal\">nil</span>; p = p.Next &#123;</span><br><span class=\"line\">        n++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reshead := &amp;ListNode&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lasttail *ListNode</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, p := <span class=\"number\">0</span>, head; i &lt;= n/k; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == n / k &#123;</span><br><span class=\"line\">            lasttail.Next = p</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        curhead, curtail := p, p</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; k; j++ &#123;</span><br><span class=\"line\">            tmp := p</span><br><span class=\"line\">            p = p.Next</span><br><span class=\"line\">            tmp.Next = curhead</span><br><span class=\"line\">            curhead = tmp</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            reshead.Next = curhead</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            lasttail.Next = curhead</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lasttail = curtail</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reshead.Next</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(1): 双指针","date":"2023-03-19T13:41:00.000Z","_content":"\n双指针通常用在有序数组，链表的数据结构上，根据题目条件移动对应的指针。比如判断子串、链表是否有环的问题。\n\n## 1.1 最长子串\n[LeetCode No.524](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)\n\n> 题目描述：给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串\n输入:\ns = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]\n输出: \n\"apple\"\n\n**思路：本题主要思路是要将删除s中某些字符后和target匹配转化为判断是target是否为s的子串**\n**判断是否为子串：**使用双指针，如果当前字符相等，两个指针同时+1，否则只有母字符串的指针+1，最后判断目标字符传的指针是否等于其长度即可。\n[参考原文](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md)\n\n`示例代码：`\n```go\nfunc is_substr(s, target string) bool {\n\tj := 0\n\tfor i := 0; i < len(s) && j < len(target); i++ {\n\t\tif s[i] == target[j] {\n\t\t\tj++\n\t\t}\n\t}\n\treturn j == len(target)\n}\n\nfunc findLongestWord(s string, dictionary []string) string {\n\tvar longest string\n\tfor _, cur := range dictionary {\n\t\t// 如果当前字符串是s的子串，当当前字符串长度大于目前结果 或 长度相等但是当前串字典序排在前面时更新目前结果\n\t\tif is_substr(s, cur) && (len(cur) > len(longest) || len(cur) == len(longest) && cur < longest) {\n\t\t\tlongest = cur\n\t\t}\n\t}\n\treturn longest\n}\n```\n\n## 1.2 两数之和\n[LeetCode No.167](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)\n\n> 题目描述：给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。\n输入：numbers = [2,7,11,15], target = 9\n输出：[1,2]\n\n**思路：**因为输入数组有序，那么可以用左右两个指针，初始位于两端，判断当前两数和如果大于target，那么right指针减一，如果小于target，left加一，如果等于就返回。\n\n`示例代码:`\n```go\nfunc twoSum(numbers []int, target int) []int {\n    for left, right := 0, len(numbers) - 1; left < right; {\n        cur := numbers[left] + numbers[right]\n        if cur == target {\n            return []int{left+1, right+1}\n        }\n        if cur < target {\n            left++\n        } else {\n            right--\n        }\n    }\n    return []int{}\n}\n```\n\n## 1.3 判断链表是否存在环\n[LeetCode No.141](https://leetcode-cn.com/problems/linked-list-cycle/description/)\n\n> 题目描述：给定一个链表，判断链表中是否有环。\n\n**思路：**经典解法使用快慢指针，如果存在环两个指针一定会相遇，注意指针空的判断，避免出现野指针。\n\n`示例代码：`\n```go\nfunc hasCycle(head *ListNode) bool {\n\tif head == nil || head.Next == nil {\n\t\treturn false\n\t}\n\tfaster, slower := head.Next.Next, head.Next\n\tfor faster != nil && faster.Next != nil && slower != nil {\n\t\tif faster == slower {\n\t\t\treturn true\n\t\t}\n\t\tfaster = faster.Next.Next\n\t\tslower = slower.Next\n\t}\n\treturn false\n}\n```\n\n## 1.4 接雨水\n[LeetCode No.42](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n> 题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n**思路：**当前柱子能接的雨水数为其左右最高的柱子的较小值减当前柱子的高度\n\n方法1：先求出每个柱子i左边的最大高度left_max[i]，右边最大高度right_max[i]，然后遍历一次计算。时间复杂度T = O(3n)\n\n`示例代码：`\n```go\nfunc trap(height []int) int {\n    res, n := 0, len(height)\n    if n == 0 {\n        return res\n    }\n    left_max, right_max := make([]int, n), make([]int, n)\n    left_max[0], right_max[n - 1] = height[0], height[n - 1]\n    for i := 1; i < n; i++ {\n        left_max[i] = max(left_max[i - 1], height[i])\n    }\n    for i := n - 2; i >= 0; i-- {\n        right_max[i] = max(right_max[i + 1], height[i])\n    }\n    for i := 0; i < n; i++ {\n        res += min(right_max[i], left_max[i]) - height[i]\n    }\n    return res\n}\n```\n\n方法2：只需遍历一次的双指针解法，两个指针最终在最高点相遇。\n\n`示例代码：`\n```go\nfunc trap(height []int) int {\n    res, left, right := 0, 0, len(height) - 1\n    if right < 0 {\n        return res\n    }\n    left_max, right_max := 0, 0\n    for left < right {\n        if height[left] > height[right] {\n            right_max = max(right_max, height[right])\n            res += right_max - height[right]\n            right--\n        } else {\n            left_max = max(left_max, height[left])\n            res += left_max - height[left]\n            left++\n        }\n    }\n    return res\n}\n```\n","source":"_posts/2023/03-19-算法-1-双指针.md","raw":"---\ntitle: '算法(1): 双指针'\ndate: 2023-03-19 21:41:00\ncategories:\n- [算法]\ntags:\n- leetcode\n---\n\n双指针通常用在有序数组，链表的数据结构上，根据题目条件移动对应的指针。比如判断子串、链表是否有环的问题。\n\n## 1.1 最长子串\n[LeetCode No.524](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)\n\n> 题目描述：给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串\n输入:\ns = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]\n输出: \n\"apple\"\n\n**思路：本题主要思路是要将删除s中某些字符后和target匹配转化为判断是target是否为s的子串**\n**判断是否为子串：**使用双指针，如果当前字符相等，两个指针同时+1，否则只有母字符串的指针+1，最后判断目标字符传的指针是否等于其长度即可。\n[参考原文](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md)\n\n`示例代码：`\n```go\nfunc is_substr(s, target string) bool {\n\tj := 0\n\tfor i := 0; i < len(s) && j < len(target); i++ {\n\t\tif s[i] == target[j] {\n\t\t\tj++\n\t\t}\n\t}\n\treturn j == len(target)\n}\n\nfunc findLongestWord(s string, dictionary []string) string {\n\tvar longest string\n\tfor _, cur := range dictionary {\n\t\t// 如果当前字符串是s的子串，当当前字符串长度大于目前结果 或 长度相等但是当前串字典序排在前面时更新目前结果\n\t\tif is_substr(s, cur) && (len(cur) > len(longest) || len(cur) == len(longest) && cur < longest) {\n\t\t\tlongest = cur\n\t\t}\n\t}\n\treturn longest\n}\n```\n\n## 1.2 两数之和\n[LeetCode No.167](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)\n\n> 题目描述：给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。\n输入：numbers = [2,7,11,15], target = 9\n输出：[1,2]\n\n**思路：**因为输入数组有序，那么可以用左右两个指针，初始位于两端，判断当前两数和如果大于target，那么right指针减一，如果小于target，left加一，如果等于就返回。\n\n`示例代码:`\n```go\nfunc twoSum(numbers []int, target int) []int {\n    for left, right := 0, len(numbers) - 1; left < right; {\n        cur := numbers[left] + numbers[right]\n        if cur == target {\n            return []int{left+1, right+1}\n        }\n        if cur < target {\n            left++\n        } else {\n            right--\n        }\n    }\n    return []int{}\n}\n```\n\n## 1.3 判断链表是否存在环\n[LeetCode No.141](https://leetcode-cn.com/problems/linked-list-cycle/description/)\n\n> 题目描述：给定一个链表，判断链表中是否有环。\n\n**思路：**经典解法使用快慢指针，如果存在环两个指针一定会相遇，注意指针空的判断，避免出现野指针。\n\n`示例代码：`\n```go\nfunc hasCycle(head *ListNode) bool {\n\tif head == nil || head.Next == nil {\n\t\treturn false\n\t}\n\tfaster, slower := head.Next.Next, head.Next\n\tfor faster != nil && faster.Next != nil && slower != nil {\n\t\tif faster == slower {\n\t\t\treturn true\n\t\t}\n\t\tfaster = faster.Next.Next\n\t\tslower = slower.Next\n\t}\n\treturn false\n}\n```\n\n## 1.4 接雨水\n[LeetCode No.42](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n> 题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n**思路：**当前柱子能接的雨水数为其左右最高的柱子的较小值减当前柱子的高度\n\n方法1：先求出每个柱子i左边的最大高度left_max[i]，右边最大高度right_max[i]，然后遍历一次计算。时间复杂度T = O(3n)\n\n`示例代码：`\n```go\nfunc trap(height []int) int {\n    res, n := 0, len(height)\n    if n == 0 {\n        return res\n    }\n    left_max, right_max := make([]int, n), make([]int, n)\n    left_max[0], right_max[n - 1] = height[0], height[n - 1]\n    for i := 1; i < n; i++ {\n        left_max[i] = max(left_max[i - 1], height[i])\n    }\n    for i := n - 2; i >= 0; i-- {\n        right_max[i] = max(right_max[i + 1], height[i])\n    }\n    for i := 0; i < n; i++ {\n        res += min(right_max[i], left_max[i]) - height[i]\n    }\n    return res\n}\n```\n\n方法2：只需遍历一次的双指针解法，两个指针最终在最高点相遇。\n\n`示例代码：`\n```go\nfunc trap(height []int) int {\n    res, left, right := 0, 0, len(height) - 1\n    if right < 0 {\n        return res\n    }\n    left_max, right_max := 0, 0\n    for left < right {\n        if height[left] > height[right] {\n            right_max = max(right_max, height[right])\n            res += right_max - height[right]\n            right--\n        } else {\n            left_max = max(left_max, height[left])\n            res += left_max - height[left]\n            left++\n        }\n    }\n    return res\n}\n```\n","slug":"算法-1-双指针","published":1,"updated":"2023-03-19T14:29:50.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyw8000ivhfi7vqmeols","content":"<p>双指针通常用在有序数组，链表的数据结构上，根据题目条件移动对应的指针。比如判断子串、链表是否有环的问题。</p>\n<h2 id=\"1-1-最长子串\"><a href=\"#1-1-最长子串\" class=\"headerlink\" title=\"1.1 最长子串\"></a>1.1 最长子串</h2><p><a href=\"https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/\">LeetCode No.524</a></p>\n<blockquote>\n<p>题目描述：给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串<br>输入:<br>s &#x3D; “abpcplea”, d &#x3D; [“ale”,”apple”,”monkey”,”plea”]<br>输出:<br>“apple”</p>\n</blockquote>\n<p><strong>思路：本题主要思路是要将删除s中某些字符后和target匹配转化为判断是target是否为s的子串</strong><br><strong>判断是否为子串：</strong>使用双指针，如果当前字符相等，两个指针同时+1，否则只有母字符串的指针+1，最后判断目标字符传的指针是否等于其长度即可。<br><a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md\">参考原文</a></p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">is_substr</span><span class=\"params\">(s, target <span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\tj := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s) &amp;&amp; j &lt; <span class=\"built_in\">len</span>(target); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s[i] == target[j] &#123;</span><br><span class=\"line\">\t\t\tj++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> j == <span class=\"built_in\">len</span>(target)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findLongestWord</span><span class=\"params\">(s <span class=\"type\">string</span>, dictionary []<span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> longest <span class=\"type\">string</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, cur := <span class=\"keyword\">range</span> dictionary &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果当前字符串是s的子串，当当前字符串长度大于目前结果 或 长度相等但是当前串字典序排在前面时更新目前结果</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> is_substr(s, cur) &amp;&amp; (<span class=\"built_in\">len</span>(cur) &gt; <span class=\"built_in\">len</span>(longest) || <span class=\"built_in\">len</span>(cur) == <span class=\"built_in\">len</span>(longest) &amp;&amp; cur &lt; longest) &#123;</span><br><span class=\"line\">\t\t\tlongest = cur</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> longest</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-两数之和\"><a href=\"#1-2-两数之和\" class=\"headerlink\" title=\"1.2 两数之和\"></a>1.2 两数之和</h2><p><a href=\"https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\">LeetCode No.167</a></p>\n<blockquote>\n<p>题目描述：给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。<br>输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[1,2]</p>\n</blockquote>\n<p><strong>思路：</strong>因为输入数组有序，那么可以用左右两个指针，初始位于两端，判断当前两数和如果大于target，那么right指针减一，如果小于target，left加一，如果等于就返回。</p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(numbers []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> left, right := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(numbers) - <span class=\"number\">1</span>; left &lt; right; &#123;</span><br><span class=\"line\">        cur := numbers[left] + numbers[right]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == target &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;left+<span class=\"number\">1</span>, right+<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur &lt; target &#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-判断链表是否存在环\"><a href=\"#1-3-判断链表是否存在环\" class=\"headerlink\" title=\"1.3 判断链表是否存在环\"></a>1.3 判断链表是否存在环</h2><p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/description/\">LeetCode No.141</a></p>\n<blockquote>\n<p>题目描述：给定一个链表，判断链表中是否有环。</p>\n</blockquote>\n<p><strong>思路：</strong>经典解法使用快慢指针，如果存在环两个指针一定会相遇，注意指针空的判断，避免出现野指针。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hasCycle</span><span class=\"params\">(head *ListNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfaster, slower := head.Next.Next, head.Next</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> faster != <span class=\"literal\">nil</span> &amp;&amp; faster.Next != <span class=\"literal\">nil</span> &amp;&amp; slower != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> faster == slower &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfaster = faster.Next.Next</span><br><span class=\"line\">\t\tslower = slower.Next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-接雨水\"><a href=\"#1-4-接雨水\" class=\"headerlink\" title=\"1.4 接雨水\"></a>1.4 接雨水</h2><p><a href=\"https://leetcode-cn.com/problems/trapping-rain-water/\">LeetCode No.42</a></p>\n<blockquote>\n<p>题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n</blockquote>\n<p><strong>思路：</strong>当前柱子能接的雨水数为其左右最高的柱子的较小值减当前柱子的高度</p>\n<p>方法1：先求出每个柱子i左边的最大高度left_max[i]，右边最大高度right_max[i]，然后遍历一次计算。时间复杂度T &#x3D; O(3n)</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">trap</span><span class=\"params\">(height []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    res, n := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(height)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left_max, right_max := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n), <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n)</span><br><span class=\"line\">    left_max[<span class=\"number\">0</span>], right_max[n - <span class=\"number\">1</span>] = height[<span class=\"number\">0</span>], height[n - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        left_max[i] = max(left_max[i - <span class=\"number\">1</span>], height[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := n - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">        right_max[i] = max(right_max[i + <span class=\"number\">1</span>], height[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        res += min(right_max[i], left_max[i]) - height[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法2：只需遍历一次的双指针解法，两个指针最终在最高点相遇。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">trap</span><span class=\"params\">(height []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    res, left, right := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(height) - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> right &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left_max, right_max := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> height[left] &gt; height[right] &#123;</span><br><span class=\"line\">            right_max = max(right_max, height[right])</span><br><span class=\"line\">            res += right_max - height[right]</span><br><span class=\"line\">            right--</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            left_max = max(left_max, height[left])</span><br><span class=\"line\">            res += left_max - height[left]</span><br><span class=\"line\">            left++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>双指针通常用在有序数组，链表的数据结构上，根据题目条件移动对应的指针。比如判断子串、链表是否有环的问题。</p>\n<h2 id=\"1-1-最长子串\"><a href=\"#1-1-最长子串\" class=\"headerlink\" title=\"1.1 最长子串\"></a>1.1 最长子串</h2><p><a href=\"https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/\">LeetCode No.524</a></p>\n<blockquote>\n<p>题目描述：给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串<br>输入:<br>s &#x3D; “abpcplea”, d &#x3D; [“ale”,”apple”,”monkey”,”plea”]<br>输出:<br>“apple”</p>\n</blockquote>\n<p><strong>思路：本题主要思路是要将删除s中某些字符后和target匹配转化为判断是target是否为s的子串</strong><br><strong>判断是否为子串：</strong>使用双指针，如果当前字符相等，两个指针同时+1，否则只有母字符串的指针+1，最后判断目标字符传的指针是否等于其长度即可。<br><a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md\">参考原文</a></p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">is_substr</span><span class=\"params\">(s, target <span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\tj := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s) &amp;&amp; j &lt; <span class=\"built_in\">len</span>(target); i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s[i] == target[j] &#123;</span><br><span class=\"line\">\t\t\tj++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> j == <span class=\"built_in\">len</span>(target)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findLongestWord</span><span class=\"params\">(s <span class=\"type\">string</span>, dictionary []<span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> longest <span class=\"type\">string</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, cur := <span class=\"keyword\">range</span> dictionary &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果当前字符串是s的子串，当当前字符串长度大于目前结果 或 长度相等但是当前串字典序排在前面时更新目前结果</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> is_substr(s, cur) &amp;&amp; (<span class=\"built_in\">len</span>(cur) &gt; <span class=\"built_in\">len</span>(longest) || <span class=\"built_in\">len</span>(cur) == <span class=\"built_in\">len</span>(longest) &amp;&amp; cur &lt; longest) &#123;</span><br><span class=\"line\">\t\t\tlongest = cur</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> longest</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-两数之和\"><a href=\"#1-2-两数之和\" class=\"headerlink\" title=\"1.2 两数之和\"></a>1.2 两数之和</h2><p><a href=\"https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\">LeetCode No.167</a></p>\n<blockquote>\n<p>题目描述：给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。<br>输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[1,2]</p>\n</blockquote>\n<p><strong>思路：</strong>因为输入数组有序，那么可以用左右两个指针，初始位于两端，判断当前两数和如果大于target，那么right指针减一，如果小于target，left加一，如果等于就返回。</p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(numbers []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> left, right := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(numbers) - <span class=\"number\">1</span>; left &lt; right; &#123;</span><br><span class=\"line\">        cur := numbers[left] + numbers[right]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == target &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;left+<span class=\"number\">1</span>, right+<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur &lt; target &#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-判断链表是否存在环\"><a href=\"#1-3-判断链表是否存在环\" class=\"headerlink\" title=\"1.3 判断链表是否存在环\"></a>1.3 判断链表是否存在环</h2><p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/description/\">LeetCode No.141</a></p>\n<blockquote>\n<p>题目描述：给定一个链表，判断链表中是否有环。</p>\n</blockquote>\n<p><strong>思路：</strong>经典解法使用快慢指针，如果存在环两个指针一定会相遇，注意指针空的判断，避免出现野指针。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hasCycle</span><span class=\"params\">(head *ListNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfaster, slower := head.Next.Next, head.Next</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> faster != <span class=\"literal\">nil</span> &amp;&amp; faster.Next != <span class=\"literal\">nil</span> &amp;&amp; slower != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> faster == slower &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfaster = faster.Next.Next</span><br><span class=\"line\">\t\tslower = slower.Next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-接雨水\"><a href=\"#1-4-接雨水\" class=\"headerlink\" title=\"1.4 接雨水\"></a>1.4 接雨水</h2><p><a href=\"https://leetcode-cn.com/problems/trapping-rain-water/\">LeetCode No.42</a></p>\n<blockquote>\n<p>题目描述：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n</blockquote>\n<p><strong>思路：</strong>当前柱子能接的雨水数为其左右最高的柱子的较小值减当前柱子的高度</p>\n<p>方法1：先求出每个柱子i左边的最大高度left_max[i]，右边最大高度right_max[i]，然后遍历一次计算。时间复杂度T &#x3D; O(3n)</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">trap</span><span class=\"params\">(height []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    res, n := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(height)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left_max, right_max := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n), <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n)</span><br><span class=\"line\">    left_max[<span class=\"number\">0</span>], right_max[n - <span class=\"number\">1</span>] = height[<span class=\"number\">0</span>], height[n - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        left_max[i] = max(left_max[i - <span class=\"number\">1</span>], height[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := n - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">        right_max[i] = max(right_max[i + <span class=\"number\">1</span>], height[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        res += min(right_max[i], left_max[i]) - height[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法2：只需遍历一次的双指针解法，两个指针最终在最高点相遇。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">trap</span><span class=\"params\">(height []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    res, left, right := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(height) - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> right &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    left_max, right_max := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> height[left] &gt; height[right] &#123;</span><br><span class=\"line\">            right_max = max(right_max, height[right])</span><br><span class=\"line\">            res += right_max - height[right]</span><br><span class=\"line\">            right--</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            left_max = max(left_max, height[left])</span><br><span class=\"line\">            res += left_max - height[left]</span><br><span class=\"line\">            left++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(2): 排序","date":"2023-03-19T13:43:50.000Z","_content":"## 2.1 快速排序\n> 题目描述：实现快速排序\n\n**思路**：采用交换法，选第一个数为基准数pivot，在pl <= pr的前提下，指针pl从基准数+1的位置向右走，直到碰到比pivot大的数，指针pr从最右边向左走，直到碰到比pivot小的数，交换arr[pl], arr[pr]，循环结束时pr = pl - 1，将基准数和pr交换。递归调用对基准数位置两边的区间调整。\n\n![](https://upload-images.jianshu.io/upload_images/14151453-a8e8b8d1195b3f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`示例代码：`\n```go\nfunc partition(arr []int, left, right int) int {\n\tpivot := arr[left]\n\tpl, pr := left + 1, right\n\tfor pl <= pr {\n\t\tfor ; pl <= pr && arr[pl] < pivot; pl++ {}\n\t\tfor ; pl <= pr && arr[pr] > pivot; pr-- {}\n\t\tif pl < pr {\n\t\t\tarr[pl], arr[pr] = arr[pr], arr[pl]\n\t\t}\n\t}\n\t// 结束时pr = pl -1\n\tarr[left], arr[pr] = arr[pr], arr[left]\n\treturn pr\n}\n\nfunc recursive(arr []int, left, right int)  {\n\tif left >= right {\n\t\treturn\n\t}\n\tmid := partition(arr, left, right)\n\trecursive(arr, left, mid - 1)\n\trecursive(arr, mid + 1, right)\n}\n\nfunc QuickSort(arr []int) []int {\n\trecursive(arr, 0, len(arr) - 1)\n\treturn arr\n}\n```\n","source":"_posts/2023/03-19-算法-2-排序.md","raw":"---\ntitle: '算法(2): 排序'\ndate: 2023-03-19 21:43:50\ncategories:\n- [算法]\ntags:\n- 快速排序\n---\n## 2.1 快速排序\n> 题目描述：实现快速排序\n\n**思路**：采用交换法，选第一个数为基准数pivot，在pl <= pr的前提下，指针pl从基准数+1的位置向右走，直到碰到比pivot大的数，指针pr从最右边向左走，直到碰到比pivot小的数，交换arr[pl], arr[pr]，循环结束时pr = pl - 1，将基准数和pr交换。递归调用对基准数位置两边的区间调整。\n\n![](https://upload-images.jianshu.io/upload_images/14151453-a8e8b8d1195b3f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n`示例代码：`\n```go\nfunc partition(arr []int, left, right int) int {\n\tpivot := arr[left]\n\tpl, pr := left + 1, right\n\tfor pl <= pr {\n\t\tfor ; pl <= pr && arr[pl] < pivot; pl++ {}\n\t\tfor ; pl <= pr && arr[pr] > pivot; pr-- {}\n\t\tif pl < pr {\n\t\t\tarr[pl], arr[pr] = arr[pr], arr[pl]\n\t\t}\n\t}\n\t// 结束时pr = pl -1\n\tarr[left], arr[pr] = arr[pr], arr[left]\n\treturn pr\n}\n\nfunc recursive(arr []int, left, right int)  {\n\tif left >= right {\n\t\treturn\n\t}\n\tmid := partition(arr, left, right)\n\trecursive(arr, left, mid - 1)\n\trecursive(arr, mid + 1, right)\n}\n\nfunc QuickSort(arr []int) []int {\n\trecursive(arr, 0, len(arr) - 1)\n\treturn arr\n}\n```\n","slug":"算法-2-排序","published":1,"updated":"2023-03-19T13:50:13.288Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyw9000kvhfi4cq44j7x","content":"<h2 id=\"2-1-快速排序\"><a href=\"#2-1-快速排序\" class=\"headerlink\" title=\"2.1 快速排序\"></a>2.1 快速排序</h2><blockquote>\n<p>题目描述：实现快速排序</p>\n</blockquote>\n<p><strong>思路</strong>：采用交换法，选第一个数为基准数pivot，在pl &lt;&#x3D; pr的前提下，指针pl从基准数+1的位置向右走，直到碰到比pivot大的数，指针pr从最右边向左走，直到碰到比pivot小的数，交换arr[pl], arr[pr]，循环结束时pr &#x3D; pl - 1，将基准数和pr交换。递归调用对基准数位置两边的区间调整。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-a8e8b8d1195b3f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-a8e8b8d1195b3f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">partition</span><span class=\"params\">(arr []<span class=\"type\">int</span>, left, right <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tpivot := arr[left]</span><br><span class=\"line\">\tpl, pr := left + <span class=\"number\">1</span>, right</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> pl &lt;= pr &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ; pl &lt;= pr &amp;&amp; arr[pl] &lt; pivot; pl++ &#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ; pl &lt;= pr &amp;&amp; arr[pr] &gt; pivot; pr-- &#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> pl &lt; pr &#123;</span><br><span class=\"line\">\t\t\tarr[pl], arr[pr] = arr[pr], arr[pl]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 结束时pr = pl -1</span></span><br><span class=\"line\">\tarr[left], arr[pr] = arr[pr], arr[left]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recursive</span><span class=\"params\">(arr []<span class=\"type\">int</span>, left, right <span class=\"type\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> left &gt;= right &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmid := partition(arr, left, right)</span><br><span class=\"line\">\trecursive(arr, left, mid - <span class=\"number\">1</span>)</span><br><span class=\"line\">\trecursive(arr, mid + <span class=\"number\">1</span>, right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">QuickSort</span><span class=\"params\">(arr []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\trecursive(arr, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(arr) - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"2-1-快速排序\"><a href=\"#2-1-快速排序\" class=\"headerlink\" title=\"2.1 快速排序\"></a>2.1 快速排序</h2><blockquote>\n<p>题目描述：实现快速排序</p>\n</blockquote>\n<p><strong>思路</strong>：采用交换法，选第一个数为基准数pivot，在pl &lt;&#x3D; pr的前提下，指针pl从基准数+1的位置向右走，直到碰到比pivot大的数，指针pr从最右边向左走，直到碰到比pivot小的数，交换arr[pl], arr[pr]，循环结束时pr &#x3D; pl - 1，将基准数和pr交换。递归调用对基准数位置两边的区间调整。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-a8e8b8d1195b3f44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">partition</span><span class=\"params\">(arr []<span class=\"type\">int</span>, left, right <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tpivot := arr[left]</span><br><span class=\"line\">\tpl, pr := left + <span class=\"number\">1</span>, right</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> pl &lt;= pr &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ; pl &lt;= pr &amp;&amp; arr[pl] &lt; pivot; pl++ &#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ; pl &lt;= pr &amp;&amp; arr[pr] &gt; pivot; pr-- &#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> pl &lt; pr &#123;</span><br><span class=\"line\">\t\t\tarr[pl], arr[pr] = arr[pr], arr[pl]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 结束时pr = pl -1</span></span><br><span class=\"line\">\tarr[left], arr[pr] = arr[pr], arr[left]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recursive</span><span class=\"params\">(arr []<span class=\"type\">int</span>, left, right <span class=\"type\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> left &gt;= right &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmid := partition(arr, left, right)</span><br><span class=\"line\">\trecursive(arr, left, mid - <span class=\"number\">1</span>)</span><br><span class=\"line\">\trecursive(arr, mid + <span class=\"number\">1</span>, right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">QuickSort</span><span class=\"params\">(arr []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\trecursive(arr, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(arr) - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(3): 二分查找","date":"2023-03-19T13:51:01.000Z","_content":"\n二分查找是一种在有序列表中查找元素的高效方法，时间复杂度（logN），二分查找思路和时间都比较简单，但是实际问题中的细节不可忽视。\n### 3.1 搜索插入位置\n[LeetCode No.35](https://leetcode-cn.com/problems/search-insert-position/)\n\n> 问题描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置，你可以假设数组中无重复元素。\n\n**思路**：按照二分查找法，定义low，high两个指针，结束条件为low > high，如果目标值不存在返回low的位置就是要插入的位置。\n\n`示例代码：`\n```go\nfunc searchInsert(nums []int, target int) int {\n\tl, h := 0, len(nums) - 1\n\tvar m int\n\tfor l <= h {\n\t\tm = h + l >> 1\n\t\tif nums[m] == target {\n\t\t\treturn m\n\t\t}\n\t\tif nums[m] > target {\n\t\t\th = m - 1\n\t\t} else {\n\t\t\tl = m + 1\n\t\t}\n\t}\n\treturn l\n}\n```\n\n### 3.2 搜索旋转排序数组\n[LeetCode No.33](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n\n> 问题描述：整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1\n\n**思路**：进行二分之后的mid位置元素位置可能有两种情况：左边元素的所有元素是有序的，或右边的所有元素是有序的。\n![](https://upload-images.jianshu.io/upload_images/14151453-16f62cfda81d1fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 如果是左边有序，则nums[mid] > nums[low]，反之是右边有序\n- 在知道是那边有序后即可根据边界和target来选择去左半区还是右半区搜索\n\n`示例代码：`\n```go\nfunc search(nums []int, target int) int {\n\tlow, high := 0, len(nums) - 1\n\tfor low <= high {\n\t\tmid := (low + high) / 2\n\t\tif nums[mid] == target {\n\t\t\treturn mid\n\t\t}\n\t\tif nums[mid] >= nums[low] {\n\t\t\tif target < nums[mid] && target >= nums[low] {\n\t\t\t\thigh = mid - 1\n\t\t\t} else {\n\t\t\t\tlow = mid + 1\n\t\t\t}\n\t\t} else {\n\t\t\tif target > nums[mid] && target <= nums[high] {\n\t\t\t\tlow = mid + 1\n\t\t\t} else {\n\t\t\t\thigh = mid - 1\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n### 3.3 排序数组中查找元素的第一个和最后一个位置（有重复元素）\n[LeetCode No.34](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n> 问题描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置，如果数组中不存在目标值 target，返回 [-1, -1]。\n\n**思路**：找到最左边的target位置和target+1最左边的位置-1，要找最左边的target，那么当nums[mid] >= target时都要继续往左半区搜索。\n\n`示例代码：`\n```go\nfunc searchRange(nums []int, target int) []int {\n\tledge := search(nums, target)\n\tif ledge == len(nums) || nums[ledge] != target {\n\t\treturn []int{-1, -1}\n\t}\n\tredge := search(nums, target + 1) - 1\n\treturn []int{ledge, redge}\n}\n\nfunc search(nums []int, target int) int  {\n\tl, r := 0, len(nums) - 1\n\tfor l <= r {\n\t\tmid := (l + r) / 2\n\t\tif nums[mid] >= target {\n\t\t\tr = mid - 1\n\t\t\tif l > r && nums[mid] == target {\n\t\t\t\treturn mid\n\t\t\t}\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t}\n\treturn l\n}\n```\n","source":"_posts/2023/03-19-算法-3-二分查找.md","raw":"---\ntitle: '算法(3): 二分查找'\ndate: 2023-03-19 21:51:01\ncategories:\n- [算法]\ntags:\n- 二分查找\n- leetcode\n---\n\n二分查找是一种在有序列表中查找元素的高效方法，时间复杂度（logN），二分查找思路和时间都比较简单，但是实际问题中的细节不可忽视。\n### 3.1 搜索插入位置\n[LeetCode No.35](https://leetcode-cn.com/problems/search-insert-position/)\n\n> 问题描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置，你可以假设数组中无重复元素。\n\n**思路**：按照二分查找法，定义low，high两个指针，结束条件为low > high，如果目标值不存在返回low的位置就是要插入的位置。\n\n`示例代码：`\n```go\nfunc searchInsert(nums []int, target int) int {\n\tl, h := 0, len(nums) - 1\n\tvar m int\n\tfor l <= h {\n\t\tm = h + l >> 1\n\t\tif nums[m] == target {\n\t\t\treturn m\n\t\t}\n\t\tif nums[m] > target {\n\t\t\th = m - 1\n\t\t} else {\n\t\t\tl = m + 1\n\t\t}\n\t}\n\treturn l\n}\n```\n\n### 3.2 搜索旋转排序数组\n[LeetCode No.33](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n\n> 问题描述：整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1\n\n**思路**：进行二分之后的mid位置元素位置可能有两种情况：左边元素的所有元素是有序的，或右边的所有元素是有序的。\n![](https://upload-images.jianshu.io/upload_images/14151453-16f62cfda81d1fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 如果是左边有序，则nums[mid] > nums[low]，反之是右边有序\n- 在知道是那边有序后即可根据边界和target来选择去左半区还是右半区搜索\n\n`示例代码：`\n```go\nfunc search(nums []int, target int) int {\n\tlow, high := 0, len(nums) - 1\n\tfor low <= high {\n\t\tmid := (low + high) / 2\n\t\tif nums[mid] == target {\n\t\t\treturn mid\n\t\t}\n\t\tif nums[mid] >= nums[low] {\n\t\t\tif target < nums[mid] && target >= nums[low] {\n\t\t\t\thigh = mid - 1\n\t\t\t} else {\n\t\t\t\tlow = mid + 1\n\t\t\t}\n\t\t} else {\n\t\t\tif target > nums[mid] && target <= nums[high] {\n\t\t\t\tlow = mid + 1\n\t\t\t} else {\n\t\t\t\thigh = mid - 1\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n### 3.3 排序数组中查找元素的第一个和最后一个位置（有重复元素）\n[LeetCode No.34](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n> 问题描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置，如果数组中不存在目标值 target，返回 [-1, -1]。\n\n**思路**：找到最左边的target位置和target+1最左边的位置-1，要找最左边的target，那么当nums[mid] >= target时都要继续往左半区搜索。\n\n`示例代码：`\n```go\nfunc searchRange(nums []int, target int) []int {\n\tledge := search(nums, target)\n\tif ledge == len(nums) || nums[ledge] != target {\n\t\treturn []int{-1, -1}\n\t}\n\tredge := search(nums, target + 1) - 1\n\treturn []int{ledge, redge}\n}\n\nfunc search(nums []int, target int) int  {\n\tl, r := 0, len(nums) - 1\n\tfor l <= r {\n\t\tmid := (l + r) / 2\n\t\tif nums[mid] >= target {\n\t\t\tr = mid - 1\n\t\t\tif l > r && nums[mid] == target {\n\t\t\t\treturn mid\n\t\t\t}\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t}\n\treturn l\n}\n```\n","slug":"算法-3-二分查找","published":1,"updated":"2023-03-19T13:51:59.644Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywa000pvhfia9hy8b2m","content":"<p>二分查找是一种在有序列表中查找元素的高效方法，时间复杂度（logN），二分查找思路和时间都比较简单，但是实际问题中的细节不可忽视。</p>\n<h3 id=\"3-1-搜索插入位置\"><a href=\"#3-1-搜索插入位置\" class=\"headerlink\" title=\"3.1 搜索插入位置\"></a>3.1 搜索插入位置</h3><p><a href=\"https://leetcode-cn.com/problems/search-insert-position/\">LeetCode No.35</a></p>\n<blockquote>\n<p>问题描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置，你可以假设数组中无重复元素。</p>\n</blockquote>\n<p><strong>思路</strong>：按照二分查找法，定义low，high两个指针，结束条件为low &gt; high，如果目标值不存在返回low的位置就是要插入的位置。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchInsert</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tl, h := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> m <span class=\"type\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l &lt;= h &#123;</span><br><span class=\"line\">\t\tm = h + l &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[m] == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> m</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[m] &gt; target &#123;</span><br><span class=\"line\">\t\t\th = m - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tl = m + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-搜索旋转排序数组\"><a href=\"#3-2-搜索旋转排序数组\" class=\"headerlink\" title=\"3.2 搜索旋转排序数组\"></a>3.2 搜索旋转排序数组</h3><p><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\">LeetCode No.33</a></p>\n<blockquote>\n<p>问题描述：整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1</p>\n</blockquote>\n<p><strong>思路</strong>：进行二分之后的mid位置元素位置可能有两种情况：左边元素的所有元素是有序的，或右边的所有元素是有序的。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-16f62cfda81d1fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-16f62cfda81d1fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<ul>\n<li>如果是左边有序，则nums[mid] &gt; nums[low]，反之是右边有序</li>\n<li>在知道是那边有序后即可根据边界和target来选择去左半区还是右半区搜索</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tlow, high := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> low &lt;= high &#123;</span><br><span class=\"line\">\t\tmid := (low + high) / <span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> mid</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] &gt;= nums[low] &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> target &lt; nums[mid] &amp;&amp; target &gt;= nums[low] &#123;</span><br><span class=\"line\">\t\t\t\thigh = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tlow = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> target &gt; nums[mid] &amp;&amp; target &lt;= nums[high] &#123;</span><br><span class=\"line\">\t\t\t\tlow = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\thigh = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-排序数组中查找元素的第一个和最后一个位置（有重复元素）\"><a href=\"#3-3-排序数组中查找元素的第一个和最后一个位置（有重复元素）\" class=\"headerlink\" title=\"3.3 排序数组中查找元素的第一个和最后一个位置（有重复元素）\"></a>3.3 排序数组中查找元素的第一个和最后一个位置（有重复元素）</h3><p><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\">LeetCode No.34</a></p>\n<blockquote>\n<p>问题描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置，如果数组中不存在目标值 target，返回 [-1, -1]。</p>\n</blockquote>\n<p><strong>思路</strong>：找到最左边的target位置和target+1最左边的位置-1，要找最左边的target，那么当nums[mid] &gt;&#x3D; target时都要继续往左半区搜索。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchRange</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tledge := search(nums, target)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ledge == <span class=\"built_in\">len</span>(nums) || nums[ledge] != target &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tredge := search(nums, target + <span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;ledge, redge&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span>  &#123;</span><br><span class=\"line\">\tl, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l &lt;= r &#123;</span><br><span class=\"line\">\t\tmid := (l + r) / <span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] &gt;= target &#123;</span><br><span class=\"line\">\t\t\tr = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> l &gt; r &amp;&amp; nums[mid] == target &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> mid</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tl = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>二分查找是一种在有序列表中查找元素的高效方法，时间复杂度（logN），二分查找思路和时间都比较简单，但是实际问题中的细节不可忽视。</p>\n<h3 id=\"3-1-搜索插入位置\"><a href=\"#3-1-搜索插入位置\" class=\"headerlink\" title=\"3.1 搜索插入位置\"></a>3.1 搜索插入位置</h3><p><a href=\"https://leetcode-cn.com/problems/search-insert-position/\">LeetCode No.35</a></p>\n<blockquote>\n<p>问题描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置，你可以假设数组中无重复元素。</p>\n</blockquote>\n<p><strong>思路</strong>：按照二分查找法，定义low，high两个指针，结束条件为low &gt; high，如果目标值不存在返回low的位置就是要插入的位置。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchInsert</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tl, h := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> m <span class=\"type\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l &lt;= h &#123;</span><br><span class=\"line\">\t\tm = h + l &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[m] == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> m</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[m] &gt; target &#123;</span><br><span class=\"line\">\t\t\th = m - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tl = m + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-搜索旋转排序数组\"><a href=\"#3-2-搜索旋转排序数组\" class=\"headerlink\" title=\"3.2 搜索旋转排序数组\"></a>3.2 搜索旋转排序数组</h3><p><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\">LeetCode No.33</a></p>\n<blockquote>\n<p>问题描述：整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1</p>\n</blockquote>\n<p><strong>思路</strong>：进行二分之后的mid位置元素位置可能有两种情况：左边元素的所有元素是有序的，或右边的所有元素是有序的。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-16f62cfda81d1fdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<ul>\n<li>如果是左边有序，则nums[mid] &gt; nums[low]，反之是右边有序</li>\n<li>在知道是那边有序后即可根据边界和target来选择去左半区还是右半区搜索</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tlow, high := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> low &lt;= high &#123;</span><br><span class=\"line\">\t\tmid := (low + high) / <span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> mid</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] &gt;= nums[low] &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> target &lt; nums[mid] &amp;&amp; target &gt;= nums[low] &#123;</span><br><span class=\"line\">\t\t\t\thigh = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tlow = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> target &gt; nums[mid] &amp;&amp; target &lt;= nums[high] &#123;</span><br><span class=\"line\">\t\t\t\tlow = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\thigh = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-排序数组中查找元素的第一个和最后一个位置（有重复元素）\"><a href=\"#3-3-排序数组中查找元素的第一个和最后一个位置（有重复元素）\" class=\"headerlink\" title=\"3.3 排序数组中查找元素的第一个和最后一个位置（有重复元素）\"></a>3.3 排序数组中查找元素的第一个和最后一个位置（有重复元素）</h3><p><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\">LeetCode No.34</a></p>\n<blockquote>\n<p>问题描述：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置，如果数组中不存在目标值 target，返回 [-1, -1]。</p>\n</blockquote>\n<p><strong>思路</strong>：找到最左边的target位置和target+1最左边的位置-1，要找最左边的target，那么当nums[mid] &gt;&#x3D; target时都要继续往左半区搜索。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchRange</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tledge := search(nums, target)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ledge == <span class=\"built_in\">len</span>(nums) || nums[ledge] != target &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tredge := search(nums, target + <span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;ledge, redge&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span>  &#123;</span><br><span class=\"line\">\tl, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l &lt;= r &#123;</span><br><span class=\"line\">\t\tmid := (l + r) / <span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] &gt;= target &#123;</span><br><span class=\"line\">\t\t\tr = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> l &gt; r &amp;&amp; nums[mid] == target &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> mid</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tl = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(4): 搜索","date":"2023-03-19T13:52:31.000Z","_content":"\n## 3.1 深度优先DFS\n> 问题1：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n![image.png](https://upload-images.jianshu.io/upload_images/14151453-d06c5120f4a6ffc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nInput: \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n\n思路：深度优先搜索，从根节点到每个叶子节点的所有路径即结果，深度为子串的长度\n\n`示例代码:`\n```go\nvar (\n\tletterMap = []string{\n\t\t\" \",    //0\n\t\t\"\",     //1\n\t\t\"abc\",  //2\n\t\t\"def\",  //3\n\t\t\"ghi\",  //4\n\t\t\"jkl\",  //5\n\t\t\"mno\",  //6\n\t\t\"pqrs\", //7\n\t\t\"tuv\",  //8\n\t\t\"wxyz\", //9\n\t}\n\tres   = []string{}\n)\n\nfunc letterCombinations(digits string) []string {\n\tif digits == \"\" {\n\t\treturn []string{}\n\t}\n    res = []string{}\n\tdfs(digits, 0, \"\")\n\treturn res\n}\n\nfunc dfs(digits string, i int, s string) {\n\tif i == len(digits) {\n\t\tres = append(res, s)\n\t\treturn\n\t}\n\tcurs := letterMap[digits[i] - '0']\n\tfor _, ch := range curs {\n\t\tdfs(digits, i+1, s + string(ch))\n\t}\n}\n```\n\n> 问题2：给定一个数组，要求在这个数组中找出 k 个数之和为 target 的所有组合。\nInput: nums = [1, 0, -1, 0, -2, 2], and target = 0.\nOutput:  [ [-1,  0, 0, 1], [-2, -1, 1, 2], [-2,  0, 0, 2] ]\n\n思路：深度优先搜索，层数为k。注意去重的处理。\n\n`示例代码:`\n```go\nimport \"sort\"\n\nvar res = [][]int{}\n\nfunc fourSum(nums []int, target int) [][]int {\n    if len(nums) == 0 {\n\t\treturn [][]int{}\n\t}\n    sort.Ints(nums)\n    res = [][]int{}\n\tr := []int{}\n\tdfs_sum(nums, 0, r, target)\n\treturn res\n}\n\nfunc dfs_sum(nums []int, i int, r []int, target int)  {\n    if i == 4 || 0 == len(nums) {\n        if len(r) >= 4 && r[0] + r[1] + r[2] + r[3] == target {\n            res = append(res, []int{r[0], r[1], r[2], r[3]})\n\t\t}\n\t\treturn\n\t}\n\tfor j := 0; j < len(nums); j++ {\n        if j > 0 && nums[j] == nums[j-1] {\n            continue\n        }\n        r = append(r, nums[j])\n        dfs_sum(nums[j+1:], i + 1, r, target)\n        if len(r) >= 1 {\n            r = r[:len(r)-1]\n        }\n\t}\n}\n```\n\n## 3.2 宽度优先搜索 BFS\n宽度优先搜索通常用在求最短路径，按层遍历，第一次满足要求的层数就是最短的路径。BFS需要借助队列来保存每一层的节点，访问过的节点要做标记避免重复访问。\n\n### 3.2.1 二进制矩阵中的最短路径\n[LeetCode No.1091](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)\n\n> 题目描述：给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：\n1 路径途经的所有单元格都的值都是 0 。\n2 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。\n畅通路径的长度 是该路径途经的单元格总数。\n\n**思路**：从左上角开始，遍历所有可以走的方向，BFS方式求到达右下角的最小层数。\n\n`示例代码：`\n```go\ntype Pos struct {\n\tx, y int\n}\n\nfunc shortestPathBinaryMatrix(grid [][]int) int {\n\tif len(grid) == 0 || len(grid[0]) == 0 {\n\t\treturn -1\n\t}\n\tM, N := len(grid), len(grid[0])\n\tdirection := []Pos{{1, -1}, {1, 0}, {1, 1}, {0, -1}, {0, 1}, {-1, -1}, {-1, 0}, {-1, 1}}\n\tQ := list.New()\n\t// 根节点入队\n\tQ.PushBack(Pos{0, 0})\n\tpath_len := 0\n\tfor Q.Len() != 0 {\n\t\t// 保存当前层的长度\n\t\tlevel_size := Q.Len()\n\t\tpath_len++\n\t\t// 依次处理当前层的所有节点\n\t\tfor i := 0; i < level_size; i++ {\n\t\t\tcur_pos := Q.Front().Value.(Pos)\n\t\t\tQ.Remove(Q.Front())\n\t\t\tif grid[cur_pos.x][cur_pos.y] == 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// 如果到达右下角返回结果\n\t\t\tif cur_pos.x == (M - 1) && cur_pos.y == (N - 1) {\n\t\t\t\treturn path_len\n\t\t\t}\n\t\t\t// 访问过的位置标记为1\n\t\t\tgrid[cur_pos.x][cur_pos.y] = 1\n\t\t\t// 遍历所有能走的方向，加入队列\n\t\t\tfor _, dr := range direction {\n\t\t\t\tnx, ny := cur_pos.x + dr.x, cur_pos.y + dr.y\n\t\t\t\tif nx < 0 || nx >= M || ny < 0 || ny >= N {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tQ.PushBack(Pos{nx, ny})\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n### 3.2.2 完全平方数\n[LeetCode No.279](https://leetcode-cn.com/problems/perfect-squares)\n\n> 题目描述：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n\n**思路**：转化为BFS问题模型，从1到根号n的所有平方数（1，4，9...）为每次所有可能的路径。从n开始遍历，当n=0时即为结果。\n\n`示例代码：`\n```go\nfunc numSquares(n int) int {\n\tnumsqs := []int{}\n\tfor i, ii := 1, 1; ii <= n; i, ii = i + 1, (i + 1) * (i + 1){\n\t\tnumsqs = append(numsqs, ii)\n\t}\n\tmark := map[int]bool{}\n\tQ := list.New()\n\tQ.PushBack(n)\n\tmark[n] = true\n\tans := 0\n\tfor Q.Len() != 0 {\n\t\tlv_size := Q.Len()\n\t\tans++\n\t\tfor i := 0; i < lv_size; i++ {\n\t\t\tcur := Q.Front().Value.(int)\n\t\t\tQ.Remove(Q.Front())\n\t\t\tfor _, nq := range numsqs {\n\t\t\t\tif cur == nq {\n\t\t\t\t\treturn ans\n\t\t\t\t}\n\t\t\t\tif cur < nq {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif mark[cur - nq] {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmark[cur - nq] = true\n\t\t\t\tQ.PushBack(cur - nq)\n\t\t\t}\n\t\t}\n\t}\n\treturn n\n}\n```\n","source":"_posts/2023/03-19-算法-4-搜索.md","raw":"---\ntitle: '算法(4): 搜索'\ndate: 2023-03-19 21:52:31\ncategories:\n- [算法]\ntags:\n- leetcode\n- 深度优先搜索\n- 广度优先搜索\n---\n\n## 3.1 深度优先DFS\n> 问题1：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n![image.png](https://upload-images.jianshu.io/upload_images/14151453-d06c5120f4a6ffc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nInput: \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n\n思路：深度优先搜索，从根节点到每个叶子节点的所有路径即结果，深度为子串的长度\n\n`示例代码:`\n```go\nvar (\n\tletterMap = []string{\n\t\t\" \",    //0\n\t\t\"\",     //1\n\t\t\"abc\",  //2\n\t\t\"def\",  //3\n\t\t\"ghi\",  //4\n\t\t\"jkl\",  //5\n\t\t\"mno\",  //6\n\t\t\"pqrs\", //7\n\t\t\"tuv\",  //8\n\t\t\"wxyz\", //9\n\t}\n\tres   = []string{}\n)\n\nfunc letterCombinations(digits string) []string {\n\tif digits == \"\" {\n\t\treturn []string{}\n\t}\n    res = []string{}\n\tdfs(digits, 0, \"\")\n\treturn res\n}\n\nfunc dfs(digits string, i int, s string) {\n\tif i == len(digits) {\n\t\tres = append(res, s)\n\t\treturn\n\t}\n\tcurs := letterMap[digits[i] - '0']\n\tfor _, ch := range curs {\n\t\tdfs(digits, i+1, s + string(ch))\n\t}\n}\n```\n\n> 问题2：给定一个数组，要求在这个数组中找出 k 个数之和为 target 的所有组合。\nInput: nums = [1, 0, -1, 0, -2, 2], and target = 0.\nOutput:  [ [-1,  0, 0, 1], [-2, -1, 1, 2], [-2,  0, 0, 2] ]\n\n思路：深度优先搜索，层数为k。注意去重的处理。\n\n`示例代码:`\n```go\nimport \"sort\"\n\nvar res = [][]int{}\n\nfunc fourSum(nums []int, target int) [][]int {\n    if len(nums) == 0 {\n\t\treturn [][]int{}\n\t}\n    sort.Ints(nums)\n    res = [][]int{}\n\tr := []int{}\n\tdfs_sum(nums, 0, r, target)\n\treturn res\n}\n\nfunc dfs_sum(nums []int, i int, r []int, target int)  {\n    if i == 4 || 0 == len(nums) {\n        if len(r) >= 4 && r[0] + r[1] + r[2] + r[3] == target {\n            res = append(res, []int{r[0], r[1], r[2], r[3]})\n\t\t}\n\t\treturn\n\t}\n\tfor j := 0; j < len(nums); j++ {\n        if j > 0 && nums[j] == nums[j-1] {\n            continue\n        }\n        r = append(r, nums[j])\n        dfs_sum(nums[j+1:], i + 1, r, target)\n        if len(r) >= 1 {\n            r = r[:len(r)-1]\n        }\n\t}\n}\n```\n\n## 3.2 宽度优先搜索 BFS\n宽度优先搜索通常用在求最短路径，按层遍历，第一次满足要求的层数就是最短的路径。BFS需要借助队列来保存每一层的节点，访问过的节点要做标记避免重复访问。\n\n### 3.2.1 二进制矩阵中的最短路径\n[LeetCode No.1091](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)\n\n> 题目描述：给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：\n1 路径途经的所有单元格都的值都是 0 。\n2 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。\n畅通路径的长度 是该路径途经的单元格总数。\n\n**思路**：从左上角开始，遍历所有可以走的方向，BFS方式求到达右下角的最小层数。\n\n`示例代码：`\n```go\ntype Pos struct {\n\tx, y int\n}\n\nfunc shortestPathBinaryMatrix(grid [][]int) int {\n\tif len(grid) == 0 || len(grid[0]) == 0 {\n\t\treturn -1\n\t}\n\tM, N := len(grid), len(grid[0])\n\tdirection := []Pos{{1, -1}, {1, 0}, {1, 1}, {0, -1}, {0, 1}, {-1, -1}, {-1, 0}, {-1, 1}}\n\tQ := list.New()\n\t// 根节点入队\n\tQ.PushBack(Pos{0, 0})\n\tpath_len := 0\n\tfor Q.Len() != 0 {\n\t\t// 保存当前层的长度\n\t\tlevel_size := Q.Len()\n\t\tpath_len++\n\t\t// 依次处理当前层的所有节点\n\t\tfor i := 0; i < level_size; i++ {\n\t\t\tcur_pos := Q.Front().Value.(Pos)\n\t\t\tQ.Remove(Q.Front())\n\t\t\tif grid[cur_pos.x][cur_pos.y] == 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// 如果到达右下角返回结果\n\t\t\tif cur_pos.x == (M - 1) && cur_pos.y == (N - 1) {\n\t\t\t\treturn path_len\n\t\t\t}\n\t\t\t// 访问过的位置标记为1\n\t\t\tgrid[cur_pos.x][cur_pos.y] = 1\n\t\t\t// 遍历所有能走的方向，加入队列\n\t\t\tfor _, dr := range direction {\n\t\t\t\tnx, ny := cur_pos.x + dr.x, cur_pos.y + dr.y\n\t\t\t\tif nx < 0 || nx >= M || ny < 0 || ny >= N {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tQ.PushBack(Pos{nx, ny})\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n```\n\n### 3.2.2 完全平方数\n[LeetCode No.279](https://leetcode-cn.com/problems/perfect-squares)\n\n> 题目描述：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n\n**思路**：转化为BFS问题模型，从1到根号n的所有平方数（1，4，9...）为每次所有可能的路径。从n开始遍历，当n=0时即为结果。\n\n`示例代码：`\n```go\nfunc numSquares(n int) int {\n\tnumsqs := []int{}\n\tfor i, ii := 1, 1; ii <= n; i, ii = i + 1, (i + 1) * (i + 1){\n\t\tnumsqs = append(numsqs, ii)\n\t}\n\tmark := map[int]bool{}\n\tQ := list.New()\n\tQ.PushBack(n)\n\tmark[n] = true\n\tans := 0\n\tfor Q.Len() != 0 {\n\t\tlv_size := Q.Len()\n\t\tans++\n\t\tfor i := 0; i < lv_size; i++ {\n\t\t\tcur := Q.Front().Value.(int)\n\t\t\tQ.Remove(Q.Front())\n\t\t\tfor _, nq := range numsqs {\n\t\t\t\tif cur == nq {\n\t\t\t\t\treturn ans\n\t\t\t\t}\n\t\t\t\tif cur < nq {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif mark[cur - nq] {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmark[cur - nq] = true\n\t\t\t\tQ.PushBack(cur - nq)\n\t\t\t}\n\t\t}\n\t}\n\treturn n\n}\n```\n","slug":"算法-4-搜索","published":1,"updated":"2023-03-19T13:53:40.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywb000qvhfibo0327vj","content":"<h2 id=\"3-1-深度优先DFS\"><a href=\"#3-1-深度优先DFS\" class=\"headerlink\" title=\"3.1 深度优先DFS\"></a>3.1 深度优先DFS</h2><blockquote>\n<p>问题1：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-d06c5120f4a6ffc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-d06c5120f4a6ffc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" alt=\"image.png\"><br>Input: “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</p>\n</blockquote>\n<p>思路：深度优先搜索，从根节点到每个叶子节点的所有路径即结果，深度为子串的长度</p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tletterMap = []<span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot; &quot;</span>,    <span class=\"comment\">//0</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;&quot;</span>,     <span class=\"comment\">//1</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;abc&quot;</span>,  <span class=\"comment\">//2</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;def&quot;</span>,  <span class=\"comment\">//3</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;ghi&quot;</span>,  <span class=\"comment\">//4</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;jkl&quot;</span>,  <span class=\"comment\">//5</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;mno&quot;</span>,  <span class=\"comment\">//6</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pqrs&quot;</span>, <span class=\"comment\">//7</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;tuv&quot;</span>,  <span class=\"comment\">//8</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;wxyz&quot;</span>, <span class=\"comment\">//9</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres   = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(digits <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> digits == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    res = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\tdfs(digits, <span class=\"number\">0</span>, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(digits <span class=\"type\">string</span>, i <span class=\"type\">int</span>, s <span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i == <span class=\"built_in\">len</span>(digits) &#123;</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, s)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcurs := letterMap[digits[i] - <span class=\"string\">&#x27;0&#x27;</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, ch := <span class=\"keyword\">range</span> curs &#123;</span><br><span class=\"line\">\t\tdfs(digits, i+<span class=\"number\">1</span>, s + <span class=\"type\">string</span>(ch))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>问题2：给定一个数组，要求在这个数组中找出 k 个数之和为 target 的所有组合。<br>Input: nums &#x3D; [1, 0, -1, 0, -2, 2], and target &#x3D; 0.<br>Output:  [ [-1,  0, 0, 1], [-2, -1, 1, 2], [-2,  0, 0, 2] ]</p>\n</blockquote>\n<p>思路：深度优先搜索，层数为k。注意去重的处理。</p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;sort&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> res = [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fourSum</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(nums) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    sort.Ints(nums)</span><br><span class=\"line\">    res = [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\tr := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\tdfs_sum(nums, <span class=\"number\">0</span>, r, target)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs_sum</span><span class=\"params\">(nums []<span class=\"type\">int</span>, i <span class=\"type\">int</span>, r []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">4</span> || <span class=\"number\">0</span> == <span class=\"built_in\">len</span>(nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(r) &gt;= <span class=\"number\">4</span> &amp;&amp; r[<span class=\"number\">0</span>] + r[<span class=\"number\">1</span>] + r[<span class=\"number\">2</span>] + r[<span class=\"number\">3</span>] == target &#123;</span><br><span class=\"line\">            res = <span class=\"built_in\">append</span>(res, []<span class=\"type\">int</span>&#123;r[<span class=\"number\">0</span>], r[<span class=\"number\">1</span>], r[<span class=\"number\">2</span>], r[<span class=\"number\">3</span>]&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(nums); j++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> j &gt; <span class=\"number\">0</span> &amp;&amp; nums[j] == nums[j<span class=\"number\">-1</span>] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r = <span class=\"built_in\">append</span>(r, nums[j])</span><br><span class=\"line\">        dfs_sum(nums[j+<span class=\"number\">1</span>:], i + <span class=\"number\">1</span>, r, target)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(r) &gt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            r = r[:<span class=\"built_in\">len</span>(r)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-宽度优先搜索-BFS\"><a href=\"#3-2-宽度优先搜索-BFS\" class=\"headerlink\" title=\"3.2 宽度优先搜索 BFS\"></a>3.2 宽度优先搜索 BFS</h2><p>宽度优先搜索通常用在求最短路径，按层遍历，第一次满足要求的层数就是最短的路径。BFS需要借助队列来保存每一层的节点，访问过的节点要做标记避免重复访问。</p>\n<h3 id=\"3-2-1-二进制矩阵中的最短路径\"><a href=\"#3-2-1-二进制矩阵中的最短路径\" class=\"headerlink\" title=\"3.2.1 二进制矩阵中的最短路径\"></a>3.2.1 二进制矩阵中的最短路径</h3><p><a href=\"https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/\">LeetCode No.1091</a></p>\n<blockquote>\n<p>题目描述：给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：<br>1 路径途经的所有单元格都的值都是 0 。<br>2 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。<br>畅通路径的长度 是该路径途经的单元格总数。</p>\n</blockquote>\n<p><strong>思路</strong>：从左上角开始，遍历所有可以走的方向，BFS方式求到达右下角的最小层数。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Pos <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tx, y <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shortestPathBinaryMatrix</span><span class=\"params\">(grid [][]<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(grid) == <span class=\"number\">0</span> || <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>]) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tM, N := <span class=\"built_in\">len</span>(grid), <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">\tdirection := []Pos&#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;&#125;</span><br><span class=\"line\">\tQ := list.New()</span><br><span class=\"line\">\t<span class=\"comment\">// 根节点入队</span></span><br><span class=\"line\">\tQ.PushBack(Pos&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;)</span><br><span class=\"line\">\tpath_len := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> Q.Len() != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 保存当前层的长度</span></span><br><span class=\"line\">\t\tlevel_size := Q.Len()</span><br><span class=\"line\">\t\tpath_len++</span><br><span class=\"line\">\t\t<span class=\"comment\">// 依次处理当前层的所有节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; level_size; i++ &#123;</span><br><span class=\"line\">\t\t\tcur_pos := Q.Front().Value.(Pos)</span><br><span class=\"line\">\t\t\tQ.Remove(Q.Front())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> grid[cur_pos.x][cur_pos.y] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果到达右下角返回结果</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> cur_pos.x == (M - <span class=\"number\">1</span>) &amp;&amp; cur_pos.y == (N - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> path_len</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 访问过的位置标记为1</span></span><br><span class=\"line\">\t\t\tgrid[cur_pos.x][cur_pos.y] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遍历所有能走的方向，加入队列</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, dr := <span class=\"keyword\">range</span> direction &#123;</span><br><span class=\"line\">\t\t\t\tnx, ny := cur_pos.x + dr.x, cur_pos.y + dr.y</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> nx &lt; <span class=\"number\">0</span> || nx &gt;= M || ny &lt; <span class=\"number\">0</span> || ny &gt;= N &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tQ.PushBack(Pos&#123;nx, ny&#125;)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2-完全平方数\"><a href=\"#3-2-2-完全平方数\" class=\"headerlink\" title=\"3.2.2 完全平方数\"></a>3.2.2 完全平方数</h3><p><a href=\"https://leetcode-cn.com/problems/perfect-squares\">LeetCode No.279</a></p>\n<blockquote>\n<p>题目描述：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。<br>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。<br>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>\n</blockquote>\n<p><strong>思路</strong>：转化为BFS问题模型，从1到根号n的所有平方数（1，4，9…）为每次所有可能的路径。从n开始遍历，当n&#x3D;0时即为结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">numSquares</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tnumsqs := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, ii := <span class=\"number\">1</span>, <span class=\"number\">1</span>; ii &lt;= n; i, ii = i + <span class=\"number\">1</span>, (i + <span class=\"number\">1</span>) * (i + <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tnumsqs = <span class=\"built_in\">append</span>(numsqs, ii)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmark := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>&#123;&#125;</span><br><span class=\"line\">\tQ := list.New()</span><br><span class=\"line\">\tQ.PushBack(n)</span><br><span class=\"line\">\tmark[n] = <span class=\"literal\">true</span></span><br><span class=\"line\">\tans := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> Q.Len() != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tlv_size := Q.Len()</span><br><span class=\"line\">\t\tans++</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; lv_size; i++ &#123;</span><br><span class=\"line\">\t\t\tcur := Q.Front().Value.(<span class=\"type\">int</span>)</span><br><span class=\"line\">\t\t\tQ.Remove(Q.Front())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, nq := <span class=\"keyword\">range</span> numsqs &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> cur == nq &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> ans</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> cur &lt; nq &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> mark[cur - nq] &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tmark[cur - nq] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\tQ.PushBack(cur - nq)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"3-1-深度优先DFS\"><a href=\"#3-1-深度优先DFS\" class=\"headerlink\" title=\"3.1 深度优先DFS\"></a>3.1 深度优先DFS</h2><blockquote>\n<p>问题1：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-d06c5120f4a6ffc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>Input: “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</p>\n</blockquote>\n<p>思路：深度优先搜索，从根节点到每个叶子节点的所有路径即结果，深度为子串的长度</p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tletterMap = []<span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot; &quot;</span>,    <span class=\"comment\">//0</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;&quot;</span>,     <span class=\"comment\">//1</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;abc&quot;</span>,  <span class=\"comment\">//2</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;def&quot;</span>,  <span class=\"comment\">//3</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;ghi&quot;</span>,  <span class=\"comment\">//4</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;jkl&quot;</span>,  <span class=\"comment\">//5</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;mno&quot;</span>,  <span class=\"comment\">//6</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;pqrs&quot;</span>, <span class=\"comment\">//7</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;tuv&quot;</span>,  <span class=\"comment\">//8</span></span><br><span class=\"line\">\t\t<span class=\"string\">&quot;wxyz&quot;</span>, <span class=\"comment\">//9</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres   = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">letterCombinations</span><span class=\"params\">(digits <span class=\"type\">string</span>)</span></span> []<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> digits == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    res = []<span class=\"type\">string</span>&#123;&#125;</span><br><span class=\"line\">\tdfs(digits, <span class=\"number\">0</span>, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(digits <span class=\"type\">string</span>, i <span class=\"type\">int</span>, s <span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> i == <span class=\"built_in\">len</span>(digits) &#123;</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">append</span>(res, s)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcurs := letterMap[digits[i] - <span class=\"string\">&#x27;0&#x27;</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, ch := <span class=\"keyword\">range</span> curs &#123;</span><br><span class=\"line\">\t\tdfs(digits, i+<span class=\"number\">1</span>, s + <span class=\"type\">string</span>(ch))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>问题2：给定一个数组，要求在这个数组中找出 k 个数之和为 target 的所有组合。<br>Input: nums &#x3D; [1, 0, -1, 0, -2, 2], and target &#x3D; 0.<br>Output:  [ [-1,  0, 0, 1], [-2, -1, 1, 2], [-2,  0, 0, 2] ]</p>\n</blockquote>\n<p>思路：深度优先搜索，层数为k。注意去重的处理。</p>\n<p><code>示例代码:</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;sort&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> res = [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fourSum</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(nums) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    sort.Ints(nums)</span><br><span class=\"line\">    res = [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\tr := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\tdfs_sum(nums, <span class=\"number\">0</span>, r, target)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs_sum</span><span class=\"params\">(nums []<span class=\"type\">int</span>, i <span class=\"type\">int</span>, r []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">4</span> || <span class=\"number\">0</span> == <span class=\"built_in\">len</span>(nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(r) &gt;= <span class=\"number\">4</span> &amp;&amp; r[<span class=\"number\">0</span>] + r[<span class=\"number\">1</span>] + r[<span class=\"number\">2</span>] + r[<span class=\"number\">3</span>] == target &#123;</span><br><span class=\"line\">            res = <span class=\"built_in\">append</span>(res, []<span class=\"type\">int</span>&#123;r[<span class=\"number\">0</span>], r[<span class=\"number\">1</span>], r[<span class=\"number\">2</span>], r[<span class=\"number\">3</span>]&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(nums); j++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> j &gt; <span class=\"number\">0</span> &amp;&amp; nums[j] == nums[j<span class=\"number\">-1</span>] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r = <span class=\"built_in\">append</span>(r, nums[j])</span><br><span class=\"line\">        dfs_sum(nums[j+<span class=\"number\">1</span>:], i + <span class=\"number\">1</span>, r, target)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(r) &gt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            r = r[:<span class=\"built_in\">len</span>(r)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-宽度优先搜索-BFS\"><a href=\"#3-2-宽度优先搜索-BFS\" class=\"headerlink\" title=\"3.2 宽度优先搜索 BFS\"></a>3.2 宽度优先搜索 BFS</h2><p>宽度优先搜索通常用在求最短路径，按层遍历，第一次满足要求的层数就是最短的路径。BFS需要借助队列来保存每一层的节点，访问过的节点要做标记避免重复访问。</p>\n<h3 id=\"3-2-1-二进制矩阵中的最短路径\"><a href=\"#3-2-1-二进制矩阵中的最短路径\" class=\"headerlink\" title=\"3.2.1 二进制矩阵中的最短路径\"></a>3.2.1 二进制矩阵中的最短路径</h3><p><a href=\"https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/\">LeetCode No.1091</a></p>\n<blockquote>\n<p>题目描述：给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：<br>1 路径途经的所有单元格都的值都是 0 。<br>2 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。<br>畅通路径的长度 是该路径途经的单元格总数。</p>\n</blockquote>\n<p><strong>思路</strong>：从左上角开始，遍历所有可以走的方向，BFS方式求到达右下角的最小层数。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Pos <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tx, y <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shortestPathBinaryMatrix</span><span class=\"params\">(grid [][]<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(grid) == <span class=\"number\">0</span> || <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>]) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tM, N := <span class=\"built_in\">len</span>(grid), <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">\tdirection := []Pos&#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;&#125;</span><br><span class=\"line\">\tQ := list.New()</span><br><span class=\"line\">\t<span class=\"comment\">// 根节点入队</span></span><br><span class=\"line\">\tQ.PushBack(Pos&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;)</span><br><span class=\"line\">\tpath_len := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> Q.Len() != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 保存当前层的长度</span></span><br><span class=\"line\">\t\tlevel_size := Q.Len()</span><br><span class=\"line\">\t\tpath_len++</span><br><span class=\"line\">\t\t<span class=\"comment\">// 依次处理当前层的所有节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; level_size; i++ &#123;</span><br><span class=\"line\">\t\t\tcur_pos := Q.Front().Value.(Pos)</span><br><span class=\"line\">\t\t\tQ.Remove(Q.Front())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> grid[cur_pos.x][cur_pos.y] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果到达右下角返回结果</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> cur_pos.x == (M - <span class=\"number\">1</span>) &amp;&amp; cur_pos.y == (N - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> path_len</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 访问过的位置标记为1</span></span><br><span class=\"line\">\t\t\tgrid[cur_pos.x][cur_pos.y] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 遍历所有能走的方向，加入队列</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, dr := <span class=\"keyword\">range</span> direction &#123;</span><br><span class=\"line\">\t\t\t\tnx, ny := cur_pos.x + dr.x, cur_pos.y + dr.y</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> nx &lt; <span class=\"number\">0</span> || nx &gt;= M || ny &lt; <span class=\"number\">0</span> || ny &gt;= N &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tQ.PushBack(Pos&#123;nx, ny&#125;)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2-完全平方数\"><a href=\"#3-2-2-完全平方数\" class=\"headerlink\" title=\"3.2.2 完全平方数\"></a>3.2.2 完全平方数</h3><p><a href=\"https://leetcode-cn.com/problems/perfect-squares\">LeetCode No.279</a></p>\n<blockquote>\n<p>题目描述：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。<br>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。<br>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>\n</blockquote>\n<p><strong>思路</strong>：转化为BFS问题模型，从1到根号n的所有平方数（1，4，9…）为每次所有可能的路径。从n开始遍历，当n&#x3D;0时即为结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">numSquares</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tnumsqs := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, ii := <span class=\"number\">1</span>, <span class=\"number\">1</span>; ii &lt;= n; i, ii = i + <span class=\"number\">1</span>, (i + <span class=\"number\">1</span>) * (i + <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tnumsqs = <span class=\"built_in\">append</span>(numsqs, ii)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmark := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>&#123;&#125;</span><br><span class=\"line\">\tQ := list.New()</span><br><span class=\"line\">\tQ.PushBack(n)</span><br><span class=\"line\">\tmark[n] = <span class=\"literal\">true</span></span><br><span class=\"line\">\tans := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> Q.Len() != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tlv_size := Q.Len()</span><br><span class=\"line\">\t\tans++</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; lv_size; i++ &#123;</span><br><span class=\"line\">\t\t\tcur := Q.Front().Value.(<span class=\"type\">int</span>)</span><br><span class=\"line\">\t\t\tQ.Remove(Q.Front())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, nq := <span class=\"keyword\">range</span> numsqs &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> cur == nq &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> ans</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> cur &lt; nq &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> mark[cur - nq] &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tmark[cur - nq] = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\tQ.PushBack(cur - nq)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(5): 分治/归并","date":"2023-03-19T13:54:37.000Z","_content":"\n分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。\n\n## 5.1 不同的二叉搜索树\n[LeetCode No.95](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n> 问题描述：给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。\n\n**思路**：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1...n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。\n\n`示例代码：`\n```go\nfunc generateTrees(n int) []*TreeNode {\n\treturn _generateTrees(1, n)\n}\n\nfunc _generateTrees(start, end int) []*TreeNode {\n\tif start > end {\n\t\treturn []*TreeNode{nil}\n\t}\n\tres := []*TreeNode{}\n\tfor i := start; i <= end; i++ {\n\t\tleft := _generateTrees(start, i - 1)\n\t\tright := _generateTrees(i + 1, end)\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\ttmp := &TreeNode{\n\t\t\t\t\tVal: i,\n\t\t\t\t\tLeft: l,\n\t\t\t\t\tRight: r,\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n\n## 5.2 为运算表达式设计优先级\n[LeetCode No.241](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)\n\n> 题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。\n\n**思路**：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。\n\n`示例代码：`\n```go\nfunc diffWaysToCompute(expression string) []int {\n\tnum, err := strconv.Atoi(expression)\n\t// 如果为纯数字，直接返回数字\n\tif err == nil {\n\t\treturn []int{num}\n\t}\n\tres := []int{}\n\tfor i, ch := range expression {\n\t\t// 跳过非运算符\n\t\tif ch != '+' && ch != '-' && ch != '*' {\n\t\t\tcontinue\n\t\t}\n\t\t// 计算运算符左右两边子表达式的结果\n\t\tleft := diffWaysToCompute(expression[ : i])\n\t\tright := diffWaysToCompute(expression[i + 1 : ])\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\tvar tmp int\n\t\t\t\tswitch ch {\n\t\t\t\tcase '+': tmp = l + r\n\t\t\t\tcase '-': tmp = l - r\n\t\t\t\tcase '*': tmp = l * r\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n","source":"_posts/2023/03-19-算法-5-分治-归并.md","raw":"---\ntitle: '算法(5): 分治/归并'\ndate: 2023-03-19 21:54:37\ncategories:\n- [算法]\ntags:\n- leetcode\n- 二叉搜索树\n---\n\n分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。\n\n## 5.1 不同的二叉搜索树\n[LeetCode No.95](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n> 问题描述：给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。\n\n**思路**：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1...n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。\n\n`示例代码：`\n```go\nfunc generateTrees(n int) []*TreeNode {\n\treturn _generateTrees(1, n)\n}\n\nfunc _generateTrees(start, end int) []*TreeNode {\n\tif start > end {\n\t\treturn []*TreeNode{nil}\n\t}\n\tres := []*TreeNode{}\n\tfor i := start; i <= end; i++ {\n\t\tleft := _generateTrees(start, i - 1)\n\t\tright := _generateTrees(i + 1, end)\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\ttmp := &TreeNode{\n\t\t\t\t\tVal: i,\n\t\t\t\t\tLeft: l,\n\t\t\t\t\tRight: r,\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n\n## 5.2 为运算表达式设计优先级\n[LeetCode No.241](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)\n\n> 题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。\n\n**思路**：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。\n\n`示例代码：`\n```go\nfunc diffWaysToCompute(expression string) []int {\n\tnum, err := strconv.Atoi(expression)\n\t// 如果为纯数字，直接返回数字\n\tif err == nil {\n\t\treturn []int{num}\n\t}\n\tres := []int{}\n\tfor i, ch := range expression {\n\t\t// 跳过非运算符\n\t\tif ch != '+' && ch != '-' && ch != '*' {\n\t\t\tcontinue\n\t\t}\n\t\t// 计算运算符左右两边子表达式的结果\n\t\tleft := diffWaysToCompute(expression[ : i])\n\t\tright := diffWaysToCompute(expression[i + 1 : ])\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\tvar tmp int\n\t\t\t\tswitch ch {\n\t\t\t\tcase '+': tmp = l + r\n\t\t\t\tcase '-': tmp = l - r\n\t\t\t\tcase '*': tmp = l * r\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n","slug":"算法-5-分治-归并","published":1,"updated":"2023-03-19T13:55:12.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywc000tvhfi59jc5isn","content":"<p>分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。</p>\n<h2 id=\"5-1-不同的二叉搜索树\"><a href=\"#5-1-不同的二叉搜索树\" class=\"headerlink\" title=\"5.1 不同的二叉搜索树\"></a>5.1 不同的二叉搜索树</h2><p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\">LeetCode No.95</a></p>\n<blockquote>\n<p>问题描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>\n</blockquote>\n<p><strong>思路</strong>：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1…n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateTrees</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _generateTrees(<span class=\"number\">1</span>, n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> _<span class=\"title\">generateTrees</span><span class=\"params\">(start, end <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> start &gt; end &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []*TreeNode&#123;<span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []*TreeNode&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class=\"line\">\t\tleft := _generateTrees(start, i - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tright := _generateTrees(i + <span class=\"number\">1</span>, end)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\ttmp := &amp;TreeNode&#123;</span><br><span class=\"line\">\t\t\t\t\tVal: i,</span><br><span class=\"line\">\t\t\t\t\tLeft: l,</span><br><span class=\"line\">\t\t\t\t\tRight: r,</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-为运算表达式设计优先级\"><a href=\"#5-2-为运算表达式设计优先级\" class=\"headerlink\" title=\"5.2 为运算表达式设计优先级\"></a>5.2 为运算表达式设计优先级</h2><p><a href=\"https://leetcode-cn.com/problems/different-ways-to-add-parentheses/\">LeetCode No.241</a></p>\n<blockquote>\n<p>题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>\n</blockquote>\n<p><strong>思路</strong>：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">diffWaysToCompute</span><span class=\"params\">(expression <span class=\"type\">string</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tnum, err := strconv.Atoi(expression)</span><br><span class=\"line\">\t<span class=\"comment\">// 如果为纯数字，直接返回数字</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;num&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, ch := <span class=\"keyword\">range</span> expression &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 跳过非运算符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ch != <span class=\"string\">&#x27;+&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;-&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;*&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算运算符左右两边子表达式的结果</span></span><br><span class=\"line\">\t\tleft := diffWaysToCompute(expression[ : i])</span><br><span class=\"line\">\t\tright := diffWaysToCompute(expression[i + <span class=\"number\">1</span> : ])</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> tmp <span class=\"type\">int</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> ch &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: tmp = l + r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: tmp = l - r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: tmp = l * r</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。</p>\n<h2 id=\"5-1-不同的二叉搜索树\"><a href=\"#5-1-不同的二叉搜索树\" class=\"headerlink\" title=\"5.1 不同的二叉搜索树\"></a>5.1 不同的二叉搜索树</h2><p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\">LeetCode No.95</a></p>\n<blockquote>\n<p>问题描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>\n</blockquote>\n<p><strong>思路</strong>：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1…n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateTrees</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _generateTrees(<span class=\"number\">1</span>, n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> _<span class=\"title\">generateTrees</span><span class=\"params\">(start, end <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> start &gt; end &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []*TreeNode&#123;<span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []*TreeNode&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class=\"line\">\t\tleft := _generateTrees(start, i - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tright := _generateTrees(i + <span class=\"number\">1</span>, end)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\ttmp := &amp;TreeNode&#123;</span><br><span class=\"line\">\t\t\t\t\tVal: i,</span><br><span class=\"line\">\t\t\t\t\tLeft: l,</span><br><span class=\"line\">\t\t\t\t\tRight: r,</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-为运算表达式设计优先级\"><a href=\"#5-2-为运算表达式设计优先级\" class=\"headerlink\" title=\"5.2 为运算表达式设计优先级\"></a>5.2 为运算表达式设计优先级</h2><p><a href=\"https://leetcode-cn.com/problems/different-ways-to-add-parentheses/\">LeetCode No.241</a></p>\n<blockquote>\n<p>题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>\n</blockquote>\n<p><strong>思路</strong>：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">diffWaysToCompute</span><span class=\"params\">(expression <span class=\"type\">string</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tnum, err := strconv.Atoi(expression)</span><br><span class=\"line\">\t<span class=\"comment\">// 如果为纯数字，直接返回数字</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;num&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, ch := <span class=\"keyword\">range</span> expression &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 跳过非运算符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ch != <span class=\"string\">&#x27;+&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;-&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;*&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算运算符左右两边子表达式的结果</span></span><br><span class=\"line\">\t\tleft := diffWaysToCompute(expression[ : i])</span><br><span class=\"line\">\t\tright := diffWaysToCompute(expression[i + <span class=\"number\">1</span> : ])</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> tmp <span class=\"type\">int</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> ch &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: tmp = l + r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: tmp = l - r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: tmp = l * r</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(6): 贪心算法","date":"2023-03-19T13:55:40.000Z","_content":"\n分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。\n\n## 5.1 不同的二叉搜索树\n[LeetCode No.95](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n> 问题描述：给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。\n\n**思路**：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1...n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。\n\n`示例代码：`\n```go\nfunc generateTrees(n int) []*TreeNode {\n\treturn _generateTrees(1, n)\n}\n\nfunc _generateTrees(start, end int) []*TreeNode {\n\tif start > end {\n\t\treturn []*TreeNode{nil}\n\t}\n\tres := []*TreeNode{}\n\tfor i := start; i <= end; i++ {\n\t\tleft := _generateTrees(start, i - 1)\n\t\tright := _generateTrees(i + 1, end)\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\ttmp := &TreeNode{\n\t\t\t\t\tVal: i,\n\t\t\t\t\tLeft: l,\n\t\t\t\t\tRight: r,\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n\n## 5.2 为运算表达式设计优先级\n[LeetCode No.241](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)\n\n> 题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。\n\n**思路**：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。\n\n`示例代码：`\n```go\nfunc diffWaysToCompute(expression string) []int {\n\tnum, err := strconv.Atoi(expression)\n\t// 如果为纯数字，直接返回数字\n\tif err == nil {\n\t\treturn []int{num}\n\t}\n\tres := []int{}\n\tfor i, ch := range expression {\n\t\t// 跳过非运算符\n\t\tif ch != '+' && ch != '-' && ch != '*' {\n\t\t\tcontinue\n\t\t}\n\t\t// 计算运算符左右两边子表达式的结果\n\t\tleft := diffWaysToCompute(expression[ : i])\n\t\tright := diffWaysToCompute(expression[i + 1 : ])\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\tvar tmp int\n\t\t\t\tswitch ch {\n\t\t\t\tcase '+': tmp = l + r\n\t\t\t\tcase '-': tmp = l - r\n\t\t\t\tcase '*': tmp = l * r\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n","source":"_posts/2023/03-19-算法-6-贪心算法.md","raw":"---\ntitle: '算法(6): 贪心算法'\ndate: 2023-03-19 21:55:40\ncategories:\n- [算法]\ntags:\n- 贪心\n- leetcode\n---\n\n分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。\n\n## 5.1 不同的二叉搜索树\n[LeetCode No.95](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n> 问题描述：给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。\n\n**思路**：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1...n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。\n\n`示例代码：`\n```go\nfunc generateTrees(n int) []*TreeNode {\n\treturn _generateTrees(1, n)\n}\n\nfunc _generateTrees(start, end int) []*TreeNode {\n\tif start > end {\n\t\treturn []*TreeNode{nil}\n\t}\n\tres := []*TreeNode{}\n\tfor i := start; i <= end; i++ {\n\t\tleft := _generateTrees(start, i - 1)\n\t\tright := _generateTrees(i + 1, end)\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\ttmp := &TreeNode{\n\t\t\t\t\tVal: i,\n\t\t\t\t\tLeft: l,\n\t\t\t\t\tRight: r,\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n\n## 5.2 为运算表达式设计优先级\n[LeetCode No.241](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)\n\n> 题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。\n\n**思路**：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。\n\n`示例代码：`\n```go\nfunc diffWaysToCompute(expression string) []int {\n\tnum, err := strconv.Atoi(expression)\n\t// 如果为纯数字，直接返回数字\n\tif err == nil {\n\t\treturn []int{num}\n\t}\n\tres := []int{}\n\tfor i, ch := range expression {\n\t\t// 跳过非运算符\n\t\tif ch != '+' && ch != '-' && ch != '*' {\n\t\t\tcontinue\n\t\t}\n\t\t// 计算运算符左右两边子表达式的结果\n\t\tleft := diffWaysToCompute(expression[ : i])\n\t\tright := diffWaysToCompute(expression[i + 1 : ])\n\t\tfor _, l := range left {\n\t\t\tfor _, r := range right {\n\t\t\t\tvar tmp int\n\t\t\t\tswitch ch {\n\t\t\t\tcase '+': tmp = l + r\n\t\t\t\tcase '-': tmp = l - r\n\t\t\t\tcase '*': tmp = l * r\n\t\t\t\t}\n\t\t\t\tres = append(res, tmp)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n```\n","slug":"算法-6-贪心算法","published":1,"updated":"2023-03-19T13:56:25.642Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywd000vvhfi02xw3aze","content":"<p>分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。</p>\n<h2 id=\"5-1-不同的二叉搜索树\"><a href=\"#5-1-不同的二叉搜索树\" class=\"headerlink\" title=\"5.1 不同的二叉搜索树\"></a>5.1 不同的二叉搜索树</h2><p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\">LeetCode No.95</a></p>\n<blockquote>\n<p>问题描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>\n</blockquote>\n<p><strong>思路</strong>：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1…n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateTrees</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _generateTrees(<span class=\"number\">1</span>, n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> _<span class=\"title\">generateTrees</span><span class=\"params\">(start, end <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> start &gt; end &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []*TreeNode&#123;<span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []*TreeNode&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class=\"line\">\t\tleft := _generateTrees(start, i - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tright := _generateTrees(i + <span class=\"number\">1</span>, end)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\ttmp := &amp;TreeNode&#123;</span><br><span class=\"line\">\t\t\t\t\tVal: i,</span><br><span class=\"line\">\t\t\t\t\tLeft: l,</span><br><span class=\"line\">\t\t\t\t\tRight: r,</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-为运算表达式设计优先级\"><a href=\"#5-2-为运算表达式设计优先级\" class=\"headerlink\" title=\"5.2 为运算表达式设计优先级\"></a>5.2 为运算表达式设计优先级</h2><p><a href=\"https://leetcode-cn.com/problems/different-ways-to-add-parentheses/\">LeetCode No.241</a></p>\n<blockquote>\n<p>题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>\n</blockquote>\n<p><strong>思路</strong>：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">diffWaysToCompute</span><span class=\"params\">(expression <span class=\"type\">string</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tnum, err := strconv.Atoi(expression)</span><br><span class=\"line\">\t<span class=\"comment\">// 如果为纯数字，直接返回数字</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;num&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, ch := <span class=\"keyword\">range</span> expression &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 跳过非运算符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ch != <span class=\"string\">&#x27;+&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;-&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;*&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算运算符左右两边子表达式的结果</span></span><br><span class=\"line\">\t\tleft := diffWaysToCompute(expression[ : i])</span><br><span class=\"line\">\t\tright := diffWaysToCompute(expression[i + <span class=\"number\">1</span> : ])</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> tmp <span class=\"type\">int</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> ch &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: tmp = l + r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: tmp = l - r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: tmp = l * r</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>分治的思想为将大问题分解为子问题，子问题再分解为更小的子问题，直到不能再拆分，然后再合并子问题的结果，通常需要用到递归。关键是要找对如何拆解问题。</p>\n<h2 id=\"5-1-不同的二叉搜索树\"><a href=\"#5-1-不同的二叉搜索树\" class=\"headerlink\" title=\"5.1 不同的二叉搜索树\"></a>5.1 不同的二叉搜索树</h2><p><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\">LeetCode No.95</a></p>\n<blockquote>\n<p>问题描述：给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>\n</blockquote>\n<p><strong>思路</strong>：根据二叉搜索树的特点，左子树的所有节点值均小于根节点，右子树的所有节点值均大于根节点，同时对于每一个子树也要满足以上条件。1…n有序序列，假设对于每一个值i作为根节点，可以先求的[1，i - 1]构成的二叉搜索左子树，[i + 1, n]构成的二叉搜索右子树，然后从左右子树中各选一个作为当前根节点的左右子树。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateTrees</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _generateTrees(<span class=\"number\">1</span>, n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> _<span class=\"title\">generateTrees</span><span class=\"params\">(start, end <span class=\"type\">int</span>)</span></span> []*TreeNode &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> start &gt; end &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []*TreeNode&#123;<span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []*TreeNode&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class=\"line\">\t\tleft := _generateTrees(start, i - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tright := _generateTrees(i + <span class=\"number\">1</span>, end)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\ttmp := &amp;TreeNode&#123;</span><br><span class=\"line\">\t\t\t\t\tVal: i,</span><br><span class=\"line\">\t\t\t\t\tLeft: l,</span><br><span class=\"line\">\t\t\t\t\tRight: r,</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-为运算表达式设计优先级\"><a href=\"#5-2-为运算表达式设计优先级\" class=\"headerlink\" title=\"5.2 为运算表达式设计优先级\"></a>5.2 为运算表达式设计优先级</h2><p><a href=\"https://leetcode-cn.com/problems/different-ways-to-add-parentheses/\">LeetCode No.241</a></p>\n<blockquote>\n<p>题目描述：给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>\n</blockquote>\n<p><strong>思路</strong>：对于每个预算式形如x op y，其左右表达式也可以看做一个形如x op y的运算式，对左右两边的运算式的所有结果进行计算，就可以得到最终的结果。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">diffWaysToCompute</span><span class=\"params\">(expression <span class=\"type\">string</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tnum, err := strconv.Atoi(expression)</span><br><span class=\"line\">\t<span class=\"comment\">// 如果为纯数字，直接返回数字</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;num&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tres := []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, ch := <span class=\"keyword\">range</span> expression &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 跳过非运算符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ch != <span class=\"string\">&#x27;+&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;-&#x27;</span> &amp;&amp; ch != <span class=\"string\">&#x27;*&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算运算符左右两边子表达式的结果</span></span><br><span class=\"line\">\t\tleft := diffWaysToCompute(expression[ : i])</span><br><span class=\"line\">\t\tright := diffWaysToCompute(expression[i + <span class=\"number\">1</span> : ])</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, l := <span class=\"keyword\">range</span> left &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> right &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">var</span> tmp <span class=\"type\">int</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">switch</span> ch &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>: tmp = l + r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>: tmp = l - r</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>: tmp = l * r</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tres = <span class=\"built_in\">append</span>(res, tmp)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(7): 动态规划","date":"2023-03-19T13:56:37.000Z","_content":"\n- 动态规划的关键思想在于将问题转换成较小的子问题，然后根据子问题的结果总结出一个状态转移方程，最后得到整个问题的解\n\n### 7.1 打家劫舍\n[LeetCode No.198](https://leetcode-cn.com/problems/house-robber/)\n\n> 问题描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n**思路**：当设选第i个房屋，则不能选i-1，假设dp[i]表示前i个房屋能偷到的最高金额，则有 dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n`示例代码：`\n```go\nfunc rob(nums []int) int {\n    n := len(nums)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return nums[0]\n    }\n    dp := make([]int, n)\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n    ans := dp[1]\n    for i := 2; i < n; i++ {\n        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n        if ans < dp[i] {\n            ans = dp[i]\n        }\n    }\n    return ans\n}\n```\n\n### 7.1-1 打家劫舍2\n[LeetCode No.213](https://leetcode-cn.com/problems/house-robber-ii/)\n\n> 问题描述：房屋变成了环形排列，其他和7.1相同\n\n**思路**：环形排列后，第一个和最后一个不能同时偷，可以转化为[0, n-1]和[1, n]两个单排街道较大值。同时，可以看到第i个问题的最大值只和第i-1和i-2有关，可以只用两个值来保存前两个结果，降低空间复杂度。\n\n`示例代码：`\n```go\nfunc rob(nums []int) int {\n    n := len(nums)\n    if n == 1 {\n        return nums[0]\n    }\n    return max(dorob(nums[1:]), dorob(nums[:n-1]))\n}\n\nfunc dorob(nums []int) int {\n    n := len(nums)\n    if n == 1 {\n        return nums[0]\n    }\n    fisrt, second := nums[0], max(nums[0], nums[1])\n    ans := second\n    for i := 2; i < n; i++ {\n        fisrt, second = second, max(fisrt + nums[i], second)\n        if second > ans {\n            ans = second\n        }\n    }\n    return ans\n}\n```\n\n### 7.2 分割等和子集\n[LeetCode No.416](https://leetcode-cn.com/problems/partition-equal-subset-sum/)\n\n> 问题描述：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n输入: [1, 5, 11, 5]\n输出: true\n解释: 数组可以分割成 [1, 5, 5] 和 [11]\n\n**思路**：如果数组大小为奇数，结果必为false。然后该问题可以转化为背包大小为sum/2的0-1背包问题，如果恰好能装满则结果为true。\n\n`示例代码：`\n```go\nfunc canPartition(nums []int) bool {\n    sum := 0\n    for _, n := range nums {\n        sum += n\n    }\n    if sum % 2 != 0 {\n        return false\n    }\n    W := sum >> 1\n    dp := make(map[int]bool)\n    dp[0] = true\n    for _, n := range nums {\n        // 这里进行了空间优化，需要从后向前算，否则计算后面的时候前面的值已经改过，不是上一层的值了。\n        // dp[i][w] = dp[i - 1][w] || dp[i-1][w-v]\n        for i := W; i >= n; i-- {\n            dp[i] = dp[i] || dp[i - n]\n        }\n    }\n    return dp[W]\n}\n```\n\n### 7.3 青蛙过河\n[LeetCode No.403](https://leetcode-cn.com/problems/frog-jump/)\n\n> 题目描述：一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。\n给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。\n如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。\n**输入**：[0,1,3,5,6,8,12,17]\n总共有8个石子。\n第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,\n第三个石子在序号为3的单元格的位置， 以此定义整个数组...\n最后一个石子处于序号为17的单元格的位置。\n**输出**： true。即青蛙可以成功过河，按照如下方案跳跃： \n跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 \n跳2个单位到第4块石子, 然后跳3个单位到第6块石子, \n跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。\n\n**思路**：参考官方题解动态规划的方法，使用dmap[curpos] = {jumps}表示到达当前curpos可以由jumps集合的任意一个步长一次到达当前位置，对于dmap[0] = {0}，依次遍历每个石头的位置，对每个位置pos遍历jumps集合，对每个jump遍历k = [jump-1，jump+1]，如果当前位置跳k补可以到达某个石头的位置（dmap中的存在key=curpos+k），则将k添加到dmap[curpos+k]的集合。\n\n`示例代码：`\n```go\nfunc canCross(stones []int) bool {\n\t// 用集合模拟set，只需要键值当做集合的元素，value设为空结构\n\tdmap := make(map[int]map[int]struct{}, 0)\n\tdmap[0] = map[int]struct{}{0: {}}\n\tfor i := 1; i < len(stones); i++ {\n\t\tdmap[stones[i]] = map[int]struct{}{}\n\t}\n\tfor _, cur_pos := range stones {\n\t\tsteps := dmap[cur_pos]\n\t\tfor step, _ := range steps {\n\t\t\tfor k := step - 1; k <= step + 1; k++ {\n\t\t\t\tif _, ok := dmap[cur_pos + k]; ok == true && k > 0 {\n\t\t\t\t\tdmap[cur_pos + k][k] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn len(dmap[stones[len(stones) - 1]]) != 0\n}\n```\n\n### 7.4 编辑距离\n[LeetCode No.72](https://leetcode-cn.com/problems/edit-distance/)\n\n> 题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。\n\n**思路**：使用dp[i][j]表示从word1[:i]转换为word2[:j]需要的最少次数，对于任意一个单词为空，所需次数为另一个单词的长度，只能通过增或删来达到相同。对于dp[i][j]，dp[i-1][j]表示从word2中删除一个字符得到，dp[i][j - 1]表示从word1中增加一个字符得到，dp[i-1][j-1]表示从word1中修改一个字符得到，对于word1[i] == word2[j]则不需要修改。那么dp[i][j]只能为上述三种情况的最小值。所以有状态转移方程：\n- 当word1[i] == word2[j]时 dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1)\n- 当word1[i] != word2[j]时 dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1\n\n`示例代码：`\n```go\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc minDistance(word1 string, word2 string) int {\n\tLFROM, LTO := len(word1), len(word2)\n\tdp := make([][]int, LFROM + 1)\n\tfor i := 0; i <= LFROM; i++ {\n\t\tdp[i] = make([]int, LTO + 1)\n\t\tdp[i][0] = i\n\t}\n\tfor j := 0; j <= LTO; j++ {\n\t\tdp[0][j] = j\n\t}\n\tfor i := 1; i <= LFROM; i++ {\n\t\tfor j := 1; j <= LTO; j++ {\n\t\t\tif word1[i - 1] == word2[j - 1] {\n\t\t\t\tdp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1)\n\t\t\t} else {\n\t\t\t\tdp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[LFROM][LTO]\n}\n```\n","source":"_posts/2023/03-19-算法-7-动态规划.md","raw":"---\ntitle: '算法(7): 动态规划'\ndate: 2023-03-19 21:56:37\ncategories:\n- [算法]\ntags:\n- leetcode\n- 动态规划\n---\n\n- 动态规划的关键思想在于将问题转换成较小的子问题，然后根据子问题的结果总结出一个状态转移方程，最后得到整个问题的解\n\n### 7.1 打家劫舍\n[LeetCode No.198](https://leetcode-cn.com/problems/house-robber/)\n\n> 问题描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n**思路**：当设选第i个房屋，则不能选i-1，假设dp[i]表示前i个房屋能偷到的最高金额，则有 dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n`示例代码：`\n```go\nfunc rob(nums []int) int {\n    n := len(nums)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return nums[0]\n    }\n    dp := make([]int, n)\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n    ans := dp[1]\n    for i := 2; i < n; i++ {\n        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n        if ans < dp[i] {\n            ans = dp[i]\n        }\n    }\n    return ans\n}\n```\n\n### 7.1-1 打家劫舍2\n[LeetCode No.213](https://leetcode-cn.com/problems/house-robber-ii/)\n\n> 问题描述：房屋变成了环形排列，其他和7.1相同\n\n**思路**：环形排列后，第一个和最后一个不能同时偷，可以转化为[0, n-1]和[1, n]两个单排街道较大值。同时，可以看到第i个问题的最大值只和第i-1和i-2有关，可以只用两个值来保存前两个结果，降低空间复杂度。\n\n`示例代码：`\n```go\nfunc rob(nums []int) int {\n    n := len(nums)\n    if n == 1 {\n        return nums[0]\n    }\n    return max(dorob(nums[1:]), dorob(nums[:n-1]))\n}\n\nfunc dorob(nums []int) int {\n    n := len(nums)\n    if n == 1 {\n        return nums[0]\n    }\n    fisrt, second := nums[0], max(nums[0], nums[1])\n    ans := second\n    for i := 2; i < n; i++ {\n        fisrt, second = second, max(fisrt + nums[i], second)\n        if second > ans {\n            ans = second\n        }\n    }\n    return ans\n}\n```\n\n### 7.2 分割等和子集\n[LeetCode No.416](https://leetcode-cn.com/problems/partition-equal-subset-sum/)\n\n> 问题描述：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n输入: [1, 5, 11, 5]\n输出: true\n解释: 数组可以分割成 [1, 5, 5] 和 [11]\n\n**思路**：如果数组大小为奇数，结果必为false。然后该问题可以转化为背包大小为sum/2的0-1背包问题，如果恰好能装满则结果为true。\n\n`示例代码：`\n```go\nfunc canPartition(nums []int) bool {\n    sum := 0\n    for _, n := range nums {\n        sum += n\n    }\n    if sum % 2 != 0 {\n        return false\n    }\n    W := sum >> 1\n    dp := make(map[int]bool)\n    dp[0] = true\n    for _, n := range nums {\n        // 这里进行了空间优化，需要从后向前算，否则计算后面的时候前面的值已经改过，不是上一层的值了。\n        // dp[i][w] = dp[i - 1][w] || dp[i-1][w-v]\n        for i := W; i >= n; i-- {\n            dp[i] = dp[i] || dp[i - n]\n        }\n    }\n    return dp[W]\n}\n```\n\n### 7.3 青蛙过河\n[LeetCode No.403](https://leetcode-cn.com/problems/frog-jump/)\n\n> 题目描述：一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。\n给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。\n如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。\n**输入**：[0,1,3,5,6,8,12,17]\n总共有8个石子。\n第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,\n第三个石子在序号为3的单元格的位置， 以此定义整个数组...\n最后一个石子处于序号为17的单元格的位置。\n**输出**： true。即青蛙可以成功过河，按照如下方案跳跃： \n跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 \n跳2个单位到第4块石子, 然后跳3个单位到第6块石子, \n跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。\n\n**思路**：参考官方题解动态规划的方法，使用dmap[curpos] = {jumps}表示到达当前curpos可以由jumps集合的任意一个步长一次到达当前位置，对于dmap[0] = {0}，依次遍历每个石头的位置，对每个位置pos遍历jumps集合，对每个jump遍历k = [jump-1，jump+1]，如果当前位置跳k补可以到达某个石头的位置（dmap中的存在key=curpos+k），则将k添加到dmap[curpos+k]的集合。\n\n`示例代码：`\n```go\nfunc canCross(stones []int) bool {\n\t// 用集合模拟set，只需要键值当做集合的元素，value设为空结构\n\tdmap := make(map[int]map[int]struct{}, 0)\n\tdmap[0] = map[int]struct{}{0: {}}\n\tfor i := 1; i < len(stones); i++ {\n\t\tdmap[stones[i]] = map[int]struct{}{}\n\t}\n\tfor _, cur_pos := range stones {\n\t\tsteps := dmap[cur_pos]\n\t\tfor step, _ := range steps {\n\t\t\tfor k := step - 1; k <= step + 1; k++ {\n\t\t\t\tif _, ok := dmap[cur_pos + k]; ok == true && k > 0 {\n\t\t\t\t\tdmap[cur_pos + k][k] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn len(dmap[stones[len(stones) - 1]]) != 0\n}\n```\n\n### 7.4 编辑距离\n[LeetCode No.72](https://leetcode-cn.com/problems/edit-distance/)\n\n> 题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。\n\n**思路**：使用dp[i][j]表示从word1[:i]转换为word2[:j]需要的最少次数，对于任意一个单词为空，所需次数为另一个单词的长度，只能通过增或删来达到相同。对于dp[i][j]，dp[i-1][j]表示从word2中删除一个字符得到，dp[i][j - 1]表示从word1中增加一个字符得到，dp[i-1][j-1]表示从word1中修改一个字符得到，对于word1[i] == word2[j]则不需要修改。那么dp[i][j]只能为上述三种情况的最小值。所以有状态转移方程：\n- 当word1[i] == word2[j]时 dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1)\n- 当word1[i] != word2[j]时 dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1\n\n`示例代码：`\n```go\nfunc min(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc minDistance(word1 string, word2 string) int {\n\tLFROM, LTO := len(word1), len(word2)\n\tdp := make([][]int, LFROM + 1)\n\tfor i := 0; i <= LFROM; i++ {\n\t\tdp[i] = make([]int, LTO + 1)\n\t\tdp[i][0] = i\n\t}\n\tfor j := 0; j <= LTO; j++ {\n\t\tdp[0][j] = j\n\t}\n\tfor i := 1; i <= LFROM; i++ {\n\t\tfor j := 1; j <= LTO; j++ {\n\t\t\tif word1[i - 1] == word2[j - 1] {\n\t\t\t\tdp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1)\n\t\t\t} else {\n\t\t\t\tdp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[LFROM][LTO]\n}\n```\n","slug":"算法-7-动态规划","published":1,"updated":"2023-03-19T13:57:12.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywf000yvhfi26l0a044","content":"<ul>\n<li>动态规划的关键思想在于将问题转换成较小的子问题，然后根据子问题的结果总结出一个状态转移方程，最后得到整个问题的解</li>\n</ul>\n<h3 id=\"7-1-打家劫舍\"><a href=\"#7-1-打家劫舍\" class=\"headerlink\" title=\"7.1 打家劫舍\"></a>7.1 打家劫舍</h3><p><a href=\"https://leetcode-cn.com/problems/house-robber/\">LeetCode No.198</a></p>\n<blockquote>\n<p>问题描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<br>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>\n</blockquote>\n<p><strong>思路</strong>：当设选第i个房屋，则不能选i-1，假设dp[i]表示前i个房屋能偷到的最高金额，则有 dp[i] &#x3D; max(dp[i - 1], dp[i - 2] + nums[i])</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rob</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>], dp[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>], max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>])</span><br><span class=\"line\">    ans := dp[<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">2</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        dp[i] = max(dp[i - <span class=\"number\">2</span>] + nums[i], dp[i - <span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ans &lt; dp[i] &#123;</span><br><span class=\"line\">            ans = dp[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-1-打家劫舍2\"><a href=\"#7-1-1-打家劫舍2\" class=\"headerlink\" title=\"7.1-1 打家劫舍2\"></a>7.1-1 打家劫舍2</h3><p><a href=\"https://leetcode-cn.com/problems/house-robber-ii/\">LeetCode No.213</a></p>\n<blockquote>\n<p>问题描述：房屋变成了环形排列，其他和7.1相同</p>\n</blockquote>\n<p><strong>思路</strong>：环形排列后，第一个和最后一个不能同时偷，可以转化为[0, n-1]和[1, n]两个单排街道较大值。同时，可以看到第i个问题的最大值只和第i-1和i-2有关，可以只用两个值来保存前两个结果，降低空间复杂度。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rob</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(dorob(nums[<span class=\"number\">1</span>:]), dorob(nums[:n<span class=\"number\">-1</span>]))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dorob</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fisrt, second := nums[<span class=\"number\">0</span>], max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>])</span><br><span class=\"line\">    ans := second</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">2</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        fisrt, second = second, max(fisrt + nums[i], second)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> second &gt; ans &#123;</span><br><span class=\"line\">            ans = second</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-2-分割等和子集\"><a href=\"#7-2-分割等和子集\" class=\"headerlink\" title=\"7.2 分割等和子集\"></a>7.2 分割等和子集</h3><p><a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/\">LeetCode No.416</a></p>\n<blockquote>\n<p>问题描述：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>输入: [1, 5, 11, 5]<br>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11]</p>\n</blockquote>\n<p><strong>思路</strong>：如果数组大小为奇数，结果必为false。然后该问题可以转化为背包大小为sum&#x2F;2的0-1背包问题，如果恰好能装满则结果为true。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">canPartition</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    sum := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        sum += n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> sum % <span class=\"number\">2</span> != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    W := sum &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">    dp := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里进行了空间优化，需要从后向前算，否则计算后面的时候前面的值已经改过，不是上一层的值了。</span></span><br><span class=\"line\">        <span class=\"comment\">// dp[i][w] = dp[i - 1][w] || dp[i-1][w-v]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := W; i &gt;= n; i-- &#123;</span><br><span class=\"line\">            dp[i] = dp[i] || dp[i - n]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[W]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-3-青蛙过河\"><a href=\"#7-3-青蛙过河\" class=\"headerlink\" title=\"7.3 青蛙过河\"></a>7.3 青蛙过河</h3><p><a href=\"https://leetcode-cn.com/problems/frog-jump/\">LeetCode No.403</a></p>\n<blockquote>\n<p>题目描述：一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。<br>给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。<br>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。<br><strong>输入</strong>：[0,1,3,5,6,8,12,17]<br>总共有8个石子。<br>第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,<br>第三个石子在序号为3的单元格的位置， 以此定义整个数组…<br>最后一个石子处于序号为17的单元格的位置。<br><strong>输出</strong>： true。即青蛙可以成功过河，按照如下方案跳跃：<br>跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着<br>跳2个单位到第4块石子, 然后跳3个单位到第6块石子,<br>跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。</p>\n</blockquote>\n<p><strong>思路</strong>：参考官方题解动态规划的方法，使用dmap[curpos] &#x3D; {jumps}表示到达当前curpos可以由jumps集合的任意一个步长一次到达当前位置，对于dmap[0] &#x3D; {0}，依次遍历每个石头的位置，对每个位置pos遍历jumps集合，对每个jump遍历k &#x3D; [jump-1，jump+1]，如果当前位置跳k补可以到达某个石头的位置（dmap中的存在key&#x3D;curpos+k），则将k添加到dmap[curpos+k]的集合。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">canCross</span><span class=\"params\">(stones []<span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 用集合模拟set，只需要键值当做集合的元素，value设为空结构</span></span><br><span class=\"line\">\tdmap := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">\tdmap[<span class=\"number\">0</span>] = <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">struct</span>&#123;&#125;&#123;<span class=\"number\">0</span>: &#123;&#125;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">len</span>(stones); i++ &#123;</span><br><span class=\"line\">\t\tdmap[stones[i]] = <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, cur_pos := <span class=\"keyword\">range</span> stones &#123;</span><br><span class=\"line\">\t\tsteps := dmap[cur_pos]</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> step, _ := <span class=\"keyword\">range</span> steps &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> k := step - <span class=\"number\">1</span>; k &lt;= step + <span class=\"number\">1</span>; k++ &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> _, ok := dmap[cur_pos + k]; ok == <span class=\"literal\">true</span> &amp;&amp; k &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tdmap[cur_pos + k][k] = <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(dmap[stones[<span class=\"built_in\">len</span>(stones) - <span class=\"number\">1</span>]]) != <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-4-编辑距离\"><a href=\"#7-4-编辑距离\" class=\"headerlink\" title=\"7.4 编辑距离\"></a>7.4 编辑距离</h3><p><a href=\"https://leetcode-cn.com/problems/edit-distance/\">LeetCode No.72</a></p>\n<blockquote>\n<p>题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。</p>\n</blockquote>\n<p><strong>思路</strong>：使用dp[i][j]表示从word1[:i]转换为word2[:j]需要的最少次数，对于任意一个单词为空，所需次数为另一个单词的长度，只能通过增或删来达到相同。对于dp[i][j]，dp[i-1][j]表示从word2中删除一个字符得到，dp[i][j - 1]表示从word1中增加一个字符得到，dp[i-1][j-1]表示从word1中修改一个字符得到，对于word1[i] &#x3D;&#x3D; word2[j]则不需要修改。那么dp[i][j]只能为上述三种情况的最小值。所以有状态转移方程：</p>\n<ul>\n<li>当word1[i] &#x3D;&#x3D; word2[j]时 dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1)</li>\n<li>当word1[i] !&#x3D; word2[j]时 dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt; y &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minDistance</span><span class=\"params\">(word1 <span class=\"type\">string</span>, word2 <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tLFROM, LTO := <span class=\"built_in\">len</span>(word1), <span class=\"built_in\">len</span>(word2)</span><br><span class=\"line\">\tdp := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, LFROM + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;= LFROM; i++ &#123;</span><br><span class=\"line\">\t\tdp[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, LTO + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tdp[i][<span class=\"number\">0</span>] = i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt;= LTO; j++ &#123;</span><br><span class=\"line\">\t\tdp[<span class=\"number\">0</span>][j] = j</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= LFROM; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j := <span class=\"number\">1</span>; j &lt;= LTO; j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> word1[i - <span class=\"number\">1</span>] == word2[j - <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = min(dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], min(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]) + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = min(dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], min(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>])) + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[LFROM][LTO]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>动态规划的关键思想在于将问题转换成较小的子问题，然后根据子问题的结果总结出一个状态转移方程，最后得到整个问题的解</li>\n</ul>\n<h3 id=\"7-1-打家劫舍\"><a href=\"#7-1-打家劫舍\" class=\"headerlink\" title=\"7.1 打家劫舍\"></a>7.1 打家劫舍</h3><p><a href=\"https://leetcode-cn.com/problems/house-robber/\">LeetCode No.198</a></p>\n<blockquote>\n<p>问题描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<br>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>\n</blockquote>\n<p><strong>思路</strong>：当设选第i个房屋，则不能选i-1，假设dp[i]表示前i个房屋能偷到的最高金额，则有 dp[i] &#x3D; max(dp[i - 1], dp[i - 2] + nums[i])</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rob</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>], dp[<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>], max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>])</span><br><span class=\"line\">    ans := dp[<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">2</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        dp[i] = max(dp[i - <span class=\"number\">2</span>] + nums[i], dp[i - <span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ans &lt; dp[i] &#123;</span><br><span class=\"line\">            ans = dp[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-1-打家劫舍2\"><a href=\"#7-1-1-打家劫舍2\" class=\"headerlink\" title=\"7.1-1 打家劫舍2\"></a>7.1-1 打家劫舍2</h3><p><a href=\"https://leetcode-cn.com/problems/house-robber-ii/\">LeetCode No.213</a></p>\n<blockquote>\n<p>问题描述：房屋变成了环形排列，其他和7.1相同</p>\n</blockquote>\n<p><strong>思路</strong>：环形排列后，第一个和最后一个不能同时偷，可以转化为[0, n-1]和[1, n]两个单排街道较大值。同时，可以看到第i个问题的最大值只和第i-1和i-2有关，可以只用两个值来保存前两个结果，降低空间复杂度。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rob</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(dorob(nums[<span class=\"number\">1</span>:]), dorob(nums[:n<span class=\"number\">-1</span>]))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dorob</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fisrt, second := nums[<span class=\"number\">0</span>], max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>])</span><br><span class=\"line\">    ans := second</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">2</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        fisrt, second = second, max(fisrt + nums[i], second)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> second &gt; ans &#123;</span><br><span class=\"line\">            ans = second</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-2-分割等和子集\"><a href=\"#7-2-分割等和子集\" class=\"headerlink\" title=\"7.2 分割等和子集\"></a>7.2 分割等和子集</h3><p><a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/\">LeetCode No.416</a></p>\n<blockquote>\n<p>问题描述：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>输入: [1, 5, 11, 5]<br>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11]</p>\n</blockquote>\n<p><strong>思路</strong>：如果数组大小为奇数，结果必为false。然后该问题可以转化为背包大小为sum&#x2F;2的0-1背包问题，如果恰好能装满则结果为true。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">canPartition</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    sum := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        sum += n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> sum % <span class=\"number\">2</span> != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    W := sum &gt;&gt; <span class=\"number\">1</span></span><br><span class=\"line\">    dp := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">bool</span>)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, n := <span class=\"keyword\">range</span> nums &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里进行了空间优化，需要从后向前算，否则计算后面的时候前面的值已经改过，不是上一层的值了。</span></span><br><span class=\"line\">        <span class=\"comment\">// dp[i][w] = dp[i - 1][w] || dp[i-1][w-v]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := W; i &gt;= n; i-- &#123;</span><br><span class=\"line\">            dp[i] = dp[i] || dp[i - n]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[W]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-3-青蛙过河\"><a href=\"#7-3-青蛙过河\" class=\"headerlink\" title=\"7.3 青蛙过河\"></a>7.3 青蛙过河</h3><p><a href=\"https://leetcode-cn.com/problems/frog-jump/\">LeetCode No.403</a></p>\n<blockquote>\n<p>题目描述：一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。<br>给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。<br>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。<br><strong>输入</strong>：[0,1,3,5,6,8,12,17]<br>总共有8个石子。<br>第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,<br>第三个石子在序号为3的单元格的位置， 以此定义整个数组…<br>最后一个石子处于序号为17的单元格的位置。<br><strong>输出</strong>： true。即青蛙可以成功过河，按照如下方案跳跃：<br>跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着<br>跳2个单位到第4块石子, 然后跳3个单位到第6块石子,<br>跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。</p>\n</blockquote>\n<p><strong>思路</strong>：参考官方题解动态规划的方法，使用dmap[curpos] &#x3D; {jumps}表示到达当前curpos可以由jumps集合的任意一个步长一次到达当前位置，对于dmap[0] &#x3D; {0}，依次遍历每个石头的位置，对每个位置pos遍历jumps集合，对每个jump遍历k &#x3D; [jump-1，jump+1]，如果当前位置跳k补可以到达某个石头的位置（dmap中的存在key&#x3D;curpos+k），则将k添加到dmap[curpos+k]的集合。</p>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">canCross</span><span class=\"params\">(stones []<span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 用集合模拟set，只需要键值当做集合的元素，value设为空结构</span></span><br><span class=\"line\">\tdmap := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">\tdmap[<span class=\"number\">0</span>] = <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">struct</span>&#123;&#125;&#123;<span class=\"number\">0</span>: &#123;&#125;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">len</span>(stones); i++ &#123;</span><br><span class=\"line\">\t\tdmap[stones[i]] = <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, cur_pos := <span class=\"keyword\">range</span> stones &#123;</span><br><span class=\"line\">\t\tsteps := dmap[cur_pos]</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> step, _ := <span class=\"keyword\">range</span> steps &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> k := step - <span class=\"number\">1</span>; k &lt;= step + <span class=\"number\">1</span>; k++ &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> _, ok := dmap[cur_pos + k]; ok == <span class=\"literal\">true</span> &amp;&amp; k &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tdmap[cur_pos + k][k] = <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(dmap[stones[<span class=\"built_in\">len</span>(stones) - <span class=\"number\">1</span>]]) != <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-4-编辑距离\"><a href=\"#7-4-编辑距离\" class=\"headerlink\" title=\"7.4 编辑距离\"></a>7.4 编辑距离</h3><p><a href=\"https://leetcode-cn.com/problems/edit-distance/\">LeetCode No.72</a></p>\n<blockquote>\n<p>题目描述：给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。</p>\n</blockquote>\n<p><strong>思路</strong>：使用dp[i][j]表示从word1[:i]转换为word2[:j]需要的最少次数，对于任意一个单词为空，所需次数为另一个单词的长度，只能通过增或删来达到相同。对于dp[i][j]，dp[i-1][j]表示从word2中删除一个字符得到，dp[i][j - 1]表示从word1中增加一个字符得到，dp[i-1][j-1]表示从word1中修改一个字符得到，对于word1[i] &#x3D;&#x3D; word2[j]则不需要修改。那么dp[i][j]只能为上述三种情况的最小值。所以有状态转移方程：</p>\n<ul>\n<li>当word1[i] &#x3D;&#x3D; word2[j]时 dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1)</li>\n<li>当word1[i] !&#x3D; word2[j]时 dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1</li>\n</ul>\n<p><code>示例代码：</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt; y &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minDistance</span><span class=\"params\">(word1 <span class=\"type\">string</span>, word2 <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tLFROM, LTO := <span class=\"built_in\">len</span>(word1), <span class=\"built_in\">len</span>(word2)</span><br><span class=\"line\">\tdp := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, LFROM + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;= LFROM; i++ &#123;</span><br><span class=\"line\">\t\tdp[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, LTO + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tdp[i][<span class=\"number\">0</span>] = i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt;= LTO; j++ &#123;</span><br><span class=\"line\">\t\tdp[<span class=\"number\">0</span>][j] = j</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= LFROM; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j := <span class=\"number\">1</span>; j &lt;= LTO; j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> word1[i - <span class=\"number\">1</span>] == word2[j - <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = min(dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], min(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]) + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = min(dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], min(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>])) + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp[LFROM][LTO]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法(8): LRU 策略","date":"2023-03-19T13:58:05.000Z","_content":"\n[LeetCode No.146 LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)\n\nLRU（Least Recent Used）策略：优先淘汰最近最少使用的数据，常用于缓存淘汰机制，如Linux系统的内存淘汰、Redis的缓存淘汰等。\n\n## 基于哈希表和双向链表实现LRU\n核心思路是，利用双向链表存储键值对，哈希表存储键在链表中对应的节点指针，如下图所示\n![](https://upload-images.jianshu.io/upload_images/14151453-0372ff8cff5afd07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样的好处是使访问和更新操作时间复杂度都在O(1)。\n\n### PUT操作\n- 判断哈希表中key是否已存在，如果存在为修改操作：\n  1. 将链表节点修改为新的键值对\n  2. 将节点移到头部\n- 如果不存在为新增操作，此时如果容量已满，需要淘汰数据\n  1. 取出链表尾节点，删除哈希表中对应key\n  2. 删除链表尾节点\n  3. 在链表头部添加新的节点\n  4. 将新的链表头节点加到哈希表\n- 如果容量没有满，直接添加节点，执行上述步骤3、4即可\n\n### GET操作\n- 判断哈希表中key是否存在，如果存在将节点移动到链表头部，返回对应的值\n- 如果不存在直接返回nil值\n\n### Go语言实现\n使用Go内建map类型和container包的list（双向链表）\n```go\nimport (\n\t\"container/list\"\n)\n\ntype Pair struct {\n\tkey int\n\tval int\n}\n\ntype LRUCache struct {\n\tcap int\n\tlist *list.List\n\tkv map[int]*list.Element\n}\n\n\nfunc Constructor(capacity int) LRUCache {\n\treturn LRUCache{\n\t\tcap: capacity,\n\t\tlist: list.New(),\n\t\tkv: make(map[int]*list.Element),\n\t}\n}\n\n\nfunc (this *LRUCache) Get(key int) int {\n\tif v, ok := this.kv[key]; ok == true {\n\t\tthis.list.MoveToFront(v)\n\t\treturn v.Value.(Pair).val\n\t} else {\n\t\treturn -1\n\t}\n}\n\n\nfunc (this *LRUCache) Put(key int, value int)  {\n\tif elem, ok := this.kv[key]; ok == true {\n\t\telem.Value = Pair{key: key, val: value}\n\t\tthis.list.MoveToFront(elem)\n\t\treturn\n\t}\n\tif this.list.Len() >= this.cap {\n\t\tdelete(this.kv, this.list.Back().Value.(Pair).key)\n\t\tthis.list.Remove(this.list.Back())\n\t}\n\tthis.list.PushFront(Pair{key: key, val: value})\n\tthis.kv[key] = this.list.Front()\n}\n```\n","source":"_posts/2023/03-19-算法-8-LRU-策略.md","raw":"---\ntitle: '算法(8): LRU 策略'\ndate: 2023-03-19 21:58:05\ncategories:\n- [算法]\ntags:\n- leetcode\n- LRU\n- 缓存\n---\n\n[LeetCode No.146 LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)\n\nLRU（Least Recent Used）策略：优先淘汰最近最少使用的数据，常用于缓存淘汰机制，如Linux系统的内存淘汰、Redis的缓存淘汰等。\n\n## 基于哈希表和双向链表实现LRU\n核心思路是，利用双向链表存储键值对，哈希表存储键在链表中对应的节点指针，如下图所示\n![](https://upload-images.jianshu.io/upload_images/14151453-0372ff8cff5afd07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这样的好处是使访问和更新操作时间复杂度都在O(1)。\n\n### PUT操作\n- 判断哈希表中key是否已存在，如果存在为修改操作：\n  1. 将链表节点修改为新的键值对\n  2. 将节点移到头部\n- 如果不存在为新增操作，此时如果容量已满，需要淘汰数据\n  1. 取出链表尾节点，删除哈希表中对应key\n  2. 删除链表尾节点\n  3. 在链表头部添加新的节点\n  4. 将新的链表头节点加到哈希表\n- 如果容量没有满，直接添加节点，执行上述步骤3、4即可\n\n### GET操作\n- 判断哈希表中key是否存在，如果存在将节点移动到链表头部，返回对应的值\n- 如果不存在直接返回nil值\n\n### Go语言实现\n使用Go内建map类型和container包的list（双向链表）\n```go\nimport (\n\t\"container/list\"\n)\n\ntype Pair struct {\n\tkey int\n\tval int\n}\n\ntype LRUCache struct {\n\tcap int\n\tlist *list.List\n\tkv map[int]*list.Element\n}\n\n\nfunc Constructor(capacity int) LRUCache {\n\treturn LRUCache{\n\t\tcap: capacity,\n\t\tlist: list.New(),\n\t\tkv: make(map[int]*list.Element),\n\t}\n}\n\n\nfunc (this *LRUCache) Get(key int) int {\n\tif v, ok := this.kv[key]; ok == true {\n\t\tthis.list.MoveToFront(v)\n\t\treturn v.Value.(Pair).val\n\t} else {\n\t\treturn -1\n\t}\n}\n\n\nfunc (this *LRUCache) Put(key int, value int)  {\n\tif elem, ok := this.kv[key]; ok == true {\n\t\telem.Value = Pair{key: key, val: value}\n\t\tthis.list.MoveToFront(elem)\n\t\treturn\n\t}\n\tif this.list.Len() >= this.cap {\n\t\tdelete(this.kv, this.list.Back().Value.(Pair).key)\n\t\tthis.list.Remove(this.list.Back())\n\t}\n\tthis.list.PushFront(Pair{key: key, val: value})\n\tthis.kv[key] = this.list.Front()\n}\n```\n","slug":"算法-8-LRU-策略","published":1,"updated":"2023-03-19T14:00:33.583Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywf0011vhfigddah650","content":"<p><a href=\"https://leetcode-cn.com/problems/lru-cache/\">LeetCode No.146 LRU缓存机制</a></p>\n<p>LRU（Least Recent Used）策略：优先淘汰最近最少使用的数据，常用于缓存淘汰机制，如Linux系统的内存淘汰、Redis的缓存淘汰等。</p>\n<h2 id=\"基于哈希表和双向链表实现LRU\"><a href=\"#基于哈希表和双向链表实现LRU\" class=\"headerlink\" title=\"基于哈希表和双向链表实现LRU\"></a>基于哈希表和双向链表实现LRU</h2><p>核心思路是，利用双向链表存储键值对，哈希表存储键在链表中对应的节点指针，如下图所示<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-0372ff8cff5afd07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-0372ff8cff5afd07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>这样的好处是使访问和更新操作时间复杂度都在O(1)。</p>\n<h3 id=\"PUT操作\"><a href=\"#PUT操作\" class=\"headerlink\" title=\"PUT操作\"></a>PUT操作</h3><ul>\n<li>判断哈希表中key是否已存在，如果存在为修改操作：<ol>\n<li>将链表节点修改为新的键值对</li>\n<li>将节点移到头部</li>\n</ol>\n</li>\n<li>如果不存在为新增操作，此时如果容量已满，需要淘汰数据<ol>\n<li>取出链表尾节点，删除哈希表中对应key</li>\n<li>删除链表尾节点</li>\n<li>在链表头部添加新的节点</li>\n<li>将新的链表头节点加到哈希表</li>\n</ol>\n</li>\n<li>如果容量没有满，直接添加节点，执行上述步骤3、4即可</li>\n</ul>\n<h3 id=\"GET操作\"><a href=\"#GET操作\" class=\"headerlink\" title=\"GET操作\"></a>GET操作</h3><ul>\n<li>判断哈希表中key是否存在，如果存在将节点移动到链表头部，返回对应的值</li>\n<li>如果不存在直接返回nil值</li>\n</ul>\n<h3 id=\"Go语言实现\"><a href=\"#Go语言实现\" class=\"headerlink\" title=\"Go语言实现\"></a>Go语言实现</h3><p>使用Go内建map类型和container包的list（双向链表）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;container/list&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Pair <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tkey <span class=\"type\">int</span></span><br><span class=\"line\">\tval <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LRUCache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cap</span> <span class=\"type\">int</span></span><br><span class=\"line\">\tlist *list.List</span><br><span class=\"line\">\tkv <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*list.Element</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(capacity <span class=\"type\">int</span>)</span></span> LRUCache &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> LRUCache&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cap</span>: capacity,</span><br><span class=\"line\">\t\tlist: list.New(),</span><br><span class=\"line\">\t\tkv: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*list.Element),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Get(key <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v, ok := this.kv[key]; ok == <span class=\"literal\">true</span> &#123;</span><br><span class=\"line\">\t\tthis.list.MoveToFront(v)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v.Value.(Pair).val</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Put(key <span class=\"type\">int</span>, value <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> elem, ok := this.kv[key]; ok == <span class=\"literal\">true</span> &#123;</span><br><span class=\"line\">\t\telem.Value = Pair&#123;key: key, val: value&#125;</span><br><span class=\"line\">\t\tthis.list.MoveToFront(elem)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> this.list.Len() &gt;= this.<span class=\"built_in\">cap</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">delete</span>(this.kv, this.list.Back().Value.(Pair).key)</span><br><span class=\"line\">\t\tthis.list.Remove(this.list.Back())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis.list.PushFront(Pair&#123;key: key, val: value&#125;)</span><br><span class=\"line\">\tthis.kv[key] = this.list.Front()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://leetcode-cn.com/problems/lru-cache/\">LeetCode No.146 LRU缓存机制</a></p>\n<p>LRU（Least Recent Used）策略：优先淘汰最近最少使用的数据，常用于缓存淘汰机制，如Linux系统的内存淘汰、Redis的缓存淘汰等。</p>\n<h2 id=\"基于哈希表和双向链表实现LRU\"><a href=\"#基于哈希表和双向链表实现LRU\" class=\"headerlink\" title=\"基于哈希表和双向链表实现LRU\"></a>基于哈希表和双向链表实现LRU</h2><p>核心思路是，利用双向链表存储键值对，哈希表存储键在链表中对应的节点指针，如下图所示<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-0372ff8cff5afd07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>这样的好处是使访问和更新操作时间复杂度都在O(1)。</p>\n<h3 id=\"PUT操作\"><a href=\"#PUT操作\" class=\"headerlink\" title=\"PUT操作\"></a>PUT操作</h3><ul>\n<li>判断哈希表中key是否已存在，如果存在为修改操作：<ol>\n<li>将链表节点修改为新的键值对</li>\n<li>将节点移到头部</li>\n</ol>\n</li>\n<li>如果不存在为新增操作，此时如果容量已满，需要淘汰数据<ol>\n<li>取出链表尾节点，删除哈希表中对应key</li>\n<li>删除链表尾节点</li>\n<li>在链表头部添加新的节点</li>\n<li>将新的链表头节点加到哈希表</li>\n</ol>\n</li>\n<li>如果容量没有满，直接添加节点，执行上述步骤3、4即可</li>\n</ul>\n<h3 id=\"GET操作\"><a href=\"#GET操作\" class=\"headerlink\" title=\"GET操作\"></a>GET操作</h3><ul>\n<li>判断哈希表中key是否存在，如果存在将节点移动到链表头部，返回对应的值</li>\n<li>如果不存在直接返回nil值</li>\n</ul>\n<h3 id=\"Go语言实现\"><a href=\"#Go语言实现\" class=\"headerlink\" title=\"Go语言实现\"></a>Go语言实现</h3><p>使用Go内建map类型和container包的list（双向链表）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;container/list&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Pair <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tkey <span class=\"type\">int</span></span><br><span class=\"line\">\tval <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LRUCache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cap</span> <span class=\"type\">int</span></span><br><span class=\"line\">\tlist *list.List</span><br><span class=\"line\">\tkv <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*list.Element</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(capacity <span class=\"type\">int</span>)</span></span> LRUCache &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> LRUCache&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cap</span>: capacity,</span><br><span class=\"line\">\t\tlist: list.New(),</span><br><span class=\"line\">\t\tkv: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*list.Element),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Get(key <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v, ok := this.kv[key]; ok == <span class=\"literal\">true</span> &#123;</span><br><span class=\"line\">\t\tthis.list.MoveToFront(v)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v.Value.(Pair).val</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Put(key <span class=\"type\">int</span>, value <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> elem, ok := this.kv[key]; ok == <span class=\"literal\">true</span> &#123;</span><br><span class=\"line\">\t\telem.Value = Pair&#123;key: key, val: value&#125;</span><br><span class=\"line\">\t\tthis.list.MoveToFront(elem)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> this.list.Len() &gt;= this.<span class=\"built_in\">cap</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">delete</span>(this.kv, this.list.Back().Value.(Pair).key)</span><br><span class=\"line\">\t\tthis.list.Remove(this.list.Back())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis.list.PushFront(Pair&#123;key: key, val: value&#125;)</span><br><span class=\"line\">\tthis.kv[key] = this.list.Front()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"HTTPS原理详解","date":"2023-03-25T06:43:24.000Z","_content":"\nWeb应用存在HTTP和HTTPS两种通信方式，HTTP默认端口80，数据以明文传输，HTTPS默认端口443，数据加密传输。\n\n## HTTPS协议\nHTTPS实际上并不是一种新的网络协议，是HTTP的基础上加了SSL层，数据的加密就是在SSL层完成的。\n![](https://upload-images.jianshu.io/upload_images/14151453-4915c1ecfe442f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 数据传输方式\n\n### 明文传输\n客户端和服务器已明文方式传输数据，没有安全性，数据再传输过程中可能被劫持和篡改\n![](https://upload-images.jianshu.io/upload_images/14151453-af0efb8a2b3599db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 对称加密传输\n对称加密算法：双方使用同一秘钥对数据进行加解密（AES、DES）\n![](https://upload-images.jianshu.io/upload_images/14151453-046d2c536baae247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**特点**：\n- 如果不知道秘钥，是无法解出对应的明文，但是如果所有客户端都用相同的秘钥，相当于没有加密，坏人也可以作为一个用户拿到秘钥。\n- 加解密性能高\n\n一种改进的方案是每个客户端先协商一个加密算法和秘钥，不同客户端使用不同的算法和秘钥，这就坏人即使作为一个用户也不知道别的用户的秘钥。但是这种方式协商秘钥的过程是公开明文的，坏人也有办法窃取到秘钥的，仍然存在风险。\n\n### 非对称加密传输\n非对称加密算法：加密解密采用不同的秘钥，私钥加密后的密文，所有的公钥都可以解密，公钥加密后的密文只有私钥能解密。私钥通常只有一个人有，公钥可以公开发给所有人。（常见算法：RSA）\n![](https://upload-images.jianshu.io/upload_images/14151453-eefe11cf0a2b22f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n**特点**：\n- 只要把私钥保存在服务器，公钥发给客户端，那么客户端向服务器发送的数据就是安全的，但是服务器向客户端发送的数据坏人也可以通过公钥解密\n- 加解密消耗的时间较长，传输效率会降低\n\n### HTTPS（对称加密+非对称加密）\n![](https://upload-images.jianshu.io/upload_images/14151453-9a21634026ce4d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**特点**：\n- 使用非对称加密传输协商一个对称加密算法和秘钥\n- 使用对称加密算法对数据加密传输\n- 数据双向安全，且效率较高\n\n## CA机构和数字证书\n从前面可以看到，协商阶段时候用非对称加密，客户端一开始就要持有公钥，那么客户端如何安全的获取公钥呢？\n如果服务端直接将公钥发给客户端，中间可能被坏人劫持，返回一个假公钥，客户端使用假公钥进行加密后请求，坏人就可以使用假私钥解出明文，篡改内容后再使用真公钥加密后请求到服务器，这时服务器拿到的是被篡改后的数据。\n![](https://upload-images.jianshu.io/upload_images/14151453-fb5c49e4b5019e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n数字证书和CA机构就是用来保证服务器安全的发送公钥给客户端的。\n**校验过程**\n1. 读取证书中的所有者，有效期等信息进行校验\n2. 查找系统内置的受信任证书发布机构CA，与服务器下发的证书中的CA对比，校验是否是合法机构颁发\n3. 如果找不到，浏览器报错警告证书不可信\n4. 如果找到了：\n- 对证书里的数字签名使用公钥解密得到明文的hash摘要\n- 浏览器使用相同的hash算法计算明文的hash值，将这个值与上述计算的摘要对比验证证书的合法性。\n\n## 总结\n一个完整的HTTPS请求流程如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-06d256f8dff32472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 参考\n【1】[【掘金】深入理解HTTPS工作原理](https://juejin.cn/post/6844903830916694030)\n","source":"_posts/2023/03-25-HTTPS原理详解.md","raw":"---\ntitle: HTTPS原理详解\ndate: 2023-03-25 14:43:24\ncategories:\n- [计算机网络]\ntags:\n- HTTPS\n---\n\nWeb应用存在HTTP和HTTPS两种通信方式，HTTP默认端口80，数据以明文传输，HTTPS默认端口443，数据加密传输。\n\n## HTTPS协议\nHTTPS实际上并不是一种新的网络协议，是HTTP的基础上加了SSL层，数据的加密就是在SSL层完成的。\n![](https://upload-images.jianshu.io/upload_images/14151453-4915c1ecfe442f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 数据传输方式\n\n### 明文传输\n客户端和服务器已明文方式传输数据，没有安全性，数据再传输过程中可能被劫持和篡改\n![](https://upload-images.jianshu.io/upload_images/14151453-af0efb8a2b3599db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 对称加密传输\n对称加密算法：双方使用同一秘钥对数据进行加解密（AES、DES）\n![](https://upload-images.jianshu.io/upload_images/14151453-046d2c536baae247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**特点**：\n- 如果不知道秘钥，是无法解出对应的明文，但是如果所有客户端都用相同的秘钥，相当于没有加密，坏人也可以作为一个用户拿到秘钥。\n- 加解密性能高\n\n一种改进的方案是每个客户端先协商一个加密算法和秘钥，不同客户端使用不同的算法和秘钥，这就坏人即使作为一个用户也不知道别的用户的秘钥。但是这种方式协商秘钥的过程是公开明文的，坏人也有办法窃取到秘钥的，仍然存在风险。\n\n### 非对称加密传输\n非对称加密算法：加密解密采用不同的秘钥，私钥加密后的密文，所有的公钥都可以解密，公钥加密后的密文只有私钥能解密。私钥通常只有一个人有，公钥可以公开发给所有人。（常见算法：RSA）\n![](https://upload-images.jianshu.io/upload_images/14151453-eefe11cf0a2b22f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n**特点**：\n- 只要把私钥保存在服务器，公钥发给客户端，那么客户端向服务器发送的数据就是安全的，但是服务器向客户端发送的数据坏人也可以通过公钥解密\n- 加解密消耗的时间较长，传输效率会降低\n\n### HTTPS（对称加密+非对称加密）\n![](https://upload-images.jianshu.io/upload_images/14151453-9a21634026ce4d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**特点**：\n- 使用非对称加密传输协商一个对称加密算法和秘钥\n- 使用对称加密算法对数据加密传输\n- 数据双向安全，且效率较高\n\n## CA机构和数字证书\n从前面可以看到，协商阶段时候用非对称加密，客户端一开始就要持有公钥，那么客户端如何安全的获取公钥呢？\n如果服务端直接将公钥发给客户端，中间可能被坏人劫持，返回一个假公钥，客户端使用假公钥进行加密后请求，坏人就可以使用假私钥解出明文，篡改内容后再使用真公钥加密后请求到服务器，这时服务器拿到的是被篡改后的数据。\n![](https://upload-images.jianshu.io/upload_images/14151453-fb5c49e4b5019e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n数字证书和CA机构就是用来保证服务器安全的发送公钥给客户端的。\n**校验过程**\n1. 读取证书中的所有者，有效期等信息进行校验\n2. 查找系统内置的受信任证书发布机构CA，与服务器下发的证书中的CA对比，校验是否是合法机构颁发\n3. 如果找不到，浏览器报错警告证书不可信\n4. 如果找到了：\n- 对证书里的数字签名使用公钥解密得到明文的hash摘要\n- 浏览器使用相同的hash算法计算明文的hash值，将这个值与上述计算的摘要对比验证证书的合法性。\n\n## 总结\n一个完整的HTTPS请求流程如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-06d256f8dff32472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 参考\n【1】[【掘金】深入理解HTTPS工作原理](https://juejin.cn/post/6844903830916694030)\n","slug":"HTTPS原理详解","published":1,"updated":"2023-03-25T06:58:23.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywg0014vhfi388t5ulg","content":"<p>Web应用存在HTTP和HTTPS两种通信方式，HTTP默认端口80，数据以明文传输，HTTPS默认端口443，数据加密传输。</p>\n<h2 id=\"HTTPS协议\"><a href=\"#HTTPS协议\" class=\"headerlink\" title=\"HTTPS协议\"></a>HTTPS协议</h2><p>HTTPS实际上并不是一种新的网络协议，是HTTP的基础上加了SSL层，数据的加密就是在SSL层完成的。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-4915c1ecfe442f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-4915c1ecfe442f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h2 id=\"数据传输方式\"><a href=\"#数据传输方式\" class=\"headerlink\" title=\"数据传输方式\"></a>数据传输方式</h2><h3 id=\"明文传输\"><a href=\"#明文传输\" class=\"headerlink\" title=\"明文传输\"></a>明文传输</h3><p>客户端和服务器已明文方式传输数据，没有安全性，数据再传输过程中可能被劫持和篡改<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-af0efb8a2b3599db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-af0efb8a2b3599db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h3 id=\"对称加密传输\"><a href=\"#对称加密传输\" class=\"headerlink\" title=\"对称加密传输\"></a>对称加密传输</h3><p>对称加密算法：双方使用同一秘钥对数据进行加解密（AES、DES）<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-046d2c536baae247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-046d2c536baae247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br><strong>特点</strong>：</p>\n<ul>\n<li>如果不知道秘钥，是无法解出对应的明文，但是如果所有客户端都用相同的秘钥，相当于没有加密，坏人也可以作为一个用户拿到秘钥。</li>\n<li>加解密性能高</li>\n</ul>\n<p>一种改进的方案是每个客户端先协商一个加密算法和秘钥，不同客户端使用不同的算法和秘钥，这就坏人即使作为一个用户也不知道别的用户的秘钥。但是这种方式协商秘钥的过程是公开明文的，坏人也有办法窃取到秘钥的，仍然存在风险。</p>\n<h3 id=\"非对称加密传输\"><a href=\"#非对称加密传输\" class=\"headerlink\" title=\"非对称加密传输\"></a>非对称加密传输</h3><p>非对称加密算法：加密解密采用不同的秘钥，私钥加密后的密文，所有的公钥都可以解密，公钥加密后的密文只有私钥能解密。私钥通常只有一个人有，公钥可以公开发给所有人。（常见算法：RSA）<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-eefe11cf0a2b22f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-eefe11cf0a2b22f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>只要把私钥保存在服务器，公钥发给客户端，那么客户端向服务器发送的数据就是安全的，但是服务器向客户端发送的数据坏人也可以通过公钥解密</li>\n<li>加解密消耗的时间较长，传输效率会降低</li>\n</ul>\n<h3 id=\"HTTPS（对称加密-非对称加密）\"><a href=\"#HTTPS（对称加密-非对称加密）\" class=\"headerlink\" title=\"HTTPS（对称加密+非对称加密）\"></a>HTTPS（对称加密+非对称加密）</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-9a21634026ce4d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-9a21634026ce4d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>使用非对称加密传输协商一个对称加密算法和秘钥</li>\n<li>使用对称加密算法对数据加密传输</li>\n<li>数据双向安全，且效率较高</li>\n</ul>\n<h2 id=\"CA机构和数字证书\"><a href=\"#CA机构和数字证书\" class=\"headerlink\" title=\"CA机构和数字证书\"></a>CA机构和数字证书</h2><p>从前面可以看到，协商阶段时候用非对称加密，客户端一开始就要持有公钥，那么客户端如何安全的获取公钥呢？<br>如果服务端直接将公钥发给客户端，中间可能被坏人劫持，返回一个假公钥，客户端使用假公钥进行加密后请求，坏人就可以使用假私钥解出明文，篡改内容后再使用真公钥加密后请求到服务器，这时服务器拿到的是被篡改后的数据。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-fb5c49e4b5019e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-fb5c49e4b5019e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>数字证书和CA机构就是用来保证服务器安全的发送公钥给客户端的。<br><strong>校验过程</strong></p>\n<ol>\n<li>读取证书中的所有者，有效期等信息进行校验</li>\n<li>查找系统内置的受信任证书发布机构CA，与服务器下发的证书中的CA对比，校验是否是合法机构颁发</li>\n<li>如果找不到，浏览器报错警告证书不可信</li>\n<li>如果找到了：</li>\n</ol>\n<ul>\n<li>对证书里的数字签名使用公钥解密得到明文的hash摘要</li>\n<li>浏览器使用相同的hash算法计算明文的hash值，将这个值与上述计算的摘要对比验证证书的合法性。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一个完整的HTTPS请求流程如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-06d256f8dff32472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-06d256f8dff32472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://juejin.cn/post/6844903830916694030\">【掘金】深入理解HTTPS工作原理</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Web应用存在HTTP和HTTPS两种通信方式，HTTP默认端口80，数据以明文传输，HTTPS默认端口443，数据加密传输。</p>\n<h2 id=\"HTTPS协议\"><a href=\"#HTTPS协议\" class=\"headerlink\" title=\"HTTPS协议\"></a>HTTPS协议</h2><p>HTTPS实际上并不是一种新的网络协议，是HTTP的基础上加了SSL层，数据的加密就是在SSL层完成的。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-4915c1ecfe442f0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h2 id=\"数据传输方式\"><a href=\"#数据传输方式\" class=\"headerlink\" title=\"数据传输方式\"></a>数据传输方式</h2><h3 id=\"明文传输\"><a href=\"#明文传输\" class=\"headerlink\" title=\"明文传输\"></a>明文传输</h3><p>客户端和服务器已明文方式传输数据，没有安全性，数据再传输过程中可能被劫持和篡改<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-af0efb8a2b3599db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h3 id=\"对称加密传输\"><a href=\"#对称加密传输\" class=\"headerlink\" title=\"对称加密传输\"></a>对称加密传输</h3><p>对称加密算法：双方使用同一秘钥对数据进行加解密（AES、DES）<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-046d2c536baae247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br><strong>特点</strong>：</p>\n<ul>\n<li>如果不知道秘钥，是无法解出对应的明文，但是如果所有客户端都用相同的秘钥，相当于没有加密，坏人也可以作为一个用户拿到秘钥。</li>\n<li>加解密性能高</li>\n</ul>\n<p>一种改进的方案是每个客户端先协商一个加密算法和秘钥，不同客户端使用不同的算法和秘钥，这就坏人即使作为一个用户也不知道别的用户的秘钥。但是这种方式协商秘钥的过程是公开明文的，坏人也有办法窃取到秘钥的，仍然存在风险。</p>\n<h3 id=\"非对称加密传输\"><a href=\"#非对称加密传输\" class=\"headerlink\" title=\"非对称加密传输\"></a>非对称加密传输</h3><p>非对称加密算法：加密解密采用不同的秘钥，私钥加密后的密文，所有的公钥都可以解密，公钥加密后的密文只有私钥能解密。私钥通常只有一个人有，公钥可以公开发给所有人。（常见算法：RSA）<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-eefe11cf0a2b22f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>只要把私钥保存在服务器，公钥发给客户端，那么客户端向服务器发送的数据就是安全的，但是服务器向客户端发送的数据坏人也可以通过公钥解密</li>\n<li>加解密消耗的时间较长，传输效率会降低</li>\n</ul>\n<h3 id=\"HTTPS（对称加密-非对称加密）\"><a href=\"#HTTPS（对称加密-非对称加密）\" class=\"headerlink\" title=\"HTTPS（对称加密+非对称加密）\"></a>HTTPS（对称加密+非对称加密）</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-9a21634026ce4d86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><strong>特点</strong>：</p>\n<ul>\n<li>使用非对称加密传输协商一个对称加密算法和秘钥</li>\n<li>使用对称加密算法对数据加密传输</li>\n<li>数据双向安全，且效率较高</li>\n</ul>\n<h2 id=\"CA机构和数字证书\"><a href=\"#CA机构和数字证书\" class=\"headerlink\" title=\"CA机构和数字证书\"></a>CA机构和数字证书</h2><p>从前面可以看到，协商阶段时候用非对称加密，客户端一开始就要持有公钥，那么客户端如何安全的获取公钥呢？<br>如果服务端直接将公钥发给客户端，中间可能被坏人劫持，返回一个假公钥，客户端使用假公钥进行加密后请求，坏人就可以使用假私钥解出明文，篡改内容后再使用真公钥加密后请求到服务器，这时服务器拿到的是被篡改后的数据。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-fb5c49e4b5019e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>数字证书和CA机构就是用来保证服务器安全的发送公钥给客户端的。<br><strong>校验过程</strong></p>\n<ol>\n<li>读取证书中的所有者，有效期等信息进行校验</li>\n<li>查找系统内置的受信任证书发布机构CA，与服务器下发的证书中的CA对比，校验是否是合法机构颁发</li>\n<li>如果找不到，浏览器报错警告证书不可信</li>\n<li>如果找到了：</li>\n</ol>\n<ul>\n<li>对证书里的数字签名使用公钥解密得到明文的hash摘要</li>\n<li>浏览器使用相同的hash算法计算明文的hash值，将这个值与上述计算的摘要对比验证证书的合法性。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一个完整的HTTPS请求流程如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-06d256f8dff32472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://juejin.cn/post/6844903830916694030\">【掘金】深入理解HTTPS工作原理</a></p>\n"},{"title":"MySQL ORDER BY 如何实现排序的?","date":"2023-03-25T07:12:42.000Z","_content":"## MySQL是如何进行排序的？\n假设有一个表t结构如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-c7aec6166a2d984f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nid为主键，type上建有索引，那么如果要查类型为1，val最小的1000行，那么SQL语句如下：\n`SELECT type, val, detail FROM t WHERE type = 1 ORDER BY val LIMIT 1000;`\n\n### 全字段排序\n对上述查询执行explain结果如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-b14d9da637a8123d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nUsing filesort表示需要排序，MySQL会给每个线程分配一块内存用来排序，称为sort buffer，具体的流程如下：\n1. 初始化sort buffer，确定放入type，val，detail三个字段\n2. 从索引type中找到第一个满足type=1条件的主键id\n3. 根据id回主键索引查询type和val的值存入sort buffer中，从索引type中继续取下一个id\n4. 重复3的操作直到type不满足条件\n5. 对sort buffer中的数据按照val字段做快速排序\n6. 按照排序结果取前1000行返回\n\n如果sort buffer够存下所有需要排序的记录，排序在内存中完成，如果内存放不下则需要借助磁盘临时文件进行外部排序。\n\n### rowid排序\n全字段排序过程里只对原表扫描的一遍，剩下的操作都是在sort buffer 和临时文件中执行的，但是如果要查询的字段比较多，sort buffer能存的行数就很少，需要分成多个临时文件进行外部排序，性能比较差，所以在单行数大的情况下这种方式明显不合适。\n\nMySQL的参数`max_length_for_sort_data`表示如果单行记录长度超过这个值，就认为单行太大，要换一种排序算法，排序过程中只放要排序的列和主键id，执行流程如下：\n1. 初始化sort buffer，放入val，id字段\n2. 从索引type中找到第一个满足type=1条件的主键id\n3. 根据id回主键索引查询val的值，将val和id存入sort buffer中，从索引type中继续取下一个id\n4. 重复3的操作直到type不满足条件\n5. 对sort buffer中的数据按照val字段做快速排序\n6. 按照排序结果依次取1000行，并按照id值回表取出type，val，detail三个字段返回\n\n可以看到改流程与全字段排序的主要区别在于：\n- 第1步放入sort buffer的字段不同，rowid排序只放入排序字段和id，全字段排序放入查询的全部字段\n- 第6步，rowid排序完成后要再回主键索引查一次全部数据返回，全字段排序因为所以要返回的字段内容都在sort buffer中了所以直接返回\n\n**说明**：结果集只是一个逻辑概念，实际上MySQL从排序后的sort buffer中依次取出id，然后到原表查询所有字段的结果不需要在服务端再消耗内存保存，是直接返回的。\n\n### 联合索引避免排序\n上面两种方法都是需要建临时表进行排序的，对于MySQL来说都是成本比较高的操作。但并不是所有order by都是需要排序的，因为MySQL索引是天然有序的，如果在type和val字段创建一个联合索引idx_type_val，那么该查询就不需要排序了，这时执行过程就变成了如下流程：\n1. 在索引idx_type_val上找到第一个满足type=1条件记录\n2. 根据索引上的主键id回主键索引查询所有字段的值返回，在idx_type_val索引上继续取一下个值\n3. 重复2的操作直到不满足type=1或者超过1000行结束。\n\n使用联合索引，首先不在需要建临时表做排序，其次也不需要扫描出满足type=1条件的所有记录，因为索引有序直接扫描前1000行就结束了，大大减少了扫描的行数。\n\n## 优先队列排序\n\n对于MySQL来说并不是所有的排序都是用快速排序实现的，假如之前的查询变成了如下：\n`EXPLAIN SELECT type, val FROM t WHERE type = 1 ORDER BY val LIMIT 3;`\n假设type=1的记录有1万条，只需要去前val最小的前三行。\n\n对于这种情况，即使sort buffer不能放下1万行记录，会发现MySQL也没有使用到临时文件，这时因为选择了另一种算法：优先队列算法。\n\n#### 算法流程\n1. 对于这10000准备排序的记录，先取前三行构造一个最大堆\n2. 取下一行Next记录跟当前堆顶记录Top比较，如果Next.val < Top.val，就把堆顶记录弹出，将Next记录放入堆\n3. 重复2的操作直到取出所有10000行记录，最后堆中的三个记录就是最小的三个\n\n#### 复杂度\n快速排序时间复杂度是`O(N*logN)`，优先队列排序时间复杂度为`O((N-K)*logK)`，K表示堆的大小，即返回记录的个数，对于该场景下为`(N-3)*log3`，基本可以看做线性时间复杂度，如果是limit 1的时候就相当于求最小值，该算法就是线性时间复杂度。\n其次sort buffer中只需要维护堆，内存的消耗也大大减少，空间复杂度为`O(K)`。\n\n## order by rand()\n如果需要随机选1个数，SQL语句可能如下：\n`SELECT * FROM t ORDER BY RAND() LIMIT 1`\n需要注意到是这种方式会建临时表进行排序，临时表除了查询字段会多加一个排序字段存放rand()生成的值，即对每一行记录使用rand()函数生成一个随机数，然后根据这个数来排序。\n\n这种写法的成本是比较高的，所以建议尽量避免这种写法，建议先随机一个0~N-1的值（N表示表总行数），然后去查数据库的某行，比如：\n```python\ndef rand1():\n    N = mysql.query(\"select count(*) from t\")\n    res = mysql.query(\"select * from t limit N, 1\")\n    return res\n```\n\n## 参考\n【极客时间】[MySQL实战45讲：16、17](https://time.geekbang.org/column/article/73479)\n","source":"_posts/2023/03-25-MySQL-ORDER-BY-如何实现排序的.md","raw":"---\ntitle: MySQL ORDER BY 如何实现排序的?\ndate: 2023-03-25 15:12:42\ncategories:\n- [数据库]\ntags:\n- MySQL\n- 排序\n---\n## MySQL是如何进行排序的？\n假设有一个表t结构如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-c7aec6166a2d984f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nid为主键，type上建有索引，那么如果要查类型为1，val最小的1000行，那么SQL语句如下：\n`SELECT type, val, detail FROM t WHERE type = 1 ORDER BY val LIMIT 1000;`\n\n### 全字段排序\n对上述查询执行explain结果如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-b14d9da637a8123d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nUsing filesort表示需要排序，MySQL会给每个线程分配一块内存用来排序，称为sort buffer，具体的流程如下：\n1. 初始化sort buffer，确定放入type，val，detail三个字段\n2. 从索引type中找到第一个满足type=1条件的主键id\n3. 根据id回主键索引查询type和val的值存入sort buffer中，从索引type中继续取下一个id\n4. 重复3的操作直到type不满足条件\n5. 对sort buffer中的数据按照val字段做快速排序\n6. 按照排序结果取前1000行返回\n\n如果sort buffer够存下所有需要排序的记录，排序在内存中完成，如果内存放不下则需要借助磁盘临时文件进行外部排序。\n\n### rowid排序\n全字段排序过程里只对原表扫描的一遍，剩下的操作都是在sort buffer 和临时文件中执行的，但是如果要查询的字段比较多，sort buffer能存的行数就很少，需要分成多个临时文件进行外部排序，性能比较差，所以在单行数大的情况下这种方式明显不合适。\n\nMySQL的参数`max_length_for_sort_data`表示如果单行记录长度超过这个值，就认为单行太大，要换一种排序算法，排序过程中只放要排序的列和主键id，执行流程如下：\n1. 初始化sort buffer，放入val，id字段\n2. 从索引type中找到第一个满足type=1条件的主键id\n3. 根据id回主键索引查询val的值，将val和id存入sort buffer中，从索引type中继续取下一个id\n4. 重复3的操作直到type不满足条件\n5. 对sort buffer中的数据按照val字段做快速排序\n6. 按照排序结果依次取1000行，并按照id值回表取出type，val，detail三个字段返回\n\n可以看到改流程与全字段排序的主要区别在于：\n- 第1步放入sort buffer的字段不同，rowid排序只放入排序字段和id，全字段排序放入查询的全部字段\n- 第6步，rowid排序完成后要再回主键索引查一次全部数据返回，全字段排序因为所以要返回的字段内容都在sort buffer中了所以直接返回\n\n**说明**：结果集只是一个逻辑概念，实际上MySQL从排序后的sort buffer中依次取出id，然后到原表查询所有字段的结果不需要在服务端再消耗内存保存，是直接返回的。\n\n### 联合索引避免排序\n上面两种方法都是需要建临时表进行排序的，对于MySQL来说都是成本比较高的操作。但并不是所有order by都是需要排序的，因为MySQL索引是天然有序的，如果在type和val字段创建一个联合索引idx_type_val，那么该查询就不需要排序了，这时执行过程就变成了如下流程：\n1. 在索引idx_type_val上找到第一个满足type=1条件记录\n2. 根据索引上的主键id回主键索引查询所有字段的值返回，在idx_type_val索引上继续取一下个值\n3. 重复2的操作直到不满足type=1或者超过1000行结束。\n\n使用联合索引，首先不在需要建临时表做排序，其次也不需要扫描出满足type=1条件的所有记录，因为索引有序直接扫描前1000行就结束了，大大减少了扫描的行数。\n\n## 优先队列排序\n\n对于MySQL来说并不是所有的排序都是用快速排序实现的，假如之前的查询变成了如下：\n`EXPLAIN SELECT type, val FROM t WHERE type = 1 ORDER BY val LIMIT 3;`\n假设type=1的记录有1万条，只需要去前val最小的前三行。\n\n对于这种情况，即使sort buffer不能放下1万行记录，会发现MySQL也没有使用到临时文件，这时因为选择了另一种算法：优先队列算法。\n\n#### 算法流程\n1. 对于这10000准备排序的记录，先取前三行构造一个最大堆\n2. 取下一行Next记录跟当前堆顶记录Top比较，如果Next.val < Top.val，就把堆顶记录弹出，将Next记录放入堆\n3. 重复2的操作直到取出所有10000行记录，最后堆中的三个记录就是最小的三个\n\n#### 复杂度\n快速排序时间复杂度是`O(N*logN)`，优先队列排序时间复杂度为`O((N-K)*logK)`，K表示堆的大小，即返回记录的个数，对于该场景下为`(N-3)*log3`，基本可以看做线性时间复杂度，如果是limit 1的时候就相当于求最小值，该算法就是线性时间复杂度。\n其次sort buffer中只需要维护堆，内存的消耗也大大减少，空间复杂度为`O(K)`。\n\n## order by rand()\n如果需要随机选1个数，SQL语句可能如下：\n`SELECT * FROM t ORDER BY RAND() LIMIT 1`\n需要注意到是这种方式会建临时表进行排序，临时表除了查询字段会多加一个排序字段存放rand()生成的值，即对每一行记录使用rand()函数生成一个随机数，然后根据这个数来排序。\n\n这种写法的成本是比较高的，所以建议尽量避免这种写法，建议先随机一个0~N-1的值（N表示表总行数），然后去查数据库的某行，比如：\n```python\ndef rand1():\n    N = mysql.query(\"select count(*) from t\")\n    res = mysql.query(\"select * from t limit N, 1\")\n    return res\n```\n\n## 参考\n【极客时间】[MySQL实战45讲：16、17](https://time.geekbang.org/column/article/73479)\n","slug":"MySQL-ORDER-BY-如何实现排序的","published":1,"updated":"2023-03-25T07:18:17.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywh0018vhfi498673fj","content":"<h2 id=\"MySQL是如何进行排序的？\"><a href=\"#MySQL是如何进行排序的？\" class=\"headerlink\" title=\"MySQL是如何进行排序的？\"></a>MySQL是如何进行排序的？</h2><p>假设有一个表t结构如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-c7aec6166a2d984f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-c7aec6166a2d984f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>id为主键，type上建有索引，那么如果要查类型为1，val最小的1000行，那么SQL语句如下：<br><code>SELECT type, val, detail FROM t WHERE type = 1 ORDER BY val LIMIT 1000;</code></p>\n<h3 id=\"全字段排序\"><a href=\"#全字段排序\" class=\"headerlink\" title=\"全字段排序\"></a>全字段排序</h3><p>对上述查询执行explain结果如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-b14d9da637a8123d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-b14d9da637a8123d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>Using filesort表示需要排序，MySQL会给每个线程分配一块内存用来排序，称为sort buffer，具体的流程如下：</p>\n<ol>\n<li>初始化sort buffer，确定放入type，val，detail三个字段</li>\n<li>从索引type中找到第一个满足type&#x3D;1条件的主键id</li>\n<li>根据id回主键索引查询type和val的值存入sort buffer中，从索引type中继续取下一个id</li>\n<li>重复3的操作直到type不满足条件</li>\n<li>对sort buffer中的数据按照val字段做快速排序</li>\n<li>按照排序结果取前1000行返回</li>\n</ol>\n<p>如果sort buffer够存下所有需要排序的记录，排序在内存中完成，如果内存放不下则需要借助磁盘临时文件进行外部排序。</p>\n<h3 id=\"rowid排序\"><a href=\"#rowid排序\" class=\"headerlink\" title=\"rowid排序\"></a>rowid排序</h3><p>全字段排序过程里只对原表扫描的一遍，剩下的操作都是在sort buffer 和临时文件中执行的，但是如果要查询的字段比较多，sort buffer能存的行数就很少，需要分成多个临时文件进行外部排序，性能比较差，所以在单行数大的情况下这种方式明显不合适。</p>\n<p>MySQL的参数<code>max_length_for_sort_data</code>表示如果单行记录长度超过这个值，就认为单行太大，要换一种排序算法，排序过程中只放要排序的列和主键id，执行流程如下：</p>\n<ol>\n<li>初始化sort buffer，放入val，id字段</li>\n<li>从索引type中找到第一个满足type&#x3D;1条件的主键id</li>\n<li>根据id回主键索引查询val的值，将val和id存入sort buffer中，从索引type中继续取下一个id</li>\n<li>重复3的操作直到type不满足条件</li>\n<li>对sort buffer中的数据按照val字段做快速排序</li>\n<li>按照排序结果依次取1000行，并按照id值回表取出type，val，detail三个字段返回</li>\n</ol>\n<p>可以看到改流程与全字段排序的主要区别在于：</p>\n<ul>\n<li>第1步放入sort buffer的字段不同，rowid排序只放入排序字段和id，全字段排序放入查询的全部字段</li>\n<li>第6步，rowid排序完成后要再回主键索引查一次全部数据返回，全字段排序因为所以要返回的字段内容都在sort buffer中了所以直接返回</li>\n</ul>\n<p><strong>说明</strong>：结果集只是一个逻辑概念，实际上MySQL从排序后的sort buffer中依次取出id，然后到原表查询所有字段的结果不需要在服务端再消耗内存保存，是直接返回的。</p>\n<h3 id=\"联合索引避免排序\"><a href=\"#联合索引避免排序\" class=\"headerlink\" title=\"联合索引避免排序\"></a>联合索引避免排序</h3><p>上面两种方法都是需要建临时表进行排序的，对于MySQL来说都是成本比较高的操作。但并不是所有order by都是需要排序的，因为MySQL索引是天然有序的，如果在type和val字段创建一个联合索引idx_type_val，那么该查询就不需要排序了，这时执行过程就变成了如下流程：</p>\n<ol>\n<li>在索引idx_type_val上找到第一个满足type&#x3D;1条件记录</li>\n<li>根据索引上的主键id回主键索引查询所有字段的值返回，在idx_type_val索引上继续取一下个值</li>\n<li>重复2的操作直到不满足type&#x3D;1或者超过1000行结束。</li>\n</ol>\n<p>使用联合索引，首先不在需要建临时表做排序，其次也不需要扫描出满足type&#x3D;1条件的所有记录，因为索引有序直接扫描前1000行就结束了，大大减少了扫描的行数。</p>\n<h2 id=\"优先队列排序\"><a href=\"#优先队列排序\" class=\"headerlink\" title=\"优先队列排序\"></a>优先队列排序</h2><p>对于MySQL来说并不是所有的排序都是用快速排序实现的，假如之前的查询变成了如下：<br><code>EXPLAIN SELECT type, val FROM t WHERE type = 1 ORDER BY val LIMIT 3;</code><br>假设type&#x3D;1的记录有1万条，只需要去前val最小的前三行。</p>\n<p>对于这种情况，即使sort buffer不能放下1万行记录，会发现MySQL也没有使用到临时文件，这时因为选择了另一种算法：优先队列算法。</p>\n<h4 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h4><ol>\n<li>对于这10000准备排序的记录，先取前三行构造一个最大堆</li>\n<li>取下一行Next记录跟当前堆顶记录Top比较，如果Next.val &lt; Top.val，就把堆顶记录弹出，将Next记录放入堆</li>\n<li>重复2的操作直到取出所有10000行记录，最后堆中的三个记录就是最小的三个</li>\n</ol>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>快速排序时间复杂度是<code>O(N*logN)</code>，优先队列排序时间复杂度为<code>O((N-K)*logK)</code>，K表示堆的大小，即返回记录的个数，对于该场景下为<code>(N-3)*log3</code>，基本可以看做线性时间复杂度，如果是limit 1的时候就相当于求最小值，该算法就是线性时间复杂度。<br>其次sort buffer中只需要维护堆，内存的消耗也大大减少，空间复杂度为<code>O(K)</code>。</p>\n<h2 id=\"order-by-rand\"><a href=\"#order-by-rand\" class=\"headerlink\" title=\"order by rand()\"></a>order by rand()</h2><p>如果需要随机选1个数，SQL语句可能如下：<br><code>SELECT * FROM t ORDER BY RAND() LIMIT 1</code><br>需要注意到是这种方式会建临时表进行排序，临时表除了查询字段会多加一个排序字段存放rand()生成的值，即对每一行记录使用rand()函数生成一个随机数，然后根据这个数来排序。</p>\n<p>这种写法的成本是比较高的，所以建议尽量避免这种写法，建议先随机一个0~N-1的值（N表示表总行数），然后去查数据库的某行，比如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">rand1</span>():</span><br><span class=\"line\">    N = mysql.query(<span class=\"string\">&quot;select count(*) from t&quot;</span>)</span><br><span class=\"line\">    res = mysql.query(<span class=\"string\">&quot;select * from t limit N, 1&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【极客时间】<a href=\"https://time.geekbang.org/column/article/73479\">MySQL实战45讲：16、17</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MySQL是如何进行排序的？\"><a href=\"#MySQL是如何进行排序的？\" class=\"headerlink\" title=\"MySQL是如何进行排序的？\"></a>MySQL是如何进行排序的？</h2><p>假设有一个表t结构如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-c7aec6166a2d984f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>id为主键，type上建有索引，那么如果要查类型为1，val最小的1000行，那么SQL语句如下：<br><code>SELECT type, val, detail FROM t WHERE type = 1 ORDER BY val LIMIT 1000;</code></p>\n<h3 id=\"全字段排序\"><a href=\"#全字段排序\" class=\"headerlink\" title=\"全字段排序\"></a>全字段排序</h3><p>对上述查询执行explain结果如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-b14d9da637a8123d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>Using filesort表示需要排序，MySQL会给每个线程分配一块内存用来排序，称为sort buffer，具体的流程如下：</p>\n<ol>\n<li>初始化sort buffer，确定放入type，val，detail三个字段</li>\n<li>从索引type中找到第一个满足type&#x3D;1条件的主键id</li>\n<li>根据id回主键索引查询type和val的值存入sort buffer中，从索引type中继续取下一个id</li>\n<li>重复3的操作直到type不满足条件</li>\n<li>对sort buffer中的数据按照val字段做快速排序</li>\n<li>按照排序结果取前1000行返回</li>\n</ol>\n<p>如果sort buffer够存下所有需要排序的记录，排序在内存中完成，如果内存放不下则需要借助磁盘临时文件进行外部排序。</p>\n<h3 id=\"rowid排序\"><a href=\"#rowid排序\" class=\"headerlink\" title=\"rowid排序\"></a>rowid排序</h3><p>全字段排序过程里只对原表扫描的一遍，剩下的操作都是在sort buffer 和临时文件中执行的，但是如果要查询的字段比较多，sort buffer能存的行数就很少，需要分成多个临时文件进行外部排序，性能比较差，所以在单行数大的情况下这种方式明显不合适。</p>\n<p>MySQL的参数<code>max_length_for_sort_data</code>表示如果单行记录长度超过这个值，就认为单行太大，要换一种排序算法，排序过程中只放要排序的列和主键id，执行流程如下：</p>\n<ol>\n<li>初始化sort buffer，放入val，id字段</li>\n<li>从索引type中找到第一个满足type&#x3D;1条件的主键id</li>\n<li>根据id回主键索引查询val的值，将val和id存入sort buffer中，从索引type中继续取下一个id</li>\n<li>重复3的操作直到type不满足条件</li>\n<li>对sort buffer中的数据按照val字段做快速排序</li>\n<li>按照排序结果依次取1000行，并按照id值回表取出type，val，detail三个字段返回</li>\n</ol>\n<p>可以看到改流程与全字段排序的主要区别在于：</p>\n<ul>\n<li>第1步放入sort buffer的字段不同，rowid排序只放入排序字段和id，全字段排序放入查询的全部字段</li>\n<li>第6步，rowid排序完成后要再回主键索引查一次全部数据返回，全字段排序因为所以要返回的字段内容都在sort buffer中了所以直接返回</li>\n</ul>\n<p><strong>说明</strong>：结果集只是一个逻辑概念，实际上MySQL从排序后的sort buffer中依次取出id，然后到原表查询所有字段的结果不需要在服务端再消耗内存保存，是直接返回的。</p>\n<h3 id=\"联合索引避免排序\"><a href=\"#联合索引避免排序\" class=\"headerlink\" title=\"联合索引避免排序\"></a>联合索引避免排序</h3><p>上面两种方法都是需要建临时表进行排序的，对于MySQL来说都是成本比较高的操作。但并不是所有order by都是需要排序的，因为MySQL索引是天然有序的，如果在type和val字段创建一个联合索引idx_type_val，那么该查询就不需要排序了，这时执行过程就变成了如下流程：</p>\n<ol>\n<li>在索引idx_type_val上找到第一个满足type&#x3D;1条件记录</li>\n<li>根据索引上的主键id回主键索引查询所有字段的值返回，在idx_type_val索引上继续取一下个值</li>\n<li>重复2的操作直到不满足type&#x3D;1或者超过1000行结束。</li>\n</ol>\n<p>使用联合索引，首先不在需要建临时表做排序，其次也不需要扫描出满足type&#x3D;1条件的所有记录，因为索引有序直接扫描前1000行就结束了，大大减少了扫描的行数。</p>\n<h2 id=\"优先队列排序\"><a href=\"#优先队列排序\" class=\"headerlink\" title=\"优先队列排序\"></a>优先队列排序</h2><p>对于MySQL来说并不是所有的排序都是用快速排序实现的，假如之前的查询变成了如下：<br><code>EXPLAIN SELECT type, val FROM t WHERE type = 1 ORDER BY val LIMIT 3;</code><br>假设type&#x3D;1的记录有1万条，只需要去前val最小的前三行。</p>\n<p>对于这种情况，即使sort buffer不能放下1万行记录，会发现MySQL也没有使用到临时文件，这时因为选择了另一种算法：优先队列算法。</p>\n<h4 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h4><ol>\n<li>对于这10000准备排序的记录，先取前三行构造一个最大堆</li>\n<li>取下一行Next记录跟当前堆顶记录Top比较，如果Next.val &lt; Top.val，就把堆顶记录弹出，将Next记录放入堆</li>\n<li>重复2的操作直到取出所有10000行记录，最后堆中的三个记录就是最小的三个</li>\n</ol>\n<h4 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h4><p>快速排序时间复杂度是<code>O(N*logN)</code>，优先队列排序时间复杂度为<code>O((N-K)*logK)</code>，K表示堆的大小，即返回记录的个数，对于该场景下为<code>(N-3)*log3</code>，基本可以看做线性时间复杂度，如果是limit 1的时候就相当于求最小值，该算法就是线性时间复杂度。<br>其次sort buffer中只需要维护堆，内存的消耗也大大减少，空间复杂度为<code>O(K)</code>。</p>\n<h2 id=\"order-by-rand\"><a href=\"#order-by-rand\" class=\"headerlink\" title=\"order by rand()\"></a>order by rand()</h2><p>如果需要随机选1个数，SQL语句可能如下：<br><code>SELECT * FROM t ORDER BY RAND() LIMIT 1</code><br>需要注意到是这种方式会建临时表进行排序，临时表除了查询字段会多加一个排序字段存放rand()生成的值，即对每一行记录使用rand()函数生成一个随机数，然后根据这个数来排序。</p>\n<p>这种写法的成本是比较高的，所以建议尽量避免这种写法，建议先随机一个0~N-1的值（N表示表总行数），然后去查数据库的某行，比如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">rand1</span>():</span><br><span class=\"line\">    N = mysql.query(<span class=\"string\">&quot;select count(*) from t&quot;</span>)</span><br><span class=\"line\">    res = mysql.query(<span class=\"string\">&quot;select * from t limit N, 1&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【极客时间】<a href=\"https://time.geekbang.org/column/article/73479\">MySQL实战45讲：16、17</a></p>\n"},{"title":"MySQL 中一条 SQL 语句是如何执行的？","date":"2023-03-25T07:11:22.000Z","_content":"## SQL语句执行的经过\n从用户发起请求，到服务接口调用MySQL驱动，MySQL服务器执行完SQL语句返回结果中间发生了什么？首先放一张图来看整个过程使用到的各个组件，然后再对各个过程进行分析。\n\n![SQL语句执行链路](https://upload-images.jianshu.io/upload_images/14151453-bfe61aa3f5d1fcad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 1. 连接过程\n以Openresty服务器为例，Openresty是多进程+I/O多路复用结构（Nginx的I/O模型），可以支撑高的并发，一个Worker就是一个进程，一个进程可以处理多条请求。\n我们知道当需要执行SQL语句时需要先于MySQL服务器建立连接，如果每个一个请求都建立一个连接，使用完再关闭连接，如果频繁的创建和销毁连接显然是不合理的，浪费系统资源造成性能下降，这时连接池就出现了。\n#### 连接池\n连接池会维护多个（长）连接，一个SQL语句执行时分配一个连接，使用完不会销毁连接，而是放到空闲队列中等待下次使用，这样可以在高并发的场景大大减少创建、销毁连接带来的性能问题。\n\n#### 连接器\n类似Web服务器通过连接池维护与数据库服务器的连接，MySQL的连接器提供了同样的功能，也维护了一个连接池，不同的是MySQL连接器同时还有权限验证的功能。\n\n- 修改密码不会影响已经建立的链接。\n- 连接完成后如果没有操作，改连接就会处于空闲状态，可以使用`show processlist`命令查看，如果长时间没有操作连接器会在到达超时时间后断开它。\n\n#### 长连接\n长连接是客户端持续有请求，使用的是同一个连接，建立连接的过程通常是比较慢的，建议尽量使用长连接。但是长连接累计较多时可能会导致内存过大（内存管理在连接对象里），比系统强行kill，引起MySQL异常重启，可以使用以下两种方法解决：\n- 定期断开长连接。\n- 如果是MySQL5.7及以上的版本，可以在每次执行一个比较大的操作后执行`mysql_reset_connection`重新初始化连接资源（不会重新建立连接）。\n\n### 2. 执行过程\n\n#### 查询缓存\n如果是查询语句，而且开启了查询缓存，连接器拿到一个查询请求后，会先查看查询缓存是否有（之前执行过这条语句）。缓存key为sql语句，value是查询结果。\n- 不建议开启查询缓存，除非是基本不会变的数据表。因为只要对表有更新，该表上的所有查询缓存都会清空，导致查询命中率很低。\n\n#### 分析器\n分析器的功能就是对SQL语句做词法分析和语法分析，解析这条语句要干什么，语法错误会返回错误提醒。\n\n#### 优化器\n优化器是在表中有多个索引的时候决定使用哪个索引，或者有多表关联（join）的时候决定各个表的连接顺序。\n\n#### 执行器\n通过分析器知道了要做什么，优化器知道了改怎么做，执行器就是真正的语句执行阶段。开始执行的时候要先判断对表是否有权限（在优化器之前也会做预检查）。执行器会调用存储引擎提供的接口进行读写操作。\n\n### 3. 更新语句执行过程\n查询语句是只读的，比较简单，经过一系列组件最终查询到结果返回。但是更新语句就相对复杂一些，涉及到两个日志模块：redo log和binlog。\n\n#### redo log（重做日志）\n如果每次更新都要刷盘，整个过程磁盘IO成本、查询成本都比较高，为了提升更新效率，InnoDB引擎提供了redo log（顺序写入速度很快）。\n\n**WAL（Write-Ahead Logging）**：先写日志，再写磁盘。当有一条记录需要更新的时候，InnoDB引擎会先将记录写入redo log并更新内存，这时候更新就算完成了，再需要的时候再将这个操作更新到磁盘里。\n\n**日志结构**：redo log大小是固定的，比如配置一组4个文件，每个文件1G，\n就可以记录总共4G的记录。从头开始写，写完后又回到开头循环写入。\n\n**crash-safe**：故障安全，redo log除了能提高更新操作的效率，同时还保证了故障安全，在数据库异常时不会导致数据丢失。\n\n#### binlog（归档日志）\nMySQL最开始没有InnoDB引擎，binlog日志只用于归档和复制，只依靠binlog没有crash-safe能力。\n\n- redo log是InnoDB引擎独有的，属于存储层；binlog是MySQL提供的，属于server层\n- redo log是物理日志，记录在某个数据页上做了什么修改；binlog是逻辑日志，记录SQL语句的原始逻辑\n- redo log是循环写的，空间固定，用完会从头开始写；binlog是追加写的，一定大小后切换到下一个文件，不会覆盖\n\n#### Buffer Pool缓冲池\nInnoDB重要的内存结构，数据的操作都是在Buffer Pool中操作的，如果数据不在缓冲内存中，会先从磁盘中读取到数据页到缓冲池，然后再执行相关操作。\n\n#### update执行过程\n`update T set k = k + 2 where id = '1' limit 1`\n1. 执行器调引擎读接口找id=2这一行，如果数据页本来在内存就直接返回，否则先从磁盘load到内存中再返回。\n2. 然后执行器将k值加上2，得到新的一行数据，在调用引擎的写接口写入这行新数据。\n3. 引擎将这行数据更新到内存中，同时将更新操作记录到redo log，此时redo log处于prepare状态，然后告知执行器执行完成，可以提交事务。\n4. 执行器生成这个操作的binlog并写入磁盘。\n5. 执行器调用存储引擎的事务提交接口，引擎把刚写入redo log改为commit状态，更新完成。\n\n## 两阶段提交\n保证了crash-safe能力，如果不使用两阶段提交，使用binlog恢复数据库时会导致与原数据库状态不一致。\n\n假如不使用两阶段提交，在写日志时机器发生故障：\n1. redo log写入（比如k，本来为0，执行更新后\nk = 2）后发生故障，binlog未写入。由于redo log写完之后即使系统崩溃，也会能将数据恢复，恢复后这一行数据k=2。但是binlog没写完就crash，binlog没有记录这条语句，如果使用binlog来恢复时会少一个事务，恢复后的k=0，原数据库k=2。\n2. binlog写入后发生故障，redo log未写入。redo log为写入，崩溃后这个事务无效，k=0。但是binlog已经记录了更新语句，之后恢复时会多出一个事务，恢复后k=2，原数据库k=0。\n\n## 总结\n1. MySQL连接器使用连接池维护连接，并进行检查权限，接收一个SQL语句\n2. 然后通过分析器、优化器知道如何执行SQL语句\n3. 通过执行器与存储引擎交互，完成数据的读写。\n4. 数据更新同时会写入两个重要的日志文件：redo log和binlog，并通过两阶段提交保证了crash-safe能力。\n\n**参考资料**\n[【码农有道】详解一条 SQL 的执行过程](https://mp.weixin.qq.com/s/J_ng048H4eHBm_4VBjFiWw)\n[【极客时间】MySQL实战45讲01、02讲](https://time.geekbang.org/column/article/68319)\n","source":"_posts/2023/03-25-MySQL-中一条-SQL-语句是如何执行的？.md","raw":"---\ntitle: MySQL 中一条 SQL 语句是如何执行的？\ndate: 2023-03-25 15:11:22\ncategories:\n- [数据库]\ntags:\n- MySQL\n- SQL语句\n---\n## SQL语句执行的经过\n从用户发起请求，到服务接口调用MySQL驱动，MySQL服务器执行完SQL语句返回结果中间发生了什么？首先放一张图来看整个过程使用到的各个组件，然后再对各个过程进行分析。\n\n![SQL语句执行链路](https://upload-images.jianshu.io/upload_images/14151453-bfe61aa3f5d1fcad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 1. 连接过程\n以Openresty服务器为例，Openresty是多进程+I/O多路复用结构（Nginx的I/O模型），可以支撑高的并发，一个Worker就是一个进程，一个进程可以处理多条请求。\n我们知道当需要执行SQL语句时需要先于MySQL服务器建立连接，如果每个一个请求都建立一个连接，使用完再关闭连接，如果频繁的创建和销毁连接显然是不合理的，浪费系统资源造成性能下降，这时连接池就出现了。\n#### 连接池\n连接池会维护多个（长）连接，一个SQL语句执行时分配一个连接，使用完不会销毁连接，而是放到空闲队列中等待下次使用，这样可以在高并发的场景大大减少创建、销毁连接带来的性能问题。\n\n#### 连接器\n类似Web服务器通过连接池维护与数据库服务器的连接，MySQL的连接器提供了同样的功能，也维护了一个连接池，不同的是MySQL连接器同时还有权限验证的功能。\n\n- 修改密码不会影响已经建立的链接。\n- 连接完成后如果没有操作，改连接就会处于空闲状态，可以使用`show processlist`命令查看，如果长时间没有操作连接器会在到达超时时间后断开它。\n\n#### 长连接\n长连接是客户端持续有请求，使用的是同一个连接，建立连接的过程通常是比较慢的，建议尽量使用长连接。但是长连接累计较多时可能会导致内存过大（内存管理在连接对象里），比系统强行kill，引起MySQL异常重启，可以使用以下两种方法解决：\n- 定期断开长连接。\n- 如果是MySQL5.7及以上的版本，可以在每次执行一个比较大的操作后执行`mysql_reset_connection`重新初始化连接资源（不会重新建立连接）。\n\n### 2. 执行过程\n\n#### 查询缓存\n如果是查询语句，而且开启了查询缓存，连接器拿到一个查询请求后，会先查看查询缓存是否有（之前执行过这条语句）。缓存key为sql语句，value是查询结果。\n- 不建议开启查询缓存，除非是基本不会变的数据表。因为只要对表有更新，该表上的所有查询缓存都会清空，导致查询命中率很低。\n\n#### 分析器\n分析器的功能就是对SQL语句做词法分析和语法分析，解析这条语句要干什么，语法错误会返回错误提醒。\n\n#### 优化器\n优化器是在表中有多个索引的时候决定使用哪个索引，或者有多表关联（join）的时候决定各个表的连接顺序。\n\n#### 执行器\n通过分析器知道了要做什么，优化器知道了改怎么做，执行器就是真正的语句执行阶段。开始执行的时候要先判断对表是否有权限（在优化器之前也会做预检查）。执行器会调用存储引擎提供的接口进行读写操作。\n\n### 3. 更新语句执行过程\n查询语句是只读的，比较简单，经过一系列组件最终查询到结果返回。但是更新语句就相对复杂一些，涉及到两个日志模块：redo log和binlog。\n\n#### redo log（重做日志）\n如果每次更新都要刷盘，整个过程磁盘IO成本、查询成本都比较高，为了提升更新效率，InnoDB引擎提供了redo log（顺序写入速度很快）。\n\n**WAL（Write-Ahead Logging）**：先写日志，再写磁盘。当有一条记录需要更新的时候，InnoDB引擎会先将记录写入redo log并更新内存，这时候更新就算完成了，再需要的时候再将这个操作更新到磁盘里。\n\n**日志结构**：redo log大小是固定的，比如配置一组4个文件，每个文件1G，\n就可以记录总共4G的记录。从头开始写，写完后又回到开头循环写入。\n\n**crash-safe**：故障安全，redo log除了能提高更新操作的效率，同时还保证了故障安全，在数据库异常时不会导致数据丢失。\n\n#### binlog（归档日志）\nMySQL最开始没有InnoDB引擎，binlog日志只用于归档和复制，只依靠binlog没有crash-safe能力。\n\n- redo log是InnoDB引擎独有的，属于存储层；binlog是MySQL提供的，属于server层\n- redo log是物理日志，记录在某个数据页上做了什么修改；binlog是逻辑日志，记录SQL语句的原始逻辑\n- redo log是循环写的，空间固定，用完会从头开始写；binlog是追加写的，一定大小后切换到下一个文件，不会覆盖\n\n#### Buffer Pool缓冲池\nInnoDB重要的内存结构，数据的操作都是在Buffer Pool中操作的，如果数据不在缓冲内存中，会先从磁盘中读取到数据页到缓冲池，然后再执行相关操作。\n\n#### update执行过程\n`update T set k = k + 2 where id = '1' limit 1`\n1. 执行器调引擎读接口找id=2这一行，如果数据页本来在内存就直接返回，否则先从磁盘load到内存中再返回。\n2. 然后执行器将k值加上2，得到新的一行数据，在调用引擎的写接口写入这行新数据。\n3. 引擎将这行数据更新到内存中，同时将更新操作记录到redo log，此时redo log处于prepare状态，然后告知执行器执行完成，可以提交事务。\n4. 执行器生成这个操作的binlog并写入磁盘。\n5. 执行器调用存储引擎的事务提交接口，引擎把刚写入redo log改为commit状态，更新完成。\n\n## 两阶段提交\n保证了crash-safe能力，如果不使用两阶段提交，使用binlog恢复数据库时会导致与原数据库状态不一致。\n\n假如不使用两阶段提交，在写日志时机器发生故障：\n1. redo log写入（比如k，本来为0，执行更新后\nk = 2）后发生故障，binlog未写入。由于redo log写完之后即使系统崩溃，也会能将数据恢复，恢复后这一行数据k=2。但是binlog没写完就crash，binlog没有记录这条语句，如果使用binlog来恢复时会少一个事务，恢复后的k=0，原数据库k=2。\n2. binlog写入后发生故障，redo log未写入。redo log为写入，崩溃后这个事务无效，k=0。但是binlog已经记录了更新语句，之后恢复时会多出一个事务，恢复后k=2，原数据库k=0。\n\n## 总结\n1. MySQL连接器使用连接池维护连接，并进行检查权限，接收一个SQL语句\n2. 然后通过分析器、优化器知道如何执行SQL语句\n3. 通过执行器与存储引擎交互，完成数据的读写。\n4. 数据更新同时会写入两个重要的日志文件：redo log和binlog，并通过两阶段提交保证了crash-safe能力。\n\n**参考资料**\n[【码农有道】详解一条 SQL 的执行过程](https://mp.weixin.qq.com/s/J_ng048H4eHBm_4VBjFiWw)\n[【极客时间】MySQL实战45讲01、02讲](https://time.geekbang.org/column/article/68319)\n","slug":"MySQL-中一条-SQL-语句是如何执行的？","published":1,"updated":"2023-03-25T07:18:09.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywh001avhfidh9sebuk","content":"<h2 id=\"SQL语句执行的经过\"><a href=\"#SQL语句执行的经过\" class=\"headerlink\" title=\"SQL语句执行的经过\"></a>SQL语句执行的经过</h2><p>从用户发起请求，到服务接口调用MySQL驱动，MySQL服务器执行完SQL语句返回结果中间发生了什么？首先放一张图来看整个过程使用到的各个组件，然后再对各个过程进行分析。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-bfe61aa3f5d1fcad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-bfe61aa3f5d1fcad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" alt=\"SQL语句执行链路\"></p>\n<h3 id=\"1-连接过程\"><a href=\"#1-连接过程\" class=\"headerlink\" title=\"1. 连接过程\"></a>1. 连接过程</h3><p>以Openresty服务器为例，Openresty是多进程+I&#x2F;O多路复用结构（Nginx的I&#x2F;O模型），可以支撑高的并发，一个Worker就是一个进程，一个进程可以处理多条请求。<br>我们知道当需要执行SQL语句时需要先于MySQL服务器建立连接，如果每个一个请求都建立一个连接，使用完再关闭连接，如果频繁的创建和销毁连接显然是不合理的，浪费系统资源造成性能下降，这时连接池就出现了。</p>\n<h4 id=\"连接池\"><a href=\"#连接池\" class=\"headerlink\" title=\"连接池\"></a>连接池</h4><p>连接池会维护多个（长）连接，一个SQL语句执行时分配一个连接，使用完不会销毁连接，而是放到空闲队列中等待下次使用，这样可以在高并发的场景大大减少创建、销毁连接带来的性能问题。</p>\n<h4 id=\"连接器\"><a href=\"#连接器\" class=\"headerlink\" title=\"连接器\"></a>连接器</h4><p>类似Web服务器通过连接池维护与数据库服务器的连接，MySQL的连接器提供了同样的功能，也维护了一个连接池，不同的是MySQL连接器同时还有权限验证的功能。</p>\n<ul>\n<li>修改密码不会影响已经建立的链接。</li>\n<li>连接完成后如果没有操作，改连接就会处于空闲状态，可以使用<code>show processlist</code>命令查看，如果长时间没有操作连接器会在到达超时时间后断开它。</li>\n</ul>\n<h4 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h4><p>长连接是客户端持续有请求，使用的是同一个连接，建立连接的过程通常是比较慢的，建议尽量使用长连接。但是长连接累计较多时可能会导致内存过大（内存管理在连接对象里），比系统强行kill，引起MySQL异常重启，可以使用以下两种方法解决：</p>\n<ul>\n<li>定期断开长连接。</li>\n<li>如果是MySQL5.7及以上的版本，可以在每次执行一个比较大的操作后执行<code>mysql_reset_connection</code>重新初始化连接资源（不会重新建立连接）。</li>\n</ul>\n<h3 id=\"2-执行过程\"><a href=\"#2-执行过程\" class=\"headerlink\" title=\"2. 执行过程\"></a>2. 执行过程</h3><h4 id=\"查询缓存\"><a href=\"#查询缓存\" class=\"headerlink\" title=\"查询缓存\"></a>查询缓存</h4><p>如果是查询语句，而且开启了查询缓存，连接器拿到一个查询请求后，会先查看查询缓存是否有（之前执行过这条语句）。缓存key为sql语句，value是查询结果。</p>\n<ul>\n<li>不建议开启查询缓存，除非是基本不会变的数据表。因为只要对表有更新，该表上的所有查询缓存都会清空，导致查询命中率很低。</li>\n</ul>\n<h4 id=\"分析器\"><a href=\"#分析器\" class=\"headerlink\" title=\"分析器\"></a>分析器</h4><p>分析器的功能就是对SQL语句做词法分析和语法分析，解析这条语句要干什么，语法错误会返回错误提醒。</p>\n<h4 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h4><p>优化器是在表中有多个索引的时候决定使用哪个索引，或者有多表关联（join）的时候决定各个表的连接顺序。</p>\n<h4 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h4><p>通过分析器知道了要做什么，优化器知道了改怎么做，执行器就是真正的语句执行阶段。开始执行的时候要先判断对表是否有权限（在优化器之前也会做预检查）。执行器会调用存储引擎提供的接口进行读写操作。</p>\n<h3 id=\"3-更新语句执行过程\"><a href=\"#3-更新语句执行过程\" class=\"headerlink\" title=\"3. 更新语句执行过程\"></a>3. 更新语句执行过程</h3><p>查询语句是只读的，比较简单，经过一系列组件最终查询到结果返回。但是更新语句就相对复杂一些，涉及到两个日志模块：redo log和binlog。</p>\n<h4 id=\"redo-log（重做日志）\"><a href=\"#redo-log（重做日志）\" class=\"headerlink\" title=\"redo log（重做日志）\"></a>redo log（重做日志）</h4><p>如果每次更新都要刷盘，整个过程磁盘IO成本、查询成本都比较高，为了提升更新效率，InnoDB引擎提供了redo log（顺序写入速度很快）。</p>\n<p><strong>WAL（Write-Ahead Logging）</strong>：先写日志，再写磁盘。当有一条记录需要更新的时候，InnoDB引擎会先将记录写入redo log并更新内存，这时候更新就算完成了，再需要的时候再将这个操作更新到磁盘里。</p>\n<p><strong>日志结构</strong>：redo log大小是固定的，比如配置一组4个文件，每个文件1G，<br>就可以记录总共4G的记录。从头开始写，写完后又回到开头循环写入。</p>\n<p><strong>crash-safe</strong>：故障安全，redo log除了能提高更新操作的效率，同时还保证了故障安全，在数据库异常时不会导致数据丢失。</p>\n<h4 id=\"binlog（归档日志）\"><a href=\"#binlog（归档日志）\" class=\"headerlink\" title=\"binlog（归档日志）\"></a>binlog（归档日志）</h4><p>MySQL最开始没有InnoDB引擎，binlog日志只用于归档和复制，只依靠binlog没有crash-safe能力。</p>\n<ul>\n<li>redo log是InnoDB引擎独有的，属于存储层；binlog是MySQL提供的，属于server层</li>\n<li>redo log是物理日志，记录在某个数据页上做了什么修改；binlog是逻辑日志，记录SQL语句的原始逻辑</li>\n<li>redo log是循环写的，空间固定，用完会从头开始写；binlog是追加写的，一定大小后切换到下一个文件，不会覆盖</li>\n</ul>\n<h4 id=\"Buffer-Pool缓冲池\"><a href=\"#Buffer-Pool缓冲池\" class=\"headerlink\" title=\"Buffer Pool缓冲池\"></a>Buffer Pool缓冲池</h4><p>InnoDB重要的内存结构，数据的操作都是在Buffer Pool中操作的，如果数据不在缓冲内存中，会先从磁盘中读取到数据页到缓冲池，然后再执行相关操作。</p>\n<h4 id=\"update执行过程\"><a href=\"#update执行过程\" class=\"headerlink\" title=\"update执行过程\"></a>update执行过程</h4><p><code>update T set k = k + 2 where id = &#39;1&#39; limit 1</code></p>\n<ol>\n<li>执行器调引擎读接口找id&#x3D;2这一行，如果数据页本来在内存就直接返回，否则先从磁盘load到内存中再返回。</li>\n<li>然后执行器将k值加上2，得到新的一行数据，在调用引擎的写接口写入这行新数据。</li>\n<li>引擎将这行数据更新到内存中，同时将更新操作记录到redo log，此时redo log处于prepare状态，然后告知执行器执行完成，可以提交事务。</li>\n<li>执行器生成这个操作的binlog并写入磁盘。</li>\n<li>执行器调用存储引擎的事务提交接口，引擎把刚写入redo log改为commit状态，更新完成。</li>\n</ol>\n<h2 id=\"两阶段提交\"><a href=\"#两阶段提交\" class=\"headerlink\" title=\"两阶段提交\"></a>两阶段提交</h2><p>保证了crash-safe能力，如果不使用两阶段提交，使用binlog恢复数据库时会导致与原数据库状态不一致。</p>\n<p>假如不使用两阶段提交，在写日志时机器发生故障：</p>\n<ol>\n<li>redo log写入（比如k，本来为0，执行更新后<br>k &#x3D; 2）后发生故障，binlog未写入。由于redo log写完之后即使系统崩溃，也会能将数据恢复，恢复后这一行数据k&#x3D;2。但是binlog没写完就crash，binlog没有记录这条语句，如果使用binlog来恢复时会少一个事务，恢复后的k&#x3D;0，原数据库k&#x3D;2。</li>\n<li>binlog写入后发生故障，redo log未写入。redo log为写入，崩溃后这个事务无效，k&#x3D;0。但是binlog已经记录了更新语句，之后恢复时会多出一个事务，恢复后k&#x3D;2，原数据库k&#x3D;0。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>MySQL连接器使用连接池维护连接，并进行检查权限，接收一个SQL语句</li>\n<li>然后通过分析器、优化器知道如何执行SQL语句</li>\n<li>通过执行器与存储引擎交互，完成数据的读写。</li>\n<li>数据更新同时会写入两个重要的日志文件：redo log和binlog，并通过两阶段提交保证了crash-safe能力。</li>\n</ol>\n<p><strong>参考资料</strong><br><a href=\"https://mp.weixin.qq.com/s/J_ng048H4eHBm_4VBjFiWw\">【码农有道】详解一条 SQL 的执行过程</a><br><a href=\"https://time.geekbang.org/column/article/68319\">【极客时间】MySQL实战45讲01、02讲</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SQL语句执行的经过\"><a href=\"#SQL语句执行的经过\" class=\"headerlink\" title=\"SQL语句执行的经过\"></a>SQL语句执行的经过</h2><p>从用户发起请求，到服务接口调用MySQL驱动，MySQL服务器执行完SQL语句返回结果中间发生了什么？首先放一张图来看整个过程使用到的各个组件，然后再对各个过程进行分析。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-bfe61aa3f5d1fcad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"SQL语句执行链路\"></p>\n<h3 id=\"1-连接过程\"><a href=\"#1-连接过程\" class=\"headerlink\" title=\"1. 连接过程\"></a>1. 连接过程</h3><p>以Openresty服务器为例，Openresty是多进程+I&#x2F;O多路复用结构（Nginx的I&#x2F;O模型），可以支撑高的并发，一个Worker就是一个进程，一个进程可以处理多条请求。<br>我们知道当需要执行SQL语句时需要先于MySQL服务器建立连接，如果每个一个请求都建立一个连接，使用完再关闭连接，如果频繁的创建和销毁连接显然是不合理的，浪费系统资源造成性能下降，这时连接池就出现了。</p>\n<h4 id=\"连接池\"><a href=\"#连接池\" class=\"headerlink\" title=\"连接池\"></a>连接池</h4><p>连接池会维护多个（长）连接，一个SQL语句执行时分配一个连接，使用完不会销毁连接，而是放到空闲队列中等待下次使用，这样可以在高并发的场景大大减少创建、销毁连接带来的性能问题。</p>\n<h4 id=\"连接器\"><a href=\"#连接器\" class=\"headerlink\" title=\"连接器\"></a>连接器</h4><p>类似Web服务器通过连接池维护与数据库服务器的连接，MySQL的连接器提供了同样的功能，也维护了一个连接池，不同的是MySQL连接器同时还有权限验证的功能。</p>\n<ul>\n<li>修改密码不会影响已经建立的链接。</li>\n<li>连接完成后如果没有操作，改连接就会处于空闲状态，可以使用<code>show processlist</code>命令查看，如果长时间没有操作连接器会在到达超时时间后断开它。</li>\n</ul>\n<h4 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h4><p>长连接是客户端持续有请求，使用的是同一个连接，建立连接的过程通常是比较慢的，建议尽量使用长连接。但是长连接累计较多时可能会导致内存过大（内存管理在连接对象里），比系统强行kill，引起MySQL异常重启，可以使用以下两种方法解决：</p>\n<ul>\n<li>定期断开长连接。</li>\n<li>如果是MySQL5.7及以上的版本，可以在每次执行一个比较大的操作后执行<code>mysql_reset_connection</code>重新初始化连接资源（不会重新建立连接）。</li>\n</ul>\n<h3 id=\"2-执行过程\"><a href=\"#2-执行过程\" class=\"headerlink\" title=\"2. 执行过程\"></a>2. 执行过程</h3><h4 id=\"查询缓存\"><a href=\"#查询缓存\" class=\"headerlink\" title=\"查询缓存\"></a>查询缓存</h4><p>如果是查询语句，而且开启了查询缓存，连接器拿到一个查询请求后，会先查看查询缓存是否有（之前执行过这条语句）。缓存key为sql语句，value是查询结果。</p>\n<ul>\n<li>不建议开启查询缓存，除非是基本不会变的数据表。因为只要对表有更新，该表上的所有查询缓存都会清空，导致查询命中率很低。</li>\n</ul>\n<h4 id=\"分析器\"><a href=\"#分析器\" class=\"headerlink\" title=\"分析器\"></a>分析器</h4><p>分析器的功能就是对SQL语句做词法分析和语法分析，解析这条语句要干什么，语法错误会返回错误提醒。</p>\n<h4 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h4><p>优化器是在表中有多个索引的时候决定使用哪个索引，或者有多表关联（join）的时候决定各个表的连接顺序。</p>\n<h4 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h4><p>通过分析器知道了要做什么，优化器知道了改怎么做，执行器就是真正的语句执行阶段。开始执行的时候要先判断对表是否有权限（在优化器之前也会做预检查）。执行器会调用存储引擎提供的接口进行读写操作。</p>\n<h3 id=\"3-更新语句执行过程\"><a href=\"#3-更新语句执行过程\" class=\"headerlink\" title=\"3. 更新语句执行过程\"></a>3. 更新语句执行过程</h3><p>查询语句是只读的，比较简单，经过一系列组件最终查询到结果返回。但是更新语句就相对复杂一些，涉及到两个日志模块：redo log和binlog。</p>\n<h4 id=\"redo-log（重做日志）\"><a href=\"#redo-log（重做日志）\" class=\"headerlink\" title=\"redo log（重做日志）\"></a>redo log（重做日志）</h4><p>如果每次更新都要刷盘，整个过程磁盘IO成本、查询成本都比较高，为了提升更新效率，InnoDB引擎提供了redo log（顺序写入速度很快）。</p>\n<p><strong>WAL（Write-Ahead Logging）</strong>：先写日志，再写磁盘。当有一条记录需要更新的时候，InnoDB引擎会先将记录写入redo log并更新内存，这时候更新就算完成了，再需要的时候再将这个操作更新到磁盘里。</p>\n<p><strong>日志结构</strong>：redo log大小是固定的，比如配置一组4个文件，每个文件1G，<br>就可以记录总共4G的记录。从头开始写，写完后又回到开头循环写入。</p>\n<p><strong>crash-safe</strong>：故障安全，redo log除了能提高更新操作的效率，同时还保证了故障安全，在数据库异常时不会导致数据丢失。</p>\n<h4 id=\"binlog（归档日志）\"><a href=\"#binlog（归档日志）\" class=\"headerlink\" title=\"binlog（归档日志）\"></a>binlog（归档日志）</h4><p>MySQL最开始没有InnoDB引擎，binlog日志只用于归档和复制，只依靠binlog没有crash-safe能力。</p>\n<ul>\n<li>redo log是InnoDB引擎独有的，属于存储层；binlog是MySQL提供的，属于server层</li>\n<li>redo log是物理日志，记录在某个数据页上做了什么修改；binlog是逻辑日志，记录SQL语句的原始逻辑</li>\n<li>redo log是循环写的，空间固定，用完会从头开始写；binlog是追加写的，一定大小后切换到下一个文件，不会覆盖</li>\n</ul>\n<h4 id=\"Buffer-Pool缓冲池\"><a href=\"#Buffer-Pool缓冲池\" class=\"headerlink\" title=\"Buffer Pool缓冲池\"></a>Buffer Pool缓冲池</h4><p>InnoDB重要的内存结构，数据的操作都是在Buffer Pool中操作的，如果数据不在缓冲内存中，会先从磁盘中读取到数据页到缓冲池，然后再执行相关操作。</p>\n<h4 id=\"update执行过程\"><a href=\"#update执行过程\" class=\"headerlink\" title=\"update执行过程\"></a>update执行过程</h4><p><code>update T set k = k + 2 where id = &#39;1&#39; limit 1</code></p>\n<ol>\n<li>执行器调引擎读接口找id&#x3D;2这一行，如果数据页本来在内存就直接返回，否则先从磁盘load到内存中再返回。</li>\n<li>然后执行器将k值加上2，得到新的一行数据，在调用引擎的写接口写入这行新数据。</li>\n<li>引擎将这行数据更新到内存中，同时将更新操作记录到redo log，此时redo log处于prepare状态，然后告知执行器执行完成，可以提交事务。</li>\n<li>执行器生成这个操作的binlog并写入磁盘。</li>\n<li>执行器调用存储引擎的事务提交接口，引擎把刚写入redo log改为commit状态，更新完成。</li>\n</ol>\n<h2 id=\"两阶段提交\"><a href=\"#两阶段提交\" class=\"headerlink\" title=\"两阶段提交\"></a>两阶段提交</h2><p>保证了crash-safe能力，如果不使用两阶段提交，使用binlog恢复数据库时会导致与原数据库状态不一致。</p>\n<p>假如不使用两阶段提交，在写日志时机器发生故障：</p>\n<ol>\n<li>redo log写入（比如k，本来为0，执行更新后<br>k &#x3D; 2）后发生故障，binlog未写入。由于redo log写完之后即使系统崩溃，也会能将数据恢复，恢复后这一行数据k&#x3D;2。但是binlog没写完就crash，binlog没有记录这条语句，如果使用binlog来恢复时会少一个事务，恢复后的k&#x3D;0，原数据库k&#x3D;2。</li>\n<li>binlog写入后发生故障，redo log未写入。redo log为写入，崩溃后这个事务无效，k&#x3D;0。但是binlog已经记录了更新语句，之后恢复时会多出一个事务，恢复后k&#x3D;2，原数据库k&#x3D;0。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>MySQL连接器使用连接池维护连接，并进行检查权限，接收一个SQL语句</li>\n<li>然后通过分析器、优化器知道如何执行SQL语句</li>\n<li>通过执行器与存储引擎交互，完成数据的读写。</li>\n<li>数据更新同时会写入两个重要的日志文件：redo log和binlog，并通过两阶段提交保证了crash-safe能力。</li>\n</ol>\n<p><strong>参考资料</strong><br><a href=\"https://mp.weixin.qq.com/s/J_ng048H4eHBm_4VBjFiWw\">【码农有道】详解一条 SQL 的执行过程</a><br><a href=\"https://time.geekbang.org/column/article/68319\">【极客时间】MySQL实战45讲01、02讲</a></p>\n"},{"title":"MySQL 和 NoSQL基础知识概述","date":"2023-03-25T07:10:58.000Z","_content":"## MySQL\n\n### 索引\n\n- B+Tree\n\n\t- 平衡树，查找树，所有叶子节点位于同一层\n\t- 进行查找时首先再根节点进行二分查找，找到一个key所在的指针，然后递归的在指针所指向的节点进行查找，直到查到叶子节点，然后在叶子节点二分查找，找出key所对应的data\n\t- 插入删除操作会破坏数的平衡性，需要进行分裂、合并、旋转等操作来维护平衡性\n\t- 与红黑树相比\n\n\t\t- B+树的高度更低\n\t\t- 更适合磁盘访问，节点大小设置和磁盘页大小一致\n\t\t- 磁盘预读，减少I/O\n\n- MySQL索引\n\n\t- 索引类型\n\n\t\t- B+Tree索引\n\n\t\t\t- 大多数MySQL存储引擎的默认索引类型\n\t\t\t- 有序性保证查找、排序、分组效率更高\n\t\t\t- 可以指定多个列为索引列，多个索引列共同组成键\n\t\t\t- 适用于全键值、键值范围和键前缀（只支持最左前缀）查找\n\t\t\t- 主索引和辅助索引\n\n\t\t\t\t- 主索引的叶子节点data域记录着完整的数据记录，称为聚簇索引，一个表只能有一个聚簇索引\n\t\t\t\t- 辅助索引的叶子节点域记录着主键的值，因此使用辅助索引要先查到主键的值，再到主索引查数据\n\n\t\t- 哈希索引\n\n\t\t\t- O(1)查找，但失去了有序性\n\n\t\t\t\t- 无法用于排序和分组\n\t\t\t\t- 只支持精确查找，不能用于部分查找和范围查找\n\n\t\t\t- InnoDB自适应哈希索引，当某个索引值被使用的非常频繁时，会在B+Tree索引只上再建一个哈希索引，以实现快速的哈希查找\n\n\t\t- 全文索引\n\n\t\t\t- 查找文本中的关键字而不是等值比较\n\n\t\t- 空间数据索引\n\n\t- 索引优化\n\n\t\t- 独立的列：索引列不能是表达式的一部分，也不能是函数的参数，否则不会使用索引\n\t\t- 多列索引：需要使用多个列作为条件查询时，使用多列索引比使用单列索引性能更好\n\t\t- 索引列的顺序：选择性强的索引列放在前面\n\t\t- 前缀索引：对于BLOB、TEXT、VARCHAR类型的数据，必须使用前缀索引，只索引开始的部分字符\n\t\t- 覆盖索引：索引包含所有需要查询的字段的值\n\n\t\t\t- 索引通常远小于数据行的大小，只读取索引能减少数据访问量\n\t\t\t- 一些存储引擎（MyISAM）在内存中只缓存索引，只访问索引可以不使用系统调用\n\t\t\t- 对于InnoDB引擎，若辅助索引能够覆盖查询，则无需访问主索引\n\n\t- 优点\n\n\t\t- 大大减少需要扫描的数据行数\n\t\t- 帮助服务器避免进行排序和分组，以及避免创建临时表\n\t\t- 将随机I/O变为顺序I/O\n\n\t- 使用条件\n\n\t\t- 对于非常小的表大部分情况下全表扫描更高效（如用来保存配置信息的表）\n\t\t- 对于中型大型的表，使用索引的效果非常明显\n\t\t- 对于特大型的表，建立和维护索引的代价会随之增长\n\n\t\t\t- 分区\n\t\t\t- 分库分表\n\n### 查询性能优化\n\n- 使用Explain进行分析\n\n\t- Select_type：查询类型，如简单查询，联合查询、子查询\n\t- key：使用的索引\n\t- Rows：扫描的行数\n\n- 优化数据访问\n\n\t- 减少请求的数据量\n\n\t\t- 只返回必要的列，拒绝无脑select * from...\n\t\t- 只返回必要的行，使用limit限制返回的数据数量\n\t\t- 缓存重复查询的数据\n\n\t- 减少扫描的行数\n\n\t\t- 用索引覆盖查询\n\n- 重构查询方式\n\n\t- 切分大查询\n\t- 分解大连接查询（将一个大连接查询分解成对每个表进行\n一次单表查询，然后在应用程序中进行关联）\n\t  - 让缓存更高效，分解后多个查询，即使一个表发生改变，其他表的缓存仍然可以使用\n\t  - 单表查询的结果可能被其他查询用到，减少冗余记录的查询\n\t  - 减少锁竞争\n\t  - 应用层进行连接，更容易对数据库进行拆分，从而更容易做到高性能和可伸缩\n\t  - 查询本身效率提升\n\n### 存储引擎\n\n- InnoDB\n\n\t- MySQL默认的事务型存储引擎\n\t- 实现了四个标准的事务隔离级别\n\t- 主索引是聚簇索引，在索引中保存了数据，对查询性能很大提升\n\t- 内部做了优化，比如磁盘读取数据时采用可预测性读，自动创建自适应哈希索引，能加快插入操作的插入缓冲区\n\t- 支持真正的在线热备份\n\n- MyISAM\n\n\t- 设计简单，提供了很多特性，如压缩表、空间数据索引\n\t- 不支持事务、不支持行级锁\n\n- 如果不是特殊特性需要，建议都使用InnoDB引擎\n\n### 复制\n\n- 主从复制\n\n\t- binlog线程：负责将主服务器上的数据更改写入二进制日志中\n\t- I/O线程：负责从主服务器上读取binlog，并写入从服务器的中继日志（Relay Log）\n\t- SQL线程：负责读取中继日志，解析出SQL更改并在从服务器中重放（Replay）\n\t- 主从复制不是强一致性，只能保证最终一致性\n\t- 复制模式\n\n\t\t- 异步模式\n\n\t\t\t- 主节点不会主动push binlog，同步不及时\n\n\t\t- 半同步复制\n\n\t\t\t- 主节点只需要接收到一台从节点的返回信息就会commit，否则会等到超时然后切换成异步模式再提交，不保证从节点写入db。减少了数据延迟，响应时间会变长\n\n\t\t- 全同步复制\n\n\t\t\t- 全同步模式是主节点和从节点全部执行了commit并确认才会想客户端返回成功。响应时间最长\n\n- 读写分离\n\n\t- 优点\n\n\t\t- 主从服务器负责各自的读写，减少锁竞争\n\t\t- 增加冗余，提高可用性\n\n\t- 中间件\n\n\t\t- MySQL-Proxy\n\t\t- MySQL-Router\n\t\t- MyCat\n\n### binlog的业务应用\n\n- 数据异构\n\n\t- 随着业务发展，一些表各个业务都关注，但是对字段的使用场景不同。如订单表，可以通过binlog解析成用户维度的订单信息供用户中心查询、商户维度的订单表供运营管理、审计等\n\n- 缓存更新\n\n\t- 客户端更新了数据，缓存还未过期，可以通过binlog获取数据变更，并同步到缓存中\n\n- 任务分发\n\n\t- 多个系统依赖同一块重要数据，当数据发生变化需要通知其他系统。可以由调度系统订阅binlog进行相应的任务分发、消息发送\n\n## NoSQL\n\n### not only sql\n\n### KV型\n\n- Redis\n\n### 搜索型\n\n- ElasticSearch\n\n### 列式\n\n- HBase\n\n\t- 海量数据存储，数据持久化\n\t- 读写性能好\n\t- 横向扩展再关系型数据库中最方便的之一\n\t- 本身没有单点故障，高可用\n\t- 可存储结构化或半结构化的数据\n\t- 比较重，依赖Hadoop组件，运维成本高\n\t- KV式，条件查询弱\n\t- 不支持分页查询\n\n### 文档型\n\n- MongoDB\n\n[【参考资料】GitHub-CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes)\n","source":"_posts/2023/03-25-MySQL-和-NoSQL基础知识概述.md","raw":"---\ntitle: MySQL 和 NoSQL基础知识概述\ndate: 2023-03-25 15:10:58\ncategories:\n- [数据库]\ntags:\n- MySQL\n- NoSQL\n---\n## MySQL\n\n### 索引\n\n- B+Tree\n\n\t- 平衡树，查找树，所有叶子节点位于同一层\n\t- 进行查找时首先再根节点进行二分查找，找到一个key所在的指针，然后递归的在指针所指向的节点进行查找，直到查到叶子节点，然后在叶子节点二分查找，找出key所对应的data\n\t- 插入删除操作会破坏数的平衡性，需要进行分裂、合并、旋转等操作来维护平衡性\n\t- 与红黑树相比\n\n\t\t- B+树的高度更低\n\t\t- 更适合磁盘访问，节点大小设置和磁盘页大小一致\n\t\t- 磁盘预读，减少I/O\n\n- MySQL索引\n\n\t- 索引类型\n\n\t\t- B+Tree索引\n\n\t\t\t- 大多数MySQL存储引擎的默认索引类型\n\t\t\t- 有序性保证查找、排序、分组效率更高\n\t\t\t- 可以指定多个列为索引列，多个索引列共同组成键\n\t\t\t- 适用于全键值、键值范围和键前缀（只支持最左前缀）查找\n\t\t\t- 主索引和辅助索引\n\n\t\t\t\t- 主索引的叶子节点data域记录着完整的数据记录，称为聚簇索引，一个表只能有一个聚簇索引\n\t\t\t\t- 辅助索引的叶子节点域记录着主键的值，因此使用辅助索引要先查到主键的值，再到主索引查数据\n\n\t\t- 哈希索引\n\n\t\t\t- O(1)查找，但失去了有序性\n\n\t\t\t\t- 无法用于排序和分组\n\t\t\t\t- 只支持精确查找，不能用于部分查找和范围查找\n\n\t\t\t- InnoDB自适应哈希索引，当某个索引值被使用的非常频繁时，会在B+Tree索引只上再建一个哈希索引，以实现快速的哈希查找\n\n\t\t- 全文索引\n\n\t\t\t- 查找文本中的关键字而不是等值比较\n\n\t\t- 空间数据索引\n\n\t- 索引优化\n\n\t\t- 独立的列：索引列不能是表达式的一部分，也不能是函数的参数，否则不会使用索引\n\t\t- 多列索引：需要使用多个列作为条件查询时，使用多列索引比使用单列索引性能更好\n\t\t- 索引列的顺序：选择性强的索引列放在前面\n\t\t- 前缀索引：对于BLOB、TEXT、VARCHAR类型的数据，必须使用前缀索引，只索引开始的部分字符\n\t\t- 覆盖索引：索引包含所有需要查询的字段的值\n\n\t\t\t- 索引通常远小于数据行的大小，只读取索引能减少数据访问量\n\t\t\t- 一些存储引擎（MyISAM）在内存中只缓存索引，只访问索引可以不使用系统调用\n\t\t\t- 对于InnoDB引擎，若辅助索引能够覆盖查询，则无需访问主索引\n\n\t- 优点\n\n\t\t- 大大减少需要扫描的数据行数\n\t\t- 帮助服务器避免进行排序和分组，以及避免创建临时表\n\t\t- 将随机I/O变为顺序I/O\n\n\t- 使用条件\n\n\t\t- 对于非常小的表大部分情况下全表扫描更高效（如用来保存配置信息的表）\n\t\t- 对于中型大型的表，使用索引的效果非常明显\n\t\t- 对于特大型的表，建立和维护索引的代价会随之增长\n\n\t\t\t- 分区\n\t\t\t- 分库分表\n\n### 查询性能优化\n\n- 使用Explain进行分析\n\n\t- Select_type：查询类型，如简单查询，联合查询、子查询\n\t- key：使用的索引\n\t- Rows：扫描的行数\n\n- 优化数据访问\n\n\t- 减少请求的数据量\n\n\t\t- 只返回必要的列，拒绝无脑select * from...\n\t\t- 只返回必要的行，使用limit限制返回的数据数量\n\t\t- 缓存重复查询的数据\n\n\t- 减少扫描的行数\n\n\t\t- 用索引覆盖查询\n\n- 重构查询方式\n\n\t- 切分大查询\n\t- 分解大连接查询（将一个大连接查询分解成对每个表进行\n一次单表查询，然后在应用程序中进行关联）\n\t  - 让缓存更高效，分解后多个查询，即使一个表发生改变，其他表的缓存仍然可以使用\n\t  - 单表查询的结果可能被其他查询用到，减少冗余记录的查询\n\t  - 减少锁竞争\n\t  - 应用层进行连接，更容易对数据库进行拆分，从而更容易做到高性能和可伸缩\n\t  - 查询本身效率提升\n\n### 存储引擎\n\n- InnoDB\n\n\t- MySQL默认的事务型存储引擎\n\t- 实现了四个标准的事务隔离级别\n\t- 主索引是聚簇索引，在索引中保存了数据，对查询性能很大提升\n\t- 内部做了优化，比如磁盘读取数据时采用可预测性读，自动创建自适应哈希索引，能加快插入操作的插入缓冲区\n\t- 支持真正的在线热备份\n\n- MyISAM\n\n\t- 设计简单，提供了很多特性，如压缩表、空间数据索引\n\t- 不支持事务、不支持行级锁\n\n- 如果不是特殊特性需要，建议都使用InnoDB引擎\n\n### 复制\n\n- 主从复制\n\n\t- binlog线程：负责将主服务器上的数据更改写入二进制日志中\n\t- I/O线程：负责从主服务器上读取binlog，并写入从服务器的中继日志（Relay Log）\n\t- SQL线程：负责读取中继日志，解析出SQL更改并在从服务器中重放（Replay）\n\t- 主从复制不是强一致性，只能保证最终一致性\n\t- 复制模式\n\n\t\t- 异步模式\n\n\t\t\t- 主节点不会主动push binlog，同步不及时\n\n\t\t- 半同步复制\n\n\t\t\t- 主节点只需要接收到一台从节点的返回信息就会commit，否则会等到超时然后切换成异步模式再提交，不保证从节点写入db。减少了数据延迟，响应时间会变长\n\n\t\t- 全同步复制\n\n\t\t\t- 全同步模式是主节点和从节点全部执行了commit并确认才会想客户端返回成功。响应时间最长\n\n- 读写分离\n\n\t- 优点\n\n\t\t- 主从服务器负责各自的读写，减少锁竞争\n\t\t- 增加冗余，提高可用性\n\n\t- 中间件\n\n\t\t- MySQL-Proxy\n\t\t- MySQL-Router\n\t\t- MyCat\n\n### binlog的业务应用\n\n- 数据异构\n\n\t- 随着业务发展，一些表各个业务都关注，但是对字段的使用场景不同。如订单表，可以通过binlog解析成用户维度的订单信息供用户中心查询、商户维度的订单表供运营管理、审计等\n\n- 缓存更新\n\n\t- 客户端更新了数据，缓存还未过期，可以通过binlog获取数据变更，并同步到缓存中\n\n- 任务分发\n\n\t- 多个系统依赖同一块重要数据，当数据发生变化需要通知其他系统。可以由调度系统订阅binlog进行相应的任务分发、消息发送\n\n## NoSQL\n\n### not only sql\n\n### KV型\n\n- Redis\n\n### 搜索型\n\n- ElasticSearch\n\n### 列式\n\n- HBase\n\n\t- 海量数据存储，数据持久化\n\t- 读写性能好\n\t- 横向扩展再关系型数据库中最方便的之一\n\t- 本身没有单点故障，高可用\n\t- 可存储结构化或半结构化的数据\n\t- 比较重，依赖Hadoop组件，运维成本高\n\t- KV式，条件查询弱\n\t- 不支持分页查询\n\n### 文档型\n\n- MongoDB\n\n[【参考资料】GitHub-CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes)\n","slug":"MySQL-和-NoSQL基础知识概述","published":1,"updated":"2023-03-25T07:18:51.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywi001dvhfibuy6dcwc","content":"<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><ul>\n<li><p>B+Tree</p>\n<ul>\n<li><p>平衡树，查找树，所有叶子节点位于同一层</p>\n</li>\n<li><p>进行查找时首先再根节点进行二分查找，找到一个key所在的指针，然后递归的在指针所指向的节点进行查找，直到查到叶子节点，然后在叶子节点二分查找，找出key所对应的data</p>\n</li>\n<li><p>插入删除操作会破坏数的平衡性，需要进行分裂、合并、旋转等操作来维护平衡性</p>\n</li>\n<li><p>与红黑树相比</p>\n<ul>\n<li>B+树的高度更低</li>\n<li>更适合磁盘访问，节点大小设置和磁盘页大小一致</li>\n<li>磁盘预读，减少I&#x2F;O</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>MySQL索引</p>\n<ul>\n<li><p>索引类型</p>\n<ul>\n<li><p>B+Tree索引</p>\n<ul>\n<li><p>大多数MySQL存储引擎的默认索引类型</p>\n</li>\n<li><p>有序性保证查找、排序、分组效率更高</p>\n</li>\n<li><p>可以指定多个列为索引列，多个索引列共同组成键</p>\n</li>\n<li><p>适用于全键值、键值范围和键前缀（只支持最左前缀）查找</p>\n</li>\n<li><p>主索引和辅助索引</p>\n<ul>\n<li>主索引的叶子节点data域记录着完整的数据记录，称为聚簇索引，一个表只能有一个聚簇索引</li>\n<li>辅助索引的叶子节点域记录着主键的值，因此使用辅助索引要先查到主键的值，再到主索引查数据</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>哈希索引</p>\n<ul>\n<li><p>O(1)查找，但失去了有序性</p>\n<ul>\n<li>无法用于排序和分组</li>\n<li>只支持精确查找，不能用于部分查找和范围查找</li>\n</ul>\n</li>\n<li><p>InnoDB自适应哈希索引，当某个索引值被使用的非常频繁时，会在B+Tree索引只上再建一个哈希索引，以实现快速的哈希查找</p>\n</li>\n</ul>\n</li>\n<li><p>全文索引</p>\n<ul>\n<li>查找文本中的关键字而不是等值比较</li>\n</ul>\n</li>\n<li><p>空间数据索引</p>\n</li>\n</ul>\n</li>\n<li><p>索引优化</p>\n<ul>\n<li><p>独立的列：索引列不能是表达式的一部分，也不能是函数的参数，否则不会使用索引</p>\n</li>\n<li><p>多列索引：需要使用多个列作为条件查询时，使用多列索引比使用单列索引性能更好</p>\n</li>\n<li><p>索引列的顺序：选择性强的索引列放在前面</p>\n</li>\n<li><p>前缀索引：对于BLOB、TEXT、VARCHAR类型的数据，必须使用前缀索引，只索引开始的部分字符</p>\n</li>\n<li><p>覆盖索引：索引包含所有需要查询的字段的值</p>\n<ul>\n<li>索引通常远小于数据行的大小，只读取索引能减少数据访问量</li>\n<li>一些存储引擎（MyISAM）在内存中只缓存索引，只访问索引可以不使用系统调用</li>\n<li>对于InnoDB引擎，若辅助索引能够覆盖查询，则无需访问主索引</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>大大减少需要扫描的数据行数</li>\n<li>帮助服务器避免进行排序和分组，以及避免创建临时表</li>\n<li>将随机I&#x2F;O变为顺序I&#x2F;O</li>\n</ul>\n</li>\n<li><p>使用条件</p>\n<ul>\n<li><p>对于非常小的表大部分情况下全表扫描更高效（如用来保存配置信息的表）</p>\n</li>\n<li><p>对于中型大型的表，使用索引的效果非常明显</p>\n</li>\n<li><p>对于特大型的表，建立和维护索引的代价会随之增长</p>\n<ul>\n<li>分区</li>\n<li>分库分表</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"查询性能优化\"><a href=\"#查询性能优化\" class=\"headerlink\" title=\"查询性能优化\"></a>查询性能优化</h3><ul>\n<li><p>使用Explain进行分析</p>\n<ul>\n<li>Select_type：查询类型，如简单查询，联合查询、子查询</li>\n<li>key：使用的索引</li>\n<li>Rows：扫描的行数</li>\n</ul>\n</li>\n<li><p>优化数据访问</p>\n<ul>\n<li><p>减少请求的数据量</p>\n<ul>\n<li>只返回必要的列，拒绝无脑select * from…</li>\n<li>只返回必要的行，使用limit限制返回的数据数量</li>\n<li>缓存重复查询的数据</li>\n</ul>\n</li>\n<li><p>减少扫描的行数</p>\n<ul>\n<li>用索引覆盖查询</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>重构查询方式</p>\n<ul>\n<li>切分大查询</li>\n<li>分解大连接查询（将一个大连接查询分解成对每个表进行</li>\n</ul>\n</li>\n</ul>\n<p>一次单表查询，然后在应用程序中进行关联）<br>      - 让缓存更高效，分解后多个查询，即使一个表发生改变，其他表的缓存仍然可以使用<br>      - 单表查询的结果可能被其他查询用到，减少冗余记录的查询<br>      - 减少锁竞争<br>      - 应用层进行连接，更容易对数据库进行拆分，从而更容易做到高性能和可伸缩<br>      - 查询本身效率提升</p>\n<h3 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h3><ul>\n<li><p>InnoDB</p>\n<ul>\n<li>MySQL默认的事务型存储引擎</li>\n<li>实现了四个标准的事务隔离级别</li>\n<li>主索引是聚簇索引，在索引中保存了数据，对查询性能很大提升</li>\n<li>内部做了优化，比如磁盘读取数据时采用可预测性读，自动创建自适应哈希索引，能加快插入操作的插入缓冲区</li>\n<li>支持真正的在线热备份</li>\n</ul>\n</li>\n<li><p>MyISAM</p>\n<ul>\n<li>设计简单，提供了很多特性，如压缩表、空间数据索引</li>\n<li>不支持事务、不支持行级锁</li>\n</ul>\n</li>\n<li><p>如果不是特殊特性需要，建议都使用InnoDB引擎</p>\n</li>\n</ul>\n<h3 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h3><ul>\n<li><p>主从复制</p>\n<ul>\n<li><p>binlog线程：负责将主服务器上的数据更改写入二进制日志中</p>\n</li>\n<li><p>I&#x2F;O线程：负责从主服务器上读取binlog，并写入从服务器的中继日志（Relay Log）</p>\n</li>\n<li><p>SQL线程：负责读取中继日志，解析出SQL更改并在从服务器中重放（Replay）</p>\n</li>\n<li><p>主从复制不是强一致性，只能保证最终一致性</p>\n</li>\n<li><p>复制模式</p>\n<ul>\n<li><p>异步模式</p>\n<ul>\n<li>主节点不会主动push binlog，同步不及时</li>\n</ul>\n</li>\n<li><p>半同步复制</p>\n<ul>\n<li>主节点只需要接收到一台从节点的返回信息就会commit，否则会等到超时然后切换成异步模式再提交，不保证从节点写入db。减少了数据延迟，响应时间会变长</li>\n</ul>\n</li>\n<li><p>全同步复制</p>\n<ul>\n<li>全同步模式是主节点和从节点全部执行了commit并确认才会想客户端返回成功。响应时间最长</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>读写分离</p>\n<ul>\n<li><p>优点</p>\n<ul>\n<li>主从服务器负责各自的读写，减少锁竞争</li>\n<li>增加冗余，提高可用性</li>\n</ul>\n</li>\n<li><p>中间件</p>\n<ul>\n<li>MySQL-Proxy</li>\n<li>MySQL-Router</li>\n<li>MyCat</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"binlog的业务应用\"><a href=\"#binlog的业务应用\" class=\"headerlink\" title=\"binlog的业务应用\"></a>binlog的业务应用</h3><ul>\n<li><p>数据异构</p>\n<ul>\n<li>随着业务发展，一些表各个业务都关注，但是对字段的使用场景不同。如订单表，可以通过binlog解析成用户维度的订单信息供用户中心查询、商户维度的订单表供运营管理、审计等</li>\n</ul>\n</li>\n<li><p>缓存更新</p>\n<ul>\n<li>客户端更新了数据，缓存还未过期，可以通过binlog获取数据变更，并同步到缓存中</li>\n</ul>\n</li>\n<li><p>任务分发</p>\n<ul>\n<li>多个系统依赖同一块重要数据，当数据发生变化需要通知其他系统。可以由调度系统订阅binlog进行相应的任务分发、消息发送</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"NoSQL\"><a href=\"#NoSQL\" class=\"headerlink\" title=\"NoSQL\"></a>NoSQL</h2><h3 id=\"not-only-sql\"><a href=\"#not-only-sql\" class=\"headerlink\" title=\"not only sql\"></a>not only sql</h3><h3 id=\"KV型\"><a href=\"#KV型\" class=\"headerlink\" title=\"KV型\"></a>KV型</h3><ul>\n<li>Redis</li>\n</ul>\n<h3 id=\"搜索型\"><a href=\"#搜索型\" class=\"headerlink\" title=\"搜索型\"></a>搜索型</h3><ul>\n<li>ElasticSearch</li>\n</ul>\n<h3 id=\"列式\"><a href=\"#列式\" class=\"headerlink\" title=\"列式\"></a>列式</h3><ul>\n<li><p>HBase</p>\n<ul>\n<li>海量数据存储，数据持久化</li>\n<li>读写性能好</li>\n<li>横向扩展再关系型数据库中最方便的之一</li>\n<li>本身没有单点故障，高可用</li>\n<li>可存储结构化或半结构化的数据</li>\n<li>比较重，依赖Hadoop组件，运维成本高</li>\n<li>KV式，条件查询弱</li>\n<li>不支持分页查询</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文档型\"><a href=\"#文档型\" class=\"headerlink\" title=\"文档型\"></a>文档型</h3><ul>\n<li>MongoDB</li>\n</ul>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">【参考资料】GitHub-CyC2018&#x2F;CS-Notes</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><ul>\n<li><p>B+Tree</p>\n<ul>\n<li><p>平衡树，查找树，所有叶子节点位于同一层</p>\n</li>\n<li><p>进行查找时首先再根节点进行二分查找，找到一个key所在的指针，然后递归的在指针所指向的节点进行查找，直到查到叶子节点，然后在叶子节点二分查找，找出key所对应的data</p>\n</li>\n<li><p>插入删除操作会破坏数的平衡性，需要进行分裂、合并、旋转等操作来维护平衡性</p>\n</li>\n<li><p>与红黑树相比</p>\n<ul>\n<li>B+树的高度更低</li>\n<li>更适合磁盘访问，节点大小设置和磁盘页大小一致</li>\n<li>磁盘预读，减少I&#x2F;O</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>MySQL索引</p>\n<ul>\n<li><p>索引类型</p>\n<ul>\n<li><p>B+Tree索引</p>\n<ul>\n<li><p>大多数MySQL存储引擎的默认索引类型</p>\n</li>\n<li><p>有序性保证查找、排序、分组效率更高</p>\n</li>\n<li><p>可以指定多个列为索引列，多个索引列共同组成键</p>\n</li>\n<li><p>适用于全键值、键值范围和键前缀（只支持最左前缀）查找</p>\n</li>\n<li><p>主索引和辅助索引</p>\n<ul>\n<li>主索引的叶子节点data域记录着完整的数据记录，称为聚簇索引，一个表只能有一个聚簇索引</li>\n<li>辅助索引的叶子节点域记录着主键的值，因此使用辅助索引要先查到主键的值，再到主索引查数据</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>哈希索引</p>\n<ul>\n<li><p>O(1)查找，但失去了有序性</p>\n<ul>\n<li>无法用于排序和分组</li>\n<li>只支持精确查找，不能用于部分查找和范围查找</li>\n</ul>\n</li>\n<li><p>InnoDB自适应哈希索引，当某个索引值被使用的非常频繁时，会在B+Tree索引只上再建一个哈希索引，以实现快速的哈希查找</p>\n</li>\n</ul>\n</li>\n<li><p>全文索引</p>\n<ul>\n<li>查找文本中的关键字而不是等值比较</li>\n</ul>\n</li>\n<li><p>空间数据索引</p>\n</li>\n</ul>\n</li>\n<li><p>索引优化</p>\n<ul>\n<li><p>独立的列：索引列不能是表达式的一部分，也不能是函数的参数，否则不会使用索引</p>\n</li>\n<li><p>多列索引：需要使用多个列作为条件查询时，使用多列索引比使用单列索引性能更好</p>\n</li>\n<li><p>索引列的顺序：选择性强的索引列放在前面</p>\n</li>\n<li><p>前缀索引：对于BLOB、TEXT、VARCHAR类型的数据，必须使用前缀索引，只索引开始的部分字符</p>\n</li>\n<li><p>覆盖索引：索引包含所有需要查询的字段的值</p>\n<ul>\n<li>索引通常远小于数据行的大小，只读取索引能减少数据访问量</li>\n<li>一些存储引擎（MyISAM）在内存中只缓存索引，只访问索引可以不使用系统调用</li>\n<li>对于InnoDB引擎，若辅助索引能够覆盖查询，则无需访问主索引</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>大大减少需要扫描的数据行数</li>\n<li>帮助服务器避免进行排序和分组，以及避免创建临时表</li>\n<li>将随机I&#x2F;O变为顺序I&#x2F;O</li>\n</ul>\n</li>\n<li><p>使用条件</p>\n<ul>\n<li><p>对于非常小的表大部分情况下全表扫描更高效（如用来保存配置信息的表）</p>\n</li>\n<li><p>对于中型大型的表，使用索引的效果非常明显</p>\n</li>\n<li><p>对于特大型的表，建立和维护索引的代价会随之增长</p>\n<ul>\n<li>分区</li>\n<li>分库分表</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"查询性能优化\"><a href=\"#查询性能优化\" class=\"headerlink\" title=\"查询性能优化\"></a>查询性能优化</h3><ul>\n<li><p>使用Explain进行分析</p>\n<ul>\n<li>Select_type：查询类型，如简单查询，联合查询、子查询</li>\n<li>key：使用的索引</li>\n<li>Rows：扫描的行数</li>\n</ul>\n</li>\n<li><p>优化数据访问</p>\n<ul>\n<li><p>减少请求的数据量</p>\n<ul>\n<li>只返回必要的列，拒绝无脑select * from…</li>\n<li>只返回必要的行，使用limit限制返回的数据数量</li>\n<li>缓存重复查询的数据</li>\n</ul>\n</li>\n<li><p>减少扫描的行数</p>\n<ul>\n<li>用索引覆盖查询</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>重构查询方式</p>\n<ul>\n<li>切分大查询</li>\n<li>分解大连接查询（将一个大连接查询分解成对每个表进行</li>\n</ul>\n</li>\n</ul>\n<p>一次单表查询，然后在应用程序中进行关联）<br>      - 让缓存更高效，分解后多个查询，即使一个表发生改变，其他表的缓存仍然可以使用<br>      - 单表查询的结果可能被其他查询用到，减少冗余记录的查询<br>      - 减少锁竞争<br>      - 应用层进行连接，更容易对数据库进行拆分，从而更容易做到高性能和可伸缩<br>      - 查询本身效率提升</p>\n<h3 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h3><ul>\n<li><p>InnoDB</p>\n<ul>\n<li>MySQL默认的事务型存储引擎</li>\n<li>实现了四个标准的事务隔离级别</li>\n<li>主索引是聚簇索引，在索引中保存了数据，对查询性能很大提升</li>\n<li>内部做了优化，比如磁盘读取数据时采用可预测性读，自动创建自适应哈希索引，能加快插入操作的插入缓冲区</li>\n<li>支持真正的在线热备份</li>\n</ul>\n</li>\n<li><p>MyISAM</p>\n<ul>\n<li>设计简单，提供了很多特性，如压缩表、空间数据索引</li>\n<li>不支持事务、不支持行级锁</li>\n</ul>\n</li>\n<li><p>如果不是特殊特性需要，建议都使用InnoDB引擎</p>\n</li>\n</ul>\n<h3 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h3><ul>\n<li><p>主从复制</p>\n<ul>\n<li><p>binlog线程：负责将主服务器上的数据更改写入二进制日志中</p>\n</li>\n<li><p>I&#x2F;O线程：负责从主服务器上读取binlog，并写入从服务器的中继日志（Relay Log）</p>\n</li>\n<li><p>SQL线程：负责读取中继日志，解析出SQL更改并在从服务器中重放（Replay）</p>\n</li>\n<li><p>主从复制不是强一致性，只能保证最终一致性</p>\n</li>\n<li><p>复制模式</p>\n<ul>\n<li><p>异步模式</p>\n<ul>\n<li>主节点不会主动push binlog，同步不及时</li>\n</ul>\n</li>\n<li><p>半同步复制</p>\n<ul>\n<li>主节点只需要接收到一台从节点的返回信息就会commit，否则会等到超时然后切换成异步模式再提交，不保证从节点写入db。减少了数据延迟，响应时间会变长</li>\n</ul>\n</li>\n<li><p>全同步复制</p>\n<ul>\n<li>全同步模式是主节点和从节点全部执行了commit并确认才会想客户端返回成功。响应时间最长</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>读写分离</p>\n<ul>\n<li><p>优点</p>\n<ul>\n<li>主从服务器负责各自的读写，减少锁竞争</li>\n<li>增加冗余，提高可用性</li>\n</ul>\n</li>\n<li><p>中间件</p>\n<ul>\n<li>MySQL-Proxy</li>\n<li>MySQL-Router</li>\n<li>MyCat</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"binlog的业务应用\"><a href=\"#binlog的业务应用\" class=\"headerlink\" title=\"binlog的业务应用\"></a>binlog的业务应用</h3><ul>\n<li><p>数据异构</p>\n<ul>\n<li>随着业务发展，一些表各个业务都关注，但是对字段的使用场景不同。如订单表，可以通过binlog解析成用户维度的订单信息供用户中心查询、商户维度的订单表供运营管理、审计等</li>\n</ul>\n</li>\n<li><p>缓存更新</p>\n<ul>\n<li>客户端更新了数据，缓存还未过期，可以通过binlog获取数据变更，并同步到缓存中</li>\n</ul>\n</li>\n<li><p>任务分发</p>\n<ul>\n<li>多个系统依赖同一块重要数据，当数据发生变化需要通知其他系统。可以由调度系统订阅binlog进行相应的任务分发、消息发送</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"NoSQL\"><a href=\"#NoSQL\" class=\"headerlink\" title=\"NoSQL\"></a>NoSQL</h2><h3 id=\"not-only-sql\"><a href=\"#not-only-sql\" class=\"headerlink\" title=\"not only sql\"></a>not only sql</h3><h3 id=\"KV型\"><a href=\"#KV型\" class=\"headerlink\" title=\"KV型\"></a>KV型</h3><ul>\n<li>Redis</li>\n</ul>\n<h3 id=\"搜索型\"><a href=\"#搜索型\" class=\"headerlink\" title=\"搜索型\"></a>搜索型</h3><ul>\n<li>ElasticSearch</li>\n</ul>\n<h3 id=\"列式\"><a href=\"#列式\" class=\"headerlink\" title=\"列式\"></a>列式</h3><ul>\n<li><p>HBase</p>\n<ul>\n<li>海量数据存储，数据持久化</li>\n<li>读写性能好</li>\n<li>横向扩展再关系型数据库中最方便的之一</li>\n<li>本身没有单点故障，高可用</li>\n<li>可存储结构化或半结构化的数据</li>\n<li>比较重，依赖Hadoop组件，运维成本高</li>\n<li>KV式，条件查询弱</li>\n<li>不支持分页查询</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文档型\"><a href=\"#文档型\" class=\"headerlink\" title=\"文档型\"></a>文档型</h3><ul>\n<li>MongoDB</li>\n</ul>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">【参考资料】GitHub-CyC2018&#x2F;CS-Notes</a></p>\n"},{"title":"MySQL 索引原理详解","date":"2023-03-25T07:11:48.000Z","_content":"\n## 索引的底层实现\nInnoDB存储引擎数据结构使用B+树\n\n### B+树\nB+数据的基本结构如下图\n![](https://upload-images.jianshu.io/upload_images/14151453-8fa2fd1bbc4b7f13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 为什么选用B+树\nMySQL为什么要选B+树作为存储结构呢，与B树相比有哪些优点？\n\n**1. 减少磁盘访问，提高查询效率**\nB+树非叶子节点上是不存数据的，仅存键值，而B树节点中不仅存储键值，也会存储数据。因为数据页的大小是固定的（InnoDB中页的默认大小是16KB），如果不存储数据，那么就会存储更多的键值，相应的树的阶数N就会更大，树高就会越低，这样查询数据进行磁盘IO的次数就会大大减少，数据查询的效率也会更快。\n以InnoDB的一个整数字段索引为例，阶数N大概是1200，这棵树高是4的时候，就可以存1200^3（约17亿）个值，因为根节点总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。\n\n**2. 提高范围查找效率**\n因为B+树的所有数据均存储在叶子节点，而且是有序的，使得B+树范围查找，排序查找，分组查找以及去重查找变的简单，而B树的数据分散在各个节点上，实现起来比较困难。\n\n## 普通索引和唯一索引如何选择？\n普通索引不需要保证一条记录的唯一性，查询和更新操作都不需要保证数据页已经读到内存中，相反唯一索引为了保证唯一性，更新时必须要保证数据页在内存中，需要检查是否满足唯一性\n### 查询操作的区别\n- 普通索引：查找到满足条件的第一个记录后，需要查找下一条记录，直到碰到不满足的记录\n- 唯一索引：查找满足条件的第一个记录就会停止检索\n\n因为是innoDB的读写操作是以数据页为单位的，通常情况目标记录的下一个记录也会在内存中，对于普通索引来说，只是多了一次判断操作，这个CPU成本可以忽略不计，如果是目标记录恰好在某页的最后，下一条记录需要从磁盘中读取，这个I\\O成本会大一些，但是这种情况出现的概率很低。\n所以对于查询操作来说，唯一索引更快，但是性能差异非常小。\n\n### 更新操作的区别\n#### change buffer\n当更新一个数据页时，如果数据页在内存中就直接更新，如果数据页还没有在内存中，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存再change buffer中，这样就不用从磁盘中读入数据了，大大提高了更新操作的性能。InnoDB会在下次访问这个数据页的时候将数据页读入内存然后执行change buffer中与这个页有关的操作，保证数据的最终一致性。\n\n**change buffer**是可持久化的数据，也会被写到磁盘中，写入change buffer操作也会记录在redo log中。\n\n**merge**：将change buffer中的操作应用到原数据页的过程称为merge，merge除了在查询操作时会触发，系统后台有线程会定期merge，数据库正常关闭（shut down）时也会执行merge操作。\n\n**优点**：\n- 减少读磁盘，明显提升更新操作的速度\n- 数据读入内存会占用buffer pool，可以减少内存使用，提高内存利用率\n\n**使用条件**：\n- 唯一索引的更新操作需要判断唯一性约束，必须将数据读到内存中才能判断，因此唯一索引的更换不能使用\n- 只有普通索引可使用\n- change buffer使用的是buffer pool中的内存，因此不能过大。\n\n**应用场景**：\n- 写多读少的业务，如账单、日志类的系统\n\n如果业务更新后马上会做查询，那么merge的操作会被触发，这样随机访问磁盘的次数不会减少还增加了change buffer的维护代价，反而起到了反作用。\n\n### 索引的选择\n- 在业务保证唯一性的前提下，尽量选择普通索引。\n- 如果更新后面马上伴随这查询，应该关闭change buffer\n\n### change buffer和redo log\n使用change buffer的更新语句执行的过程：\n1. 如果数据页在内存中，直接更新内存\n2. 如果数据页不在内存中，在change buffer中记录更新操作\n3. 将1或2的动作记录在redo log中\n\n#### 区别\n- redo log主要是节省随机写磁盘的IO消耗（转为顺序写）\n- change buffer主要节省随机读磁盘的IO消耗\n\n## 为什么MySQL优化器会选错索引\n优化器选择索引的目的是找一个最优的方案，并用最小的代价去执行语句，扫描行数是影响执行速度的代价之一，扫描行数越少，意味着访问磁盘数据越少，消耗的CPU资源也越少（扫描行数并不是唯一判断标准，还会结合是否使用临时表、是否排序等因素进行综合判断）。\n在不涉及临时表和排序的情况下，选错索引肯定是在判断扫描行数的时候出错了\n\n### 扫描行数如何计算的\n执行语句前MySQL并不能精确的知道这个条件的记录有多少条，只能根据统计信息来估算扫描记录数。\n\n#### 索引的基数\n一个索引上不同的值越多，这个索引的区分度就越好，而一个索引上不同的值的个数称为基数，基数越大说明区分度越好。\n\n#### 基数的计算\nMySQL使用采样统计（选择采样而不是全表扫描是为了节省计算成本）：\n- InnoDB默认会选择N个数据页，统计这些页面上的不同值得到一个平均值，然后乘以索引的页面数得到基数。\n- 数据表持续更新的过程中，当变更的数据行占比超过1/M的时候，会自动触发做一次索引统计\n\n### 解决方案\n1. 当发现explain的结果预估的rows值跟实际差距比较大可以使用`analyze table`命令解决\n2. 使用`force index()`强行选择某个索引\n3. 优化SQL语句引导MySQL选择更合适的索引\n4. 新建一个更合适的索引\n\n## 字符串前缀索引\n给一个字符串字段上加索引有如下两种选择：\n1. 整个字符串加索引：`alter table user add index idx_email(email);`\n2. 前六个字符索引：`alter table user add index idx_email(email(6));`\n\n### 优点\n- 前缀索引的索引结构只保存了前n个字符，索引占用的空间会更小\n- 使用前缀索引定义合适的长度，即可以节省空间，又不会增加太多查询成本\n\n### 缺点\n- 增加了查询额外扫描次数，需要查找到所有前缀匹配的记录，每条记录都要回表查询完整数据进行判断。\n- 使用前缀索引会破坏覆盖索引（查询字段上都建了索引，不需要回表）对查询性能的优化\n\n### 其他方式\n- 倒序存储加前缀索引：当字符串的前n为重复度高的情况\n- hash字段：添加一个hash字段，保存字符串字段的校验码（如crc32）\n\n这两种方法都不支持范围查找，都会产生额外的cpu计算消耗，hash字段的查询性能更稳定，crc32计算的值冲突概率非常小。\n\n## 独立索引\n必须是独立的索引字段才能用到索引，在索引上使用函数、表达式都会导致不能使用索引树搜索，从而导致慢查询。\n\n### CASE1：在索引上使用函数\n建表语句如下：\n```sql\nCREATE TABLE `tradelog` (\n  `id` int(11) NOT NULL,\n  `tradeid` varchar(32) DEFAULT NULL,\n  `operator` int(11) DEFAULT NULL,\n  `t_modified` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `tradeid` (`tradeid`),\n  KEY `t_modified` (`t_modified`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n```\n如果要查询几年内某个月的交易总数，查询语句可能如下：\n`select count(*) from tradelog where month(t_modified)=7;`\n索引上使用函数可能会导致其失去有序性，从而不能使用树搜索（不代表使用索引，可以在索引上遍历），即使没有改变索引的有序性优化器还是不能用索引快速查找，所以要避免这种写法。\n\n### CASE2：隐式类型转换\n假如有如下语句：\n`select * from tradelog where tradeid=110717;`\ntradeid字段是varchar类型，如果要和数字作比较会将其转换为数字类型，对于优化器来说上述语句相当于:\n`select * from tradelog where  CAST(tradid AS signed int) = 110717;`\n可以看到隐式的在索引字段上使用了函数，从而导致不能使用树搜索。\n\n### CASE3：隐式编码转换\n如果在做连表查询是，驱动表和被驱动表的字段编码类型不一致，会导致索引不能使用树搜索。\n\n## 参考资料\n【极客时间】[MySQL实战45讲](https://time.geekbang.org/column/article/70848)：09、10、11节\n","source":"_posts/2023/03-25-MySQL-索引原理详解.md","raw":"---\ntitle: MySQL 索引原理详解\ndate: 2023-03-25 15:11:48\ncategories:\n- [数据库]\ntags:\n- MySQL\n- 索引\n---\n\n## 索引的底层实现\nInnoDB存储引擎数据结构使用B+树\n\n### B+树\nB+数据的基本结构如下图\n![](https://upload-images.jianshu.io/upload_images/14151453-8fa2fd1bbc4b7f13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 为什么选用B+树\nMySQL为什么要选B+树作为存储结构呢，与B树相比有哪些优点？\n\n**1. 减少磁盘访问，提高查询效率**\nB+树非叶子节点上是不存数据的，仅存键值，而B树节点中不仅存储键值，也会存储数据。因为数据页的大小是固定的（InnoDB中页的默认大小是16KB），如果不存储数据，那么就会存储更多的键值，相应的树的阶数N就会更大，树高就会越低，这样查询数据进行磁盘IO的次数就会大大减少，数据查询的效率也会更快。\n以InnoDB的一个整数字段索引为例，阶数N大概是1200，这棵树高是4的时候，就可以存1200^3（约17亿）个值，因为根节点总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。\n\n**2. 提高范围查找效率**\n因为B+树的所有数据均存储在叶子节点，而且是有序的，使得B+树范围查找，排序查找，分组查找以及去重查找变的简单，而B树的数据分散在各个节点上，实现起来比较困难。\n\n## 普通索引和唯一索引如何选择？\n普通索引不需要保证一条记录的唯一性，查询和更新操作都不需要保证数据页已经读到内存中，相反唯一索引为了保证唯一性，更新时必须要保证数据页在内存中，需要检查是否满足唯一性\n### 查询操作的区别\n- 普通索引：查找到满足条件的第一个记录后，需要查找下一条记录，直到碰到不满足的记录\n- 唯一索引：查找满足条件的第一个记录就会停止检索\n\n因为是innoDB的读写操作是以数据页为单位的，通常情况目标记录的下一个记录也会在内存中，对于普通索引来说，只是多了一次判断操作，这个CPU成本可以忽略不计，如果是目标记录恰好在某页的最后，下一条记录需要从磁盘中读取，这个I\\O成本会大一些，但是这种情况出现的概率很低。\n所以对于查询操作来说，唯一索引更快，但是性能差异非常小。\n\n### 更新操作的区别\n#### change buffer\n当更新一个数据页时，如果数据页在内存中就直接更新，如果数据页还没有在内存中，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存再change buffer中，这样就不用从磁盘中读入数据了，大大提高了更新操作的性能。InnoDB会在下次访问这个数据页的时候将数据页读入内存然后执行change buffer中与这个页有关的操作，保证数据的最终一致性。\n\n**change buffer**是可持久化的数据，也会被写到磁盘中，写入change buffer操作也会记录在redo log中。\n\n**merge**：将change buffer中的操作应用到原数据页的过程称为merge，merge除了在查询操作时会触发，系统后台有线程会定期merge，数据库正常关闭（shut down）时也会执行merge操作。\n\n**优点**：\n- 减少读磁盘，明显提升更新操作的速度\n- 数据读入内存会占用buffer pool，可以减少内存使用，提高内存利用率\n\n**使用条件**：\n- 唯一索引的更新操作需要判断唯一性约束，必须将数据读到内存中才能判断，因此唯一索引的更换不能使用\n- 只有普通索引可使用\n- change buffer使用的是buffer pool中的内存，因此不能过大。\n\n**应用场景**：\n- 写多读少的业务，如账单、日志类的系统\n\n如果业务更新后马上会做查询，那么merge的操作会被触发，这样随机访问磁盘的次数不会减少还增加了change buffer的维护代价，反而起到了反作用。\n\n### 索引的选择\n- 在业务保证唯一性的前提下，尽量选择普通索引。\n- 如果更新后面马上伴随这查询，应该关闭change buffer\n\n### change buffer和redo log\n使用change buffer的更新语句执行的过程：\n1. 如果数据页在内存中，直接更新内存\n2. 如果数据页不在内存中，在change buffer中记录更新操作\n3. 将1或2的动作记录在redo log中\n\n#### 区别\n- redo log主要是节省随机写磁盘的IO消耗（转为顺序写）\n- change buffer主要节省随机读磁盘的IO消耗\n\n## 为什么MySQL优化器会选错索引\n优化器选择索引的目的是找一个最优的方案，并用最小的代价去执行语句，扫描行数是影响执行速度的代价之一，扫描行数越少，意味着访问磁盘数据越少，消耗的CPU资源也越少（扫描行数并不是唯一判断标准，还会结合是否使用临时表、是否排序等因素进行综合判断）。\n在不涉及临时表和排序的情况下，选错索引肯定是在判断扫描行数的时候出错了\n\n### 扫描行数如何计算的\n执行语句前MySQL并不能精确的知道这个条件的记录有多少条，只能根据统计信息来估算扫描记录数。\n\n#### 索引的基数\n一个索引上不同的值越多，这个索引的区分度就越好，而一个索引上不同的值的个数称为基数，基数越大说明区分度越好。\n\n#### 基数的计算\nMySQL使用采样统计（选择采样而不是全表扫描是为了节省计算成本）：\n- InnoDB默认会选择N个数据页，统计这些页面上的不同值得到一个平均值，然后乘以索引的页面数得到基数。\n- 数据表持续更新的过程中，当变更的数据行占比超过1/M的时候，会自动触发做一次索引统计\n\n### 解决方案\n1. 当发现explain的结果预估的rows值跟实际差距比较大可以使用`analyze table`命令解决\n2. 使用`force index()`强行选择某个索引\n3. 优化SQL语句引导MySQL选择更合适的索引\n4. 新建一个更合适的索引\n\n## 字符串前缀索引\n给一个字符串字段上加索引有如下两种选择：\n1. 整个字符串加索引：`alter table user add index idx_email(email);`\n2. 前六个字符索引：`alter table user add index idx_email(email(6));`\n\n### 优点\n- 前缀索引的索引结构只保存了前n个字符，索引占用的空间会更小\n- 使用前缀索引定义合适的长度，即可以节省空间，又不会增加太多查询成本\n\n### 缺点\n- 增加了查询额外扫描次数，需要查找到所有前缀匹配的记录，每条记录都要回表查询完整数据进行判断。\n- 使用前缀索引会破坏覆盖索引（查询字段上都建了索引，不需要回表）对查询性能的优化\n\n### 其他方式\n- 倒序存储加前缀索引：当字符串的前n为重复度高的情况\n- hash字段：添加一个hash字段，保存字符串字段的校验码（如crc32）\n\n这两种方法都不支持范围查找，都会产生额外的cpu计算消耗，hash字段的查询性能更稳定，crc32计算的值冲突概率非常小。\n\n## 独立索引\n必须是独立的索引字段才能用到索引，在索引上使用函数、表达式都会导致不能使用索引树搜索，从而导致慢查询。\n\n### CASE1：在索引上使用函数\n建表语句如下：\n```sql\nCREATE TABLE `tradelog` (\n  `id` int(11) NOT NULL,\n  `tradeid` varchar(32) DEFAULT NULL,\n  `operator` int(11) DEFAULT NULL,\n  `t_modified` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `tradeid` (`tradeid`),\n  KEY `t_modified` (`t_modified`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n```\n如果要查询几年内某个月的交易总数，查询语句可能如下：\n`select count(*) from tradelog where month(t_modified)=7;`\n索引上使用函数可能会导致其失去有序性，从而不能使用树搜索（不代表使用索引，可以在索引上遍历），即使没有改变索引的有序性优化器还是不能用索引快速查找，所以要避免这种写法。\n\n### CASE2：隐式类型转换\n假如有如下语句：\n`select * from tradelog where tradeid=110717;`\ntradeid字段是varchar类型，如果要和数字作比较会将其转换为数字类型，对于优化器来说上述语句相当于:\n`select * from tradelog where  CAST(tradid AS signed int) = 110717;`\n可以看到隐式的在索引字段上使用了函数，从而导致不能使用树搜索。\n\n### CASE3：隐式编码转换\n如果在做连表查询是，驱动表和被驱动表的字段编码类型不一致，会导致索引不能使用树搜索。\n\n## 参考资料\n【极客时间】[MySQL实战45讲](https://time.geekbang.org/column/article/70848)：09、10、11节\n","slug":"MySQL-索引原理详解","published":1,"updated":"2023-03-25T07:17:49.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywj001gvhfidz8l31n9","content":"<h2 id=\"索引的底层实现\"><a href=\"#索引的底层实现\" class=\"headerlink\" title=\"索引的底层实现\"></a>索引的底层实现</h2><p>InnoDB存储引擎数据结构使用B+树</p>\n<h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h3><p>B+数据的基本结构如下图<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-8fa2fd1bbc4b7f13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-8fa2fd1bbc4b7f13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h3 id=\"为什么选用B-树\"><a href=\"#为什么选用B-树\" class=\"headerlink\" title=\"为什么选用B+树\"></a>为什么选用B+树</h3><p>MySQL为什么要选B+树作为存储结构呢，与B树相比有哪些优点？</p>\n<p><strong>1. 减少磁盘访问，提高查询效率</strong><br>B+树非叶子节点上是不存数据的，仅存键值，而B树节点中不仅存储键值，也会存储数据。因为数据页的大小是固定的（InnoDB中页的默认大小是16KB），如果不存储数据，那么就会存储更多的键值，相应的树的阶数N就会更大，树高就会越低，这样查询数据进行磁盘IO的次数就会大大减少，数据查询的效率也会更快。<br>以InnoDB的一个整数字段索引为例，阶数N大概是1200，这棵树高是4的时候，就可以存1200^3（约17亿）个值，因为根节点总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。</p>\n<p><strong>2. 提高范围查找效率</strong><br>因为B+树的所有数据均存储在叶子节点，而且是有序的，使得B+树范围查找，排序查找，分组查找以及去重查找变的简单，而B树的数据分散在各个节点上，实现起来比较困难。</p>\n<h2 id=\"普通索引和唯一索引如何选择？\"><a href=\"#普通索引和唯一索引如何选择？\" class=\"headerlink\" title=\"普通索引和唯一索引如何选择？\"></a>普通索引和唯一索引如何选择？</h2><p>普通索引不需要保证一条记录的唯一性，查询和更新操作都不需要保证数据页已经读到内存中，相反唯一索引为了保证唯一性，更新时必须要保证数据页在内存中，需要检查是否满足唯一性</p>\n<h3 id=\"查询操作的区别\"><a href=\"#查询操作的区别\" class=\"headerlink\" title=\"查询操作的区别\"></a>查询操作的区别</h3><ul>\n<li>普通索引：查找到满足条件的第一个记录后，需要查找下一条记录，直到碰到不满足的记录</li>\n<li>唯一索引：查找满足条件的第一个记录就会停止检索</li>\n</ul>\n<p>因为是innoDB的读写操作是以数据页为单位的，通常情况目标记录的下一个记录也会在内存中，对于普通索引来说，只是多了一次判断操作，这个CPU成本可以忽略不计，如果是目标记录恰好在某页的最后，下一条记录需要从磁盘中读取，这个I\\O成本会大一些，但是这种情况出现的概率很低。<br>所以对于查询操作来说，唯一索引更快，但是性能差异非常小。</p>\n<h3 id=\"更新操作的区别\"><a href=\"#更新操作的区别\" class=\"headerlink\" title=\"更新操作的区别\"></a>更新操作的区别</h3><h4 id=\"change-buffer\"><a href=\"#change-buffer\" class=\"headerlink\" title=\"change buffer\"></a>change buffer</h4><p>当更新一个数据页时，如果数据页在内存中就直接更新，如果数据页还没有在内存中，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存再change buffer中，这样就不用从磁盘中读入数据了，大大提高了更新操作的性能。InnoDB会在下次访问这个数据页的时候将数据页读入内存然后执行change buffer中与这个页有关的操作，保证数据的最终一致性。</p>\n<p><strong>change buffer</strong>是可持久化的数据，也会被写到磁盘中，写入change buffer操作也会记录在redo log中。</p>\n<p><strong>merge</strong>：将change buffer中的操作应用到原数据页的过程称为merge，merge除了在查询操作时会触发，系统后台有线程会定期merge，数据库正常关闭（shut down）时也会执行merge操作。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>减少读磁盘，明显提升更新操作的速度</li>\n<li>数据读入内存会占用buffer pool，可以减少内存使用，提高内存利用率</li>\n</ul>\n<p><strong>使用条件</strong>：</p>\n<ul>\n<li>唯一索引的更新操作需要判断唯一性约束，必须将数据读到内存中才能判断，因此唯一索引的更换不能使用</li>\n<li>只有普通索引可使用</li>\n<li>change buffer使用的是buffer pool中的内存，因此不能过大。</li>\n</ul>\n<p><strong>应用场景</strong>：</p>\n<ul>\n<li>写多读少的业务，如账单、日志类的系统</li>\n</ul>\n<p>如果业务更新后马上会做查询，那么merge的操作会被触发，这样随机访问磁盘的次数不会减少还增加了change buffer的维护代价，反而起到了反作用。</p>\n<h3 id=\"索引的选择\"><a href=\"#索引的选择\" class=\"headerlink\" title=\"索引的选择\"></a>索引的选择</h3><ul>\n<li>在业务保证唯一性的前提下，尽量选择普通索引。</li>\n<li>如果更新后面马上伴随这查询，应该关闭change buffer</li>\n</ul>\n<h3 id=\"change-buffer和redo-log\"><a href=\"#change-buffer和redo-log\" class=\"headerlink\" title=\"change buffer和redo log\"></a>change buffer和redo log</h3><p>使用change buffer的更新语句执行的过程：</p>\n<ol>\n<li>如果数据页在内存中，直接更新内存</li>\n<li>如果数据页不在内存中，在change buffer中记录更新操作</li>\n<li>将1或2的动作记录在redo log中</li>\n</ol>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><ul>\n<li>redo log主要是节省随机写磁盘的IO消耗（转为顺序写）</li>\n<li>change buffer主要节省随机读磁盘的IO消耗</li>\n</ul>\n<h2 id=\"为什么MySQL优化器会选错索引\"><a href=\"#为什么MySQL优化器会选错索引\" class=\"headerlink\" title=\"为什么MySQL优化器会选错索引\"></a>为什么MySQL优化器会选错索引</h2><p>优化器选择索引的目的是找一个最优的方案，并用最小的代价去执行语句，扫描行数是影响执行速度的代价之一，扫描行数越少，意味着访问磁盘数据越少，消耗的CPU资源也越少（扫描行数并不是唯一判断标准，还会结合是否使用临时表、是否排序等因素进行综合判断）。<br>在不涉及临时表和排序的情况下，选错索引肯定是在判断扫描行数的时候出错了</p>\n<h3 id=\"扫描行数如何计算的\"><a href=\"#扫描行数如何计算的\" class=\"headerlink\" title=\"扫描行数如何计算的\"></a>扫描行数如何计算的</h3><p>执行语句前MySQL并不能精确的知道这个条件的记录有多少条，只能根据统计信息来估算扫描记录数。</p>\n<h4 id=\"索引的基数\"><a href=\"#索引的基数\" class=\"headerlink\" title=\"索引的基数\"></a>索引的基数</h4><p>一个索引上不同的值越多，这个索引的区分度就越好，而一个索引上不同的值的个数称为基数，基数越大说明区分度越好。</p>\n<h4 id=\"基数的计算\"><a href=\"#基数的计算\" class=\"headerlink\" title=\"基数的计算\"></a>基数的计算</h4><p>MySQL使用采样统计（选择采样而不是全表扫描是为了节省计算成本）：</p>\n<ul>\n<li>InnoDB默认会选择N个数据页，统计这些页面上的不同值得到一个平均值，然后乘以索引的页面数得到基数。</li>\n<li>数据表持续更新的过程中，当变更的数据行占比超过1&#x2F;M的时候，会自动触发做一次索引统计</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ol>\n<li>当发现explain的结果预估的rows值跟实际差距比较大可以使用<code>analyze table</code>命令解决</li>\n<li>使用<code>force index()</code>强行选择某个索引</li>\n<li>优化SQL语句引导MySQL选择更合适的索引</li>\n<li>新建一个更合适的索引</li>\n</ol>\n<h2 id=\"字符串前缀索引\"><a href=\"#字符串前缀索引\" class=\"headerlink\" title=\"字符串前缀索引\"></a>字符串前缀索引</h2><p>给一个字符串字段上加索引有如下两种选择：</p>\n<ol>\n<li>整个字符串加索引：<code>alter table user add index idx_email(email);</code></li>\n<li>前六个字符索引：<code>alter table user add index idx_email(email(6));</code></li>\n</ol>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>前缀索引的索引结构只保存了前n个字符，索引占用的空间会更小</li>\n<li>使用前缀索引定义合适的长度，即可以节省空间，又不会增加太多查询成本</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>增加了查询额外扫描次数，需要查找到所有前缀匹配的记录，每条记录都要回表查询完整数据进行判断。</li>\n<li>使用前缀索引会破坏覆盖索引（查询字段上都建了索引，不需要回表）对查询性能的优化</li>\n</ul>\n<h3 id=\"其他方式\"><a href=\"#其他方式\" class=\"headerlink\" title=\"其他方式\"></a>其他方式</h3><ul>\n<li>倒序存储加前缀索引：当字符串的前n为重复度高的情况</li>\n<li>hash字段：添加一个hash字段，保存字符串字段的校验码（如crc32）</li>\n</ul>\n<p>这两种方法都不支持范围查找，都会产生额外的cpu计算消耗，hash字段的查询性能更稳定，crc32计算的值冲突概率非常小。</p>\n<h2 id=\"独立索引\"><a href=\"#独立索引\" class=\"headerlink\" title=\"独立索引\"></a>独立索引</h2><p>必须是独立的索引字段才能用到索引，在索引上使用函数、表达式都会导致不能使用索引树搜索，从而导致慢查询。</p>\n<h3 id=\"CASE1：在索引上使用函数\"><a href=\"#CASE1：在索引上使用函数\" class=\"headerlink\" title=\"CASE1：在索引上使用函数\"></a>CASE1：在索引上使用函数</h3><p>建表语句如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `tradelog` (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `tradeid` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `operator` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `t_modified` datetime <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`),</span><br><span class=\"line\">  KEY `tradeid` (`tradeid`),</span><br><span class=\"line\">  KEY `t_modified` (`t_modified`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>\n<p>如果要查询几年内某个月的交易总数，查询语句可能如下：<br><code>select count(*) from tradelog where month(t_modified)=7;</code><br>索引上使用函数可能会导致其失去有序性，从而不能使用树搜索（不代表使用索引，可以在索引上遍历），即使没有改变索引的有序性优化器还是不能用索引快速查找，所以要避免这种写法。</p>\n<h3 id=\"CASE2：隐式类型转换\"><a href=\"#CASE2：隐式类型转换\" class=\"headerlink\" title=\"CASE2：隐式类型转换\"></a>CASE2：隐式类型转换</h3><p>假如有如下语句：<br><code>select * from tradelog where tradeid=110717;</code><br>tradeid字段是varchar类型，如果要和数字作比较会将其转换为数字类型，对于优化器来说上述语句相当于:<br><code>select * from tradelog where  CAST(tradid AS signed int) = 110717;</code><br>可以看到隐式的在索引字段上使用了函数，从而导致不能使用树搜索。</p>\n<h3 id=\"CASE3：隐式编码转换\"><a href=\"#CASE3：隐式编码转换\" class=\"headerlink\" title=\"CASE3：隐式编码转换\"></a>CASE3：隐式编码转换</h3><p>如果在做连表查询是，驱动表和被驱动表的字段编码类型不一致，会导致索引不能使用树搜索。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>【极客时间】<a href=\"https://time.geekbang.org/column/article/70848\">MySQL实战45讲</a>：09、10、11节</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"索引的底层实现\"><a href=\"#索引的底层实现\" class=\"headerlink\" title=\"索引的底层实现\"></a>索引的底层实现</h2><p>InnoDB存储引擎数据结构使用B+树</p>\n<h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h3><p>B+数据的基本结构如下图<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-8fa2fd1bbc4b7f13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h3 id=\"为什么选用B-树\"><a href=\"#为什么选用B-树\" class=\"headerlink\" title=\"为什么选用B+树\"></a>为什么选用B+树</h3><p>MySQL为什么要选B+树作为存储结构呢，与B树相比有哪些优点？</p>\n<p><strong>1. 减少磁盘访问，提高查询效率</strong><br>B+树非叶子节点上是不存数据的，仅存键值，而B树节点中不仅存储键值，也会存储数据。因为数据页的大小是固定的（InnoDB中页的默认大小是16KB），如果不存储数据，那么就会存储更多的键值，相应的树的阶数N就会更大，树高就会越低，这样查询数据进行磁盘IO的次数就会大大减少，数据查询的效率也会更快。<br>以InnoDB的一个整数字段索引为例，阶数N大概是1200，这棵树高是4的时候，就可以存1200^3（约17亿）个值，因为根节点总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。</p>\n<p><strong>2. 提高范围查找效率</strong><br>因为B+树的所有数据均存储在叶子节点，而且是有序的，使得B+树范围查找，排序查找，分组查找以及去重查找变的简单，而B树的数据分散在各个节点上，实现起来比较困难。</p>\n<h2 id=\"普通索引和唯一索引如何选择？\"><a href=\"#普通索引和唯一索引如何选择？\" class=\"headerlink\" title=\"普通索引和唯一索引如何选择？\"></a>普通索引和唯一索引如何选择？</h2><p>普通索引不需要保证一条记录的唯一性，查询和更新操作都不需要保证数据页已经读到内存中，相反唯一索引为了保证唯一性，更新时必须要保证数据页在内存中，需要检查是否满足唯一性</p>\n<h3 id=\"查询操作的区别\"><a href=\"#查询操作的区别\" class=\"headerlink\" title=\"查询操作的区别\"></a>查询操作的区别</h3><ul>\n<li>普通索引：查找到满足条件的第一个记录后，需要查找下一条记录，直到碰到不满足的记录</li>\n<li>唯一索引：查找满足条件的第一个记录就会停止检索</li>\n</ul>\n<p>因为是innoDB的读写操作是以数据页为单位的，通常情况目标记录的下一个记录也会在内存中，对于普通索引来说，只是多了一次判断操作，这个CPU成本可以忽略不计，如果是目标记录恰好在某页的最后，下一条记录需要从磁盘中读取，这个I\\O成本会大一些，但是这种情况出现的概率很低。<br>所以对于查询操作来说，唯一索引更快，但是性能差异非常小。</p>\n<h3 id=\"更新操作的区别\"><a href=\"#更新操作的区别\" class=\"headerlink\" title=\"更新操作的区别\"></a>更新操作的区别</h3><h4 id=\"change-buffer\"><a href=\"#change-buffer\" class=\"headerlink\" title=\"change buffer\"></a>change buffer</h4><p>当更新一个数据页时，如果数据页在内存中就直接更新，如果数据页还没有在内存中，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存再change buffer中，这样就不用从磁盘中读入数据了，大大提高了更新操作的性能。InnoDB会在下次访问这个数据页的时候将数据页读入内存然后执行change buffer中与这个页有关的操作，保证数据的最终一致性。</p>\n<p><strong>change buffer</strong>是可持久化的数据，也会被写到磁盘中，写入change buffer操作也会记录在redo log中。</p>\n<p><strong>merge</strong>：将change buffer中的操作应用到原数据页的过程称为merge，merge除了在查询操作时会触发，系统后台有线程会定期merge，数据库正常关闭（shut down）时也会执行merge操作。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>减少读磁盘，明显提升更新操作的速度</li>\n<li>数据读入内存会占用buffer pool，可以减少内存使用，提高内存利用率</li>\n</ul>\n<p><strong>使用条件</strong>：</p>\n<ul>\n<li>唯一索引的更新操作需要判断唯一性约束，必须将数据读到内存中才能判断，因此唯一索引的更换不能使用</li>\n<li>只有普通索引可使用</li>\n<li>change buffer使用的是buffer pool中的内存，因此不能过大。</li>\n</ul>\n<p><strong>应用场景</strong>：</p>\n<ul>\n<li>写多读少的业务，如账单、日志类的系统</li>\n</ul>\n<p>如果业务更新后马上会做查询，那么merge的操作会被触发，这样随机访问磁盘的次数不会减少还增加了change buffer的维护代价，反而起到了反作用。</p>\n<h3 id=\"索引的选择\"><a href=\"#索引的选择\" class=\"headerlink\" title=\"索引的选择\"></a>索引的选择</h3><ul>\n<li>在业务保证唯一性的前提下，尽量选择普通索引。</li>\n<li>如果更新后面马上伴随这查询，应该关闭change buffer</li>\n</ul>\n<h3 id=\"change-buffer和redo-log\"><a href=\"#change-buffer和redo-log\" class=\"headerlink\" title=\"change buffer和redo log\"></a>change buffer和redo log</h3><p>使用change buffer的更新语句执行的过程：</p>\n<ol>\n<li>如果数据页在内存中，直接更新内存</li>\n<li>如果数据页不在内存中，在change buffer中记录更新操作</li>\n<li>将1或2的动作记录在redo log中</li>\n</ol>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><ul>\n<li>redo log主要是节省随机写磁盘的IO消耗（转为顺序写）</li>\n<li>change buffer主要节省随机读磁盘的IO消耗</li>\n</ul>\n<h2 id=\"为什么MySQL优化器会选错索引\"><a href=\"#为什么MySQL优化器会选错索引\" class=\"headerlink\" title=\"为什么MySQL优化器会选错索引\"></a>为什么MySQL优化器会选错索引</h2><p>优化器选择索引的目的是找一个最优的方案，并用最小的代价去执行语句，扫描行数是影响执行速度的代价之一，扫描行数越少，意味着访问磁盘数据越少，消耗的CPU资源也越少（扫描行数并不是唯一判断标准，还会结合是否使用临时表、是否排序等因素进行综合判断）。<br>在不涉及临时表和排序的情况下，选错索引肯定是在判断扫描行数的时候出错了</p>\n<h3 id=\"扫描行数如何计算的\"><a href=\"#扫描行数如何计算的\" class=\"headerlink\" title=\"扫描行数如何计算的\"></a>扫描行数如何计算的</h3><p>执行语句前MySQL并不能精确的知道这个条件的记录有多少条，只能根据统计信息来估算扫描记录数。</p>\n<h4 id=\"索引的基数\"><a href=\"#索引的基数\" class=\"headerlink\" title=\"索引的基数\"></a>索引的基数</h4><p>一个索引上不同的值越多，这个索引的区分度就越好，而一个索引上不同的值的个数称为基数，基数越大说明区分度越好。</p>\n<h4 id=\"基数的计算\"><a href=\"#基数的计算\" class=\"headerlink\" title=\"基数的计算\"></a>基数的计算</h4><p>MySQL使用采样统计（选择采样而不是全表扫描是为了节省计算成本）：</p>\n<ul>\n<li>InnoDB默认会选择N个数据页，统计这些页面上的不同值得到一个平均值，然后乘以索引的页面数得到基数。</li>\n<li>数据表持续更新的过程中，当变更的数据行占比超过1&#x2F;M的时候，会自动触发做一次索引统计</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ol>\n<li>当发现explain的结果预估的rows值跟实际差距比较大可以使用<code>analyze table</code>命令解决</li>\n<li>使用<code>force index()</code>强行选择某个索引</li>\n<li>优化SQL语句引导MySQL选择更合适的索引</li>\n<li>新建一个更合适的索引</li>\n</ol>\n<h2 id=\"字符串前缀索引\"><a href=\"#字符串前缀索引\" class=\"headerlink\" title=\"字符串前缀索引\"></a>字符串前缀索引</h2><p>给一个字符串字段上加索引有如下两种选择：</p>\n<ol>\n<li>整个字符串加索引：<code>alter table user add index idx_email(email);</code></li>\n<li>前六个字符索引：<code>alter table user add index idx_email(email(6));</code></li>\n</ol>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>前缀索引的索引结构只保存了前n个字符，索引占用的空间会更小</li>\n<li>使用前缀索引定义合适的长度，即可以节省空间，又不会增加太多查询成本</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>增加了查询额外扫描次数，需要查找到所有前缀匹配的记录，每条记录都要回表查询完整数据进行判断。</li>\n<li>使用前缀索引会破坏覆盖索引（查询字段上都建了索引，不需要回表）对查询性能的优化</li>\n</ul>\n<h3 id=\"其他方式\"><a href=\"#其他方式\" class=\"headerlink\" title=\"其他方式\"></a>其他方式</h3><ul>\n<li>倒序存储加前缀索引：当字符串的前n为重复度高的情况</li>\n<li>hash字段：添加一个hash字段，保存字符串字段的校验码（如crc32）</li>\n</ul>\n<p>这两种方法都不支持范围查找，都会产生额外的cpu计算消耗，hash字段的查询性能更稳定，crc32计算的值冲突概率非常小。</p>\n<h2 id=\"独立索引\"><a href=\"#独立索引\" class=\"headerlink\" title=\"独立索引\"></a>独立索引</h2><p>必须是独立的索引字段才能用到索引，在索引上使用函数、表达式都会导致不能使用索引树搜索，从而导致慢查询。</p>\n<h3 id=\"CASE1：在索引上使用函数\"><a href=\"#CASE1：在索引上使用函数\" class=\"headerlink\" title=\"CASE1：在索引上使用函数\"></a>CASE1：在索引上使用函数</h3><p>建表语句如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `tradelog` (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `tradeid` <span class=\"type\">varchar</span>(<span class=\"number\">32</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `operator` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `t_modified` datetime <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`),</span><br><span class=\"line\">  KEY `tradeid` (`tradeid`),</span><br><span class=\"line\">  KEY `t_modified` (`t_modified`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>\n<p>如果要查询几年内某个月的交易总数，查询语句可能如下：<br><code>select count(*) from tradelog where month(t_modified)=7;</code><br>索引上使用函数可能会导致其失去有序性，从而不能使用树搜索（不代表使用索引，可以在索引上遍历），即使没有改变索引的有序性优化器还是不能用索引快速查找，所以要避免这种写法。</p>\n<h3 id=\"CASE2：隐式类型转换\"><a href=\"#CASE2：隐式类型转换\" class=\"headerlink\" title=\"CASE2：隐式类型转换\"></a>CASE2：隐式类型转换</h3><p>假如有如下语句：<br><code>select * from tradelog where tradeid=110717;</code><br>tradeid字段是varchar类型，如果要和数字作比较会将其转换为数字类型，对于优化器来说上述语句相当于:<br><code>select * from tradelog where  CAST(tradid AS signed int) = 110717;</code><br>可以看到隐式的在索引字段上使用了函数，从而导致不能使用树搜索。</p>\n<h3 id=\"CASE3：隐式编码转换\"><a href=\"#CASE3：隐式编码转换\" class=\"headerlink\" title=\"CASE3：隐式编码转换\"></a>CASE3：隐式编码转换</h3><p>如果在做连表查询是，驱动表和被驱动表的字段编码类型不一致，会导致索引不能使用树搜索。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>【极客时间】<a href=\"https://time.geekbang.org/column/article/70848\">MySQL实战45讲</a>：09、10、11节</p>\n"},{"title":"MySQL 脏页刷盘","date":"2023-03-25T07:12:03.000Z","_content":"## 什么是脏页？\nInnoDB在处理更新语句时，先写内存再写redo log，并不会立即将数据页的更新落地到磁盘（WAL机制），这就会产生升内存数据页和磁盘数据页的数据不一致的情况，这种数据不一致的数据页称为**脏页**，当脏页写入到磁盘（这个操作称为flush）后，数据一致后称为干净页。\n\n## 什么时候会flush脏页？\n1. redo log写满\nredo log大小是固定的，写完后会循环覆盖写入。当有新的内容要写入时，系统必须停止所有的更新操作，将checkpoint向前推进到新的位置，但是在推进之前必须将覆盖部分的所有脏页都flush到磁盘上。\n![](https://upload-images.jianshu.io/upload_images/14151453-05061327e5e6e8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. 内存不足需要淘汰数据页\n当系统内存不足，又有新的数据页要更新，就需要淘汰一些数据页，如果淘汰的是脏页，就需要flush到磁盘（如果是干净页就直接释放出来复用）。\n\n3. 系统空闲的时候后台会定期flush适量的脏页到磁盘\n4. MySQL正常关闭（shut down）时会把所有脏页都flush到磁盘\n\n## flush对系统性能的影响\n第3种是系统空闲不会有性能问题，第4种是要关闭了不考虑性能问题。第1和2的情况flush脏页会产生系统性能问题。\n### redo log写满\n此时整个系统不能再更新了，更新数会降为0，所以这种情况要尽量避免。\n\n### 内存不够\nInnoDB缓冲池（buffer pool）中的内存页有三种状态：\n- 未使用的空闲内存\n- 使用了为脏页\n- 使用了未干净页\n\n当一个SQL语句要淘汰的脏页数量太多，会导致语句执行的响应时间显著边长。\n\n## flush速度控制策略\nInnoDB为了避免出现上述两种情况，需要有控制脏页比例的策略，控制的主要参考因素就是：脏页比例和redo log写盘速度。\n\n#### 磁盘的IO能力\n需要告诉InnoDB的磁盘读写能力（IOPS）让引擎全力flush脏页，磁盘的IOPS可以通过fio工具测试。\n```shell\n fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest \n```\n\n如果`innodb_io_capacity`参数设置的不合理，比如远远低于磁盘实际的IOPS，InnoDB会认为IO性能低，刷脏页速度会很慢，甚至低于脏页的生成速度，导致脏页累计影响查询和更新性能。\n\n#### 速度计算流程\n为了兼顾正常的业务请求，InnoDB引擎控制按照磁盘IOPS的百分比来刷脏页，具体流程如下：\n1. 参数`innodb_max_dirty_pages_pct`控制脏页比例上限，默认75%。InnoDB根据当前脏页比例（设为M），计算出一个0~100的数字F1(M)，伪代码如下\n```python\ndef F1(M):\n    if M >= innodb_max_dirty_pages_pct:\n        return 100\n    return 100 * M / innodb_max_dirty_pages_pct\n```\n2. InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的需要之间的差值设为N，根据N计算出一个0~100的数值F2(N)，N越大F2(N)越大\n3. 根据前两步计算出的两个值取较大值记为R，然后InnoDB会根据`innodb_io_capacity`设置的磁盘IOPS能力乘以R%来控制刷脏页的速度\n\n脏页比例计算:\n`Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total`\nSQL语句如下：\n```sql\nselect VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';\nselect VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';\nselect @a/@b;\n```\n\n## 连锁flush\n在准备flush一个脏页时，如果相邻的数据页也是脏页，会把这个脏页一起flush，而且对这个新的脏页还可能有相邻的脏页导致连锁flush。\nInnoDB使用`innodb_flush_neighbors`参数控制这个行为，值为1会产生上述连锁flush的情况，值为0则不会找相邻页。\n\n找相邻页flush的机制虽然可以减少很多随机IO，但会增加一次flush时间，导致flush时的SQL语句执行时间变慢。\n\n现在基本都使用的SSD这种IOPS比较高的硬盘，建议将`innodb_flush_neighbors`参数设为0，提高flush的速度。\n\n## 总结\nflush会占用IO资源影响了正在执行的SQL语句，本来正常情况下执行很快的一条语句，突然耗时大大增加，造成业务抖动。要尽量避免这种情况，需要合理的设置`innodb_io_capacity`的值，并且多关注脏页比例，不要让脏页比例经常接近75%。\n\n## 参考资料\n【极客时间】[MySQL实战45讲：第12节](https://time.geekbang.org/column/article/71806)\n","source":"_posts/2023/03-25-MySQL-脏页刷盘.md","raw":"---\ntitle: MySQL 脏页刷盘\ndate: 2023-03-25 15:12:03\ncategories:\n- [数据库]\ntags:\n- MySQL\n- 脏页\n---\n## 什么是脏页？\nInnoDB在处理更新语句时，先写内存再写redo log，并不会立即将数据页的更新落地到磁盘（WAL机制），这就会产生升内存数据页和磁盘数据页的数据不一致的情况，这种数据不一致的数据页称为**脏页**，当脏页写入到磁盘（这个操作称为flush）后，数据一致后称为干净页。\n\n## 什么时候会flush脏页？\n1. redo log写满\nredo log大小是固定的，写完后会循环覆盖写入。当有新的内容要写入时，系统必须停止所有的更新操作，将checkpoint向前推进到新的位置，但是在推进之前必须将覆盖部分的所有脏页都flush到磁盘上。\n![](https://upload-images.jianshu.io/upload_images/14151453-05061327e5e6e8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. 内存不足需要淘汰数据页\n当系统内存不足，又有新的数据页要更新，就需要淘汰一些数据页，如果淘汰的是脏页，就需要flush到磁盘（如果是干净页就直接释放出来复用）。\n\n3. 系统空闲的时候后台会定期flush适量的脏页到磁盘\n4. MySQL正常关闭（shut down）时会把所有脏页都flush到磁盘\n\n## flush对系统性能的影响\n第3种是系统空闲不会有性能问题，第4种是要关闭了不考虑性能问题。第1和2的情况flush脏页会产生系统性能问题。\n### redo log写满\n此时整个系统不能再更新了，更新数会降为0，所以这种情况要尽量避免。\n\n### 内存不够\nInnoDB缓冲池（buffer pool）中的内存页有三种状态：\n- 未使用的空闲内存\n- 使用了为脏页\n- 使用了未干净页\n\n当一个SQL语句要淘汰的脏页数量太多，会导致语句执行的响应时间显著边长。\n\n## flush速度控制策略\nInnoDB为了避免出现上述两种情况，需要有控制脏页比例的策略，控制的主要参考因素就是：脏页比例和redo log写盘速度。\n\n#### 磁盘的IO能力\n需要告诉InnoDB的磁盘读写能力（IOPS）让引擎全力flush脏页，磁盘的IOPS可以通过fio工具测试。\n```shell\n fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest \n```\n\n如果`innodb_io_capacity`参数设置的不合理，比如远远低于磁盘实际的IOPS，InnoDB会认为IO性能低，刷脏页速度会很慢，甚至低于脏页的生成速度，导致脏页累计影响查询和更新性能。\n\n#### 速度计算流程\n为了兼顾正常的业务请求，InnoDB引擎控制按照磁盘IOPS的百分比来刷脏页，具体流程如下：\n1. 参数`innodb_max_dirty_pages_pct`控制脏页比例上限，默认75%。InnoDB根据当前脏页比例（设为M），计算出一个0~100的数字F1(M)，伪代码如下\n```python\ndef F1(M):\n    if M >= innodb_max_dirty_pages_pct:\n        return 100\n    return 100 * M / innodb_max_dirty_pages_pct\n```\n2. InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的需要之间的差值设为N，根据N计算出一个0~100的数值F2(N)，N越大F2(N)越大\n3. 根据前两步计算出的两个值取较大值记为R，然后InnoDB会根据`innodb_io_capacity`设置的磁盘IOPS能力乘以R%来控制刷脏页的速度\n\n脏页比例计算:\n`Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total`\nSQL语句如下：\n```sql\nselect VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';\nselect VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total';\nselect @a/@b;\n```\n\n## 连锁flush\n在准备flush一个脏页时，如果相邻的数据页也是脏页，会把这个脏页一起flush，而且对这个新的脏页还可能有相邻的脏页导致连锁flush。\nInnoDB使用`innodb_flush_neighbors`参数控制这个行为，值为1会产生上述连锁flush的情况，值为0则不会找相邻页。\n\n找相邻页flush的机制虽然可以减少很多随机IO，但会增加一次flush时间，导致flush时的SQL语句执行时间变慢。\n\n现在基本都使用的SSD这种IOPS比较高的硬盘，建议将`innodb_flush_neighbors`参数设为0，提高flush的速度。\n\n## 总结\nflush会占用IO资源影响了正在执行的SQL语句，本来正常情况下执行很快的一条语句，突然耗时大大增加，造成业务抖动。要尽量避免这种情况，需要合理的设置`innodb_io_capacity`的值，并且多关注脏页比例，不要让脏页比例经常接近75%。\n\n## 参考资料\n【极客时间】[MySQL实战45讲：第12节](https://time.geekbang.org/column/article/71806)\n","slug":"MySQL-脏页刷盘","published":1,"updated":"2023-03-25T07:18:02.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywk001kvhfie4s4ftj2","content":"<h2 id=\"什么是脏页？\"><a href=\"#什么是脏页？\" class=\"headerlink\" title=\"什么是脏页？\"></a>什么是脏页？</h2><p>InnoDB在处理更新语句时，先写内存再写redo log，并不会立即将数据页的更新落地到磁盘（WAL机制），这就会产生升内存数据页和磁盘数据页的数据不一致的情况，这种数据不一致的数据页称为<strong>脏页</strong>，当脏页写入到磁盘（这个操作称为flush）后，数据一致后称为干净页。</p>\n<h2 id=\"什么时候会flush脏页？\"><a href=\"#什么时候会flush脏页？\" class=\"headerlink\" title=\"什么时候会flush脏页？\"></a>什么时候会flush脏页？</h2><ol>\n<li><p>redo log写满<br>redo log大小是固定的，写完后会循环覆盖写入。当有新的内容要写入时，系统必须停止所有的更新操作，将checkpoint向前推进到新的位置，但是在推进之前必须将覆盖部分的所有脏页都flush到磁盘上。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-05061327e5e6e8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-05061327e5e6e8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n</li>\n<li><p>内存不足需要淘汰数据页<br>当系统内存不足，又有新的数据页要更新，就需要淘汰一些数据页，如果淘汰的是脏页，就需要flush到磁盘（如果是干净页就直接释放出来复用）。</p>\n</li>\n<li><p>系统空闲的时候后台会定期flush适量的脏页到磁盘</p>\n</li>\n<li><p>MySQL正常关闭（shut down）时会把所有脏页都flush到磁盘</p>\n</li>\n</ol>\n<h2 id=\"flush对系统性能的影响\"><a href=\"#flush对系统性能的影响\" class=\"headerlink\" title=\"flush对系统性能的影响\"></a>flush对系统性能的影响</h2><p>第3种是系统空闲不会有性能问题，第4种是要关闭了不考虑性能问题。第1和2的情况flush脏页会产生系统性能问题。</p>\n<h3 id=\"redo-log写满\"><a href=\"#redo-log写满\" class=\"headerlink\" title=\"redo log写满\"></a>redo log写满</h3><p>此时整个系统不能再更新了，更新数会降为0，所以这种情况要尽量避免。</p>\n<h3 id=\"内存不够\"><a href=\"#内存不够\" class=\"headerlink\" title=\"内存不够\"></a>内存不够</h3><p>InnoDB缓冲池（buffer pool）中的内存页有三种状态：</p>\n<ul>\n<li>未使用的空闲内存</li>\n<li>使用了为脏页</li>\n<li>使用了未干净页</li>\n</ul>\n<p>当一个SQL语句要淘汰的脏页数量太多，会导致语句执行的响应时间显著边长。</p>\n<h2 id=\"flush速度控制策略\"><a href=\"#flush速度控制策略\" class=\"headerlink\" title=\"flush速度控制策略\"></a>flush速度控制策略</h2><p>InnoDB为了避免出现上述两种情况，需要有控制脏页比例的策略，控制的主要参考因素就是：脏页比例和redo log写盘速度。</p>\n<h4 id=\"磁盘的IO能力\"><a href=\"#磁盘的IO能力\" class=\"headerlink\" title=\"磁盘的IO能力\"></a>磁盘的IO能力</h4><p>需要告诉InnoDB的磁盘读写能力（IOPS）让引擎全力flush脏页，磁盘的IOPS可以通过fio工具测试。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest </span><br></pre></td></tr></table></figure>\n\n<p>如果<code>innodb_io_capacity</code>参数设置的不合理，比如远远低于磁盘实际的IOPS，InnoDB会认为IO性能低，刷脏页速度会很慢，甚至低于脏页的生成速度，导致脏页累计影响查询和更新性能。</p>\n<h4 id=\"速度计算流程\"><a href=\"#速度计算流程\" class=\"headerlink\" title=\"速度计算流程\"></a>速度计算流程</h4><p>为了兼顾正常的业务请求，InnoDB引擎控制按照磁盘IOPS的百分比来刷脏页，具体流程如下：</p>\n<ol>\n<li>参数<code>innodb_max_dirty_pages_pct</code>控制脏页比例上限，默认75%。InnoDB根据当前脏页比例（设为M），计算出一个0~100的数字F1(M)，伪代码如下<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">F1</span>(<span class=\"params\">M</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> M &gt;= innodb_max_dirty_pages_pct:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">100</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span> * M / innodb_max_dirty_pages_pct</span><br></pre></td></tr></table></figure></li>\n<li>InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的需要之间的差值设为N，根据N计算出一个0~100的数值F2(N)，N越大F2(N)越大</li>\n<li>根据前两步计算出的两个值取较大值记为R，然后InnoDB会根据<code>innodb_io_capacity</code>设置的磁盘IOPS能力乘以R%来控制刷脏页的速度</li>\n</ol>\n<p>脏页比例计算:<br><code>Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total</code><br>SQL语句如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> VARIABLE_VALUE <span class=\"keyword\">into</span> <span class=\"variable\">@a</span> <span class=\"keyword\">from</span> global_status <span class=\"keyword\">where</span> VARIABLE_NAME <span class=\"operator\">=</span> <span class=\"string\">&#x27;Innodb_buffer_pool_pages_dirty&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> VARIABLE_VALUE <span class=\"keyword\">into</span> <span class=\"variable\">@b</span> <span class=\"keyword\">from</span> global_status <span class=\"keyword\">where</span> VARIABLE_NAME <span class=\"operator\">=</span> <span class=\"string\">&#x27;Innodb_buffer_pool_pages_total&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@a</span><span class=\"operator\">/</span><span class=\"variable\">@b</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连锁flush\"><a href=\"#连锁flush\" class=\"headerlink\" title=\"连锁flush\"></a>连锁flush</h2><p>在准备flush一个脏页时，如果相邻的数据页也是脏页，会把这个脏页一起flush，而且对这个新的脏页还可能有相邻的脏页导致连锁flush。<br>InnoDB使用<code>innodb_flush_neighbors</code>参数控制这个行为，值为1会产生上述连锁flush的情况，值为0则不会找相邻页。</p>\n<p>找相邻页flush的机制虽然可以减少很多随机IO，但会增加一次flush时间，导致flush时的SQL语句执行时间变慢。</p>\n<p>现在基本都使用的SSD这种IOPS比较高的硬盘，建议将<code>innodb_flush_neighbors</code>参数设为0，提高flush的速度。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>flush会占用IO资源影响了正在执行的SQL语句，本来正常情况下执行很快的一条语句，突然耗时大大增加，造成业务抖动。要尽量避免这种情况，需要合理的设置<code>innodb_io_capacity</code>的值，并且多关注脏页比例，不要让脏页比例经常接近75%。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>【极客时间】<a href=\"https://time.geekbang.org/column/article/71806\">MySQL实战45讲：第12节</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是脏页？\"><a href=\"#什么是脏页？\" class=\"headerlink\" title=\"什么是脏页？\"></a>什么是脏页？</h2><p>InnoDB在处理更新语句时，先写内存再写redo log，并不会立即将数据页的更新落地到磁盘（WAL机制），这就会产生升内存数据页和磁盘数据页的数据不一致的情况，这种数据不一致的数据页称为<strong>脏页</strong>，当脏页写入到磁盘（这个操作称为flush）后，数据一致后称为干净页。</p>\n<h2 id=\"什么时候会flush脏页？\"><a href=\"#什么时候会flush脏页？\" class=\"headerlink\" title=\"什么时候会flush脏页？\"></a>什么时候会flush脏页？</h2><ol>\n<li><p>redo log写满<br>redo log大小是固定的，写完后会循环覆盖写入。当有新的内容要写入时，系统必须停止所有的更新操作，将checkpoint向前推进到新的位置，但是在推进之前必须将覆盖部分的所有脏页都flush到磁盘上。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-05061327e5e6e8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n</li>\n<li><p>内存不足需要淘汰数据页<br>当系统内存不足，又有新的数据页要更新，就需要淘汰一些数据页，如果淘汰的是脏页，就需要flush到磁盘（如果是干净页就直接释放出来复用）。</p>\n</li>\n<li><p>系统空闲的时候后台会定期flush适量的脏页到磁盘</p>\n</li>\n<li><p>MySQL正常关闭（shut down）时会把所有脏页都flush到磁盘</p>\n</li>\n</ol>\n<h2 id=\"flush对系统性能的影响\"><a href=\"#flush对系统性能的影响\" class=\"headerlink\" title=\"flush对系统性能的影响\"></a>flush对系统性能的影响</h2><p>第3种是系统空闲不会有性能问题，第4种是要关闭了不考虑性能问题。第1和2的情况flush脏页会产生系统性能问题。</p>\n<h3 id=\"redo-log写满\"><a href=\"#redo-log写满\" class=\"headerlink\" title=\"redo log写满\"></a>redo log写满</h3><p>此时整个系统不能再更新了，更新数会降为0，所以这种情况要尽量避免。</p>\n<h3 id=\"内存不够\"><a href=\"#内存不够\" class=\"headerlink\" title=\"内存不够\"></a>内存不够</h3><p>InnoDB缓冲池（buffer pool）中的内存页有三种状态：</p>\n<ul>\n<li>未使用的空闲内存</li>\n<li>使用了为脏页</li>\n<li>使用了未干净页</li>\n</ul>\n<p>当一个SQL语句要淘汰的脏页数量太多，会导致语句执行的响应时间显著边长。</p>\n<h2 id=\"flush速度控制策略\"><a href=\"#flush速度控制策略\" class=\"headerlink\" title=\"flush速度控制策略\"></a>flush速度控制策略</h2><p>InnoDB为了避免出现上述两种情况，需要有控制脏页比例的策略，控制的主要参考因素就是：脏页比例和redo log写盘速度。</p>\n<h4 id=\"磁盘的IO能力\"><a href=\"#磁盘的IO能力\" class=\"headerlink\" title=\"磁盘的IO能力\"></a>磁盘的IO能力</h4><p>需要告诉InnoDB的磁盘读写能力（IOPS）让引擎全力flush脏页，磁盘的IOPS可以通过fio工具测试。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest </span><br></pre></td></tr></table></figure>\n\n<p>如果<code>innodb_io_capacity</code>参数设置的不合理，比如远远低于磁盘实际的IOPS，InnoDB会认为IO性能低，刷脏页速度会很慢，甚至低于脏页的生成速度，导致脏页累计影响查询和更新性能。</p>\n<h4 id=\"速度计算流程\"><a href=\"#速度计算流程\" class=\"headerlink\" title=\"速度计算流程\"></a>速度计算流程</h4><p>为了兼顾正常的业务请求，InnoDB引擎控制按照磁盘IOPS的百分比来刷脏页，具体流程如下：</p>\n<ol>\n<li>参数<code>innodb_max_dirty_pages_pct</code>控制脏页比例上限，默认75%。InnoDB根据当前脏页比例（设为M），计算出一个0~100的数字F1(M)，伪代码如下<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">F1</span>(<span class=\"params\">M</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> M &gt;= innodb_max_dirty_pages_pct:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">100</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span> * M / innodb_max_dirty_pages_pct</span><br></pre></td></tr></table></figure></li>\n<li>InnoDB每次写入的日志都有一个序号，当前写入的序号跟checkpoint对应的需要之间的差值设为N，根据N计算出一个0~100的数值F2(N)，N越大F2(N)越大</li>\n<li>根据前两步计算出的两个值取较大值记为R，然后InnoDB会根据<code>innodb_io_capacity</code>设置的磁盘IOPS能力乘以R%来控制刷脏页的速度</li>\n</ol>\n<p>脏页比例计算:<br><code>Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total</code><br>SQL语句如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> VARIABLE_VALUE <span class=\"keyword\">into</span> <span class=\"variable\">@a</span> <span class=\"keyword\">from</span> global_status <span class=\"keyword\">where</span> VARIABLE_NAME <span class=\"operator\">=</span> <span class=\"string\">&#x27;Innodb_buffer_pool_pages_dirty&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> VARIABLE_VALUE <span class=\"keyword\">into</span> <span class=\"variable\">@b</span> <span class=\"keyword\">from</span> global_status <span class=\"keyword\">where</span> VARIABLE_NAME <span class=\"operator\">=</span> <span class=\"string\">&#x27;Innodb_buffer_pool_pages_total&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@a</span><span class=\"operator\">/</span><span class=\"variable\">@b</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连锁flush\"><a href=\"#连锁flush\" class=\"headerlink\" title=\"连锁flush\"></a>连锁flush</h2><p>在准备flush一个脏页时，如果相邻的数据页也是脏页，会把这个脏页一起flush，而且对这个新的脏页还可能有相邻的脏页导致连锁flush。<br>InnoDB使用<code>innodb_flush_neighbors</code>参数控制这个行为，值为1会产生上述连锁flush的情况，值为0则不会找相邻页。</p>\n<p>找相邻页flush的机制虽然可以减少很多随机IO，但会增加一次flush时间，导致flush时的SQL语句执行时间变慢。</p>\n<p>现在基本都使用的SSD这种IOPS比较高的硬盘，建议将<code>innodb_flush_neighbors</code>参数设为0，提高flush的速度。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>flush会占用IO资源影响了正在执行的SQL语句，本来正常情况下执行很快的一条语句，突然耗时大大增加，造成业务抖动。要尽量避免这种情况，需要合理的设置<code>innodb_io_capacity</code>的值，并且多关注脏页比例，不要让脏页比例经常接近75%。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>【极客时间】<a href=\"https://time.geekbang.org/column/article/71806\">MySQL实战45讲：第12节</a></p>\n"},{"title":"MySQL 连接错误问题解决","date":"2023-03-25T07:15:48.000Z","_content":"## 软件环境\n- 操作系统：Ubuntu16.04-server\n- MySQL版本：5.7.25 \n## 故障一\n只能通过localhost登录MySQL\n1. 报错如下\n> $mysql -h172.16.0.1 -uroot -p123456\nmysql: [Warning] Using a password on the command line interface can be insecure.\nERROR 1130 (HY000): Host '172.16.0.1' is not allowed to connect to this MySQL server\n2. 解决方法\n此处参考自：[https://stackoverflow.com/questions/19101243/error-1130-hy000-host-is-not-allowed-to-connect-to-this-mysql-server](https://stackoverflow.com/questions/19101243/error-1130-hy000-host-is-not-allowed-to-connect-to-this-mysql-server)\n- 首先查看你的root用户允许的主机ip\n> mysql>SELECT host FROM mysql.user WHERE User = 'root';\n+-----------+\n| host      |\n+-----------+\n| localhost |\n+-----------+\n1 row in set (0.24 sec)\n一般结果中只有localhost或同时有localhost和127.0.0.1；\n- 然后如果你想指定允许某个ip可访问可执行如下命令\n> `CREATE USER 'root'@'ip_address' IDENTIFIED BY 'some_pass';`\n`GRANT ALL PRIVILEGES ON *.* TO 'root'@'ip_address';`\n- 如果想要允许所有ip执行如下命令\n> `CREATE USER 'root'@'%' IDENTIFIED BY 'some_pass';`\n`GRANT ALL PRIVILEGES ON *.* TO 'root'@'%';`\n- 上面两种最后都要flush启用更改\n>` FLUSH PRIVILEGES;`\n- 然后在执行一次查询会发现结果多了一行“%”，说明更改成功\n+-----------+\n| host      |\n+-----------+\n| %         |\n+-----------+\n| localhost |\n+-----------+\n1 row in set (0.24 sec)\n再次登录如果仍旧失败，请看故障2\n\n## 故障二\n1. 报错如下\n> $mysql -h172.16.0.1 -uroot -p123456\nmysql: [Warning] Using a password on the command line interface can be insecure.\nERROR 2003 (HY000): Can't connect to MySQL server on '172.16.0.1' (111)\n2. 解决方法\n- 查看mysql的配置文件\n> $vim /etc/mysql/mysql.conf.d/mysqld.cnf\n- 将下面一行注释或者修改\n> `注释`\n`#bind-address            = 127.0.0.1`\n`修改`\n`bind-address            = 0.0.0.0`\n- 重启mysql启用更改\n> $service mysql restart\n\n再次尝试登录即可成功登录！\n","source":"_posts/2023/03-25-MySQL-连接错误问题解决.md","raw":"---\ntitle: MySQL 连接错误问题解决\ndate: 2023-03-25 15:15:48\ncategories:\n- [数据库]\ntags:\n- MySQL\n---\n## 软件环境\n- 操作系统：Ubuntu16.04-server\n- MySQL版本：5.7.25 \n## 故障一\n只能通过localhost登录MySQL\n1. 报错如下\n> $mysql -h172.16.0.1 -uroot -p123456\nmysql: [Warning] Using a password on the command line interface can be insecure.\nERROR 1130 (HY000): Host '172.16.0.1' is not allowed to connect to this MySQL server\n2. 解决方法\n此处参考自：[https://stackoverflow.com/questions/19101243/error-1130-hy000-host-is-not-allowed-to-connect-to-this-mysql-server](https://stackoverflow.com/questions/19101243/error-1130-hy000-host-is-not-allowed-to-connect-to-this-mysql-server)\n- 首先查看你的root用户允许的主机ip\n> mysql>SELECT host FROM mysql.user WHERE User = 'root';\n+-----------+\n| host      |\n+-----------+\n| localhost |\n+-----------+\n1 row in set (0.24 sec)\n一般结果中只有localhost或同时有localhost和127.0.0.1；\n- 然后如果你想指定允许某个ip可访问可执行如下命令\n> `CREATE USER 'root'@'ip_address' IDENTIFIED BY 'some_pass';`\n`GRANT ALL PRIVILEGES ON *.* TO 'root'@'ip_address';`\n- 如果想要允许所有ip执行如下命令\n> `CREATE USER 'root'@'%' IDENTIFIED BY 'some_pass';`\n`GRANT ALL PRIVILEGES ON *.* TO 'root'@'%';`\n- 上面两种最后都要flush启用更改\n>` FLUSH PRIVILEGES;`\n- 然后在执行一次查询会发现结果多了一行“%”，说明更改成功\n+-----------+\n| host      |\n+-----------+\n| %         |\n+-----------+\n| localhost |\n+-----------+\n1 row in set (0.24 sec)\n再次登录如果仍旧失败，请看故障2\n\n## 故障二\n1. 报错如下\n> $mysql -h172.16.0.1 -uroot -p123456\nmysql: [Warning] Using a password on the command line interface can be insecure.\nERROR 2003 (HY000): Can't connect to MySQL server on '172.16.0.1' (111)\n2. 解决方法\n- 查看mysql的配置文件\n> $vim /etc/mysql/mysql.conf.d/mysqld.cnf\n- 将下面一行注释或者修改\n> `注释`\n`#bind-address            = 127.0.0.1`\n`修改`\n`bind-address            = 0.0.0.0`\n- 重启mysql启用更改\n> $service mysql restart\n\n再次尝试登录即可成功登录！\n","slug":"MySQL-连接错误问题解决","published":1,"updated":"2023-03-25T07:18:37.329Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywl001mvhfictidbahw","content":"<h2 id=\"软件环境\"><a href=\"#软件环境\" class=\"headerlink\" title=\"软件环境\"></a>软件环境</h2><ul>\n<li>操作系统：Ubuntu16.04-server</li>\n<li>MySQL版本：5.7.25</li>\n</ul>\n<h2 id=\"故障一\"><a href=\"#故障一\" class=\"headerlink\" title=\"故障一\"></a>故障一</h2><p>只能通过localhost登录MySQL</p>\n<ol>\n<li>报错如下<blockquote>\n<p>$mysql -h172.16.0.1 -uroot -p123456<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>ERROR 1130 (HY000): Host ‘172.16.0.1’ is not allowed to connect to this MySQL server</p>\n</blockquote>\n</li>\n<li>解决方法<br>此处参考自：<a href=\"https://stackoverflow.com/questions/19101243/error-1130-hy000-host-is-not-allowed-to-connect-to-this-mysql-server\">https://stackoverflow.com/questions/19101243/error-1130-hy000-host-is-not-allowed-to-connect-to-this-mysql-server</a></li>\n</ol>\n<ul>\n<li>首先查看你的root用户允许的主机ip<blockquote>\n<p>mysql&gt;SELECT host FROM mysql.user WHERE User &#x3D; ‘root’;<br>+———–+<br>| host      |<br>+———–+<br>| localhost |<br>+———–+<br>1 row in set (0.24 sec)<br>一般结果中只有localhost或同时有localhost和127.0.0.1；</p>\n</blockquote>\n</li>\n<li>然后如果你想指定允许某个ip可访问可执行如下命令<blockquote>\n<p><code>CREATE USER &#39;root&#39;@&#39;ip_address&#39; IDENTIFIED BY &#39;some_pass&#39;;</code><br><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;ip_address&#39;;</code></p>\n</blockquote>\n</li>\n<li>如果想要允许所有ip执行如下命令<blockquote>\n<p><code>CREATE USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;some_pass&#39;;</code><br><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;;</code></p>\n</blockquote>\n</li>\n<li>上面两种最后都要flush启用更改<blockquote>\n<p><code> FLUSH PRIVILEGES;</code></p>\n</blockquote>\n</li>\n<li>然后在执行一次查询会发现结果多了一行“%”，说明更改成功<br>+———–+<br>| host      |<br>+———–+<br>| %         |<br>+———–+<br>| localhost |<br>+———–+<br>1 row in set (0.24 sec)<br>再次登录如果仍旧失败，请看故障2</li>\n</ul>\n<h2 id=\"故障二\"><a href=\"#故障二\" class=\"headerlink\" title=\"故障二\"></a>故障二</h2><ol>\n<li>报错如下<blockquote>\n<p>$mysql -h172.16.0.1 -uroot -p123456<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>ERROR 2003 (HY000): Can’t connect to MySQL server on ‘172.16.0.1’ (111)</p>\n</blockquote>\n</li>\n<li>解决方法</li>\n</ol>\n<ul>\n<li>查看mysql的配置文件<blockquote>\n<p>$vim &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</p>\n</blockquote>\n</li>\n<li>将下面一行注释或者修改<blockquote>\n<p><code>注释</code><br><code>#bind-address            = 127.0.0.1</code><br><code>修改</code><br><code>bind-address            = 0.0.0.0</code></p>\n</blockquote>\n</li>\n<li>重启mysql启用更改<blockquote>\n<p>$service mysql restart</p>\n</blockquote>\n</li>\n</ul>\n<p>再次尝试登录即可成功登录！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"软件环境\"><a href=\"#软件环境\" class=\"headerlink\" title=\"软件环境\"></a>软件环境</h2><ul>\n<li>操作系统：Ubuntu16.04-server</li>\n<li>MySQL版本：5.7.25</li>\n</ul>\n<h2 id=\"故障一\"><a href=\"#故障一\" class=\"headerlink\" title=\"故障一\"></a>故障一</h2><p>只能通过localhost登录MySQL</p>\n<ol>\n<li>报错如下<blockquote>\n<p>$mysql -h172.16.0.1 -uroot -p123456<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>ERROR 1130 (HY000): Host ‘172.16.0.1’ is not allowed to connect to this MySQL server</p>\n</blockquote>\n</li>\n<li>解决方法<br>此处参考自：<a href=\"https://stackoverflow.com/questions/19101243/error-1130-hy000-host-is-not-allowed-to-connect-to-this-mysql-server\">https://stackoverflow.com/questions/19101243/error-1130-hy000-host-is-not-allowed-to-connect-to-this-mysql-server</a></li>\n</ol>\n<ul>\n<li>首先查看你的root用户允许的主机ip<blockquote>\n<p>mysql&gt;SELECT host FROM mysql.user WHERE User &#x3D; ‘root’;<br>+———–+<br>| host      |<br>+———–+<br>| localhost |<br>+———–+<br>1 row in set (0.24 sec)<br>一般结果中只有localhost或同时有localhost和127.0.0.1；</p>\n</blockquote>\n</li>\n<li>然后如果你想指定允许某个ip可访问可执行如下命令<blockquote>\n<p><code>CREATE USER &#39;root&#39;@&#39;ip_address&#39; IDENTIFIED BY &#39;some_pass&#39;;</code><br><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;ip_address&#39;;</code></p>\n</blockquote>\n</li>\n<li>如果想要允许所有ip执行如下命令<blockquote>\n<p><code>CREATE USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;some_pass&#39;;</code><br><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;;</code></p>\n</blockquote>\n</li>\n<li>上面两种最后都要flush启用更改<blockquote>\n<p><code> FLUSH PRIVILEGES;</code></p>\n</blockquote>\n</li>\n<li>然后在执行一次查询会发现结果多了一行“%”，说明更改成功<br>+———–+<br>| host      |<br>+———–+<br>| %         |<br>+———–+<br>| localhost |<br>+———–+<br>1 row in set (0.24 sec)<br>再次登录如果仍旧失败，请看故障2</li>\n</ul>\n<h2 id=\"故障二\"><a href=\"#故障二\" class=\"headerlink\" title=\"故障二\"></a>故障二</h2><ol>\n<li>报错如下<blockquote>\n<p>$mysql -h172.16.0.1 -uroot -p123456<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>ERROR 2003 (HY000): Can’t connect to MySQL server on ‘172.16.0.1’ (111)</p>\n</blockquote>\n</li>\n<li>解决方法</li>\n</ol>\n<ul>\n<li>查看mysql的配置文件<blockquote>\n<p>$vim &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</p>\n</blockquote>\n</li>\n<li>将下面一行注释或者修改<blockquote>\n<p><code>注释</code><br><code>#bind-address            = 127.0.0.1</code><br><code>修改</code><br><code>bind-address            = 0.0.0.0</code></p>\n</blockquote>\n</li>\n<li>重启mysql启用更改<blockquote>\n<p>$service mysql restart</p>\n</blockquote>\n</li>\n</ul>\n<p>再次尝试登录即可成功登录！</p>\n"},{"title":"Redis 基础知识概述","date":"2023-03-25T07:03:37.000Z","_content":"\n## 数据类型\n\n### STRING\n\n- 字符串、整数、浮点数\n\n### LIST\n\n- 列表\n\n### SET\n\n- 集合\n\n### ZSET\n\n- 有序集合\n\n### HASH\n\n- 哈希表\n\n## 数据结构\n\n### 字典\n\n- 链地址法解决冲突\n- rehash、渐进式rehash\n\n### 跳跃表\n\n- 基于有序链表建多级索引\n- 相比红黑树的优点\n\n\t- 实现起来更简单\n\t- 范围查找更快\n\t- 支持无锁操作\n\n## 使用场景\n\n### 计数器\n\n- string可以进行自增自减运算，适合频繁读写的计数器\n\n### 缓存\n\n### 查找表\n\n- 类似缓存，利用快速查找特性。DNS记录\n\n### 消息队列\n\n- List类型可以模拟消息队列\n\n### 会话缓存\n\n### 分布式锁\n\n- RedLock\n\n\t- 多个redis节点，申请锁，当超过N/2个节点能获得锁则认为可以获得锁\n\t- 互斥：任何时刻只能有一个client获取锁\n\t- 避免死锁\n\t- 只要大部分redis节点存活就可以正常提供服务\n\n- SETNX命令自行实现\n\n### 其他\n\n- Set可以实现交集、并集实现共同关注等功能\n- ZSet有序性实现排行榜\n\n## 事务\n\n### MUTI、EXEC将多个命令包围\n\n### 不支持回滚，当一个命令出错会继续执行剩下的命令\n\n### WATCH命令\n\n- 乐观锁，可以监控一个或多个键，一旦被监控的某个键被修改，之后的事务就不会执行\n\n### 具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性\n\n### 流水线方式，减少通信次数\n\n## 事件\n\n### 文件事件\n\n- 基于Reactor模式开发了自己的网络事件处理器，使用I/O多路复用同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会调用对应事件类型的事件处理器\n\n### 时间事件\n\n- 定时事件\n- 周期性事件\n\n## 集群方案\n\n### 哨兵模式\n\n- Sentinel\n\n\t- 集群监控：定期ping集群中的其他服务器和哨兵，检查是否在线\n\t- 消息通知：如果某个redis实例故障，哨兵负责发消息给管理员\n\t- 故障转移：如果主节点挂了，会在从节点中选举出新的主节点\n\t- 配置中心：发生故障转移后通知客户端新的master地址\n\n- 至少要3个哨兵，保证自身的健壮性\n\n### Redis-Cluster\n\n- 一共分配16383个槽位（slot）\n- 方案说明\n\n\t- 通过哈希方式将数据分片，每个节点均分存储一定哈希槽区间的数据\n\t- 每份数据分片会存在多个互为主从的多节点上\n\t- 数据写入主节点，在同步从节点，同一分片的多个节点间的数据不保持一致性\n\t- 读取数据时如果key没有分配在该节点会返回转向指令，指向正确的节点\n\t- 每个redis需要额外开放一个加1w的端口来进行节点间通信（gossip协议）\n\n### 优点\n\n- 无中心架构，支持动态扩容，对业务透明\n- 具备Sentinel的监控和自动故障转移能力\n- 客户端不需要连接所有节点（会自动转向）\n- 高性能，客户端直连redis服务器，免去proxy代理的损耗\n\n### 缺点\n\n- 运维复杂，数据迁移需要人工干预\n- 不支持批量操作（pipeline）\n\n## 缓存异常\n\n### 缓存雪崩\n\n- 大面积缓存失效\n- 解决方案\n\n\t- 设置随机的过期时间\n\t- 并发不多的时候加锁排队\n\n### 缓存穿透\n\n- 缓存和DB都不存在的数据\n- 解决方案\n\n\t- 接口层拦截\n\t- 设置空缓存，过期时间要短\n\t- 布隆过滤器\n\n### 缓存击穿\n\n- 缓存中没有，但是并发用户很多\n- 解决方案\n\n\t- 设置热点数据永不过期\n\n\t\t- persist key\n\n\t- 加互斥锁\n\t- 缓存预热\n\t- 缓存降级\n\n## 对比Memcached\n\n### Memcached\n\n- 仅支持字符串类型\n- 不支持持久化\n- 不支持分布式\n\n### Redis\n\n- 读写性能优异，Read：11w/s、Write：8.1w/s\n- 支持RDB和AOF两种持久化方式\n- 支持事务，具有原子性\n- 数据结构丰富\n- 支持主从复制\n\n### Redis缺点\n\n- 内存通常比较小且贵，不适用海量数据\n- 比较难支持在线扩容\n\n## 键的过期时间\n\n### 每个键设置过期时间，过期后会自动删除\n\n### 惰性删除\n\n### 定期删除\n\n### 定时删除\n\n## 数据淘汰策略\n\n### 当内存超出容量，会施行淘汰策略\n\n### 全局键空间选择性删除\n\n- noevication\n- allkeys-lru\n- allkeys-random\n\n### 设置过期时间的键空间选择性移除\n\n- volatile-lru\n- volatile-random\n- volatile-ttl\n\n## 持久化\n\n### RDB（默认方式）\n\n- 数据快照\n- 优点\n\n\t- 只有一个dump.rdb文件，方便持久化\n\t- 容灾兴好，一个文件可以安全的保存到磁盘\n\t- 单独进程处理，不会影响主进程的IO操作\n\t- 数据集大时比AOF启动更快\n\n- 缺点\n\n\t- 定期执行持久化操作，故障会丢失数据\n\n### AOF\n\n- 写命令追加到AOF文件\n\n\t- always：每个写命令都同步\n\t- everysec：每秒同步一次\n\t- no：让操作系统决定何时同步\n\n- 优点\n\n\t- 数据安全，always模式每进行一次写命令就记录到aof文件一次\n\t- append模式写文件，即使中途宕机可以redis-check-aof工具解决数据一致性问题\n\t- AOF重写机制，减少冗余命令\n\n- 缺点\n\n\t- 文件大，恢复速度慢\n\n## 复制\n\n### 命令\n`slaveof  ${host}  ${port}`\n\n### 连接过程\n\n- 主服务器创建快照文件（rdb）发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完再向从服务器发送存储在缓冲区的写命令\n- 从服务器丢弃所有旧数据，载入快照文件，接收主服务器发来的写命令\n- 主服务器每执行一次写命令，就向所有从服务器发送相同的写命令\n\n### 主从链\n\n- 从服务器比较多的时候，为了不影响主服务器的性能，可以设置中间层来分担主服务器的复制工作\n\n[【参考文章】GitHub-CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes)\n","source":"_posts/2023/03-25-Redis-基础知识概述.md","raw":"---\ntitle: Redis 基础知识概述\ndate: 2023-03-25 15:03:37\ncategories:\n- [缓存]\ntags:\n- Redis\n---\n\n## 数据类型\n\n### STRING\n\n- 字符串、整数、浮点数\n\n### LIST\n\n- 列表\n\n### SET\n\n- 集合\n\n### ZSET\n\n- 有序集合\n\n### HASH\n\n- 哈希表\n\n## 数据结构\n\n### 字典\n\n- 链地址法解决冲突\n- rehash、渐进式rehash\n\n### 跳跃表\n\n- 基于有序链表建多级索引\n- 相比红黑树的优点\n\n\t- 实现起来更简单\n\t- 范围查找更快\n\t- 支持无锁操作\n\n## 使用场景\n\n### 计数器\n\n- string可以进行自增自减运算，适合频繁读写的计数器\n\n### 缓存\n\n### 查找表\n\n- 类似缓存，利用快速查找特性。DNS记录\n\n### 消息队列\n\n- List类型可以模拟消息队列\n\n### 会话缓存\n\n### 分布式锁\n\n- RedLock\n\n\t- 多个redis节点，申请锁，当超过N/2个节点能获得锁则认为可以获得锁\n\t- 互斥：任何时刻只能有一个client获取锁\n\t- 避免死锁\n\t- 只要大部分redis节点存活就可以正常提供服务\n\n- SETNX命令自行实现\n\n### 其他\n\n- Set可以实现交集、并集实现共同关注等功能\n- ZSet有序性实现排行榜\n\n## 事务\n\n### MUTI、EXEC将多个命令包围\n\n### 不支持回滚，当一个命令出错会继续执行剩下的命令\n\n### WATCH命令\n\n- 乐观锁，可以监控一个或多个键，一旦被监控的某个键被修改，之后的事务就不会执行\n\n### 具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性\n\n### 流水线方式，减少通信次数\n\n## 事件\n\n### 文件事件\n\n- 基于Reactor模式开发了自己的网络事件处理器，使用I/O多路复用同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会调用对应事件类型的事件处理器\n\n### 时间事件\n\n- 定时事件\n- 周期性事件\n\n## 集群方案\n\n### 哨兵模式\n\n- Sentinel\n\n\t- 集群监控：定期ping集群中的其他服务器和哨兵，检查是否在线\n\t- 消息通知：如果某个redis实例故障，哨兵负责发消息给管理员\n\t- 故障转移：如果主节点挂了，会在从节点中选举出新的主节点\n\t- 配置中心：发生故障转移后通知客户端新的master地址\n\n- 至少要3个哨兵，保证自身的健壮性\n\n### Redis-Cluster\n\n- 一共分配16383个槽位（slot）\n- 方案说明\n\n\t- 通过哈希方式将数据分片，每个节点均分存储一定哈希槽区间的数据\n\t- 每份数据分片会存在多个互为主从的多节点上\n\t- 数据写入主节点，在同步从节点，同一分片的多个节点间的数据不保持一致性\n\t- 读取数据时如果key没有分配在该节点会返回转向指令，指向正确的节点\n\t- 每个redis需要额外开放一个加1w的端口来进行节点间通信（gossip协议）\n\n### 优点\n\n- 无中心架构，支持动态扩容，对业务透明\n- 具备Sentinel的监控和自动故障转移能力\n- 客户端不需要连接所有节点（会自动转向）\n- 高性能，客户端直连redis服务器，免去proxy代理的损耗\n\n### 缺点\n\n- 运维复杂，数据迁移需要人工干预\n- 不支持批量操作（pipeline）\n\n## 缓存异常\n\n### 缓存雪崩\n\n- 大面积缓存失效\n- 解决方案\n\n\t- 设置随机的过期时间\n\t- 并发不多的时候加锁排队\n\n### 缓存穿透\n\n- 缓存和DB都不存在的数据\n- 解决方案\n\n\t- 接口层拦截\n\t- 设置空缓存，过期时间要短\n\t- 布隆过滤器\n\n### 缓存击穿\n\n- 缓存中没有，但是并发用户很多\n- 解决方案\n\n\t- 设置热点数据永不过期\n\n\t\t- persist key\n\n\t- 加互斥锁\n\t- 缓存预热\n\t- 缓存降级\n\n## 对比Memcached\n\n### Memcached\n\n- 仅支持字符串类型\n- 不支持持久化\n- 不支持分布式\n\n### Redis\n\n- 读写性能优异，Read：11w/s、Write：8.1w/s\n- 支持RDB和AOF两种持久化方式\n- 支持事务，具有原子性\n- 数据结构丰富\n- 支持主从复制\n\n### Redis缺点\n\n- 内存通常比较小且贵，不适用海量数据\n- 比较难支持在线扩容\n\n## 键的过期时间\n\n### 每个键设置过期时间，过期后会自动删除\n\n### 惰性删除\n\n### 定期删除\n\n### 定时删除\n\n## 数据淘汰策略\n\n### 当内存超出容量，会施行淘汰策略\n\n### 全局键空间选择性删除\n\n- noevication\n- allkeys-lru\n- allkeys-random\n\n### 设置过期时间的键空间选择性移除\n\n- volatile-lru\n- volatile-random\n- volatile-ttl\n\n## 持久化\n\n### RDB（默认方式）\n\n- 数据快照\n- 优点\n\n\t- 只有一个dump.rdb文件，方便持久化\n\t- 容灾兴好，一个文件可以安全的保存到磁盘\n\t- 单独进程处理，不会影响主进程的IO操作\n\t- 数据集大时比AOF启动更快\n\n- 缺点\n\n\t- 定期执行持久化操作，故障会丢失数据\n\n### AOF\n\n- 写命令追加到AOF文件\n\n\t- always：每个写命令都同步\n\t- everysec：每秒同步一次\n\t- no：让操作系统决定何时同步\n\n- 优点\n\n\t- 数据安全，always模式每进行一次写命令就记录到aof文件一次\n\t- append模式写文件，即使中途宕机可以redis-check-aof工具解决数据一致性问题\n\t- AOF重写机制，减少冗余命令\n\n- 缺点\n\n\t- 文件大，恢复速度慢\n\n## 复制\n\n### 命令\n`slaveof  ${host}  ${port}`\n\n### 连接过程\n\n- 主服务器创建快照文件（rdb）发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完再向从服务器发送存储在缓冲区的写命令\n- 从服务器丢弃所有旧数据，载入快照文件，接收主服务器发来的写命令\n- 主服务器每执行一次写命令，就向所有从服务器发送相同的写命令\n\n### 主从链\n\n- 从服务器比较多的时候，为了不影响主服务器的性能，可以设置中间层来分担主服务器的复制工作\n\n[【参考文章】GitHub-CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes)\n","slug":"Redis-基础知识概述","published":1,"updated":"2023-03-25T07:17:13.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywq001pvhfialim1ziq","content":"<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"STRING\"><a href=\"#STRING\" class=\"headerlink\" title=\"STRING\"></a>STRING</h3><ul>\n<li>字符串、整数、浮点数</li>\n</ul>\n<h3 id=\"LIST\"><a href=\"#LIST\" class=\"headerlink\" title=\"LIST\"></a>LIST</h3><ul>\n<li>列表</li>\n</ul>\n<h3 id=\"SET\"><a href=\"#SET\" class=\"headerlink\" title=\"SET\"></a>SET</h3><ul>\n<li>集合</li>\n</ul>\n<h3 id=\"ZSET\"><a href=\"#ZSET\" class=\"headerlink\" title=\"ZSET\"></a>ZSET</h3><ul>\n<li>有序集合</li>\n</ul>\n<h3 id=\"HASH\"><a href=\"#HASH\" class=\"headerlink\" title=\"HASH\"></a>HASH</h3><ul>\n<li>哈希表</li>\n</ul>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h3><ul>\n<li>链地址法解决冲突</li>\n<li>rehash、渐进式rehash</li>\n</ul>\n<h3 id=\"跳跃表\"><a href=\"#跳跃表\" class=\"headerlink\" title=\"跳跃表\"></a>跳跃表</h3><ul>\n<li><p>基于有序链表建多级索引</p>\n</li>\n<li><p>相比红黑树的优点</p>\n<ul>\n<li>实现起来更简单</li>\n<li>范围查找更快</li>\n<li>支持无锁操作</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><h3 id=\"计数器\"><a href=\"#计数器\" class=\"headerlink\" title=\"计数器\"></a>计数器</h3><ul>\n<li>string可以进行自增自减运算，适合频繁读写的计数器</li>\n</ul>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h3 id=\"查找表\"><a href=\"#查找表\" class=\"headerlink\" title=\"查找表\"></a>查找表</h3><ul>\n<li>类似缓存，利用快速查找特性。DNS记录</li>\n</ul>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><ul>\n<li>List类型可以模拟消息队列</li>\n</ul>\n<h3 id=\"会话缓存\"><a href=\"#会话缓存\" class=\"headerlink\" title=\"会话缓存\"></a>会话缓存</h3><h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><ul>\n<li><p>RedLock</p>\n<ul>\n<li>多个redis节点，申请锁，当超过N&#x2F;2个节点能获得锁则认为可以获得锁</li>\n<li>互斥：任何时刻只能有一个client获取锁</li>\n<li>避免死锁</li>\n<li>只要大部分redis节点存活就可以正常提供服务</li>\n</ul>\n</li>\n<li><p>SETNX命令自行实现</p>\n</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>Set可以实现交集、并集实现共同关注等功能</li>\n<li>ZSet有序性实现排行榜</li>\n</ul>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"MUTI、EXEC将多个命令包围\"><a href=\"#MUTI、EXEC将多个命令包围\" class=\"headerlink\" title=\"MUTI、EXEC将多个命令包围\"></a>MUTI、EXEC将多个命令包围</h3><h3 id=\"不支持回滚，当一个命令出错会继续执行剩下的命令\"><a href=\"#不支持回滚，当一个命令出错会继续执行剩下的命令\" class=\"headerlink\" title=\"不支持回滚，当一个命令出错会继续执行剩下的命令\"></a>不支持回滚，当一个命令出错会继续执行剩下的命令</h3><h3 id=\"WATCH命令\"><a href=\"#WATCH命令\" class=\"headerlink\" title=\"WATCH命令\"></a>WATCH命令</h3><ul>\n<li>乐观锁，可以监控一个或多个键，一旦被监控的某个键被修改，之后的事务就不会执行</li>\n</ul>\n<h3 id=\"具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性\"><a href=\"#具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性\" class=\"headerlink\" title=\"具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性\"></a>具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性</h3><h3 id=\"流水线方式，减少通信次数\"><a href=\"#流水线方式，减少通信次数\" class=\"headerlink\" title=\"流水线方式，减少通信次数\"></a>流水线方式，减少通信次数</h3><h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><h3 id=\"文件事件\"><a href=\"#文件事件\" class=\"headerlink\" title=\"文件事件\"></a>文件事件</h3><ul>\n<li>基于Reactor模式开发了自己的网络事件处理器，使用I&#x2F;O多路复用同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会调用对应事件类型的事件处理器</li>\n</ul>\n<h3 id=\"时间事件\"><a href=\"#时间事件\" class=\"headerlink\" title=\"时间事件\"></a>时间事件</h3><ul>\n<li>定时事件</li>\n<li>周期性事件</li>\n</ul>\n<h2 id=\"集群方案\"><a href=\"#集群方案\" class=\"headerlink\" title=\"集群方案\"></a>集群方案</h2><h3 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h3><ul>\n<li><p>Sentinel</p>\n<ul>\n<li>集群监控：定期ping集群中的其他服务器和哨兵，检查是否在线</li>\n<li>消息通知：如果某个redis实例故障，哨兵负责发消息给管理员</li>\n<li>故障转移：如果主节点挂了，会在从节点中选举出新的主节点</li>\n<li>配置中心：发生故障转移后通知客户端新的master地址</li>\n</ul>\n</li>\n<li><p>至少要3个哨兵，保证自身的健壮性</p>\n</li>\n</ul>\n<h3 id=\"Redis-Cluster\"><a href=\"#Redis-Cluster\" class=\"headerlink\" title=\"Redis-Cluster\"></a>Redis-Cluster</h3><ul>\n<li><p>一共分配16383个槽位（slot）</p>\n</li>\n<li><p>方案说明</p>\n<ul>\n<li>通过哈希方式将数据分片，每个节点均分存储一定哈希槽区间的数据</li>\n<li>每份数据分片会存在多个互为主从的多节点上</li>\n<li>数据写入主节点，在同步从节点，同一分片的多个节点间的数据不保持一致性</li>\n<li>读取数据时如果key没有分配在该节点会返回转向指令，指向正确的节点</li>\n<li>每个redis需要额外开放一个加1w的端口来进行节点间通信（gossip协议）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>无中心架构，支持动态扩容，对业务透明</li>\n<li>具备Sentinel的监控和自动故障转移能力</li>\n<li>客户端不需要连接所有节点（会自动转向）</li>\n<li>高性能，客户端直连redis服务器，免去proxy代理的损耗</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>运维复杂，数据迁移需要人工干预</li>\n<li>不支持批量操作（pipeline）</li>\n</ul>\n<h2 id=\"缓存异常\"><a href=\"#缓存异常\" class=\"headerlink\" title=\"缓存异常\"></a>缓存异常</h2><h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><ul>\n<li><p>大面积缓存失效</p>\n</li>\n<li><p>解决方案</p>\n<ul>\n<li>设置随机的过期时间</li>\n<li>并发不多的时候加锁排队</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><ul>\n<li><p>缓存和DB都不存在的数据</p>\n</li>\n<li><p>解决方案</p>\n<ul>\n<li>接口层拦截</li>\n<li>设置空缓存，过期时间要短</li>\n<li>布隆过滤器</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><ul>\n<li><p>缓存中没有，但是并发用户很多</p>\n</li>\n<li><p>解决方案</p>\n<ul>\n<li><p>设置热点数据永不过期</p>\n<ul>\n<li>persist key</li>\n</ul>\n</li>\n<li><p>加互斥锁</p>\n</li>\n<li><p>缓存预热</p>\n</li>\n<li><p>缓存降级</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"对比Memcached\"><a href=\"#对比Memcached\" class=\"headerlink\" title=\"对比Memcached\"></a>对比Memcached</h2><h3 id=\"Memcached\"><a href=\"#Memcached\" class=\"headerlink\" title=\"Memcached\"></a>Memcached</h3><ul>\n<li>仅支持字符串类型</li>\n<li>不支持持久化</li>\n<li>不支持分布式</li>\n</ul>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><ul>\n<li>读写性能优异，Read：11w&#x2F;s、Write：8.1w&#x2F;s</li>\n<li>支持RDB和AOF两种持久化方式</li>\n<li>支持事务，具有原子性</li>\n<li>数据结构丰富</li>\n<li>支持主从复制</li>\n</ul>\n<h3 id=\"Redis缺点\"><a href=\"#Redis缺点\" class=\"headerlink\" title=\"Redis缺点\"></a>Redis缺点</h3><ul>\n<li>内存通常比较小且贵，不适用海量数据</li>\n<li>比较难支持在线扩容</li>\n</ul>\n<h2 id=\"键的过期时间\"><a href=\"#键的过期时间\" class=\"headerlink\" title=\"键的过期时间\"></a>键的过期时间</h2><h3 id=\"每个键设置过期时间，过期后会自动删除\"><a href=\"#每个键设置过期时间，过期后会自动删除\" class=\"headerlink\" title=\"每个键设置过期时间，过期后会自动删除\"></a>每个键设置过期时间，过期后会自动删除</h3><h3 id=\"惰性删除\"><a href=\"#惰性删除\" class=\"headerlink\" title=\"惰性删除\"></a>惰性删除</h3><h3 id=\"定期删除\"><a href=\"#定期删除\" class=\"headerlink\" title=\"定期删除\"></a>定期删除</h3><h3 id=\"定时删除\"><a href=\"#定时删除\" class=\"headerlink\" title=\"定时删除\"></a>定时删除</h3><h2 id=\"数据淘汰策略\"><a href=\"#数据淘汰策略\" class=\"headerlink\" title=\"数据淘汰策略\"></a>数据淘汰策略</h2><h3 id=\"当内存超出容量，会施行淘汰策略\"><a href=\"#当内存超出容量，会施行淘汰策略\" class=\"headerlink\" title=\"当内存超出容量，会施行淘汰策略\"></a>当内存超出容量，会施行淘汰策略</h3><h3 id=\"全局键空间选择性删除\"><a href=\"#全局键空间选择性删除\" class=\"headerlink\" title=\"全局键空间选择性删除\"></a>全局键空间选择性删除</h3><ul>\n<li>noevication</li>\n<li>allkeys-lru</li>\n<li>allkeys-random</li>\n</ul>\n<h3 id=\"设置过期时间的键空间选择性移除\"><a href=\"#设置过期时间的键空间选择性移除\" class=\"headerlink\" title=\"设置过期时间的键空间选择性移除\"></a>设置过期时间的键空间选择性移除</h3><ul>\n<li>volatile-lru</li>\n<li>volatile-random</li>\n<li>volatile-ttl</li>\n</ul>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><h3 id=\"RDB（默认方式）\"><a href=\"#RDB（默认方式）\" class=\"headerlink\" title=\"RDB（默认方式）\"></a>RDB（默认方式）</h3><ul>\n<li><p>数据快照</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li>只有一个dump.rdb文件，方便持久化</li>\n<li>容灾兴好，一个文件可以安全的保存到磁盘</li>\n<li>单独进程处理，不会影响主进程的IO操作</li>\n<li>数据集大时比AOF启动更快</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>定期执行持久化操作，故障会丢失数据</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h3><ul>\n<li><p>写命令追加到AOF文件</p>\n<ul>\n<li>always：每个写命令都同步</li>\n<li>everysec：每秒同步一次</li>\n<li>no：让操作系统决定何时同步</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>数据安全，always模式每进行一次写命令就记录到aof文件一次</li>\n<li>append模式写文件，即使中途宕机可以redis-check-aof工具解决数据一致性问题</li>\n<li>AOF重写机制，减少冗余命令</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>文件大，恢复速度慢</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h2><h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p><code>slaveof  $&#123;host&#125;  $&#123;port&#125;</code></p>\n<h3 id=\"连接过程\"><a href=\"#连接过程\" class=\"headerlink\" title=\"连接过程\"></a>连接过程</h3><ul>\n<li>主服务器创建快照文件（rdb）发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完再向从服务器发送存储在缓冲区的写命令</li>\n<li>从服务器丢弃所有旧数据，载入快照文件，接收主服务器发来的写命令</li>\n<li>主服务器每执行一次写命令，就向所有从服务器发送相同的写命令</li>\n</ul>\n<h3 id=\"主从链\"><a href=\"#主从链\" class=\"headerlink\" title=\"主从链\"></a>主从链</h3><ul>\n<li>从服务器比较多的时候，为了不影响主服务器的性能，可以设置中间层来分担主服务器的复制工作</li>\n</ul>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">【参考文章】GitHub-CyC2018&#x2F;CS-Notes</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"STRING\"><a href=\"#STRING\" class=\"headerlink\" title=\"STRING\"></a>STRING</h3><ul>\n<li>字符串、整数、浮点数</li>\n</ul>\n<h3 id=\"LIST\"><a href=\"#LIST\" class=\"headerlink\" title=\"LIST\"></a>LIST</h3><ul>\n<li>列表</li>\n</ul>\n<h3 id=\"SET\"><a href=\"#SET\" class=\"headerlink\" title=\"SET\"></a>SET</h3><ul>\n<li>集合</li>\n</ul>\n<h3 id=\"ZSET\"><a href=\"#ZSET\" class=\"headerlink\" title=\"ZSET\"></a>ZSET</h3><ul>\n<li>有序集合</li>\n</ul>\n<h3 id=\"HASH\"><a href=\"#HASH\" class=\"headerlink\" title=\"HASH\"></a>HASH</h3><ul>\n<li>哈希表</li>\n</ul>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h3><ul>\n<li>链地址法解决冲突</li>\n<li>rehash、渐进式rehash</li>\n</ul>\n<h3 id=\"跳跃表\"><a href=\"#跳跃表\" class=\"headerlink\" title=\"跳跃表\"></a>跳跃表</h3><ul>\n<li><p>基于有序链表建多级索引</p>\n</li>\n<li><p>相比红黑树的优点</p>\n<ul>\n<li>实现起来更简单</li>\n<li>范围查找更快</li>\n<li>支持无锁操作</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><h3 id=\"计数器\"><a href=\"#计数器\" class=\"headerlink\" title=\"计数器\"></a>计数器</h3><ul>\n<li>string可以进行自增自减运算，适合频繁读写的计数器</li>\n</ul>\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h3 id=\"查找表\"><a href=\"#查找表\" class=\"headerlink\" title=\"查找表\"></a>查找表</h3><ul>\n<li>类似缓存，利用快速查找特性。DNS记录</li>\n</ul>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><ul>\n<li>List类型可以模拟消息队列</li>\n</ul>\n<h3 id=\"会话缓存\"><a href=\"#会话缓存\" class=\"headerlink\" title=\"会话缓存\"></a>会话缓存</h3><h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><ul>\n<li><p>RedLock</p>\n<ul>\n<li>多个redis节点，申请锁，当超过N&#x2F;2个节点能获得锁则认为可以获得锁</li>\n<li>互斥：任何时刻只能有一个client获取锁</li>\n<li>避免死锁</li>\n<li>只要大部分redis节点存活就可以正常提供服务</li>\n</ul>\n</li>\n<li><p>SETNX命令自行实现</p>\n</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>Set可以实现交集、并集实现共同关注等功能</li>\n<li>ZSet有序性实现排行榜</li>\n</ul>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"MUTI、EXEC将多个命令包围\"><a href=\"#MUTI、EXEC将多个命令包围\" class=\"headerlink\" title=\"MUTI、EXEC将多个命令包围\"></a>MUTI、EXEC将多个命令包围</h3><h3 id=\"不支持回滚，当一个命令出错会继续执行剩下的命令\"><a href=\"#不支持回滚，当一个命令出错会继续执行剩下的命令\" class=\"headerlink\" title=\"不支持回滚，当一个命令出错会继续执行剩下的命令\"></a>不支持回滚，当一个命令出错会继续执行剩下的命令</h3><h3 id=\"WATCH命令\"><a href=\"#WATCH命令\" class=\"headerlink\" title=\"WATCH命令\"></a>WATCH命令</h3><ul>\n<li>乐观锁，可以监控一个或多个键，一旦被监控的某个键被修改，之后的事务就不会执行</li>\n</ul>\n<h3 id=\"具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性\"><a href=\"#具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性\" class=\"headerlink\" title=\"具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性\"></a>具有ACID的一致性和隔离性，当appendfsync选项设置为always时也具有持久性</h3><h3 id=\"流水线方式，减少通信次数\"><a href=\"#流水线方式，减少通信次数\" class=\"headerlink\" title=\"流水线方式，减少通信次数\"></a>流水线方式，减少通信次数</h3><h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><h3 id=\"文件事件\"><a href=\"#文件事件\" class=\"headerlink\" title=\"文件事件\"></a>文件事件</h3><ul>\n<li>基于Reactor模式开发了自己的网络事件处理器，使用I&#x2F;O多路复用同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会调用对应事件类型的事件处理器</li>\n</ul>\n<h3 id=\"时间事件\"><a href=\"#时间事件\" class=\"headerlink\" title=\"时间事件\"></a>时间事件</h3><ul>\n<li>定时事件</li>\n<li>周期性事件</li>\n</ul>\n<h2 id=\"集群方案\"><a href=\"#集群方案\" class=\"headerlink\" title=\"集群方案\"></a>集群方案</h2><h3 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h3><ul>\n<li><p>Sentinel</p>\n<ul>\n<li>集群监控：定期ping集群中的其他服务器和哨兵，检查是否在线</li>\n<li>消息通知：如果某个redis实例故障，哨兵负责发消息给管理员</li>\n<li>故障转移：如果主节点挂了，会在从节点中选举出新的主节点</li>\n<li>配置中心：发生故障转移后通知客户端新的master地址</li>\n</ul>\n</li>\n<li><p>至少要3个哨兵，保证自身的健壮性</p>\n</li>\n</ul>\n<h3 id=\"Redis-Cluster\"><a href=\"#Redis-Cluster\" class=\"headerlink\" title=\"Redis-Cluster\"></a>Redis-Cluster</h3><ul>\n<li><p>一共分配16383个槽位（slot）</p>\n</li>\n<li><p>方案说明</p>\n<ul>\n<li>通过哈希方式将数据分片，每个节点均分存储一定哈希槽区间的数据</li>\n<li>每份数据分片会存在多个互为主从的多节点上</li>\n<li>数据写入主节点，在同步从节点，同一分片的多个节点间的数据不保持一致性</li>\n<li>读取数据时如果key没有分配在该节点会返回转向指令，指向正确的节点</li>\n<li>每个redis需要额外开放一个加1w的端口来进行节点间通信（gossip协议）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>无中心架构，支持动态扩容，对业务透明</li>\n<li>具备Sentinel的监控和自动故障转移能力</li>\n<li>客户端不需要连接所有节点（会自动转向）</li>\n<li>高性能，客户端直连redis服务器，免去proxy代理的损耗</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>运维复杂，数据迁移需要人工干预</li>\n<li>不支持批量操作（pipeline）</li>\n</ul>\n<h2 id=\"缓存异常\"><a href=\"#缓存异常\" class=\"headerlink\" title=\"缓存异常\"></a>缓存异常</h2><h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><ul>\n<li><p>大面积缓存失效</p>\n</li>\n<li><p>解决方案</p>\n<ul>\n<li>设置随机的过期时间</li>\n<li>并发不多的时候加锁排队</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><ul>\n<li><p>缓存和DB都不存在的数据</p>\n</li>\n<li><p>解决方案</p>\n<ul>\n<li>接口层拦截</li>\n<li>设置空缓存，过期时间要短</li>\n<li>布隆过滤器</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><ul>\n<li><p>缓存中没有，但是并发用户很多</p>\n</li>\n<li><p>解决方案</p>\n<ul>\n<li><p>设置热点数据永不过期</p>\n<ul>\n<li>persist key</li>\n</ul>\n</li>\n<li><p>加互斥锁</p>\n</li>\n<li><p>缓存预热</p>\n</li>\n<li><p>缓存降级</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"对比Memcached\"><a href=\"#对比Memcached\" class=\"headerlink\" title=\"对比Memcached\"></a>对比Memcached</h2><h3 id=\"Memcached\"><a href=\"#Memcached\" class=\"headerlink\" title=\"Memcached\"></a>Memcached</h3><ul>\n<li>仅支持字符串类型</li>\n<li>不支持持久化</li>\n<li>不支持分布式</li>\n</ul>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><ul>\n<li>读写性能优异，Read：11w&#x2F;s、Write：8.1w&#x2F;s</li>\n<li>支持RDB和AOF两种持久化方式</li>\n<li>支持事务，具有原子性</li>\n<li>数据结构丰富</li>\n<li>支持主从复制</li>\n</ul>\n<h3 id=\"Redis缺点\"><a href=\"#Redis缺点\" class=\"headerlink\" title=\"Redis缺点\"></a>Redis缺点</h3><ul>\n<li>内存通常比较小且贵，不适用海量数据</li>\n<li>比较难支持在线扩容</li>\n</ul>\n<h2 id=\"键的过期时间\"><a href=\"#键的过期时间\" class=\"headerlink\" title=\"键的过期时间\"></a>键的过期时间</h2><h3 id=\"每个键设置过期时间，过期后会自动删除\"><a href=\"#每个键设置过期时间，过期后会自动删除\" class=\"headerlink\" title=\"每个键设置过期时间，过期后会自动删除\"></a>每个键设置过期时间，过期后会自动删除</h3><h3 id=\"惰性删除\"><a href=\"#惰性删除\" class=\"headerlink\" title=\"惰性删除\"></a>惰性删除</h3><h3 id=\"定期删除\"><a href=\"#定期删除\" class=\"headerlink\" title=\"定期删除\"></a>定期删除</h3><h3 id=\"定时删除\"><a href=\"#定时删除\" class=\"headerlink\" title=\"定时删除\"></a>定时删除</h3><h2 id=\"数据淘汰策略\"><a href=\"#数据淘汰策略\" class=\"headerlink\" title=\"数据淘汰策略\"></a>数据淘汰策略</h2><h3 id=\"当内存超出容量，会施行淘汰策略\"><a href=\"#当内存超出容量，会施行淘汰策略\" class=\"headerlink\" title=\"当内存超出容量，会施行淘汰策略\"></a>当内存超出容量，会施行淘汰策略</h3><h3 id=\"全局键空间选择性删除\"><a href=\"#全局键空间选择性删除\" class=\"headerlink\" title=\"全局键空间选择性删除\"></a>全局键空间选择性删除</h3><ul>\n<li>noevication</li>\n<li>allkeys-lru</li>\n<li>allkeys-random</li>\n</ul>\n<h3 id=\"设置过期时间的键空间选择性移除\"><a href=\"#设置过期时间的键空间选择性移除\" class=\"headerlink\" title=\"设置过期时间的键空间选择性移除\"></a>设置过期时间的键空间选择性移除</h3><ul>\n<li>volatile-lru</li>\n<li>volatile-random</li>\n<li>volatile-ttl</li>\n</ul>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><h3 id=\"RDB（默认方式）\"><a href=\"#RDB（默认方式）\" class=\"headerlink\" title=\"RDB（默认方式）\"></a>RDB（默认方式）</h3><ul>\n<li><p>数据快照</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li>只有一个dump.rdb文件，方便持久化</li>\n<li>容灾兴好，一个文件可以安全的保存到磁盘</li>\n<li>单独进程处理，不会影响主进程的IO操作</li>\n<li>数据集大时比AOF启动更快</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>定期执行持久化操作，故障会丢失数据</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h3><ul>\n<li><p>写命令追加到AOF文件</p>\n<ul>\n<li>always：每个写命令都同步</li>\n<li>everysec：每秒同步一次</li>\n<li>no：让操作系统决定何时同步</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>数据安全，always模式每进行一次写命令就记录到aof文件一次</li>\n<li>append模式写文件，即使中途宕机可以redis-check-aof工具解决数据一致性问题</li>\n<li>AOF重写机制，减少冗余命令</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>文件大，恢复速度慢</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h2><h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p><code>slaveof  $&#123;host&#125;  $&#123;port&#125;</code></p>\n<h3 id=\"连接过程\"><a href=\"#连接过程\" class=\"headerlink\" title=\"连接过程\"></a>连接过程</h3><ul>\n<li>主服务器创建快照文件（rdb）发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完再向从服务器发送存储在缓冲区的写命令</li>\n<li>从服务器丢弃所有旧数据，载入快照文件，接收主服务器发来的写命令</li>\n<li>主服务器每执行一次写命令，就向所有从服务器发送相同的写命令</li>\n</ul>\n<h3 id=\"主从链\"><a href=\"#主从链\" class=\"headerlink\" title=\"主从链\"></a>主从链</h3><ul>\n<li>从服务器比较多的时候，为了不影响主服务器的性能，可以设置中间层来分担主服务器的复制工作</li>\n</ul>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">【参考文章】GitHub-CyC2018&#x2F;CS-Notes</a></p>\n"},{"title":"Redis 热点 key 问题如何解决?","date":"2023-03-25T07:04:18.000Z","_content":"\n## 什么是热点key？\n对于web应用来说，用户消费的数据远远大于生产的数据，大多人使用都只是进行浏览，少数的人才会进行评论。对于web服务来说，某些热门的内容，读请求的量级可能是非常大的，数据库无法支持这么高并发的请求，基本都会使用Redis集群做缓存，但是如果如果热点数据的请求量过大，导致热点key所在Redis节点无法支撑，这种情况就需要采用额外的措施解决。当然Redis的性能还是非常好的，大多数业务量级都可以撑住，除非业务体量很大。\n\n## 解决方案\n\n### 服务端缓存\n这种方式就是将热点数据同时缓存在服务器的内存中，增加一级缓存，如果数据在内存缓存中，就直接读，不用去请求Redis。如果数据没有再请求Redis，获取到数据再写入内存缓存中。这样就大大减少了Redis的压力，而且直接读内存的速度会更快。\n\n\n### 备份热点key\n为了不让热点key只请求到某一个redis节点，可以在热点key后面加一个随机数，这样热点数据可能就hash到不同的槽位，从而请求到不同的Redis节点，相当于一个key有了多个不同的备份，分散在多个Redis节点上。\n\n## 参考\n【1】[关于Redis热点key的一些思考](https://juejin.cn/post/6844903886667382798)\n","source":"_posts/2023/03-25-Redis-热点-key-问题如何解决.md","raw":"---\ntitle: Redis 热点 key 问题如何解决?\ndate: 2023-03-25 15:04:18\ncategories:\n- [缓存]\ntags:\n- Redis\n- 热点 key\n---\n\n## 什么是热点key？\n对于web应用来说，用户消费的数据远远大于生产的数据，大多人使用都只是进行浏览，少数的人才会进行评论。对于web服务来说，某些热门的内容，读请求的量级可能是非常大的，数据库无法支持这么高并发的请求，基本都会使用Redis集群做缓存，但是如果如果热点数据的请求量过大，导致热点key所在Redis节点无法支撑，这种情况就需要采用额外的措施解决。当然Redis的性能还是非常好的，大多数业务量级都可以撑住，除非业务体量很大。\n\n## 解决方案\n\n### 服务端缓存\n这种方式就是将热点数据同时缓存在服务器的内存中，增加一级缓存，如果数据在内存缓存中，就直接读，不用去请求Redis。如果数据没有再请求Redis，获取到数据再写入内存缓存中。这样就大大减少了Redis的压力，而且直接读内存的速度会更快。\n\n\n### 备份热点key\n为了不让热点key只请求到某一个redis节点，可以在热点key后面加一个随机数，这样热点数据可能就hash到不同的槽位，从而请求到不同的Redis节点，相当于一个key有了多个不同的备份，分散在多个Redis节点上。\n\n## 参考\n【1】[关于Redis热点key的一些思考](https://juejin.cn/post/6844903886667382798)\n","slug":"Redis-热点-key-问题如何解决","published":1,"updated":"2023-03-25T07:08:22.815Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywr001svhfi2tqsaaqn","content":"<h2 id=\"什么是热点key？\"><a href=\"#什么是热点key？\" class=\"headerlink\" title=\"什么是热点key？\"></a>什么是热点key？</h2><p>对于web应用来说，用户消费的数据远远大于生产的数据，大多人使用都只是进行浏览，少数的人才会进行评论。对于web服务来说，某些热门的内容，读请求的量级可能是非常大的，数据库无法支持这么高并发的请求，基本都会使用Redis集群做缓存，但是如果如果热点数据的请求量过大，导致热点key所在Redis节点无法支撑，这种情况就需要采用额外的措施解决。当然Redis的性能还是非常好的，大多数业务量级都可以撑住，除非业务体量很大。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"服务端缓存\"><a href=\"#服务端缓存\" class=\"headerlink\" title=\"服务端缓存\"></a>服务端缓存</h3><p>这种方式就是将热点数据同时缓存在服务器的内存中，增加一级缓存，如果数据在内存缓存中，就直接读，不用去请求Redis。如果数据没有再请求Redis，获取到数据再写入内存缓存中。这样就大大减少了Redis的压力，而且直接读内存的速度会更快。</p>\n<h3 id=\"备份热点key\"><a href=\"#备份热点key\" class=\"headerlink\" title=\"备份热点key\"></a>备份热点key</h3><p>为了不让热点key只请求到某一个redis节点，可以在热点key后面加一个随机数，这样热点数据可能就hash到不同的槽位，从而请求到不同的Redis节点，相当于一个key有了多个不同的备份，分散在多个Redis节点上。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://juejin.cn/post/6844903886667382798\">关于Redis热点key的一些思考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是热点key？\"><a href=\"#什么是热点key？\" class=\"headerlink\" title=\"什么是热点key？\"></a>什么是热点key？</h2><p>对于web应用来说，用户消费的数据远远大于生产的数据，大多人使用都只是进行浏览，少数的人才会进行评论。对于web服务来说，某些热门的内容，读请求的量级可能是非常大的，数据库无法支持这么高并发的请求，基本都会使用Redis集群做缓存，但是如果如果热点数据的请求量过大，导致热点key所在Redis节点无法支撑，这种情况就需要采用额外的措施解决。当然Redis的性能还是非常好的，大多数业务量级都可以撑住，除非业务体量很大。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"服务端缓存\"><a href=\"#服务端缓存\" class=\"headerlink\" title=\"服务端缓存\"></a>服务端缓存</h3><p>这种方式就是将热点数据同时缓存在服务器的内存中，增加一级缓存，如果数据在内存缓存中，就直接读，不用去请求Redis。如果数据没有再请求Redis，获取到数据再写入内存缓存中。这样就大大减少了Redis的压力，而且直接读内存的速度会更快。</p>\n<h3 id=\"备份热点key\"><a href=\"#备份热点key\" class=\"headerlink\" title=\"备份热点key\"></a>备份热点key</h3><p>为了不让热点key只请求到某一个redis节点，可以在热点key后面加一个随机数，这样热点数据可能就hash到不同的槽位，从而请求到不同的Redis节点，相当于一个key有了多个不同的备份，分散在多个Redis节点上。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://juejin.cn/post/6844903886667382798\">关于Redis热点key的一些思考</a></p>\n"},{"title":"Redis 集群架构","date":"2023-03-25T07:04:57.000Z","_content":"\n单实例往往不能满足生产环境的需求，需要引入Redis集群，比较常见的Redis集群方案有主从复制、哨兵模式、官网的Redis Cluster，另外还有一些Proxy模式，各大厂商也有自己的方案。\n\n## 主从复制模式\n#### 基本架构\n![](https://upload-images.jianshu.io/upload_images/14151453-e32695d0c4b0efc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 工作原理\n1. slave向master发送SYNC命令，master接收到命令后通过bgsave保存快照（RDB持久化），并使用缓冲区记录保存快照期间执行的写命令\n2. master将快照文件发送给slave，继续往缓冲区记录写命令\n3. slave收到快照文件后载入数据\n4. master快照发送完成后想slave发送缓冲去的写命令，slave接收命令并执行，完成复制初始化\n5. 此后每次执行一个写命令都会同步发送给slave，保持master于slave之间的数据一致性\n\n#### 特点\n最简单的一种集群方案，本质上写入还是单实例（Master节点），读可以在主节点或从节点，能够实现读写分离。缺点是容量依赖单节点，无法实现分区，不具备自动容错与恢复。\n\n## 哨兵模式\n为了解决主从复制模式不能自动进行故障恢复的不足，引入特殊的哨兵节点（Sentinel），用来监控Redis节点，在发生故障时选举出领头哨兵，由领头哨兵从所有的Slave节点中选一个作为新的Master节点，完成故障转移。\n\n#### 基本架构\n![](https://upload-images.jianshu.io/upload_images/14151453-85d5f5a9c7b7a142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nSentinel内部互相有连接，用于监控其他Sentinel和通信，同时每个Sentinel和每个Redis节点之间有两条连接，一个连接用来发送命令通信，一个连接用来订阅Redis节点的`_sentinel_:hello`频道和获取监控该节点其他Sentinel的信息。\n\n#### 工作原理\n与Master建立连接后，Sentinel会执行以下操作：\n1. 定期向Master和Slave发送INFO命令，发送INFO命令可以获取当前数据库节点信息，如果当前是Master节点，能自动发现Master的Slave节点。\n2. 定期向Master和Slave的`_sentinel_:hello`频道发送自己的信息\n3. 定期向Master、Slave和其他Sentinel发送PING命令\n\n#### 故障转移\n如果Sentinel向数据库节点发送的PING命令超时，Sentinel认为其主管下线，如果该节点是主节点，Sentinel会向其他Sentinel发送命令询问他们是否也认为改Master主观下线，如果达到一定数量的投票，Sentinel会认为改Master客观下线，并开启选举领头节点进行故障恢复，选举采用Raft算法：\n1. 认为Master客观下线的Sentinel-1向每个Sentinel发送命令，要求对方选自己为领头哨兵。\n2. 如果目标Sentinel节点没有选过其他人，则会同意选举Sentinel-1为领头哨兵\n3. 如果有超过一半的Sentinel统一Sentinel-1当选领头，则Sentinel-1成为领头。\n4. 如果有多个Sentinel同时竞选，导致一轮投票没有选出领头，则开启下一轮竞选，直到选出领头。\n\n领头哨兵从故障Master的Slave节点选出一个当选新的Master，选择的规则如下：\n1. 所有在线的Slave选优先级最高的，优先级通过slave-priority配置\n2. 如果有多个高优先级的Slave，则选取复制偏移量最大的（数据最完整的）\n3. 如果以上条件都一样，选取id最小的\n\n挑选出要升级的Slave后，领头Sentinel向该节点发送命令使其成为Master，然后再向其他Slave发送命令接收新的Master，其他Slave收到命令后向新的Master节点发送命令进行数据同步，将故障的Master更新为新的Master的Slave节点。\n\n#### 特点\n能够自动故障转移，提高了可用性，但是同样还是存在主从复制模式的难以扩容，受限于Redis单机能力的缺点。\n\n## Redis Cluster\n\n#### 基本架构\n![](https://upload-images.jianshu.io/upload_images/14151453-2f8e053a25c9dd4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nCluster采用无中心架构\n1. 所有Redis节点彼此互联，内部使用二进制协议优化传输速度和带宽\n2. 节点的fail是通过集群中半数以上节点检测失效判定的\n3. 客户端与key所在的Redis节点不需要直连，内部会做重定向；不需要中间代理层，客户端连接集群任意一个节点即可。\n\n#### 工作原理\n1. Redis Cluster引入了槽位slot的概念（取值0-16383），每个节点均分这些slot\n2. 当对某个key操作的时候，Redis会计算key的crc16值，然后对16384取模，这样每个key都会对应一个0-16383范围的哈希槽，根据哈希槽找到负责对应槽位的节点，然后自动跳转到这个槽位上进行存取操作\n3. 为了提高可用性，Cluster同时支持主从复制，每个Master对应一个或多个Slave节点，当主节点宕机的时候启动从节点\n4. 如果一个集群半数以上的Master节点认为某个Master节点疑似下线，那么这个Master将被标记为已下线。\n\n故障转移的方法和Sentinel模式类似：\n1. 从复制故障Master节点的所有Slave节点选一个作为新的Master\n2. 被选中的Slave节点执行`SLAVEOF no one`命令，成为新的Master节点\n3. 新的Master节点会撤销所有对已下线Master节点的槽指派，将这些槽指派给自己\n4. 新的Master节点向集群广播一条PONG消息，让集群中的其他节点知道这个节点已经由Slave变成了Master节点，并且已接管了槽位\n5. 新的主节点开始接受和自己负责处理的slot有关的命令请求，故障转移完成。\n\n#### 特点\n##### 优点\n- 无中心架构，不存在单点故障\n- 不需要中间代理，减少依赖\n- 支持横向扩展，伸缩性更好，能提供的并发能力更高\n- 能自动故障转移，高可用\n\n##### 缺点\n- 客户端实现复杂\n- 数据异步复制，不保证数据强一致性\n- Slave作为冷备不提供服务\n- 批量操作限制\n- 事务支持有限，只支持多key在同一节点的事务操作\n\n## 参考\n【1】书籍：Redis设计与实现\n【2】 [一文掌握Redis的三种集群方案](https://segmentfault.com/a/1190000022028642)\n","source":"_posts/2023/03-25-Redis-集群架构.md","raw":"---\ntitle: Redis 集群架构\ndate: 2023-03-25 15:04:57\ncategories:\n- [缓存]\ntags:\n- Redis\n- Redis 集群\n---\n\n单实例往往不能满足生产环境的需求，需要引入Redis集群，比较常见的Redis集群方案有主从复制、哨兵模式、官网的Redis Cluster，另外还有一些Proxy模式，各大厂商也有自己的方案。\n\n## 主从复制模式\n#### 基本架构\n![](https://upload-images.jianshu.io/upload_images/14151453-e32695d0c4b0efc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 工作原理\n1. slave向master发送SYNC命令，master接收到命令后通过bgsave保存快照（RDB持久化），并使用缓冲区记录保存快照期间执行的写命令\n2. master将快照文件发送给slave，继续往缓冲区记录写命令\n3. slave收到快照文件后载入数据\n4. master快照发送完成后想slave发送缓冲去的写命令，slave接收命令并执行，完成复制初始化\n5. 此后每次执行一个写命令都会同步发送给slave，保持master于slave之间的数据一致性\n\n#### 特点\n最简单的一种集群方案，本质上写入还是单实例（Master节点），读可以在主节点或从节点，能够实现读写分离。缺点是容量依赖单节点，无法实现分区，不具备自动容错与恢复。\n\n## 哨兵模式\n为了解决主从复制模式不能自动进行故障恢复的不足，引入特殊的哨兵节点（Sentinel），用来监控Redis节点，在发生故障时选举出领头哨兵，由领头哨兵从所有的Slave节点中选一个作为新的Master节点，完成故障转移。\n\n#### 基本架构\n![](https://upload-images.jianshu.io/upload_images/14151453-85d5f5a9c7b7a142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nSentinel内部互相有连接，用于监控其他Sentinel和通信，同时每个Sentinel和每个Redis节点之间有两条连接，一个连接用来发送命令通信，一个连接用来订阅Redis节点的`_sentinel_:hello`频道和获取监控该节点其他Sentinel的信息。\n\n#### 工作原理\n与Master建立连接后，Sentinel会执行以下操作：\n1. 定期向Master和Slave发送INFO命令，发送INFO命令可以获取当前数据库节点信息，如果当前是Master节点，能自动发现Master的Slave节点。\n2. 定期向Master和Slave的`_sentinel_:hello`频道发送自己的信息\n3. 定期向Master、Slave和其他Sentinel发送PING命令\n\n#### 故障转移\n如果Sentinel向数据库节点发送的PING命令超时，Sentinel认为其主管下线，如果该节点是主节点，Sentinel会向其他Sentinel发送命令询问他们是否也认为改Master主观下线，如果达到一定数量的投票，Sentinel会认为改Master客观下线，并开启选举领头节点进行故障恢复，选举采用Raft算法：\n1. 认为Master客观下线的Sentinel-1向每个Sentinel发送命令，要求对方选自己为领头哨兵。\n2. 如果目标Sentinel节点没有选过其他人，则会同意选举Sentinel-1为领头哨兵\n3. 如果有超过一半的Sentinel统一Sentinel-1当选领头，则Sentinel-1成为领头。\n4. 如果有多个Sentinel同时竞选，导致一轮投票没有选出领头，则开启下一轮竞选，直到选出领头。\n\n领头哨兵从故障Master的Slave节点选出一个当选新的Master，选择的规则如下：\n1. 所有在线的Slave选优先级最高的，优先级通过slave-priority配置\n2. 如果有多个高优先级的Slave，则选取复制偏移量最大的（数据最完整的）\n3. 如果以上条件都一样，选取id最小的\n\n挑选出要升级的Slave后，领头Sentinel向该节点发送命令使其成为Master，然后再向其他Slave发送命令接收新的Master，其他Slave收到命令后向新的Master节点发送命令进行数据同步，将故障的Master更新为新的Master的Slave节点。\n\n#### 特点\n能够自动故障转移，提高了可用性，但是同样还是存在主从复制模式的难以扩容，受限于Redis单机能力的缺点。\n\n## Redis Cluster\n\n#### 基本架构\n![](https://upload-images.jianshu.io/upload_images/14151453-2f8e053a25c9dd4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nCluster采用无中心架构\n1. 所有Redis节点彼此互联，内部使用二进制协议优化传输速度和带宽\n2. 节点的fail是通过集群中半数以上节点检测失效判定的\n3. 客户端与key所在的Redis节点不需要直连，内部会做重定向；不需要中间代理层，客户端连接集群任意一个节点即可。\n\n#### 工作原理\n1. Redis Cluster引入了槽位slot的概念（取值0-16383），每个节点均分这些slot\n2. 当对某个key操作的时候，Redis会计算key的crc16值，然后对16384取模，这样每个key都会对应一个0-16383范围的哈希槽，根据哈希槽找到负责对应槽位的节点，然后自动跳转到这个槽位上进行存取操作\n3. 为了提高可用性，Cluster同时支持主从复制，每个Master对应一个或多个Slave节点，当主节点宕机的时候启动从节点\n4. 如果一个集群半数以上的Master节点认为某个Master节点疑似下线，那么这个Master将被标记为已下线。\n\n故障转移的方法和Sentinel模式类似：\n1. 从复制故障Master节点的所有Slave节点选一个作为新的Master\n2. 被选中的Slave节点执行`SLAVEOF no one`命令，成为新的Master节点\n3. 新的Master节点会撤销所有对已下线Master节点的槽指派，将这些槽指派给自己\n4. 新的Master节点向集群广播一条PONG消息，让集群中的其他节点知道这个节点已经由Slave变成了Master节点，并且已接管了槽位\n5. 新的主节点开始接受和自己负责处理的slot有关的命令请求，故障转移完成。\n\n#### 特点\n##### 优点\n- 无中心架构，不存在单点故障\n- 不需要中间代理，减少依赖\n- 支持横向扩展，伸缩性更好，能提供的并发能力更高\n- 能自动故障转移，高可用\n\n##### 缺点\n- 客户端实现复杂\n- 数据异步复制，不保证数据强一致性\n- Slave作为冷备不提供服务\n- 批量操作限制\n- 事务支持有限，只支持多key在同一节点的事务操作\n\n## 参考\n【1】书籍：Redis设计与实现\n【2】 [一文掌握Redis的三种集群方案](https://segmentfault.com/a/1190000022028642)\n","slug":"Redis-集群架构","published":1,"updated":"2023-03-25T07:07:54.828Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywr001wvhfihes0frke","content":"<p>单实例往往不能满足生产环境的需求，需要引入Redis集群，比较常见的Redis集群方案有主从复制、哨兵模式、官网的Redis Cluster，另外还有一些Proxy模式，各大厂商也有自己的方案。</p>\n<h2 id=\"主从复制模式\"><a href=\"#主从复制模式\" class=\"headerlink\" title=\"主从复制模式\"></a>主从复制模式</h2><h4 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-e32695d0c4b0efc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-e32695d0c4b0efc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><ol>\n<li>slave向master发送SYNC命令，master接收到命令后通过bgsave保存快照（RDB持久化），并使用缓冲区记录保存快照期间执行的写命令</li>\n<li>master将快照文件发送给slave，继续往缓冲区记录写命令</li>\n<li>slave收到快照文件后载入数据</li>\n<li>master快照发送完成后想slave发送缓冲去的写命令，slave接收命令并执行，完成复制初始化</li>\n<li>此后每次执行一个写命令都会同步发送给slave，保持master于slave之间的数据一致性</li>\n</ol>\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><p>最简单的一种集群方案，本质上写入还是单实例（Master节点），读可以在主节点或从节点，能够实现读写分离。缺点是容量依赖单节点，无法实现分区，不具备自动容错与恢复。</p>\n<h2 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h2><p>为了解决主从复制模式不能自动进行故障恢复的不足，引入特殊的哨兵节点（Sentinel），用来监控Redis节点，在发生故障时选举出领头哨兵，由领头哨兵从所有的Slave节点中选一个作为新的Master节点，完成故障转移。</p>\n<h4 id=\"基本架构-1\"><a href=\"#基本架构-1\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-85d5f5a9c7b7a142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-85d5f5a9c7b7a142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>Sentinel内部互相有连接，用于监控其他Sentinel和通信，同时每个Sentinel和每个Redis节点之间有两条连接，一个连接用来发送命令通信，一个连接用来订阅Redis节点的<code>_sentinel_:hello</code>频道和获取监控该节点其他Sentinel的信息。</p>\n<h4 id=\"工作原理-1\"><a href=\"#工作原理-1\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><p>与Master建立连接后，Sentinel会执行以下操作：</p>\n<ol>\n<li>定期向Master和Slave发送INFO命令，发送INFO命令可以获取当前数据库节点信息，如果当前是Master节点，能自动发现Master的Slave节点。</li>\n<li>定期向Master和Slave的<code>_sentinel_:hello</code>频道发送自己的信息</li>\n<li>定期向Master、Slave和其他Sentinel发送PING命令</li>\n</ol>\n<h4 id=\"故障转移\"><a href=\"#故障转移\" class=\"headerlink\" title=\"故障转移\"></a>故障转移</h4><p>如果Sentinel向数据库节点发送的PING命令超时，Sentinel认为其主管下线，如果该节点是主节点，Sentinel会向其他Sentinel发送命令询问他们是否也认为改Master主观下线，如果达到一定数量的投票，Sentinel会认为改Master客观下线，并开启选举领头节点进行故障恢复，选举采用Raft算法：</p>\n<ol>\n<li>认为Master客观下线的Sentinel-1向每个Sentinel发送命令，要求对方选自己为领头哨兵。</li>\n<li>如果目标Sentinel节点没有选过其他人，则会同意选举Sentinel-1为领头哨兵</li>\n<li>如果有超过一半的Sentinel统一Sentinel-1当选领头，则Sentinel-1成为领头。</li>\n<li>如果有多个Sentinel同时竞选，导致一轮投票没有选出领头，则开启下一轮竞选，直到选出领头。</li>\n</ol>\n<p>领头哨兵从故障Master的Slave节点选出一个当选新的Master，选择的规则如下：</p>\n<ol>\n<li>所有在线的Slave选优先级最高的，优先级通过slave-priority配置</li>\n<li>如果有多个高优先级的Slave，则选取复制偏移量最大的（数据最完整的）</li>\n<li>如果以上条件都一样，选取id最小的</li>\n</ol>\n<p>挑选出要升级的Slave后，领头Sentinel向该节点发送命令使其成为Master，然后再向其他Slave发送命令接收新的Master，其他Slave收到命令后向新的Master节点发送命令进行数据同步，将故障的Master更新为新的Master的Slave节点。</p>\n<h4 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h4><p>能够自动故障转移，提高了可用性，但是同样还是存在主从复制模式的难以扩容，受限于Redis单机能力的缺点。</p>\n<h2 id=\"Redis-Cluster\"><a href=\"#Redis-Cluster\" class=\"headerlink\" title=\"Redis Cluster\"></a>Redis Cluster</h2><h4 id=\"基本架构-2\"><a href=\"#基本架构-2\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-2f8e053a25c9dd4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-2f8e053a25c9dd4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>Cluster采用无中心架构</p>\n<ol>\n<li>所有Redis节点彼此互联，内部使用二进制协议优化传输速度和带宽</li>\n<li>节点的fail是通过集群中半数以上节点检测失效判定的</li>\n<li>客户端与key所在的Redis节点不需要直连，内部会做重定向；不需要中间代理层，客户端连接集群任意一个节点即可。</li>\n</ol>\n<h4 id=\"工作原理-2\"><a href=\"#工作原理-2\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><ol>\n<li>Redis Cluster引入了槽位slot的概念（取值0-16383），每个节点均分这些slot</li>\n<li>当对某个key操作的时候，Redis会计算key的crc16值，然后对16384取模，这样每个key都会对应一个0-16383范围的哈希槽，根据哈希槽找到负责对应槽位的节点，然后自动跳转到这个槽位上进行存取操作</li>\n<li>为了提高可用性，Cluster同时支持主从复制，每个Master对应一个或多个Slave节点，当主节点宕机的时候启动从节点</li>\n<li>如果一个集群半数以上的Master节点认为某个Master节点疑似下线，那么这个Master将被标记为已下线。</li>\n</ol>\n<p>故障转移的方法和Sentinel模式类似：</p>\n<ol>\n<li>从复制故障Master节点的所有Slave节点选一个作为新的Master</li>\n<li>被选中的Slave节点执行<code>SLAVEOF no one</code>命令，成为新的Master节点</li>\n<li>新的Master节点会撤销所有对已下线Master节点的槽指派，将这些槽指派给自己</li>\n<li>新的Master节点向集群广播一条PONG消息，让集群中的其他节点知道这个节点已经由Slave变成了Master节点，并且已接管了槽位</li>\n<li>新的主节点开始接受和自己负责处理的slot有关的命令请求，故障转移完成。</li>\n</ol>\n<h4 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>无中心架构，不存在单点故障</li>\n<li>不需要中间代理，减少依赖</li>\n<li>支持横向扩展，伸缩性更好，能提供的并发能力更高</li>\n<li>能自动故障转移，高可用</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>客户端实现复杂</li>\n<li>数据异步复制，不保证数据强一致性</li>\n<li>Slave作为冷备不提供服务</li>\n<li>批量操作限制</li>\n<li>事务支持有限，只支持多key在同一节点的事务操作</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】书籍：Redis设计与实现<br>【2】 <a href=\"https://segmentfault.com/a/1190000022028642\">一文掌握Redis的三种集群方案</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>单实例往往不能满足生产环境的需求，需要引入Redis集群，比较常见的Redis集群方案有主从复制、哨兵模式、官网的Redis Cluster，另外还有一些Proxy模式，各大厂商也有自己的方案。</p>\n<h2 id=\"主从复制模式\"><a href=\"#主从复制模式\" class=\"headerlink\" title=\"主从复制模式\"></a>主从复制模式</h2><h4 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-e32695d0c4b0efc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><ol>\n<li>slave向master发送SYNC命令，master接收到命令后通过bgsave保存快照（RDB持久化），并使用缓冲区记录保存快照期间执行的写命令</li>\n<li>master将快照文件发送给slave，继续往缓冲区记录写命令</li>\n<li>slave收到快照文件后载入数据</li>\n<li>master快照发送完成后想slave发送缓冲去的写命令，slave接收命令并执行，完成复制初始化</li>\n<li>此后每次执行一个写命令都会同步发送给slave，保持master于slave之间的数据一致性</li>\n</ol>\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><p>最简单的一种集群方案，本质上写入还是单实例（Master节点），读可以在主节点或从节点，能够实现读写分离。缺点是容量依赖单节点，无法实现分区，不具备自动容错与恢复。</p>\n<h2 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h2><p>为了解决主从复制模式不能自动进行故障恢复的不足，引入特殊的哨兵节点（Sentinel），用来监控Redis节点，在发生故障时选举出领头哨兵，由领头哨兵从所有的Slave节点中选一个作为新的Master节点，完成故障转移。</p>\n<h4 id=\"基本架构-1\"><a href=\"#基本架构-1\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-85d5f5a9c7b7a142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>Sentinel内部互相有连接，用于监控其他Sentinel和通信，同时每个Sentinel和每个Redis节点之间有两条连接，一个连接用来发送命令通信，一个连接用来订阅Redis节点的<code>_sentinel_:hello</code>频道和获取监控该节点其他Sentinel的信息。</p>\n<h4 id=\"工作原理-1\"><a href=\"#工作原理-1\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><p>与Master建立连接后，Sentinel会执行以下操作：</p>\n<ol>\n<li>定期向Master和Slave发送INFO命令，发送INFO命令可以获取当前数据库节点信息，如果当前是Master节点，能自动发现Master的Slave节点。</li>\n<li>定期向Master和Slave的<code>_sentinel_:hello</code>频道发送自己的信息</li>\n<li>定期向Master、Slave和其他Sentinel发送PING命令</li>\n</ol>\n<h4 id=\"故障转移\"><a href=\"#故障转移\" class=\"headerlink\" title=\"故障转移\"></a>故障转移</h4><p>如果Sentinel向数据库节点发送的PING命令超时，Sentinel认为其主管下线，如果该节点是主节点，Sentinel会向其他Sentinel发送命令询问他们是否也认为改Master主观下线，如果达到一定数量的投票，Sentinel会认为改Master客观下线，并开启选举领头节点进行故障恢复，选举采用Raft算法：</p>\n<ol>\n<li>认为Master客观下线的Sentinel-1向每个Sentinel发送命令，要求对方选自己为领头哨兵。</li>\n<li>如果目标Sentinel节点没有选过其他人，则会同意选举Sentinel-1为领头哨兵</li>\n<li>如果有超过一半的Sentinel统一Sentinel-1当选领头，则Sentinel-1成为领头。</li>\n<li>如果有多个Sentinel同时竞选，导致一轮投票没有选出领头，则开启下一轮竞选，直到选出领头。</li>\n</ol>\n<p>领头哨兵从故障Master的Slave节点选出一个当选新的Master，选择的规则如下：</p>\n<ol>\n<li>所有在线的Slave选优先级最高的，优先级通过slave-priority配置</li>\n<li>如果有多个高优先级的Slave，则选取复制偏移量最大的（数据最完整的）</li>\n<li>如果以上条件都一样，选取id最小的</li>\n</ol>\n<p>挑选出要升级的Slave后，领头Sentinel向该节点发送命令使其成为Master，然后再向其他Slave发送命令接收新的Master，其他Slave收到命令后向新的Master节点发送命令进行数据同步，将故障的Master更新为新的Master的Slave节点。</p>\n<h4 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h4><p>能够自动故障转移，提高了可用性，但是同样还是存在主从复制模式的难以扩容，受限于Redis单机能力的缺点。</p>\n<h2 id=\"Redis-Cluster\"><a href=\"#Redis-Cluster\" class=\"headerlink\" title=\"Redis Cluster\"></a>Redis Cluster</h2><h4 id=\"基本架构-2\"><a href=\"#基本架构-2\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-2f8e053a25c9dd4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>Cluster采用无中心架构</p>\n<ol>\n<li>所有Redis节点彼此互联，内部使用二进制协议优化传输速度和带宽</li>\n<li>节点的fail是通过集群中半数以上节点检测失效判定的</li>\n<li>客户端与key所在的Redis节点不需要直连，内部会做重定向；不需要中间代理层，客户端连接集群任意一个节点即可。</li>\n</ol>\n<h4 id=\"工作原理-2\"><a href=\"#工作原理-2\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><ol>\n<li>Redis Cluster引入了槽位slot的概念（取值0-16383），每个节点均分这些slot</li>\n<li>当对某个key操作的时候，Redis会计算key的crc16值，然后对16384取模，这样每个key都会对应一个0-16383范围的哈希槽，根据哈希槽找到负责对应槽位的节点，然后自动跳转到这个槽位上进行存取操作</li>\n<li>为了提高可用性，Cluster同时支持主从复制，每个Master对应一个或多个Slave节点，当主节点宕机的时候启动从节点</li>\n<li>如果一个集群半数以上的Master节点认为某个Master节点疑似下线，那么这个Master将被标记为已下线。</li>\n</ol>\n<p>故障转移的方法和Sentinel模式类似：</p>\n<ol>\n<li>从复制故障Master节点的所有Slave节点选一个作为新的Master</li>\n<li>被选中的Slave节点执行<code>SLAVEOF no one</code>命令，成为新的Master节点</li>\n<li>新的Master节点会撤销所有对已下线Master节点的槽指派，将这些槽指派给自己</li>\n<li>新的Master节点向集群广播一条PONG消息，让集群中的其他节点知道这个节点已经由Slave变成了Master节点，并且已接管了槽位</li>\n<li>新的主节点开始接受和自己负责处理的slot有关的命令请求，故障转移完成。</li>\n</ol>\n<h4 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h4><h5 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h5><ul>\n<li>无中心架构，不存在单点故障</li>\n<li>不需要中间代理，减少依赖</li>\n<li>支持横向扩展，伸缩性更好，能提供的并发能力更高</li>\n<li>能自动故障转移，高可用</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><ul>\n<li>客户端实现复杂</li>\n<li>数据异步复制，不保证数据强一致性</li>\n<li>Slave作为冷备不提供服务</li>\n<li>批量操作限制</li>\n<li>事务支持有限，只支持多key在同一节点的事务操作</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】书籍：Redis设计与实现<br>【2】 <a href=\"https://segmentfault.com/a/1190000022028642\">一文掌握Redis的三种集群方案</a></p>\n"},{"title":"Session和Cookie","date":"2023-03-25T06:43:05.000Z","_content":"\n我们知道HTTP协议是无状态的，那么在Web开发中如何做好用户的整个浏览过程的控制，最经典的解决方案就是使用Cookie和Session。\nCookie是客户端的机制，把用户数据缓存在客户端，而Session是服务端的机制，每个用户都会被分配一个唯一的SessionID，可以通过url传输或保存在客户端的Cookie中，也可以将Session保存在数据库中，比如Redis中。\n\n## Session和Cookie是怎么来的？\n假如你在浏览器上从来没有登录过GitHub，当你第一次登录的时候需要输入用户名和密码进行验证，通过验证后会调到个人首页，那么在登录成功后你点击你的某个代码仓库的时候服务器如何验证你的身份呢？因为HTTP协议是无状态的，服务器并不知道你上次已经验证过了，一种方法是每次请求都带上用户名和密码，这显然会导致用户体验极差。那么就需要再客户端或服务器上保存身份信息了，于是Cookie和Session就产生了。\n\n### Cookie\n\n#### Cookie原理\nCookie就是本地计算机保存一些用户操作的历史信息，用户再次访问时在HTTP请求头中带上Cookie信息，服务端就可以对其进行验证。\n![](https://upload-images.jianshu.io/upload_images/14151453-e9dd7894922a2adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 数据内容\nCookie本质上是由浏览器管理存储在客户端的一小段文本，Chrome浏览器可以使用EditThisCookie插件来管理Cookie，如下图所示。\n![](https://upload-images.jianshu.io/upload_images/14151453-ae9b877211f0b906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 会话Cookie和持久Cookie\n- 会话Cookie：Cookie是有有效期的，如果不设置过期时间，则表示这个Cookie的生命周期从创建到浏览器关闭为止，只要关闭浏览器Cookie就消失了，相当于数据保存在内存中，进程结束就丢失了\n- 持久Cookie：如果设置了过期时间，浏览器会把Cookie数据保存到磁盘上，关闭浏览器再次打开依然有效，直到Cookie过期，浏览器通常都使用的持久Cookie。\n\n### Session\n\n#### Session原理\nSession是服务器用来保存用户操作的历史信息的，使用SessionID来标识Session，SessionID由服务器产生，保证随机性和唯一性，相当于一个随机秘钥，避免在传输中暴露用户真实密码，但是服务器仍要将请求对Session进行对应，需要借助Cookie保存客户端的标识（SessionID）。\n![](https://upload-images.jianshu.io/upload_images/14151453-849911fdca5ee4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当服务器需要对某个请求创建Session的时候，首先检查这个客户端的请求是否包含了SessionID，如果已经包含则表示次客户端之前已经创建过，只需要根据SessionID查询对应的Session。如果请求没有携带SessionID，则会生成一个Session和对应的SessionID，同时在本次响应中返回SessionID。\n\n## 参考\n【1】[build-web-application-with-golang](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md)\n","source":"_posts/2023/03-25-Session和Cookie.md","raw":"---\ntitle: Session和Cookie\ndate: 2023-03-25 14:43:05\ncategories:\n- [计算机网络]\ntags:\n- Session\n- Cookie\n---\n\n我们知道HTTP协议是无状态的，那么在Web开发中如何做好用户的整个浏览过程的控制，最经典的解决方案就是使用Cookie和Session。\nCookie是客户端的机制，把用户数据缓存在客户端，而Session是服务端的机制，每个用户都会被分配一个唯一的SessionID，可以通过url传输或保存在客户端的Cookie中，也可以将Session保存在数据库中，比如Redis中。\n\n## Session和Cookie是怎么来的？\n假如你在浏览器上从来没有登录过GitHub，当你第一次登录的时候需要输入用户名和密码进行验证，通过验证后会调到个人首页，那么在登录成功后你点击你的某个代码仓库的时候服务器如何验证你的身份呢？因为HTTP协议是无状态的，服务器并不知道你上次已经验证过了，一种方法是每次请求都带上用户名和密码，这显然会导致用户体验极差。那么就需要再客户端或服务器上保存身份信息了，于是Cookie和Session就产生了。\n\n### Cookie\n\n#### Cookie原理\nCookie就是本地计算机保存一些用户操作的历史信息，用户再次访问时在HTTP请求头中带上Cookie信息，服务端就可以对其进行验证。\n![](https://upload-images.jianshu.io/upload_images/14151453-e9dd7894922a2adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 数据内容\nCookie本质上是由浏览器管理存储在客户端的一小段文本，Chrome浏览器可以使用EditThisCookie插件来管理Cookie，如下图所示。\n![](https://upload-images.jianshu.io/upload_images/14151453-ae9b877211f0b906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 会话Cookie和持久Cookie\n- 会话Cookie：Cookie是有有效期的，如果不设置过期时间，则表示这个Cookie的生命周期从创建到浏览器关闭为止，只要关闭浏览器Cookie就消失了，相当于数据保存在内存中，进程结束就丢失了\n- 持久Cookie：如果设置了过期时间，浏览器会把Cookie数据保存到磁盘上，关闭浏览器再次打开依然有效，直到Cookie过期，浏览器通常都使用的持久Cookie。\n\n### Session\n\n#### Session原理\nSession是服务器用来保存用户操作的历史信息的，使用SessionID来标识Session，SessionID由服务器产生，保证随机性和唯一性，相当于一个随机秘钥，避免在传输中暴露用户真实密码，但是服务器仍要将请求对Session进行对应，需要借助Cookie保存客户端的标识（SessionID）。\n![](https://upload-images.jianshu.io/upload_images/14151453-849911fdca5ee4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当服务器需要对某个请求创建Session的时候，首先检查这个客户端的请求是否包含了SessionID，如果已经包含则表示次客户端之前已经创建过，只需要根据SessionID查询对应的Session。如果请求没有携带SessionID，则会生成一个Session和对应的SessionID，同时在本次响应中返回SessionID。\n\n## 参考\n【1】[build-web-application-with-golang](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md)\n","slug":"Session和Cookie","published":1,"updated":"2023-03-25T06:58:16.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywt001yvhfic0jag0wy","content":"<p>我们知道HTTP协议是无状态的，那么在Web开发中如何做好用户的整个浏览过程的控制，最经典的解决方案就是使用Cookie和Session。<br>Cookie是客户端的机制，把用户数据缓存在客户端，而Session是服务端的机制，每个用户都会被分配一个唯一的SessionID，可以通过url传输或保存在客户端的Cookie中，也可以将Session保存在数据库中，比如Redis中。</p>\n<h2 id=\"Session和Cookie是怎么来的？\"><a href=\"#Session和Cookie是怎么来的？\" class=\"headerlink\" title=\"Session和Cookie是怎么来的？\"></a>Session和Cookie是怎么来的？</h2><p>假如你在浏览器上从来没有登录过GitHub，当你第一次登录的时候需要输入用户名和密码进行验证，通过验证后会调到个人首页，那么在登录成功后你点击你的某个代码仓库的时候服务器如何验证你的身份呢？因为HTTP协议是无状态的，服务器并不知道你上次已经验证过了，一种方法是每次请求都带上用户名和密码，这显然会导致用户体验极差。那么就需要再客户端或服务器上保存身份信息了，于是Cookie和Session就产生了。</p>\n<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><h4 id=\"Cookie原理\"><a href=\"#Cookie原理\" class=\"headerlink\" title=\"Cookie原理\"></a>Cookie原理</h4><p>Cookie就是本地计算机保存一些用户操作的历史信息，用户再次访问时在HTTP请求头中带上Cookie信息，服务端就可以对其进行验证。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-e9dd7894922a2adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-e9dd7894922a2adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h4 id=\"数据内容\"><a href=\"#数据内容\" class=\"headerlink\" title=\"数据内容\"></a>数据内容</h4><p>Cookie本质上是由浏览器管理存储在客户端的一小段文本，Chrome浏览器可以使用EditThisCookie插件来管理Cookie，如下图所示。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-ae9b877211f0b906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-ae9b877211f0b906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h4 id=\"会话Cookie和持久Cookie\"><a href=\"#会话Cookie和持久Cookie\" class=\"headerlink\" title=\"会话Cookie和持久Cookie\"></a>会话Cookie和持久Cookie</h4><ul>\n<li>会话Cookie：Cookie是有有效期的，如果不设置过期时间，则表示这个Cookie的生命周期从创建到浏览器关闭为止，只要关闭浏览器Cookie就消失了，相当于数据保存在内存中，进程结束就丢失了</li>\n<li>持久Cookie：如果设置了过期时间，浏览器会把Cookie数据保存到磁盘上，关闭浏览器再次打开依然有效，直到Cookie过期，浏览器通常都使用的持久Cookie。</li>\n</ul>\n<h3 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h3><h4 id=\"Session原理\"><a href=\"#Session原理\" class=\"headerlink\" title=\"Session原理\"></a>Session原理</h4><p>Session是服务器用来保存用户操作的历史信息的，使用SessionID来标识Session，SessionID由服务器产生，保证随机性和唯一性，相当于一个随机秘钥，避免在传输中暴露用户真实密码，但是服务器仍要将请求对Session进行对应，需要借助Cookie保存客户端的标识（SessionID）。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-849911fdca5ee4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-849911fdca5ee4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>当服务器需要对某个请求创建Session的时候，首先检查这个客户端的请求是否包含了SessionID，如果已经包含则表示次客户端之前已经创建过，只需要根据SessionID查询对应的Session。如果请求没有携带SessionID，则会生成一个Session和对应的SessionID，同时在本次响应中返回SessionID。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md\">build-web-application-with-golang</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们知道HTTP协议是无状态的，那么在Web开发中如何做好用户的整个浏览过程的控制，最经典的解决方案就是使用Cookie和Session。<br>Cookie是客户端的机制，把用户数据缓存在客户端，而Session是服务端的机制，每个用户都会被分配一个唯一的SessionID，可以通过url传输或保存在客户端的Cookie中，也可以将Session保存在数据库中，比如Redis中。</p>\n<h2 id=\"Session和Cookie是怎么来的？\"><a href=\"#Session和Cookie是怎么来的？\" class=\"headerlink\" title=\"Session和Cookie是怎么来的？\"></a>Session和Cookie是怎么来的？</h2><p>假如你在浏览器上从来没有登录过GitHub，当你第一次登录的时候需要输入用户名和密码进行验证，通过验证后会调到个人首页，那么在登录成功后你点击你的某个代码仓库的时候服务器如何验证你的身份呢？因为HTTP协议是无状态的，服务器并不知道你上次已经验证过了，一种方法是每次请求都带上用户名和密码，这显然会导致用户体验极差。那么就需要再客户端或服务器上保存身份信息了，于是Cookie和Session就产生了。</p>\n<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><h4 id=\"Cookie原理\"><a href=\"#Cookie原理\" class=\"headerlink\" title=\"Cookie原理\"></a>Cookie原理</h4><p>Cookie就是本地计算机保存一些用户操作的历史信息，用户再次访问时在HTTP请求头中带上Cookie信息，服务端就可以对其进行验证。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-e9dd7894922a2adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h4 id=\"数据内容\"><a href=\"#数据内容\" class=\"headerlink\" title=\"数据内容\"></a>数据内容</h4><p>Cookie本质上是由浏览器管理存储在客户端的一小段文本，Chrome浏览器可以使用EditThisCookie插件来管理Cookie，如下图所示。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-ae9b877211f0b906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h4 id=\"会话Cookie和持久Cookie\"><a href=\"#会话Cookie和持久Cookie\" class=\"headerlink\" title=\"会话Cookie和持久Cookie\"></a>会话Cookie和持久Cookie</h4><ul>\n<li>会话Cookie：Cookie是有有效期的，如果不设置过期时间，则表示这个Cookie的生命周期从创建到浏览器关闭为止，只要关闭浏览器Cookie就消失了，相当于数据保存在内存中，进程结束就丢失了</li>\n<li>持久Cookie：如果设置了过期时间，浏览器会把Cookie数据保存到磁盘上，关闭浏览器再次打开依然有效，直到Cookie过期，浏览器通常都使用的持久Cookie。</li>\n</ul>\n<h3 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h3><h4 id=\"Session原理\"><a href=\"#Session原理\" class=\"headerlink\" title=\"Session原理\"></a>Session原理</h4><p>Session是服务器用来保存用户操作的历史信息的，使用SessionID来标识Session，SessionID由服务器产生，保证随机性和唯一性，相当于一个随机秘钥，避免在传输中暴露用户真实密码，但是服务器仍要将请求对Session进行对应，需要借助Cookie保存客户端的标识（SessionID）。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-849911fdca5ee4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>当服务器需要对某个请求创建Session的时候，首先检查这个客户端的请求是否包含了SessionID，如果已经包含则表示次客户端之前已经创建过，只需要根据SessionID查询对应的Session。如果请求没有携带SessionID，则会生成一个Session和对应的SessionID，同时在本次响应中返回SessionID。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.1.md\">build-web-application-with-golang</a></p>\n"},{"title":"TCP是如何实现可靠传输的？","date":"2023-03-25T06:43:37.000Z","_content":"\n在计算机网络的经典五层协议中，TCP属于运输层，实现了进程间的通信，保证了数据的可靠传输，属于计算机网络协议族中最重要的协议之一，那么TCP是如何实现可靠数据传输的呢？\n## 底层实现\n运输层的进程间通信是通过socket实现的，socket是一个抽象的概念，在Linux系统中以文件的形式存在。网络层通过IP来区分主机，运输层则增加了端口的概念来区分进程。TCP协议中使用目标IP、目标端口、源IP、源端口来定义一个socket，只需要在运输层的报文头部附加上这些信息，目标主机就会知道数据要发送那个socket，对应监听该socket的进程就可以收到数据进行处理。\n\n## TCP报文格式\nTCP报文包括首部和数据部分，首部附加了TCP报文的信息，首部长度固定部分为20字节，还有40字节的可选部分，具体如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-cdbb73e6c3f47d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中几个关键字段的作用如下：\n- 源端口和目的端口：分别16个字节（表示范围0-65535），用来区分主机上的进程\n- 序号：TCP连接中的每个字节都编一个序号，表示本报文的第一个字节在整个数据包中的偏移位置\n- 确认号：期望收到对方的下一个报文段的数据的第一个字节的序号\n- 数据偏移：首部长度，4字节为单位\n- 标志位\n  - ACK：ACK=1表示接收发向发送方发的确认报文\n  - SYN：同步SYN=1表示是一个连接请求或连接接受报文\n  - FIN：FIN=1表示发送方已经发送完毕，可以断开连接\n- 窗口：发送方接收缓冲区剩下的字节数\n- 校验和：检验报文在网络传输过程中是否发生了变化\n- 选项字段：\n  - 窗口扩大选项，用于流量控制\n  - 时间戳选项\n  - 选择确认选项，由于接收方收到了不连续的报文，告知发送方目前收到的数据报范围（两个4字节的边界表示）\n\n## 可靠传输原理\n网络层只管尽可能将数据从一个主机发送到另一个主机，并不保证数据可靠到达，由于网络环境总是不稳定的，可能存在丢包、差错等请求，TCP则通过一系列的机制在运输层保证了数据的可靠传输。\n网络传输可能发生的异常情况和解决方法：\n- 丢包：超时重传\n- 差错：校验码来检验数据正确收到\n\n### 停止等待协议\n要实现可靠传输，最简单的方法就是发送方发送一个报文，接收方收到报文后发送确认报文表示我收到了，你可以发下一个了，传输模型如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-60467e00e08bd710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这种方式保证可靠传输称为停止等待协议，这种方式缺点也很明显，效率非常低。\n\n### 连续ARQ协议\n为了提高传输效率，充分利用带宽，发送方会连续的发送数据包，如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-3e2aee42126ae328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n客户端不等收到前一个包的确认报文就开始不断的发下一个包，这样可以充分利用网络带宽，提高传输效率，但是于此同时也带来了另外的问题，那么TCP是如何解决这些问题的？\n\n#### 确认报文冗余\n**累计确认**：网络中充斥着大量的发送包和确认回复报文，这些数据只是为了确认报文到达，并不是实际需要传输的数据。是不是一定要每一个报文都要发一个回复确认的报文呢，TCP采用了累计确认的方法：接收方在累计收到了一定量的数据包后发送一个确认报文告诉发送方在此之前的数据包都已经收到了，这样便可以减少确认报文的数量，提高带宽利用率。\n\n#### 丢包的处理\n**GBN（回退n步）**：如果发生丢包的情况，在连续ARQ中，如果接受方收到了123 567个字节，编号为4字节的包丢失了，按照累计确认只能发送3的确认回复，567都要丢掉，因为发送发会进行重传。\n\n**选择确认ACK**：在TCP报文头部的选项字段部分设置已收到的报文，每一段用两个边界来确定，比如上述情况可以用[1,3]和[5,7]来表示，客户端就会根据选项只重传丢失的数据段。\n\n#### 滑动窗口\n因为接收方读数据的能力有限，发送发不能一直发送报文直到把缓冲区所有数据发送完，这样会导致接收方无法接收丢弃掉数据包，发送方收不到确认认为超时又会继续重传，产生了大量无用数据的重传。对此情况TCP使用滑动窗口来解决，基本模型如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-06581f647ab4c35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 发送方根据接受方缓冲区的大小，设置自己可发送窗口大小，处于窗口内的数据表示可以发送，之外的数据不能发送\n- 当窗口内的未确认数据收到确认回复时，整个窗口往前移动，知道发送完所有数据\n\n滑动窗口机制实现了TCP的**流量控制**，不至于发送太快导致太多的数据丢弃和重传。\n\n## 拥塞控制\n为了避免网络过分拥挤导致丢包严重，传输效率低，TCP实现了拥塞控制机制，拥塞控制的解决办法本质上是流量控制，控制发送方发送的速度，而上文提到流量控制是通过滑动窗口来实现的，所以最终也是通过调整发送方的滑动窗口大小来实现的。\n\n拥塞控制的几个重要的概念：慢启动、拥塞避免、快恢复、快重传\n\n### Reno算法模型\n![](https://upload-images.jianshu.io/upload_images/14151453-2ca1f629fb91be2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 慢启动：最开始的时候把窗口设置为较小的值，然后每轮变成两倍（虽然叫慢启动，但其实是指数增长）\n- 拥塞避免：当窗口大小达到初始阈值ssthresh，每轮窗口大小增加1（试探网络最大的负载能力）\n- 如果发生了超时，表示极可能发生了拥塞，此时直接执行慢启动，尽可能让网络中的报文先接收，以尽快恢复网络状况。\n- 快重传：如果收到三个重复的ACK，表示中间有段数据丢包了，发送方无需等待计时器到达超时时间，立即进行重传丢失的报文段。\n- 快恢复：连续收到了三个重复ACK，说明网络情况还不是很拥堵，此时将窗口初始的阈值减半，然后执行拥塞避免，这个过程称为快恢复。\n\nReno算法是比较常见的TCP实现的拥塞控制算法，其他拥塞算法还有Tahoe（已废弃不用）、New Reno等，通过拥塞控制算法可以很大程度避免网络拥挤。\n\n## 参考\n【书籍】计算机网络：自顶向下方法\n【码农有道】[这一篇TCP总结请收下](https://mp.weixin.qq.com/s/B1Qttaejav4UzPn0GNoOHw)\n","source":"_posts/2023/03-25-TCP是如何实现可靠传输的？.md","raw":"---\ntitle: TCP是如何实现可靠传输的？\ndate: 2023-03-25 14:43:37\ncategories:\n- [计算机网络]\ntags:\n- TCP\n---\n\n在计算机网络的经典五层协议中，TCP属于运输层，实现了进程间的通信，保证了数据的可靠传输，属于计算机网络协议族中最重要的协议之一，那么TCP是如何实现可靠数据传输的呢？\n## 底层实现\n运输层的进程间通信是通过socket实现的，socket是一个抽象的概念，在Linux系统中以文件的形式存在。网络层通过IP来区分主机，运输层则增加了端口的概念来区分进程。TCP协议中使用目标IP、目标端口、源IP、源端口来定义一个socket，只需要在运输层的报文头部附加上这些信息，目标主机就会知道数据要发送那个socket，对应监听该socket的进程就可以收到数据进行处理。\n\n## TCP报文格式\nTCP报文包括首部和数据部分，首部附加了TCP报文的信息，首部长度固定部分为20字节，还有40字节的可选部分，具体如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-cdbb73e6c3f47d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中几个关键字段的作用如下：\n- 源端口和目的端口：分别16个字节（表示范围0-65535），用来区分主机上的进程\n- 序号：TCP连接中的每个字节都编一个序号，表示本报文的第一个字节在整个数据包中的偏移位置\n- 确认号：期望收到对方的下一个报文段的数据的第一个字节的序号\n- 数据偏移：首部长度，4字节为单位\n- 标志位\n  - ACK：ACK=1表示接收发向发送方发的确认报文\n  - SYN：同步SYN=1表示是一个连接请求或连接接受报文\n  - FIN：FIN=1表示发送方已经发送完毕，可以断开连接\n- 窗口：发送方接收缓冲区剩下的字节数\n- 校验和：检验报文在网络传输过程中是否发生了变化\n- 选项字段：\n  - 窗口扩大选项，用于流量控制\n  - 时间戳选项\n  - 选择确认选项，由于接收方收到了不连续的报文，告知发送方目前收到的数据报范围（两个4字节的边界表示）\n\n## 可靠传输原理\n网络层只管尽可能将数据从一个主机发送到另一个主机，并不保证数据可靠到达，由于网络环境总是不稳定的，可能存在丢包、差错等请求，TCP则通过一系列的机制在运输层保证了数据的可靠传输。\n网络传输可能发生的异常情况和解决方法：\n- 丢包：超时重传\n- 差错：校验码来检验数据正确收到\n\n### 停止等待协议\n要实现可靠传输，最简单的方法就是发送方发送一个报文，接收方收到报文后发送确认报文表示我收到了，你可以发下一个了，传输模型如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-60467e00e08bd710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这种方式保证可靠传输称为停止等待协议，这种方式缺点也很明显，效率非常低。\n\n### 连续ARQ协议\n为了提高传输效率，充分利用带宽，发送方会连续的发送数据包，如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-3e2aee42126ae328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n客户端不等收到前一个包的确认报文就开始不断的发下一个包，这样可以充分利用网络带宽，提高传输效率，但是于此同时也带来了另外的问题，那么TCP是如何解决这些问题的？\n\n#### 确认报文冗余\n**累计确认**：网络中充斥着大量的发送包和确认回复报文，这些数据只是为了确认报文到达，并不是实际需要传输的数据。是不是一定要每一个报文都要发一个回复确认的报文呢，TCP采用了累计确认的方法：接收方在累计收到了一定量的数据包后发送一个确认报文告诉发送方在此之前的数据包都已经收到了，这样便可以减少确认报文的数量，提高带宽利用率。\n\n#### 丢包的处理\n**GBN（回退n步）**：如果发生丢包的情况，在连续ARQ中，如果接受方收到了123 567个字节，编号为4字节的包丢失了，按照累计确认只能发送3的确认回复，567都要丢掉，因为发送发会进行重传。\n\n**选择确认ACK**：在TCP报文头部的选项字段部分设置已收到的报文，每一段用两个边界来确定，比如上述情况可以用[1,3]和[5,7]来表示，客户端就会根据选项只重传丢失的数据段。\n\n#### 滑动窗口\n因为接收方读数据的能力有限，发送发不能一直发送报文直到把缓冲区所有数据发送完，这样会导致接收方无法接收丢弃掉数据包，发送方收不到确认认为超时又会继续重传，产生了大量无用数据的重传。对此情况TCP使用滑动窗口来解决，基本模型如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-06581f647ab4c35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 发送方根据接受方缓冲区的大小，设置自己可发送窗口大小，处于窗口内的数据表示可以发送，之外的数据不能发送\n- 当窗口内的未确认数据收到确认回复时，整个窗口往前移动，知道发送完所有数据\n\n滑动窗口机制实现了TCP的**流量控制**，不至于发送太快导致太多的数据丢弃和重传。\n\n## 拥塞控制\n为了避免网络过分拥挤导致丢包严重，传输效率低，TCP实现了拥塞控制机制，拥塞控制的解决办法本质上是流量控制，控制发送方发送的速度，而上文提到流量控制是通过滑动窗口来实现的，所以最终也是通过调整发送方的滑动窗口大小来实现的。\n\n拥塞控制的几个重要的概念：慢启动、拥塞避免、快恢复、快重传\n\n### Reno算法模型\n![](https://upload-images.jianshu.io/upload_images/14151453-2ca1f629fb91be2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 慢启动：最开始的时候把窗口设置为较小的值，然后每轮变成两倍（虽然叫慢启动，但其实是指数增长）\n- 拥塞避免：当窗口大小达到初始阈值ssthresh，每轮窗口大小增加1（试探网络最大的负载能力）\n- 如果发生了超时，表示极可能发生了拥塞，此时直接执行慢启动，尽可能让网络中的报文先接收，以尽快恢复网络状况。\n- 快重传：如果收到三个重复的ACK，表示中间有段数据丢包了，发送方无需等待计时器到达超时时间，立即进行重传丢失的报文段。\n- 快恢复：连续收到了三个重复ACK，说明网络情况还不是很拥堵，此时将窗口初始的阈值减半，然后执行拥塞避免，这个过程称为快恢复。\n\nReno算法是比较常见的TCP实现的拥塞控制算法，其他拥塞算法还有Tahoe（已废弃不用）、New Reno等，通过拥塞控制算法可以很大程度避免网络拥挤。\n\n## 参考\n【书籍】计算机网络：自顶向下方法\n【码农有道】[这一篇TCP总结请收下](https://mp.weixin.qq.com/s/B1Qttaejav4UzPn0GNoOHw)\n","slug":"TCP是如何实现可靠传输的？","published":1,"updated":"2023-03-25T06:58:47.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywt0020vhfi9f61glb4","content":"<p>在计算机网络的经典五层协议中，TCP属于运输层，实现了进程间的通信，保证了数据的可靠传输，属于计算机网络协议族中最重要的协议之一，那么TCP是如何实现可靠数据传输的呢？</p>\n<h2 id=\"底层实现\"><a href=\"#底层实现\" class=\"headerlink\" title=\"底层实现\"></a>底层实现</h2><p>运输层的进程间通信是通过socket实现的，socket是一个抽象的概念，在Linux系统中以文件的形式存在。网络层通过IP来区分主机，运输层则增加了端口的概念来区分进程。TCP协议中使用目标IP、目标端口、源IP、源端口来定义一个socket，只需要在运输层的报文头部附加上这些信息，目标主机就会知道数据要发送那个socket，对应监听该socket的进程就可以收到数据进行处理。</p>\n<h2 id=\"TCP报文格式\"><a href=\"#TCP报文格式\" class=\"headerlink\" title=\"TCP报文格式\"></a>TCP报文格式</h2><p>TCP报文包括首部和数据部分，首部附加了TCP报文的信息，首部长度固定部分为20字节，还有40字节的可选部分，具体如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-cdbb73e6c3f47d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-cdbb73e6c3f47d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>其中几个关键字段的作用如下：</p>\n<ul>\n<li>源端口和目的端口：分别16个字节（表示范围0-65535），用来区分主机上的进程</li>\n<li>序号：TCP连接中的每个字节都编一个序号，表示本报文的第一个字节在整个数据包中的偏移位置</li>\n<li>确认号：期望收到对方的下一个报文段的数据的第一个字节的序号</li>\n<li>数据偏移：首部长度，4字节为单位</li>\n<li>标志位<ul>\n<li>ACK：ACK&#x3D;1表示接收发向发送方发的确认报文</li>\n<li>SYN：同步SYN&#x3D;1表示是一个连接请求或连接接受报文</li>\n<li>FIN：FIN&#x3D;1表示发送方已经发送完毕，可以断开连接</li>\n</ul>\n</li>\n<li>窗口：发送方接收缓冲区剩下的字节数</li>\n<li>校验和：检验报文在网络传输过程中是否发生了变化</li>\n<li>选项字段：<ul>\n<li>窗口扩大选项，用于流量控制</li>\n<li>时间戳选项</li>\n<li>选择确认选项，由于接收方收到了不连续的报文，告知发送方目前收到的数据报范围（两个4字节的边界表示）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"可靠传输原理\"><a href=\"#可靠传输原理\" class=\"headerlink\" title=\"可靠传输原理\"></a>可靠传输原理</h2><p>网络层只管尽可能将数据从一个主机发送到另一个主机，并不保证数据可靠到达，由于网络环境总是不稳定的，可能存在丢包、差错等请求，TCP则通过一系列的机制在运输层保证了数据的可靠传输。<br>网络传输可能发生的异常情况和解决方法：</p>\n<ul>\n<li>丢包：超时重传</li>\n<li>差错：校验码来检验数据正确收到</li>\n</ul>\n<h3 id=\"停止等待协议\"><a href=\"#停止等待协议\" class=\"headerlink\" title=\"停止等待协议\"></a>停止等待协议</h3><p>要实现可靠传输，最简单的方法就是发送方发送一个报文，接收方收到报文后发送确认报文表示我收到了，你可以发下一个了，传输模型如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-60467e00e08bd710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-60467e00e08bd710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>这种方式保证可靠传输称为停止等待协议，这种方式缺点也很明显，效率非常低。</p>\n<h3 id=\"连续ARQ协议\"><a href=\"#连续ARQ协议\" class=\"headerlink\" title=\"连续ARQ协议\"></a>连续ARQ协议</h3><p>为了提高传输效率，充分利用带宽，发送方会连续的发送数据包，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-3e2aee42126ae328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-3e2aee42126ae328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>客户端不等收到前一个包的确认报文就开始不断的发下一个包，这样可以充分利用网络带宽，提高传输效率，但是于此同时也带来了另外的问题，那么TCP是如何解决这些问题的？</p>\n<h4 id=\"确认报文冗余\"><a href=\"#确认报文冗余\" class=\"headerlink\" title=\"确认报文冗余\"></a>确认报文冗余</h4><p><strong>累计确认</strong>：网络中充斥着大量的发送包和确认回复报文，这些数据只是为了确认报文到达，并不是实际需要传输的数据。是不是一定要每一个报文都要发一个回复确认的报文呢，TCP采用了累计确认的方法：接收方在累计收到了一定量的数据包后发送一个确认报文告诉发送方在此之前的数据包都已经收到了，这样便可以减少确认报文的数量，提高带宽利用率。</p>\n<h4 id=\"丢包的处理\"><a href=\"#丢包的处理\" class=\"headerlink\" title=\"丢包的处理\"></a>丢包的处理</h4><p><strong>GBN（回退n步）</strong>：如果发生丢包的情况，在连续ARQ中，如果接受方收到了123 567个字节，编号为4字节的包丢失了，按照累计确认只能发送3的确认回复，567都要丢掉，因为发送发会进行重传。</p>\n<p><strong>选择确认ACK</strong>：在TCP报文头部的选项字段部分设置已收到的报文，每一段用两个边界来确定，比如上述情况可以用[1,3]和[5,7]来表示，客户端就会根据选项只重传丢失的数据段。</p>\n<h4 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h4><p>因为接收方读数据的能力有限，发送发不能一直发送报文直到把缓冲区所有数据发送完，这样会导致接收方无法接收丢弃掉数据包，发送方收不到确认认为超时又会继续重传，产生了大量无用数据的重传。对此情况TCP使用滑动窗口来解决，基本模型如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-06581f647ab4c35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-06581f647ab4c35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<ul>\n<li>发送方根据接受方缓冲区的大小，设置自己可发送窗口大小，处于窗口内的数据表示可以发送，之外的数据不能发送</li>\n<li>当窗口内的未确认数据收到确认回复时，整个窗口往前移动，知道发送完所有数据</li>\n</ul>\n<p>滑动窗口机制实现了TCP的<strong>流量控制</strong>，不至于发送太快导致太多的数据丢弃和重传。</p>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h2><p>为了避免网络过分拥挤导致丢包严重，传输效率低，TCP实现了拥塞控制机制，拥塞控制的解决办法本质上是流量控制，控制发送方发送的速度，而上文提到流量控制是通过滑动窗口来实现的，所以最终也是通过调整发送方的滑动窗口大小来实现的。</p>\n<p>拥塞控制的几个重要的概念：慢启动、拥塞避免、快恢复、快重传</p>\n<h3 id=\"Reno算法模型\"><a href=\"#Reno算法模型\" class=\"headerlink\" title=\"Reno算法模型\"></a>Reno算法模型</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-2ca1f629fb91be2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-2ca1f629fb91be2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<ul>\n<li>慢启动：最开始的时候把窗口设置为较小的值，然后每轮变成两倍（虽然叫慢启动，但其实是指数增长）</li>\n<li>拥塞避免：当窗口大小达到初始阈值ssthresh，每轮窗口大小增加1（试探网络最大的负载能力）</li>\n<li>如果发生了超时，表示极可能发生了拥塞，此时直接执行慢启动，尽可能让网络中的报文先接收，以尽快恢复网络状况。</li>\n<li>快重传：如果收到三个重复的ACK，表示中间有段数据丢包了，发送方无需等待计时器到达超时时间，立即进行重传丢失的报文段。</li>\n<li>快恢复：连续收到了三个重复ACK，说明网络情况还不是很拥堵，此时将窗口初始的阈值减半，然后执行拥塞避免，这个过程称为快恢复。</li>\n</ul>\n<p>Reno算法是比较常见的TCP实现的拥塞控制算法，其他拥塞算法还有Tahoe（已废弃不用）、New Reno等，通过拥塞控制算法可以很大程度避免网络拥挤。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【书籍】计算机网络：自顶向下方法<br>【码农有道】<a href=\"https://mp.weixin.qq.com/s/B1Qttaejav4UzPn0GNoOHw\">这一篇TCP总结请收下</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在计算机网络的经典五层协议中，TCP属于运输层，实现了进程间的通信，保证了数据的可靠传输，属于计算机网络协议族中最重要的协议之一，那么TCP是如何实现可靠数据传输的呢？</p>\n<h2 id=\"底层实现\"><a href=\"#底层实现\" class=\"headerlink\" title=\"底层实现\"></a>底层实现</h2><p>运输层的进程间通信是通过socket实现的，socket是一个抽象的概念，在Linux系统中以文件的形式存在。网络层通过IP来区分主机，运输层则增加了端口的概念来区分进程。TCP协议中使用目标IP、目标端口、源IP、源端口来定义一个socket，只需要在运输层的报文头部附加上这些信息，目标主机就会知道数据要发送那个socket，对应监听该socket的进程就可以收到数据进行处理。</p>\n<h2 id=\"TCP报文格式\"><a href=\"#TCP报文格式\" class=\"headerlink\" title=\"TCP报文格式\"></a>TCP报文格式</h2><p>TCP报文包括首部和数据部分，首部附加了TCP报文的信息，首部长度固定部分为20字节，还有40字节的可选部分，具体如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-cdbb73e6c3f47d3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>其中几个关键字段的作用如下：</p>\n<ul>\n<li>源端口和目的端口：分别16个字节（表示范围0-65535），用来区分主机上的进程</li>\n<li>序号：TCP连接中的每个字节都编一个序号，表示本报文的第一个字节在整个数据包中的偏移位置</li>\n<li>确认号：期望收到对方的下一个报文段的数据的第一个字节的序号</li>\n<li>数据偏移：首部长度，4字节为单位</li>\n<li>标志位<ul>\n<li>ACK：ACK&#x3D;1表示接收发向发送方发的确认报文</li>\n<li>SYN：同步SYN&#x3D;1表示是一个连接请求或连接接受报文</li>\n<li>FIN：FIN&#x3D;1表示发送方已经发送完毕，可以断开连接</li>\n</ul>\n</li>\n<li>窗口：发送方接收缓冲区剩下的字节数</li>\n<li>校验和：检验报文在网络传输过程中是否发生了变化</li>\n<li>选项字段：<ul>\n<li>窗口扩大选项，用于流量控制</li>\n<li>时间戳选项</li>\n<li>选择确认选项，由于接收方收到了不连续的报文，告知发送方目前收到的数据报范围（两个4字节的边界表示）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"可靠传输原理\"><a href=\"#可靠传输原理\" class=\"headerlink\" title=\"可靠传输原理\"></a>可靠传输原理</h2><p>网络层只管尽可能将数据从一个主机发送到另一个主机，并不保证数据可靠到达，由于网络环境总是不稳定的，可能存在丢包、差错等请求，TCP则通过一系列的机制在运输层保证了数据的可靠传输。<br>网络传输可能发生的异常情况和解决方法：</p>\n<ul>\n<li>丢包：超时重传</li>\n<li>差错：校验码来检验数据正确收到</li>\n</ul>\n<h3 id=\"停止等待协议\"><a href=\"#停止等待协议\" class=\"headerlink\" title=\"停止等待协议\"></a>停止等待协议</h3><p>要实现可靠传输，最简单的方法就是发送方发送一个报文，接收方收到报文后发送确认报文表示我收到了，你可以发下一个了，传输模型如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-60467e00e08bd710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>这种方式保证可靠传输称为停止等待协议，这种方式缺点也很明显，效率非常低。</p>\n<h3 id=\"连续ARQ协议\"><a href=\"#连续ARQ协议\" class=\"headerlink\" title=\"连续ARQ协议\"></a>连续ARQ协议</h3><p>为了提高传输效率，充分利用带宽，发送方会连续的发送数据包，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-3e2aee42126ae328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>客户端不等收到前一个包的确认报文就开始不断的发下一个包，这样可以充分利用网络带宽，提高传输效率，但是于此同时也带来了另外的问题，那么TCP是如何解决这些问题的？</p>\n<h4 id=\"确认报文冗余\"><a href=\"#确认报文冗余\" class=\"headerlink\" title=\"确认报文冗余\"></a>确认报文冗余</h4><p><strong>累计确认</strong>：网络中充斥着大量的发送包和确认回复报文，这些数据只是为了确认报文到达，并不是实际需要传输的数据。是不是一定要每一个报文都要发一个回复确认的报文呢，TCP采用了累计确认的方法：接收方在累计收到了一定量的数据包后发送一个确认报文告诉发送方在此之前的数据包都已经收到了，这样便可以减少确认报文的数量，提高带宽利用率。</p>\n<h4 id=\"丢包的处理\"><a href=\"#丢包的处理\" class=\"headerlink\" title=\"丢包的处理\"></a>丢包的处理</h4><p><strong>GBN（回退n步）</strong>：如果发生丢包的情况，在连续ARQ中，如果接受方收到了123 567个字节，编号为4字节的包丢失了，按照累计确认只能发送3的确认回复，567都要丢掉，因为发送发会进行重传。</p>\n<p><strong>选择确认ACK</strong>：在TCP报文头部的选项字段部分设置已收到的报文，每一段用两个边界来确定，比如上述情况可以用[1,3]和[5,7]来表示，客户端就会根据选项只重传丢失的数据段。</p>\n<h4 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h4><p>因为接收方读数据的能力有限，发送发不能一直发送报文直到把缓冲区所有数据发送完，这样会导致接收方无法接收丢弃掉数据包，发送方收不到确认认为超时又会继续重传，产生了大量无用数据的重传。对此情况TCP使用滑动窗口来解决，基本模型如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-06581f647ab4c35b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<ul>\n<li>发送方根据接受方缓冲区的大小，设置自己可发送窗口大小，处于窗口内的数据表示可以发送，之外的数据不能发送</li>\n<li>当窗口内的未确认数据收到确认回复时，整个窗口往前移动，知道发送完所有数据</li>\n</ul>\n<p>滑动窗口机制实现了TCP的<strong>流量控制</strong>，不至于发送太快导致太多的数据丢弃和重传。</p>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h2><p>为了避免网络过分拥挤导致丢包严重，传输效率低，TCP实现了拥塞控制机制，拥塞控制的解决办法本质上是流量控制，控制发送方发送的速度，而上文提到流量控制是通过滑动窗口来实现的，所以最终也是通过调整发送方的滑动窗口大小来实现的。</p>\n<p>拥塞控制的几个重要的概念：慢启动、拥塞避免、快恢复、快重传</p>\n<h3 id=\"Reno算法模型\"><a href=\"#Reno算法模型\" class=\"headerlink\" title=\"Reno算法模型\"></a>Reno算法模型</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-2ca1f629fb91be2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<ul>\n<li>慢启动：最开始的时候把窗口设置为较小的值，然后每轮变成两倍（虽然叫慢启动，但其实是指数增长）</li>\n<li>拥塞避免：当窗口大小达到初始阈值ssthresh，每轮窗口大小增加1（试探网络最大的负载能力）</li>\n<li>如果发生了超时，表示极可能发生了拥塞，此时直接执行慢启动，尽可能让网络中的报文先接收，以尽快恢复网络状况。</li>\n<li>快重传：如果收到三个重复的ACK，表示中间有段数据丢包了，发送方无需等待计时器到达超时时间，立即进行重传丢失的报文段。</li>\n<li>快恢复：连续收到了三个重复ACK，说明网络情况还不是很拥堵，此时将窗口初始的阈值减半，然后执行拥塞避免，这个过程称为快恢复。</li>\n</ul>\n<p>Reno算法是比较常见的TCP实现的拥塞控制算法，其他拥塞算法还有Tahoe（已废弃不用）、New Reno等，通过拥塞控制算法可以很大程度避免网络拥挤。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【书籍】计算机网络：自顶向下方法<br>【码农有道】<a href=\"https://mp.weixin.qq.com/s/B1Qttaejav4UzPn0GNoOHw\">这一篇TCP总结请收下</a></p>\n"},{"title":"一致性哈希算法原理","date":"2023-03-25T07:25:04.000Z","_content":"## 传统哈希算法的局限性\n在分布式系统中，通常使用多个节点来保存数据，以提高并发能力和容量，那么如果决定数据保存到哪个节点上呢？一般的做法是通过一个哈希函数对数据key进行计算，然后对节点数量取模，从而得到数据分配的节点：\n`node_id = hash(key) % N`\n但是这种做法在节点数量N变化的时候，大部分key的计算的节点都会重新分配。如果是应用在分布式缓存，就会导致大规模的缓存失效，引起缓存雪崩。\n\n## 一致性哈希算法\n\n### 原理\n一致性哈希算法将哈希空间分配到哈希环的数据结构上，取值范围0~2^32-1，并且起点与终点相连。\n![](https://upload-images.jianshu.io/upload_images/14151453-3d4ac4aed2d0295d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n1. 将服务器通过哈希函数（以IP或者主机名作为key）放置到环上\n2. 对数据key使用相同的哈希函数，落到哈希空间上的某个点，如果该点不是服务器节点的位置，则顺时针向前寻找，直到碰到第一个服务器节点，将数据分配到该节点。\n\n#### 新增节点\n![](https://upload-images.jianshu.io/upload_images/14151453-889a824feb485b6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n新增了节点S4，那么影响的只是哈希空间S3到S4之间的数据，如原来key4是分配到节点S1，现在分配到了S4。\n\n#### 下线节点\n![](https://upload-images.jianshu.io/upload_images/14151453-de338ef1527c2666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n节点S2下线，只影响哈希空间S1到S2之间的数据，如原来key2分配到了S2，现在分配到了S3。\n\n### 虚拟节点优化\n当服务节点比较少的时候会出现分配不平衡的问题，造成大量数据集中到一个节点上，如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-9197f7ebe16f828a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n大部分的哈希空间都会分配到S1上，少量分配到S2上。\n为了解决这种数据倾斜问题，一致性哈希引入了虚拟节点机制：对每一个服务器节点计算多个哈希，每个计算结果都防止一个此服务器对应的虚拟节点。具体做法可以在服务器IP后面加上编号再计算哈希值。\n![](https://upload-images.jianshu.io/upload_images/14151453-01a834f729aa04c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n如上图所示，对S1和S2分别虚拟出两个节点，形成四个虚拟节点，数据分配方式不变，不过多了先顺时针找到服务器的虚拟节点，再映射到对应的物理服务器节点。\n\n### 特点\n- 良好的伸缩性。一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，比传统的哈希算法大大节省了数据移动的开销。\n- 更好的适应数据增长。当数据不断增长，部分虚拟节点可能包含很多数据，造成数据分配不平衡，此时可以将包含数据多的虚拟节点分裂，这种分裂仅仅是将原有的虚拟节点一分为二，不需要对全部数据重新哈希划分。\n\n## 参考\n【1】 [图解一致性哈希算法](https://segmentfault.com/a/1190000021199728)\n【2】[一致性Hash算法详解](https://zhuanlan.zhihu.com/p/98030096)\n","source":"_posts/2023/03-25-一致性哈希算法原理.md","raw":"---\ntitle: 一致性哈希算法原理\ndate: 2023-03-25 15:25:04\ncategories:\n- [分布式系统]\ntags:\n- 一致性哈希\n---\n## 传统哈希算法的局限性\n在分布式系统中，通常使用多个节点来保存数据，以提高并发能力和容量，那么如果决定数据保存到哪个节点上呢？一般的做法是通过一个哈希函数对数据key进行计算，然后对节点数量取模，从而得到数据分配的节点：\n`node_id = hash(key) % N`\n但是这种做法在节点数量N变化的时候，大部分key的计算的节点都会重新分配。如果是应用在分布式缓存，就会导致大规模的缓存失效，引起缓存雪崩。\n\n## 一致性哈希算法\n\n### 原理\n一致性哈希算法将哈希空间分配到哈希环的数据结构上，取值范围0~2^32-1，并且起点与终点相连。\n![](https://upload-images.jianshu.io/upload_images/14151453-3d4ac4aed2d0295d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n1. 将服务器通过哈希函数（以IP或者主机名作为key）放置到环上\n2. 对数据key使用相同的哈希函数，落到哈希空间上的某个点，如果该点不是服务器节点的位置，则顺时针向前寻找，直到碰到第一个服务器节点，将数据分配到该节点。\n\n#### 新增节点\n![](https://upload-images.jianshu.io/upload_images/14151453-889a824feb485b6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n新增了节点S4，那么影响的只是哈希空间S3到S4之间的数据，如原来key4是分配到节点S1，现在分配到了S4。\n\n#### 下线节点\n![](https://upload-images.jianshu.io/upload_images/14151453-de338ef1527c2666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n节点S2下线，只影响哈希空间S1到S2之间的数据，如原来key2分配到了S2，现在分配到了S3。\n\n### 虚拟节点优化\n当服务节点比较少的时候会出现分配不平衡的问题，造成大量数据集中到一个节点上，如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-9197f7ebe16f828a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n大部分的哈希空间都会分配到S1上，少量分配到S2上。\n为了解决这种数据倾斜问题，一致性哈希引入了虚拟节点机制：对每一个服务器节点计算多个哈希，每个计算结果都防止一个此服务器对应的虚拟节点。具体做法可以在服务器IP后面加上编号再计算哈希值。\n![](https://upload-images.jianshu.io/upload_images/14151453-01a834f729aa04c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n如上图所示，对S1和S2分别虚拟出两个节点，形成四个虚拟节点，数据分配方式不变，不过多了先顺时针找到服务器的虚拟节点，再映射到对应的物理服务器节点。\n\n### 特点\n- 良好的伸缩性。一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，比传统的哈希算法大大节省了数据移动的开销。\n- 更好的适应数据增长。当数据不断增长，部分虚拟节点可能包含很多数据，造成数据分配不平衡，此时可以将包含数据多的虚拟节点分裂，这种分裂仅仅是将原有的虚拟节点一分为二，不需要对全部数据重新哈希划分。\n\n## 参考\n【1】 [图解一致性哈希算法](https://segmentfault.com/a/1190000021199728)\n【2】[一致性Hash算法详解](https://zhuanlan.zhihu.com/p/98030096)\n","slug":"一致性哈希算法原理","published":1,"updated":"2023-03-25T07:32:08.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywv0023vhfigsehdgp1","content":"<h2 id=\"传统哈希算法的局限性\"><a href=\"#传统哈希算法的局限性\" class=\"headerlink\" title=\"传统哈希算法的局限性\"></a>传统哈希算法的局限性</h2><p>在分布式系统中，通常使用多个节点来保存数据，以提高并发能力和容量，那么如果决定数据保存到哪个节点上呢？一般的做法是通过一个哈希函数对数据key进行计算，然后对节点数量取模，从而得到数据分配的节点：<br><code>node_id = hash(key) % N</code><br>但是这种做法在节点数量N变化的时候，大部分key的计算的节点都会重新分配。如果是应用在分布式缓存，就会导致大规模的缓存失效，引起缓存雪崩。</p>\n<h2 id=\"一致性哈希算法\"><a href=\"#一致性哈希算法\" class=\"headerlink\" title=\"一致性哈希算法\"></a>一致性哈希算法</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>一致性哈希算法将哈希空间分配到哈希环的数据结构上，取值范围0~2^32-1，并且起点与终点相连。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-3d4ac4aed2d0295d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-3d4ac4aed2d0295d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<ol>\n<li>将服务器通过哈希函数（以IP或者主机名作为key）放置到环上</li>\n<li>对数据key使用相同的哈希函数，落到哈希空间上的某个点，如果该点不是服务器节点的位置，则顺时针向前寻找，直到碰到第一个服务器节点，将数据分配到该节点。</li>\n</ol>\n<h4 id=\"新增节点\"><a href=\"#新增节点\" class=\"headerlink\" title=\"新增节点\"></a>新增节点</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-889a824feb485b6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-889a824feb485b6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>新增了节点S4，那么影响的只是哈希空间S3到S4之间的数据，如原来key4是分配到节点S1，现在分配到了S4。</p>\n<h4 id=\"下线节点\"><a href=\"#下线节点\" class=\"headerlink\" title=\"下线节点\"></a>下线节点</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-de338ef1527c2666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-de338ef1527c2666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>节点S2下线，只影响哈希空间S1到S2之间的数据，如原来key2分配到了S2，现在分配到了S3。</p>\n<h3 id=\"虚拟节点优化\"><a href=\"#虚拟节点优化\" class=\"headerlink\" title=\"虚拟节点优化\"></a>虚拟节点优化</h3><p>当服务节点比较少的时候会出现分配不平衡的问题，造成大量数据集中到一个节点上，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-9197f7ebe16f828a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-9197f7ebe16f828a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>大部分的哈希空间都会分配到S1上，少量分配到S2上。<br>为了解决这种数据倾斜问题，一致性哈希引入了虚拟节点机制：对每一个服务器节点计算多个哈希，每个计算结果都防止一个此服务器对应的虚拟节点。具体做法可以在服务器IP后面加上编号再计算哈希值。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-01a834f729aa04c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-01a834f729aa04c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>如上图所示，对S1和S2分别虚拟出两个节点，形成四个虚拟节点，数据分配方式不变，不过多了先顺时针找到服务器的虚拟节点，再映射到对应的物理服务器节点。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>良好的伸缩性。一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，比传统的哈希算法大大节省了数据移动的开销。</li>\n<li>更好的适应数据增长。当数据不断增长，部分虚拟节点可能包含很多数据，造成数据分配不平衡，此时可以将包含数据多的虚拟节点分裂，这种分裂仅仅是将原有的虚拟节点一分为二，不需要对全部数据重新哈希划分。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】 <a href=\"https://segmentfault.com/a/1190000021199728\">图解一致性哈希算法</a><br>【2】<a href=\"https://zhuanlan.zhihu.com/p/98030096\">一致性Hash算法详解</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"传统哈希算法的局限性\"><a href=\"#传统哈希算法的局限性\" class=\"headerlink\" title=\"传统哈希算法的局限性\"></a>传统哈希算法的局限性</h2><p>在分布式系统中，通常使用多个节点来保存数据，以提高并发能力和容量，那么如果决定数据保存到哪个节点上呢？一般的做法是通过一个哈希函数对数据key进行计算，然后对节点数量取模，从而得到数据分配的节点：<br><code>node_id = hash(key) % N</code><br>但是这种做法在节点数量N变化的时候，大部分key的计算的节点都会重新分配。如果是应用在分布式缓存，就会导致大规模的缓存失效，引起缓存雪崩。</p>\n<h2 id=\"一致性哈希算法\"><a href=\"#一致性哈希算法\" class=\"headerlink\" title=\"一致性哈希算法\"></a>一致性哈希算法</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>一致性哈希算法将哈希空间分配到哈希环的数据结构上，取值范围0~2^32-1，并且起点与终点相连。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-3d4ac4aed2d0295d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<ol>\n<li>将服务器通过哈希函数（以IP或者主机名作为key）放置到环上</li>\n<li>对数据key使用相同的哈希函数，落到哈希空间上的某个点，如果该点不是服务器节点的位置，则顺时针向前寻找，直到碰到第一个服务器节点，将数据分配到该节点。</li>\n</ol>\n<h4 id=\"新增节点\"><a href=\"#新增节点\" class=\"headerlink\" title=\"新增节点\"></a>新增节点</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-889a824feb485b6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>新增了节点S4，那么影响的只是哈希空间S3到S4之间的数据，如原来key4是分配到节点S1，现在分配到了S4。</p>\n<h4 id=\"下线节点\"><a href=\"#下线节点\" class=\"headerlink\" title=\"下线节点\"></a>下线节点</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-de338ef1527c2666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>节点S2下线，只影响哈希空间S1到S2之间的数据，如原来key2分配到了S2，现在分配到了S3。</p>\n<h3 id=\"虚拟节点优化\"><a href=\"#虚拟节点优化\" class=\"headerlink\" title=\"虚拟节点优化\"></a>虚拟节点优化</h3><p>当服务节点比较少的时候会出现分配不平衡的问题，造成大量数据集中到一个节点上，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-9197f7ebe16f828a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>大部分的哈希空间都会分配到S1上，少量分配到S2上。<br>为了解决这种数据倾斜问题，一致性哈希引入了虚拟节点机制：对每一个服务器节点计算多个哈希，每个计算结果都防止一个此服务器对应的虚拟节点。具体做法可以在服务器IP后面加上编号再计算哈希值。<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-01a834f729aa04c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>如上图所示，对S1和S2分别虚拟出两个节点，形成四个虚拟节点，数据分配方式不变，不过多了先顺时针找到服务器的虚拟节点，再映射到对应的物理服务器节点。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>良好的伸缩性。一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，比传统的哈希算法大大节省了数据移动的开销。</li>\n<li>更好的适应数据增长。当数据不断增长，部分虚拟节点可能包含很多数据，造成数据分配不平衡，此时可以将包含数据多的虚拟节点分裂，这种分裂仅仅是将原有的虚拟节点一分为二，不需要对全部数据重新哈希划分。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】 <a href=\"https://segmentfault.com/a/1190000021199728\">图解一致性哈希算法</a><br>【2】<a href=\"https://zhuanlan.zhihu.com/p/98030096\">一致性Hash算法详解</a></p>\n"},{"title":"什么是WebSocket？","date":"2023-03-25T06:42:47.000Z","_content":"\n## 基本概念\nWebSocket是一种网络通信协议，是HTML5新增的特性，实现了基于浏览器的远程socket，使浏览器和服务器可以进行全双工通信，大部分浏览器都对此做了支持。\nWebSocket的URL格式形如：ws://localhost:80/、wss://localhost:443/\n\n## 为什么有了HTTP协议还要WebSocket\nHTTP协议采用的是客户端（浏览器）轮询的方式，即客户端发送请求，服务端做出响应，为了获取最新的数据，需要不断的轮询发出HTTP请求，占用大量带宽。\nWebSocket采用了一些特殊的报头，使得浏览器和服务器只需要通过“握手”建立一条连接通道后，此链接保持活跃状态，之后的客户端和服务器的通信都使用这个连接，解决了Web实时性的问题，相比于HTTP有一下好处：\n- 一个Web客户端只建立一个TCP连接\n- WebSocket服务端可以主动推送（push）数据到Web客户端\n- 有更加轻量级的头，减少了数据传输量\n\n## WebSocket原理\n![](https://upload-images.jianshu.io/upload_images/14151453-83f761a12847fa76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 建立连接\nWebSocket建立连接必须由浏览器发起，是一个标准的HTTP请求，如下图所示\n![](https://upload-images.jianshu.io/upload_images/14151453-0f3bd32d35e06362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 请求\n1. 请求地址以`ws://`开头\n2. 请求头`Upgrade: websocket`和`Connection:Upgrade`表示要将这个连接转换为WebSocket连接\n3. `Sec-WebSocket-Key`用于标识连接，是一个base64编码的字符串\n4. `Sec-WebSocket-Version`指定了WebSocket协议版本\n\n#### 响应\n1. 响应状态码`101`表示本次连接的HTTP协议将被更改\n2. `Upgrade: websocket`表示更改后的协议是WebSocket\n3. `Sec-WebSocket-Accept`通过如下方式计算：\n- 对请求头的`Sec-WebSocket-Key`字符串加上一个固定的字符串，例如：\n`H+VLjR1wb4JQ62TmabK87g==258EAFA5-E914-47DA-95CA-C5AB0DC85B11`\n- 然后对该字符串用sha1算法散列出二进制值，再对其进行base64加密，例如：\n`ccJoRDcGOFzCVrIwpX/qF3BoIN0=`\n\n### 数据格式\nWebSocket的协议比较简单，在第一次handshake通过之后，连接建立成功，之后的通讯数据都是以\"\\x00\"开头，以\"\\xFF\"结尾，对客户端来说这个是透明的，WebSocket的实现组件会对原始数据掐头去尾。\n\n### 特点\n1. 建立在TCP协议只上，服务端比较容易实现\n2. 于HTTP协议有良好的兼容性，默认端口也是80和443，握手阶段使用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器\n3. 数据格式轻量，通信高效且节省带宽\n4. 支持传输文本数据和二进制数据\n5. 没有同源限制，客户端可以与任意服务器通信\n6. 也支持加密传输，WS+SSL，URL形如`wss://`\n\n## Go语言实现\ngo的标准SDK中没有支持WebSocket，但是官方维护的net子包中支持\n`go get golang.org/x/net/websocket`\n### 客户端\n```html\n<!DOCTYPE html>\n<html>\n<head></head>\n<body>\n<script type=\"text/javascript\">\n    var sock = null;\n    var wsuri = \"ws://127.0.0.1:7777\";\n\n    window.onload = function() {\n\n        console.log(\"onload\");\n\n        sock = new WebSocket(wsuri);\n\n        sock.onopen = function() {\n            console.log(\"connected to \" + wsuri);\n        }\n\n        sock.onclose = function(e) {\n            console.log(\"connection closed (\" + e.code + \")\");\n        }\n\n        sock.onmessage = function(e) {\n            console.log(\"message received: \" + e.data);\n        }\n    };\n\n    function send() {\n        var msg = document.getElementById('message').value;\n        sock.send(msg);\n    };\n</script>\n<h1>WebSocket Echo Test</h1>\n<form>\n    <p>\n        Message: <input id=\"message\" type=\"text\" value=\"Hello, world!\">\n    </p>\n</form>\n<button onclick=\"send();\">Send Message</button>\n</body>\n</html>\n```\n客户端JavaScript代码，通过`new WebSocket(wsuri)`创建了一个WebSocket连接，握手成功后会触发onopen事件，客户端绑定了四个事件：\n- onopen：建立连接后触发\n- onmessage：收到消息后触发\n- onerror：发生错误时触发\n- onclose：关闭连接时触发\n\n### 服务端\n```go\npackage main\n\nimport (\n\t\"golang.org/x/net/websocket\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc handleEcho(ws *websocket.Conn) {\n\tvar err error\n\n\tfor {\n\t\tvar reply string\n\n\t\tif err = websocket.Message.Receive(ws, &reply); err != nil {\n\t\t\tlog.Println(\"[server] Can't receive\")\n\t\t\tbreak\n\t\t}\n\t\tlog.Println(\"[server] Received from client:\", reply)\n\n\t\tmsg := \"welcome: \" + reply\n\t\tif err = websocket.Message.Send(ws, msg); err != nil {\n\t\t\tlog.Println(\"[server] Can't Send\")\n\t\t\tbreak\n\t\t}\n\t\tlog.Println(\"[server] Send to client:\", msg)\n\t}\n}\n\nfunc main() {\n\thttp.Handle(\"/\", websocket.Handler(handleEcho))\n\tlog.Println(\"[server] listen in 127.0.0.1:7777\")\n\tif err := http.ListenAndServe(\":7777\", nil); err != nil {\n\t\tlog.Fatal(\"[server] ListenAndServe:\", err)\n\t}\n}\n\n```\n运行后在客户端页面点击Send Message按钮，可以看到服务端如下响应：\n![](https://upload-images.jianshu.io/upload_images/14151453-e2ef3c1cb34f117d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 参考资料\n【1】[build-web-application-with-golang](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.2.md)\n【2】[廖雪峰：WebSocket](https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096)\n【3】[阮一峰：WebSocket教程](https://www.ruanyifeng.com/blog/2017/05/websocket.html)\n","source":"_posts/2023/03-25-什么是WebSocket？.md","raw":"---\ntitle: 什么是WebSocket？\ndate: 2023-03-25 14:42:47\ncategories:\n- [计算机网络]\ntags:\n- \"WebSocket\"\n---\n\n## 基本概念\nWebSocket是一种网络通信协议，是HTML5新增的特性，实现了基于浏览器的远程socket，使浏览器和服务器可以进行全双工通信，大部分浏览器都对此做了支持。\nWebSocket的URL格式形如：ws://localhost:80/、wss://localhost:443/\n\n## 为什么有了HTTP协议还要WebSocket\nHTTP协议采用的是客户端（浏览器）轮询的方式，即客户端发送请求，服务端做出响应，为了获取最新的数据，需要不断的轮询发出HTTP请求，占用大量带宽。\nWebSocket采用了一些特殊的报头，使得浏览器和服务器只需要通过“握手”建立一条连接通道后，此链接保持活跃状态，之后的客户端和服务器的通信都使用这个连接，解决了Web实时性的问题，相比于HTTP有一下好处：\n- 一个Web客户端只建立一个TCP连接\n- WebSocket服务端可以主动推送（push）数据到Web客户端\n- 有更加轻量级的头，减少了数据传输量\n\n## WebSocket原理\n![](https://upload-images.jianshu.io/upload_images/14151453-83f761a12847fa76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 建立连接\nWebSocket建立连接必须由浏览器发起，是一个标准的HTTP请求，如下图所示\n![](https://upload-images.jianshu.io/upload_images/14151453-0f3bd32d35e06362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 请求\n1. 请求地址以`ws://`开头\n2. 请求头`Upgrade: websocket`和`Connection:Upgrade`表示要将这个连接转换为WebSocket连接\n3. `Sec-WebSocket-Key`用于标识连接，是一个base64编码的字符串\n4. `Sec-WebSocket-Version`指定了WebSocket协议版本\n\n#### 响应\n1. 响应状态码`101`表示本次连接的HTTP协议将被更改\n2. `Upgrade: websocket`表示更改后的协议是WebSocket\n3. `Sec-WebSocket-Accept`通过如下方式计算：\n- 对请求头的`Sec-WebSocket-Key`字符串加上一个固定的字符串，例如：\n`H+VLjR1wb4JQ62TmabK87g==258EAFA5-E914-47DA-95CA-C5AB0DC85B11`\n- 然后对该字符串用sha1算法散列出二进制值，再对其进行base64加密，例如：\n`ccJoRDcGOFzCVrIwpX/qF3BoIN0=`\n\n### 数据格式\nWebSocket的协议比较简单，在第一次handshake通过之后，连接建立成功，之后的通讯数据都是以\"\\x00\"开头，以\"\\xFF\"结尾，对客户端来说这个是透明的，WebSocket的实现组件会对原始数据掐头去尾。\n\n### 特点\n1. 建立在TCP协议只上，服务端比较容易实现\n2. 于HTTP协议有良好的兼容性，默认端口也是80和443，握手阶段使用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器\n3. 数据格式轻量，通信高效且节省带宽\n4. 支持传输文本数据和二进制数据\n5. 没有同源限制，客户端可以与任意服务器通信\n6. 也支持加密传输，WS+SSL，URL形如`wss://`\n\n## Go语言实现\ngo的标准SDK中没有支持WebSocket，但是官方维护的net子包中支持\n`go get golang.org/x/net/websocket`\n### 客户端\n```html\n<!DOCTYPE html>\n<html>\n<head></head>\n<body>\n<script type=\"text/javascript\">\n    var sock = null;\n    var wsuri = \"ws://127.0.0.1:7777\";\n\n    window.onload = function() {\n\n        console.log(\"onload\");\n\n        sock = new WebSocket(wsuri);\n\n        sock.onopen = function() {\n            console.log(\"connected to \" + wsuri);\n        }\n\n        sock.onclose = function(e) {\n            console.log(\"connection closed (\" + e.code + \")\");\n        }\n\n        sock.onmessage = function(e) {\n            console.log(\"message received: \" + e.data);\n        }\n    };\n\n    function send() {\n        var msg = document.getElementById('message').value;\n        sock.send(msg);\n    };\n</script>\n<h1>WebSocket Echo Test</h1>\n<form>\n    <p>\n        Message: <input id=\"message\" type=\"text\" value=\"Hello, world!\">\n    </p>\n</form>\n<button onclick=\"send();\">Send Message</button>\n</body>\n</html>\n```\n客户端JavaScript代码，通过`new WebSocket(wsuri)`创建了一个WebSocket连接，握手成功后会触发onopen事件，客户端绑定了四个事件：\n- onopen：建立连接后触发\n- onmessage：收到消息后触发\n- onerror：发生错误时触发\n- onclose：关闭连接时触发\n\n### 服务端\n```go\npackage main\n\nimport (\n\t\"golang.org/x/net/websocket\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc handleEcho(ws *websocket.Conn) {\n\tvar err error\n\n\tfor {\n\t\tvar reply string\n\n\t\tif err = websocket.Message.Receive(ws, &reply); err != nil {\n\t\t\tlog.Println(\"[server] Can't receive\")\n\t\t\tbreak\n\t\t}\n\t\tlog.Println(\"[server] Received from client:\", reply)\n\n\t\tmsg := \"welcome: \" + reply\n\t\tif err = websocket.Message.Send(ws, msg); err != nil {\n\t\t\tlog.Println(\"[server] Can't Send\")\n\t\t\tbreak\n\t\t}\n\t\tlog.Println(\"[server] Send to client:\", msg)\n\t}\n}\n\nfunc main() {\n\thttp.Handle(\"/\", websocket.Handler(handleEcho))\n\tlog.Println(\"[server] listen in 127.0.0.1:7777\")\n\tif err := http.ListenAndServe(\":7777\", nil); err != nil {\n\t\tlog.Fatal(\"[server] ListenAndServe:\", err)\n\t}\n}\n\n```\n运行后在客户端页面点击Send Message按钮，可以看到服务端如下响应：\n![](https://upload-images.jianshu.io/upload_images/14151453-e2ef3c1cb34f117d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 参考资料\n【1】[build-web-application-with-golang](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.2.md)\n【2】[廖雪峰：WebSocket](https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096)\n【3】[阮一峰：WebSocket教程](https://www.ruanyifeng.com/blog/2017/05/websocket.html)\n","slug":"什么是WebSocket？","published":1,"updated":"2023-03-25T06:58:29.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywv0025vhficq272x04","content":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>WebSocket是一种网络通信协议，是HTML5新增的特性，实现了基于浏览器的远程socket，使浏览器和服务器可以进行全双工通信，大部分浏览器都对此做了支持。<br>WebSocket的URL格式形如：ws:&#x2F;&#x2F;localhost:80&#x2F;、wss:&#x2F;&#x2F;localhost:443&#x2F;</p>\n<h2 id=\"为什么有了HTTP协议还要WebSocket\"><a href=\"#为什么有了HTTP协议还要WebSocket\" class=\"headerlink\" title=\"为什么有了HTTP协议还要WebSocket\"></a>为什么有了HTTP协议还要WebSocket</h2><p>HTTP协议采用的是客户端（浏览器）轮询的方式，即客户端发送请求，服务端做出响应，为了获取最新的数据，需要不断的轮询发出HTTP请求，占用大量带宽。<br>WebSocket采用了一些特殊的报头，使得浏览器和服务器只需要通过“握手”建立一条连接通道后，此链接保持活跃状态，之后的客户端和服务器的通信都使用这个连接，解决了Web实时性的问题，相比于HTTP有一下好处：</p>\n<ul>\n<li>一个Web客户端只建立一个TCP连接</li>\n<li>WebSocket服务端可以主动推送（push）数据到Web客户端</li>\n<li>有更加轻量级的头，减少了数据传输量</li>\n</ul>\n<h2 id=\"WebSocket原理\"><a href=\"#WebSocket原理\" class=\"headerlink\" title=\"WebSocket原理\"></a>WebSocket原理</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-83f761a12847fa76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-83f761a12847fa76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h3 id=\"建立连接\"><a href=\"#建立连接\" class=\"headerlink\" title=\"建立连接\"></a>建立连接</h3><p>WebSocket建立连接必须由浏览器发起，是一个标准的HTTP请求，如下图所示<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-0f3bd32d35e06362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-0f3bd32d35e06362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h4 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h4><ol>\n<li>请求地址以<code>ws://</code>开头</li>\n<li>请求头<code>Upgrade: websocket</code>和<code>Connection:Upgrade</code>表示要将这个连接转换为WebSocket连接</li>\n<li><code>Sec-WebSocket-Key</code>用于标识连接，是一个base64编码的字符串</li>\n<li><code>Sec-WebSocket-Version</code>指定了WebSocket协议版本</li>\n</ol>\n<h4 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h4><ol>\n<li>响应状态码<code>101</code>表示本次连接的HTTP协议将被更改</li>\n<li><code>Upgrade: websocket</code>表示更改后的协议是WebSocket</li>\n<li><code>Sec-WebSocket-Accept</code>通过如下方式计算：</li>\n</ol>\n<ul>\n<li>对请求头的<code>Sec-WebSocket-Key</code>字符串加上一个固定的字符串，例如：<br><code>H+VLjR1wb4JQ62TmabK87g==258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code></li>\n<li>然后对该字符串用sha1算法散列出二进制值，再对其进行base64加密，例如：<br><code>ccJoRDcGOFzCVrIwpX/qF3BoIN0=</code></li>\n</ul>\n<h3 id=\"数据格式\"><a href=\"#数据格式\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h3><p>WebSocket的协议比较简单，在第一次handshake通过之后，连接建立成功，之后的通讯数据都是以”\\x00”开头，以”\\xFF”结尾，对客户端来说这个是透明的，WebSocket的实现组件会对原始数据掐头去尾。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>建立在TCP协议只上，服务端比较容易实现</li>\n<li>于HTTP协议有良好的兼容性，默认端口也是80和443，握手阶段使用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器</li>\n<li>数据格式轻量，通信高效且节省带宽</li>\n<li>支持传输文本数据和二进制数据</li>\n<li>没有同源限制，客户端可以与任意服务器通信</li>\n<li>也支持加密传输，WS+SSL，URL形如<code>wss://</code></li>\n</ol>\n<h2 id=\"Go语言实现\"><a href=\"#Go语言实现\" class=\"headerlink\" title=\"Go语言实现\"></a>Go语言实现</h2><p>go的标准SDK中没有支持WebSocket，但是官方维护的net子包中支持<br><code>go get golang.org/x/net/websocket</code></p>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> sock = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> wsuri = <span class=\"string\">&quot;ws://127.0.0.1:7777&quot;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">window</span>.<span class=\"property\">onload</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;onload&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock = <span class=\"keyword\">new</span> <span class=\"title class_\">WebSocket</span>(wsuri);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"property\">onopen</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;connected to &quot;</span> + wsuri);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"property\">onclose</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;connection closed (&quot;</span> + e.<span class=\"property\">code</span> + <span class=\"string\">&quot;)&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"property\">onmessage</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;message received: &quot;</span> + e.<span class=\"property\">data</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">function</span> <span class=\"title function_\">send</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">var</span> msg = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;message&#x27;</span>).<span class=\"property\">value</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"title function_\">send</span>(msg);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>WebSocket Echo Test<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        Message: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;message&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Hello, world!&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;send();&quot;</span>&gt;</span>Send Message<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>客户端JavaScript代码，通过<code>new WebSocket(wsuri)</code>创建了一个WebSocket连接，握手成功后会触发onopen事件，客户端绑定了四个事件：</p>\n<ul>\n<li>onopen：建立连接后触发</li>\n<li>onmessage：收到消息后触发</li>\n<li>onerror：发生错误时触发</li>\n<li>onclose：关闭连接时触发</li>\n</ul>\n<h3 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;golang.org/x/net/websocket&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleEcho</span><span class=\"params\">(ws *websocket.Conn)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> reply <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err = websocket.Message.Receive(ws, &amp;reply); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[server] Can&#x27;t receive&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlog.Println(<span class=\"string\">&quot;[server] Received from client:&quot;</span>, reply)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmsg := <span class=\"string\">&quot;welcome: &quot;</span> + reply</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err = websocket.Message.Send(ws, msg); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[server] Can&#x27;t Send&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlog.Println(<span class=\"string\">&quot;[server] Send to client:&quot;</span>, msg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.Handle(<span class=\"string\">&quot;/&quot;</span>, websocket.Handler(handleEcho))</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;[server] listen in 127.0.0.1:7777&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := http.ListenAndServe(<span class=\"string\">&quot;:7777&quot;</span>, <span class=\"literal\">nil</span>); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(<span class=\"string\">&quot;[server] ListenAndServe:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行后在客户端页面点击Send Message按钮，可以看到服务端如下响应：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-e2ef3c1cb34f117d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-e2ef3c1cb34f117d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>【1】<a href=\"https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.2.md\">build-web-application-with-golang</a><br>【2】<a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096\">廖雪峰：WebSocket</a><br>【3】<a href=\"https://www.ruanyifeng.com/blog/2017/05/websocket.html\">阮一峰：WebSocket教程</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>WebSocket是一种网络通信协议，是HTML5新增的特性，实现了基于浏览器的远程socket，使浏览器和服务器可以进行全双工通信，大部分浏览器都对此做了支持。<br>WebSocket的URL格式形如：ws:&#x2F;&#x2F;localhost:80&#x2F;、wss:&#x2F;&#x2F;localhost:443&#x2F;</p>\n<h2 id=\"为什么有了HTTP协议还要WebSocket\"><a href=\"#为什么有了HTTP协议还要WebSocket\" class=\"headerlink\" title=\"为什么有了HTTP协议还要WebSocket\"></a>为什么有了HTTP协议还要WebSocket</h2><p>HTTP协议采用的是客户端（浏览器）轮询的方式，即客户端发送请求，服务端做出响应，为了获取最新的数据，需要不断的轮询发出HTTP请求，占用大量带宽。<br>WebSocket采用了一些特殊的报头，使得浏览器和服务器只需要通过“握手”建立一条连接通道后，此链接保持活跃状态，之后的客户端和服务器的通信都使用这个连接，解决了Web实时性的问题，相比于HTTP有一下好处：</p>\n<ul>\n<li>一个Web客户端只建立一个TCP连接</li>\n<li>WebSocket服务端可以主动推送（push）数据到Web客户端</li>\n<li>有更加轻量级的头，减少了数据传输量</li>\n</ul>\n<h2 id=\"WebSocket原理\"><a href=\"#WebSocket原理\" class=\"headerlink\" title=\"WebSocket原理\"></a>WebSocket原理</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-83f761a12847fa76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h3 id=\"建立连接\"><a href=\"#建立连接\" class=\"headerlink\" title=\"建立连接\"></a>建立连接</h3><p>WebSocket建立连接必须由浏览器发起，是一个标准的HTTP请求，如下图所示<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-0f3bd32d35e06362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h4 id=\"请求\"><a href=\"#请求\" class=\"headerlink\" title=\"请求\"></a>请求</h4><ol>\n<li>请求地址以<code>ws://</code>开头</li>\n<li>请求头<code>Upgrade: websocket</code>和<code>Connection:Upgrade</code>表示要将这个连接转换为WebSocket连接</li>\n<li><code>Sec-WebSocket-Key</code>用于标识连接，是一个base64编码的字符串</li>\n<li><code>Sec-WebSocket-Version</code>指定了WebSocket协议版本</li>\n</ol>\n<h4 id=\"响应\"><a href=\"#响应\" class=\"headerlink\" title=\"响应\"></a>响应</h4><ol>\n<li>响应状态码<code>101</code>表示本次连接的HTTP协议将被更改</li>\n<li><code>Upgrade: websocket</code>表示更改后的协议是WebSocket</li>\n<li><code>Sec-WebSocket-Accept</code>通过如下方式计算：</li>\n</ol>\n<ul>\n<li>对请求头的<code>Sec-WebSocket-Key</code>字符串加上一个固定的字符串，例如：<br><code>H+VLjR1wb4JQ62TmabK87g==258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code></li>\n<li>然后对该字符串用sha1算法散列出二进制值，再对其进行base64加密，例如：<br><code>ccJoRDcGOFzCVrIwpX/qF3BoIN0=</code></li>\n</ul>\n<h3 id=\"数据格式\"><a href=\"#数据格式\" class=\"headerlink\" title=\"数据格式\"></a>数据格式</h3><p>WebSocket的协议比较简单，在第一次handshake通过之后，连接建立成功，之后的通讯数据都是以”\\x00”开头，以”\\xFF”结尾，对客户端来说这个是透明的，WebSocket的实现组件会对原始数据掐头去尾。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>建立在TCP协议只上，服务端比较容易实现</li>\n<li>于HTTP协议有良好的兼容性，默认端口也是80和443，握手阶段使用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器</li>\n<li>数据格式轻量，通信高效且节省带宽</li>\n<li>支持传输文本数据和二进制数据</li>\n<li>没有同源限制，客户端可以与任意服务器通信</li>\n<li>也支持加密传输，WS+SSL，URL形如<code>wss://</code></li>\n</ol>\n<h2 id=\"Go语言实现\"><a href=\"#Go语言实现\" class=\"headerlink\" title=\"Go语言实现\"></a>Go语言实现</h2><p>go的标准SDK中没有支持WebSocket，但是官方维护的net子包中支持<br><code>go get golang.org/x/net/websocket</code></p>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> sock = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> wsuri = <span class=\"string\">&quot;ws://127.0.0.1:7777&quot;</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">window</span>.<span class=\"property\">onload</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;onload&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock = <span class=\"keyword\">new</span> <span class=\"title class_\">WebSocket</span>(wsuri);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"property\">onopen</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;connected to &quot;</span> + wsuri);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"property\">onclose</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;connection closed (&quot;</span> + e.<span class=\"property\">code</span> + <span class=\"string\">&quot;)&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"property\">onmessage</span> = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;message received: &quot;</span> + e.<span class=\"property\">data</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">function</span> <span class=\"title function_\">send</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">var</span> msg = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;message&#x27;</span>).<span class=\"property\">value</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        sock.<span class=\"title function_\">send</span>(msg);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>WebSocket Echo Test<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        Message: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;message&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Hello, world!&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;send();&quot;</span>&gt;</span>Send Message<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>客户端JavaScript代码，通过<code>new WebSocket(wsuri)</code>创建了一个WebSocket连接，握手成功后会触发onopen事件，客户端绑定了四个事件：</p>\n<ul>\n<li>onopen：建立连接后触发</li>\n<li>onmessage：收到消息后触发</li>\n<li>onerror：发生错误时触发</li>\n<li>onclose：关闭连接时触发</li>\n</ul>\n<h3 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;golang.org/x/net/websocket&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleEcho</span><span class=\"params\">(ws *websocket.Conn)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> reply <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err = websocket.Message.Receive(ws, &amp;reply); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[server] Can&#x27;t receive&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlog.Println(<span class=\"string\">&quot;[server] Received from client:&quot;</span>, reply)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmsg := <span class=\"string\">&quot;welcome: &quot;</span> + reply</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err = websocket.Message.Send(ws, msg); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[server] Can&#x27;t Send&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlog.Println(<span class=\"string\">&quot;[server] Send to client:&quot;</span>, msg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.Handle(<span class=\"string\">&quot;/&quot;</span>, websocket.Handler(handleEcho))</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;[server] listen in 127.0.0.1:7777&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := http.ListenAndServe(<span class=\"string\">&quot;:7777&quot;</span>, <span class=\"literal\">nil</span>); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(<span class=\"string\">&quot;[server] ListenAndServe:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>运行后在客户端页面点击Send Message按钮，可以看到服务端如下响应：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-e2ef3c1cb34f117d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p>【1】<a href=\"https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.2.md\">build-web-application-with-golang</a><br>【2】<a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096\">廖雪峰：WebSocket</a><br>【3】<a href=\"https://www.ruanyifeng.com/blog/2017/05/websocket.html\">阮一峰：WebSocket教程</a></p>\n"},{"title":"从五个问题出发认识消息队列","date":"2023-03-25T07:23:17.000Z","_content":"# 消息队列\n消息队列是分布式系统的一个重要组件，从五个问题来初步认识一下消息队列，基本原理是什么样的，如何正确的使用消息队列。\n- Q1: 为什么需要消息队列？\n- Q2: 如何保证消息不丢失？\n- Q3: 如何处理重复消息？\n- Q4: 如何保证消息有序性？\n- Q5: 如何处理消息堆积？\n\n## 为什么需要\n\n### 异步处理\n\n- 随着业务的增长，业务逻辑会不断加重，为了保持较快速的响应，可以在核心逻辑处理完后就返回，其他逻辑放到消息队列之后异步处理\n\n### 应用解耦\n\n- 业务模块增加，可以通过订阅核心服务的消息主题，不影响核心服务\n\n### 流量控制\n\n- 后端服务无法支撑大量的并发请求，请求先放到队列，后端服务尽最大的能力消费队列\n\n### 日志处理\n\n## 基本概念\n\n### 模型\n\n- 点对点（队列）模型\n\n\t- 同一个消息只能由一个消费者消费一次\n\n\t\t- Rabbit MQ\n\n- 发布/订阅模型\n\n\t- 订阅了某个主题的所有消费者都可以消费该主题的消息\n\n\t\t- Rocket MQ、Kafka\n\n### 各个组件术语（Kafka）\n\n- 生产者（Producer）\n- 消息队列服务器（Broker）\n\n\t- 主服务器（Leader）\n\t- 从服务器（Follower）\n\t- 主题（Topic）\n\n\t\t- 分区（Partition）\n\n- 消费者组（Consumer Group）\n\n\t- 消费者（Consumer）\n\n### 工作流程\n\n- 生产消息（发送数据）\n\n\t- 1. 从Kafka Cluster获取分区的Leader，Producer将消息发送给Leader\n\t- 2. Leader将消息写入本地文件（此时可以直接到步骤3）\n\n\t\t- 2.1. Followers从Leader pull消息并写入本地后向Leader发送ACK确认\n\n\t- 3. Leader向Producer响应ACK\n\n- 存储数据\n\n\t- 单独开辟一块磁盘，顺序写入\n\t- 每个分区相当于一个文件目录\n\n\t\t- Partition/Segment\n\n\t\t\t- .index\n\t\t\t- .log\n\t\t\t- .timeindex\n\n- 消费消息（接收数据）\n\n\t- 1. Consumer也是从Leader中拉取数据\n\t- 2. 一个消费者组内的某个消费者可以消费一个Topic的不同分区，单同一个组内的不同消费者不能同时消费某个Topic的同一个分区，一个组的消费者数量最好和分区数相同\n\n### 分区的好处\n\n- 方便扩展\n- 提高并发\n\n## 实际问题\n\n### 如何保证消息队列不丢失？\n\n- 1. 生产消息阶段\n\n\t- 正确处理Broker的响应，做重试机制\n\n- 2. 数据存储阶段\n\n\t- 数据落盘再响应成功，有多个副本时可以等多副本都落盘再响应成功\n\n- 3. 消费消息阶段\n\n\t- 业务逻辑处理完再确认消息\n\n- 确保了可靠性的同时会影响性能，根据业务选择合适的方式\n\n### 如何处理重复消息？\n\n- 为了保证消息不丢失，消息重复是不可避免的\n- 业务逻辑幂等性\n\n\t- 增加version版本号做控制\n\t- 数据库唯一索引\n\n### 如何保证消息有序？\n\n- 全局有序\n\n\t- 一个生产者、一个分区、一个消费者\n\n- 部分有序\n\n\t- 消息按特定规则分配到不同的分区，分区本身是有序的，每个分区由一个消费者消费\n\n### 如何处理消息堆积？\n\n- 1. 定位问题，如果是bug引起，修改bug（实际生产场景如果由于发版导致，先回滚再定位原因）\n- 2. 如果不是bug，看能不能优化消费逻辑\n- 3. 如果不能优化，就要横向扩容，同时增加分区数和消费者数量\n\n[参考文章1 微信公众号文章](https://mp.weixin.qq.com/s/u6_WH-r1bRc4m7CUm21Tew)\n[参考文章2 知乎](https://zhuanlan.zhihu.com/p/68052232)\n","source":"_posts/2023/03-25-从五个问题出发认识消息队列.md","raw":"---\ntitle: 从五个问题出发认识消息队列\ndate: 2023-03-25 15:23:17\ncategories:\n- [分布式系统]\ntags:\n- 消息队列\n- MQ\n- RabbitMQ\n- RocketMQ\n- Kafka\n---\n# 消息队列\n消息队列是分布式系统的一个重要组件，从五个问题来初步认识一下消息队列，基本原理是什么样的，如何正确的使用消息队列。\n- Q1: 为什么需要消息队列？\n- Q2: 如何保证消息不丢失？\n- Q3: 如何处理重复消息？\n- Q4: 如何保证消息有序性？\n- Q5: 如何处理消息堆积？\n\n## 为什么需要\n\n### 异步处理\n\n- 随着业务的增长，业务逻辑会不断加重，为了保持较快速的响应，可以在核心逻辑处理完后就返回，其他逻辑放到消息队列之后异步处理\n\n### 应用解耦\n\n- 业务模块增加，可以通过订阅核心服务的消息主题，不影响核心服务\n\n### 流量控制\n\n- 后端服务无法支撑大量的并发请求，请求先放到队列，后端服务尽最大的能力消费队列\n\n### 日志处理\n\n## 基本概念\n\n### 模型\n\n- 点对点（队列）模型\n\n\t- 同一个消息只能由一个消费者消费一次\n\n\t\t- Rabbit MQ\n\n- 发布/订阅模型\n\n\t- 订阅了某个主题的所有消费者都可以消费该主题的消息\n\n\t\t- Rocket MQ、Kafka\n\n### 各个组件术语（Kafka）\n\n- 生产者（Producer）\n- 消息队列服务器（Broker）\n\n\t- 主服务器（Leader）\n\t- 从服务器（Follower）\n\t- 主题（Topic）\n\n\t\t- 分区（Partition）\n\n- 消费者组（Consumer Group）\n\n\t- 消费者（Consumer）\n\n### 工作流程\n\n- 生产消息（发送数据）\n\n\t- 1. 从Kafka Cluster获取分区的Leader，Producer将消息发送给Leader\n\t- 2. Leader将消息写入本地文件（此时可以直接到步骤3）\n\n\t\t- 2.1. Followers从Leader pull消息并写入本地后向Leader发送ACK确认\n\n\t- 3. Leader向Producer响应ACK\n\n- 存储数据\n\n\t- 单独开辟一块磁盘，顺序写入\n\t- 每个分区相当于一个文件目录\n\n\t\t- Partition/Segment\n\n\t\t\t- .index\n\t\t\t- .log\n\t\t\t- .timeindex\n\n- 消费消息（接收数据）\n\n\t- 1. Consumer也是从Leader中拉取数据\n\t- 2. 一个消费者组内的某个消费者可以消费一个Topic的不同分区，单同一个组内的不同消费者不能同时消费某个Topic的同一个分区，一个组的消费者数量最好和分区数相同\n\n### 分区的好处\n\n- 方便扩展\n- 提高并发\n\n## 实际问题\n\n### 如何保证消息队列不丢失？\n\n- 1. 生产消息阶段\n\n\t- 正确处理Broker的响应，做重试机制\n\n- 2. 数据存储阶段\n\n\t- 数据落盘再响应成功，有多个副本时可以等多副本都落盘再响应成功\n\n- 3. 消费消息阶段\n\n\t- 业务逻辑处理完再确认消息\n\n- 确保了可靠性的同时会影响性能，根据业务选择合适的方式\n\n### 如何处理重复消息？\n\n- 为了保证消息不丢失，消息重复是不可避免的\n- 业务逻辑幂等性\n\n\t- 增加version版本号做控制\n\t- 数据库唯一索引\n\n### 如何保证消息有序？\n\n- 全局有序\n\n\t- 一个生产者、一个分区、一个消费者\n\n- 部分有序\n\n\t- 消息按特定规则分配到不同的分区，分区本身是有序的，每个分区由一个消费者消费\n\n### 如何处理消息堆积？\n\n- 1. 定位问题，如果是bug引起，修改bug（实际生产场景如果由于发版导致，先回滚再定位原因）\n- 2. 如果不是bug，看能不能优化消费逻辑\n- 3. 如果不能优化，就要横向扩容，同时增加分区数和消费者数量\n\n[参考文章1 微信公众号文章](https://mp.weixin.qq.com/s/u6_WH-r1bRc4m7CUm21Tew)\n[参考文章2 知乎](https://zhuanlan.zhihu.com/p/68052232)\n","slug":"从五个问题出发认识消息队列","published":1,"updated":"2023-03-25T07:28:04.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyww0029vhfi6avm4brp","content":"<h1 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h1><p>消息队列是分布式系统的一个重要组件，从五个问题来初步认识一下消息队列，基本原理是什么样的，如何正确的使用消息队列。</p>\n<ul>\n<li>Q1: 为什么需要消息队列？</li>\n<li>Q2: 如何保证消息不丢失？</li>\n<li>Q3: 如何处理重复消息？</li>\n<li>Q4: 如何保证消息有序性？</li>\n<li>Q5: 如何处理消息堆积？</li>\n</ul>\n<h2 id=\"为什么需要\"><a href=\"#为什么需要\" class=\"headerlink\" title=\"为什么需要\"></a>为什么需要</h2><h3 id=\"异步处理\"><a href=\"#异步处理\" class=\"headerlink\" title=\"异步处理\"></a>异步处理</h3><ul>\n<li>随着业务的增长，业务逻辑会不断加重，为了保持较快速的响应，可以在核心逻辑处理完后就返回，其他逻辑放到消息队列之后异步处理</li>\n</ul>\n<h3 id=\"应用解耦\"><a href=\"#应用解耦\" class=\"headerlink\" title=\"应用解耦\"></a>应用解耦</h3><ul>\n<li>业务模块增加，可以通过订阅核心服务的消息主题，不影响核心服务</li>\n</ul>\n<h3 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h3><ul>\n<li>后端服务无法支撑大量的并发请求，请求先放到队列，后端服务尽最大的能力消费队列</li>\n</ul>\n<h3 id=\"日志处理\"><a href=\"#日志处理\" class=\"headerlink\" title=\"日志处理\"></a>日志处理</h3><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h3><ul>\n<li><p>点对点（队列）模型</p>\n<ul>\n<li><p>同一个消息只能由一个消费者消费一次</p>\n<ul>\n<li>Rabbit MQ</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>发布&#x2F;订阅模型</p>\n<ul>\n<li><p>订阅了某个主题的所有消费者都可以消费该主题的消息</p>\n<ul>\n<li>Rocket MQ、Kafka</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"各个组件术语（Kafka）\"><a href=\"#各个组件术语（Kafka）\" class=\"headerlink\" title=\"各个组件术语（Kafka）\"></a>各个组件术语（Kafka）</h3><ul>\n<li><p>生产者（Producer）</p>\n</li>\n<li><p>消息队列服务器（Broker）</p>\n<ul>\n<li><p>主服务器（Leader）</p>\n</li>\n<li><p>从服务器（Follower）</p>\n</li>\n<li><p>主题（Topic）</p>\n<ul>\n<li>分区（Partition）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>消费者组（Consumer Group）</p>\n<ul>\n<li>消费者（Consumer）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h3><ul>\n<li><p>生产消息（发送数据）</p>\n<ul>\n<li><ol>\n<li>从Kafka Cluster获取分区的Leader，Producer将消息发送给Leader</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>Leader将消息写入本地文件（此时可以直接到步骤3）</li>\n</ol>\n<ul>\n<li>2.1. Followers从Leader pull消息并写入本地后向Leader发送ACK确认</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>Leader向Producer响应ACK</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>存储数据</p>\n<ul>\n<li><p>单独开辟一块磁盘，顺序写入</p>\n</li>\n<li><p>每个分区相当于一个文件目录</p>\n<ul>\n<li><p>Partition&#x2F;Segment</p>\n<ul>\n<li>.index</li>\n<li>.log</li>\n<li>.timeindex</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>消费消息（接收数据）</p>\n<ul>\n<li><ol>\n<li>Consumer也是从Leader中拉取数据</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>一个消费者组内的某个消费者可以消费一个Topic的不同分区，单同一个组内的不同消费者不能同时消费某个Topic的同一个分区，一个组的消费者数量最好和分区数相同</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分区的好处\"><a href=\"#分区的好处\" class=\"headerlink\" title=\"分区的好处\"></a>分区的好处</h3><ul>\n<li>方便扩展</li>\n<li>提高并发</li>\n</ul>\n<h2 id=\"实际问题\"><a href=\"#实际问题\" class=\"headerlink\" title=\"实际问题\"></a>实际问题</h2><h3 id=\"如何保证消息队列不丢失？\"><a href=\"#如何保证消息队列不丢失？\" class=\"headerlink\" title=\"如何保证消息队列不丢失？\"></a>如何保证消息队列不丢失？</h3><ul>\n<li><ol>\n<li>生产消息阶段</li>\n</ol>\n<ul>\n<li>正确处理Broker的响应，做重试机制</li>\n</ul>\n</li>\n<li><ol start=\"2\">\n<li>数据存储阶段</li>\n</ol>\n<ul>\n<li>数据落盘再响应成功，有多个副本时可以等多副本都落盘再响应成功</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>消费消息阶段</li>\n</ol>\n<ul>\n<li>业务逻辑处理完再确认消息</li>\n</ul>\n</li>\n<li><p>确保了可靠性的同时会影响性能，根据业务选择合适的方式</p>\n</li>\n</ul>\n<h3 id=\"如何处理重复消息？\"><a href=\"#如何处理重复消息？\" class=\"headerlink\" title=\"如何处理重复消息？\"></a>如何处理重复消息？</h3><ul>\n<li><p>为了保证消息不丢失，消息重复是不可避免的</p>\n</li>\n<li><p>业务逻辑幂等性</p>\n<ul>\n<li>增加version版本号做控制</li>\n<li>数据库唯一索引</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如何保证消息有序？\"><a href=\"#如何保证消息有序？\" class=\"headerlink\" title=\"如何保证消息有序？\"></a>如何保证消息有序？</h3><ul>\n<li><p>全局有序</p>\n<ul>\n<li>一个生产者、一个分区、一个消费者</li>\n</ul>\n</li>\n<li><p>部分有序</p>\n<ul>\n<li>消息按特定规则分配到不同的分区，分区本身是有序的，每个分区由一个消费者消费</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如何处理消息堆积？\"><a href=\"#如何处理消息堆积？\" class=\"headerlink\" title=\"如何处理消息堆积？\"></a>如何处理消息堆积？</h3><ul>\n<li><ol>\n<li>定位问题，如果是bug引起，修改bug（实际生产场景如果由于发版导致，先回滚再定位原因）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>如果不是bug，看能不能优化消费逻辑</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>如果不能优化，就要横向扩容，同时增加分区数和消费者数量</li>\n</ol>\n</li>\n</ul>\n<p><a href=\"https://mp.weixin.qq.com/s/u6_WH-r1bRc4m7CUm21Tew\">参考文章1 微信公众号文章</a><br><a href=\"https://zhuanlan.zhihu.com/p/68052232\">参考文章2 知乎</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h1><p>消息队列是分布式系统的一个重要组件，从五个问题来初步认识一下消息队列，基本原理是什么样的，如何正确的使用消息队列。</p>\n<ul>\n<li>Q1: 为什么需要消息队列？</li>\n<li>Q2: 如何保证消息不丢失？</li>\n<li>Q3: 如何处理重复消息？</li>\n<li>Q4: 如何保证消息有序性？</li>\n<li>Q5: 如何处理消息堆积？</li>\n</ul>\n<h2 id=\"为什么需要\"><a href=\"#为什么需要\" class=\"headerlink\" title=\"为什么需要\"></a>为什么需要</h2><h3 id=\"异步处理\"><a href=\"#异步处理\" class=\"headerlink\" title=\"异步处理\"></a>异步处理</h3><ul>\n<li>随着业务的增长，业务逻辑会不断加重，为了保持较快速的响应，可以在核心逻辑处理完后就返回，其他逻辑放到消息队列之后异步处理</li>\n</ul>\n<h3 id=\"应用解耦\"><a href=\"#应用解耦\" class=\"headerlink\" title=\"应用解耦\"></a>应用解耦</h3><ul>\n<li>业务模块增加，可以通过订阅核心服务的消息主题，不影响核心服务</li>\n</ul>\n<h3 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h3><ul>\n<li>后端服务无法支撑大量的并发请求，请求先放到队列，后端服务尽最大的能力消费队列</li>\n</ul>\n<h3 id=\"日志处理\"><a href=\"#日志处理\" class=\"headerlink\" title=\"日志处理\"></a>日志处理</h3><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h3><ul>\n<li><p>点对点（队列）模型</p>\n<ul>\n<li><p>同一个消息只能由一个消费者消费一次</p>\n<ul>\n<li>Rabbit MQ</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>发布&#x2F;订阅模型</p>\n<ul>\n<li><p>订阅了某个主题的所有消费者都可以消费该主题的消息</p>\n<ul>\n<li>Rocket MQ、Kafka</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"各个组件术语（Kafka）\"><a href=\"#各个组件术语（Kafka）\" class=\"headerlink\" title=\"各个组件术语（Kafka）\"></a>各个组件术语（Kafka）</h3><ul>\n<li><p>生产者（Producer）</p>\n</li>\n<li><p>消息队列服务器（Broker）</p>\n<ul>\n<li><p>主服务器（Leader）</p>\n</li>\n<li><p>从服务器（Follower）</p>\n</li>\n<li><p>主题（Topic）</p>\n<ul>\n<li>分区（Partition）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>消费者组（Consumer Group）</p>\n<ul>\n<li>消费者（Consumer）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h3><ul>\n<li><p>生产消息（发送数据）</p>\n<ul>\n<li><ol>\n<li>从Kafka Cluster获取分区的Leader，Producer将消息发送给Leader</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>Leader将消息写入本地文件（此时可以直接到步骤3）</li>\n</ol>\n<ul>\n<li>2.1. Followers从Leader pull消息并写入本地后向Leader发送ACK确认</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>Leader向Producer响应ACK</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>存储数据</p>\n<ul>\n<li><p>单独开辟一块磁盘，顺序写入</p>\n</li>\n<li><p>每个分区相当于一个文件目录</p>\n<ul>\n<li><p>Partition&#x2F;Segment</p>\n<ul>\n<li>.index</li>\n<li>.log</li>\n<li>.timeindex</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>消费消息（接收数据）</p>\n<ul>\n<li><ol>\n<li>Consumer也是从Leader中拉取数据</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>一个消费者组内的某个消费者可以消费一个Topic的不同分区，单同一个组内的不同消费者不能同时消费某个Topic的同一个分区，一个组的消费者数量最好和分区数相同</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分区的好处\"><a href=\"#分区的好处\" class=\"headerlink\" title=\"分区的好处\"></a>分区的好处</h3><ul>\n<li>方便扩展</li>\n<li>提高并发</li>\n</ul>\n<h2 id=\"实际问题\"><a href=\"#实际问题\" class=\"headerlink\" title=\"实际问题\"></a>实际问题</h2><h3 id=\"如何保证消息队列不丢失？\"><a href=\"#如何保证消息队列不丢失？\" class=\"headerlink\" title=\"如何保证消息队列不丢失？\"></a>如何保证消息队列不丢失？</h3><ul>\n<li><ol>\n<li>生产消息阶段</li>\n</ol>\n<ul>\n<li>正确处理Broker的响应，做重试机制</li>\n</ul>\n</li>\n<li><ol start=\"2\">\n<li>数据存储阶段</li>\n</ol>\n<ul>\n<li>数据落盘再响应成功，有多个副本时可以等多副本都落盘再响应成功</li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li>消费消息阶段</li>\n</ol>\n<ul>\n<li>业务逻辑处理完再确认消息</li>\n</ul>\n</li>\n<li><p>确保了可靠性的同时会影响性能，根据业务选择合适的方式</p>\n</li>\n</ul>\n<h3 id=\"如何处理重复消息？\"><a href=\"#如何处理重复消息？\" class=\"headerlink\" title=\"如何处理重复消息？\"></a>如何处理重复消息？</h3><ul>\n<li><p>为了保证消息不丢失，消息重复是不可避免的</p>\n</li>\n<li><p>业务逻辑幂等性</p>\n<ul>\n<li>增加version版本号做控制</li>\n<li>数据库唯一索引</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如何保证消息有序？\"><a href=\"#如何保证消息有序？\" class=\"headerlink\" title=\"如何保证消息有序？\"></a>如何保证消息有序？</h3><ul>\n<li><p>全局有序</p>\n<ul>\n<li>一个生产者、一个分区、一个消费者</li>\n</ul>\n</li>\n<li><p>部分有序</p>\n<ul>\n<li>消息按特定规则分配到不同的分区，分区本身是有序的，每个分区由一个消费者消费</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如何处理消息堆积？\"><a href=\"#如何处理消息堆积？\" class=\"headerlink\" title=\"如何处理消息堆积？\"></a>如何处理消息堆积？</h3><ul>\n<li><ol>\n<li>定位问题，如果是bug引起，修改bug（实际生产场景如果由于发版导致，先回滚再定位原因）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>如果不是bug，看能不能优化消费逻辑</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>如果不能优化，就要横向扩容，同时增加分区数和消费者数量</li>\n</ol>\n</li>\n</ul>\n<p><a href=\"https://mp.weixin.qq.com/s/u6_WH-r1bRc4m7CUm21Tew\">参考文章1 微信公众号文章</a><br><a href=\"https://zhuanlan.zhihu.com/p/68052232\">参考文章2 知乎</a></p>\n"},{"title":"分布式全局唯一 ID 生成方案有哪些？","date":"2023-03-25T07:23:45.000Z","_content":"## 全局唯一ID要求\n分布式系统中，我们会对一些数据量大的业务进行拆分，如用户表、订单表，当数据量巨大导致数据库性能下降时，通常会进行分库分表，无法利用MySQL的自增ID，那么就需要一个单独的系统来生成全局唯一ID，而且生成的ID要求具有以下特性：\n- 整个系统全局唯一\n- ID趋势递增，提高数据库插入的效率（索引是递增的，避免乱序插入提高索引的维护成本）\n- ID简单，占用空间小，查询效率高\n\n## 常见方案\n\n### UUID\n全局唯一首先可以想到使用UUID，基本各种语言都提供了UUID的库\n##### 优点：\n- 代码实现简单\n- 本地生成，没有性能问题\n- 全球唯一的，数据迁移容易\n\n##### 缺点：\n- 每次生成的ID是无序的，不满足趋势递增\n- UUID是字符串，而且比较长，占用空间大，查询效率低\n- ID没有含义，可读性差\n\n### MySQL自增主键\n单表可以使用MySQL的自增ID，多表的情况下其实也可以使用自增ID，只是和单表每次+1不同，分多表的情况下每次需要加N，具体如下图：\n![](https://upload-images.jianshu.io/upload_images/14151453-2a5d07950848c303.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n上图中共分成了两个库4个表，那么每个表初始值一次为1~4，之后每次自增时+4，这样保证了每个表的ID不会重复，而且是趋势递增的，解决了单表的问题。\n\n#### 缺点：\n一旦步长定好就无法扩容，数据库单机能力有限，不易于横向扩展\n\n### 雪花snowflake方案\n雪花算法生成64位二进制正整数，然后转换为10进制的数，具体方案如下图：\n![](https://upload-images.jianshu.io/upload_images/14151453-73e41ba1afcd26c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n最高的一个bit不用，接下来的41个bit表示微秒级的时间（表示范围约69年），再接下来的10个bit机器编号可以分别表示1024台机器，如果对IDC划分，可以将10-bit的高几位表示IDC，最低位的12个字节是一个自增序列，表示范围为2^12=4096个，理论上这种方案每秒可以生成的唯一ID数约为4096*1000=409.6w个。\n#### 优点：\n- 整个ID满足趋势递增\n- 不依赖第三方系统，稳定性和性能都比较高\n- 可以根据自身业务分配bit位，比较灵活\n\n#### 缺点：\n- 强依赖系统时钟，如果系统时钟回拨，会导致ID重复或者服务不可用\n\n### Redis\n利用Redis的incr原子性操作\n![](https://upload-images.jianshu.io/upload_images/14151453-00f8962cc2a1ee14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n一般方案为年份+月份+小时+Redis自增。\n\n#### 优点：\n- 有序递增，可读性强\n- 性能较高\n\n#### 缺点：\n- 占用带宽，依赖Redis\n\n## 更优的方案\n### 美团的Leaf-segment方案\n在之前的数据方案中，利用自增id每次从数据库只取了一个id，由于数据库的IO能力有限，不能支持高并发的场景，那么如果一次取一批id，消耗完再取一批，是不是就可以提高并发能力了？具体的方案架构如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-4747be83c08046d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n抽象出Proxy Server，用于从数据库批量获取，然后在Leaf内部中逐个消耗分发给用户服务。\n如图中的数据库表结构：biz_tag用来区分业务，业务之间的id号相互隔离互不影响，每次从数据库取出step个id号，将数据操作次数减少到了1/step。\n对于多个Leaf抢占数据库可以利用MySQL的事务和锁机制，先更新再查询，保证多个Leaf请求的id范围不会重复复。\n```sql\nBegin\nUPDATE table SET max_id=max_id+step WHERE biz_tag=xxx\nSELECT tag, max_id, step FROM table WHERE biz_tag=xxx\nCommit\n```\n这样返回给业务服务的ID范围应该是[max_id-step+1, max_id]\n\n#### 优点：\n- Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景\n- ID是趋势递增的64位数字\n- 高可用：Leaf内部可以使用缓存，即使数据宕机短时间服务仍可用\n- 可以自定义max_id和step，便于业务迁移\n\n#### 缺点：\n- ID号码不够随机，可能导致发号数量的信息\n- TP999数据波动大，当多个Leaf同时消耗完后，还是会阻塞在数据库更新上，业务可能会出现偶尔的时延毛刺\n- 强依赖DB，DB宕机会导致系统不可用\n\n#### 双buffer优化\n对于第一个缺点，由于是这个方案设计上的问题不能优化了，但对于第二个缺点，可以作进一步的优化，具体思路如下：\n之前的方案Leaf从数据库取号段是在号段消耗完的时候进行的，这导致了需要等待从DB取回号段的时间才能返回下一个ID号码，而数据库的操作是比较耗时的，导致Leaf服务阻塞，该次请求时延会突增。\n为了解决这个问题，希望两次取号段能尽量做到无缝衔接，那么在号段消耗到某个点（比如100/1000）的时候异步的就请求DB取下一个号段然后保存在内存中，而不是等到号段用完再同步请求DB，这样就可以很大程度减少因为DB阻塞带来的业务抖动，具体实现如下图：\n![](https://upload-images.jianshu.io/upload_images/14151453-bad0803983eb9b35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nLeaf服务内部采用两个segment buffer，当前号段已下发10%时，如果下一个号段未更新，则启动线程去更新下个号段，这样当buffer1消耗完时buffer2很可能已经更新好了，只需要直接切换当前segment到segment buffer2，然后就可以继续发放号码。两个buffer交替工作，平滑DB带来的I/O阻塞。\n\n#### 数据库高可用容灾\n对于第三个缺点强依赖DB的问题，需要DB高可用，可以采用一主两从的方式，分机房部署（常见的架构有“同城三机房”、“两城三中心”），Master和Slave采用半同步复制同步数据，保证至少有两个节点数据一致且不丢失，同时可以接入中间件来实现主从切换。\n\n## 参考\n【1】[一线大厂的分布式唯一ID生成方案是什么样的？](https://blog.csdn.net/zl1zl2zl3/article/details/89509445)\n【2】[Leaf——美团点评分布式ID生成系统](https://tech.meituan.com/2017/04/21/mt-leaf.html)\n","source":"_posts/2023/03-25-分布式全局唯一-ID-生成方案有哪些？.md","raw":"---\ntitle: 分布式全局唯一 ID 生成方案有哪些？\ndate: 2023-03-25 15:23:45\ncategories:\n- [分布式系统]\ntags:\n- 唯一ID\n- snowflake\n- leaf\n---\n## 全局唯一ID要求\n分布式系统中，我们会对一些数据量大的业务进行拆分，如用户表、订单表，当数据量巨大导致数据库性能下降时，通常会进行分库分表，无法利用MySQL的自增ID，那么就需要一个单独的系统来生成全局唯一ID，而且生成的ID要求具有以下特性：\n- 整个系统全局唯一\n- ID趋势递增，提高数据库插入的效率（索引是递增的，避免乱序插入提高索引的维护成本）\n- ID简单，占用空间小，查询效率高\n\n## 常见方案\n\n### UUID\n全局唯一首先可以想到使用UUID，基本各种语言都提供了UUID的库\n##### 优点：\n- 代码实现简单\n- 本地生成，没有性能问题\n- 全球唯一的，数据迁移容易\n\n##### 缺点：\n- 每次生成的ID是无序的，不满足趋势递增\n- UUID是字符串，而且比较长，占用空间大，查询效率低\n- ID没有含义，可读性差\n\n### MySQL自增主键\n单表可以使用MySQL的自增ID，多表的情况下其实也可以使用自增ID，只是和单表每次+1不同，分多表的情况下每次需要加N，具体如下图：\n![](https://upload-images.jianshu.io/upload_images/14151453-2a5d07950848c303.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n上图中共分成了两个库4个表，那么每个表初始值一次为1~4，之后每次自增时+4，这样保证了每个表的ID不会重复，而且是趋势递增的，解决了单表的问题。\n\n#### 缺点：\n一旦步长定好就无法扩容，数据库单机能力有限，不易于横向扩展\n\n### 雪花snowflake方案\n雪花算法生成64位二进制正整数，然后转换为10进制的数，具体方案如下图：\n![](https://upload-images.jianshu.io/upload_images/14151453-73e41ba1afcd26c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n最高的一个bit不用，接下来的41个bit表示微秒级的时间（表示范围约69年），再接下来的10个bit机器编号可以分别表示1024台机器，如果对IDC划分，可以将10-bit的高几位表示IDC，最低位的12个字节是一个自增序列，表示范围为2^12=4096个，理论上这种方案每秒可以生成的唯一ID数约为4096*1000=409.6w个。\n#### 优点：\n- 整个ID满足趋势递增\n- 不依赖第三方系统，稳定性和性能都比较高\n- 可以根据自身业务分配bit位，比较灵活\n\n#### 缺点：\n- 强依赖系统时钟，如果系统时钟回拨，会导致ID重复或者服务不可用\n\n### Redis\n利用Redis的incr原子性操作\n![](https://upload-images.jianshu.io/upload_images/14151453-00f8962cc2a1ee14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n一般方案为年份+月份+小时+Redis自增。\n\n#### 优点：\n- 有序递增，可读性强\n- 性能较高\n\n#### 缺点：\n- 占用带宽，依赖Redis\n\n## 更优的方案\n### 美团的Leaf-segment方案\n在之前的数据方案中，利用自增id每次从数据库只取了一个id，由于数据库的IO能力有限，不能支持高并发的场景，那么如果一次取一批id，消耗完再取一批，是不是就可以提高并发能力了？具体的方案架构如下：\n![](https://upload-images.jianshu.io/upload_images/14151453-4747be83c08046d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n抽象出Proxy Server，用于从数据库批量获取，然后在Leaf内部中逐个消耗分发给用户服务。\n如图中的数据库表结构：biz_tag用来区分业务，业务之间的id号相互隔离互不影响，每次从数据库取出step个id号，将数据操作次数减少到了1/step。\n对于多个Leaf抢占数据库可以利用MySQL的事务和锁机制，先更新再查询，保证多个Leaf请求的id范围不会重复复。\n```sql\nBegin\nUPDATE table SET max_id=max_id+step WHERE biz_tag=xxx\nSELECT tag, max_id, step FROM table WHERE biz_tag=xxx\nCommit\n```\n这样返回给业务服务的ID范围应该是[max_id-step+1, max_id]\n\n#### 优点：\n- Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景\n- ID是趋势递增的64位数字\n- 高可用：Leaf内部可以使用缓存，即使数据宕机短时间服务仍可用\n- 可以自定义max_id和step，便于业务迁移\n\n#### 缺点：\n- ID号码不够随机，可能导致发号数量的信息\n- TP999数据波动大，当多个Leaf同时消耗完后，还是会阻塞在数据库更新上，业务可能会出现偶尔的时延毛刺\n- 强依赖DB，DB宕机会导致系统不可用\n\n#### 双buffer优化\n对于第一个缺点，由于是这个方案设计上的问题不能优化了，但对于第二个缺点，可以作进一步的优化，具体思路如下：\n之前的方案Leaf从数据库取号段是在号段消耗完的时候进行的，这导致了需要等待从DB取回号段的时间才能返回下一个ID号码，而数据库的操作是比较耗时的，导致Leaf服务阻塞，该次请求时延会突增。\n为了解决这个问题，希望两次取号段能尽量做到无缝衔接，那么在号段消耗到某个点（比如100/1000）的时候异步的就请求DB取下一个号段然后保存在内存中，而不是等到号段用完再同步请求DB，这样就可以很大程度减少因为DB阻塞带来的业务抖动，具体实现如下图：\n![](https://upload-images.jianshu.io/upload_images/14151453-bad0803983eb9b35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nLeaf服务内部采用两个segment buffer，当前号段已下发10%时，如果下一个号段未更新，则启动线程去更新下个号段，这样当buffer1消耗完时buffer2很可能已经更新好了，只需要直接切换当前segment到segment buffer2，然后就可以继续发放号码。两个buffer交替工作，平滑DB带来的I/O阻塞。\n\n#### 数据库高可用容灾\n对于第三个缺点强依赖DB的问题，需要DB高可用，可以采用一主两从的方式，分机房部署（常见的架构有“同城三机房”、“两城三中心”），Master和Slave采用半同步复制同步数据，保证至少有两个节点数据一致且不丢失，同时可以接入中间件来实现主从切换。\n\n## 参考\n【1】[一线大厂的分布式唯一ID生成方案是什么样的？](https://blog.csdn.net/zl1zl2zl3/article/details/89509445)\n【2】[Leaf——美团点评分布式ID生成系统](https://tech.meituan.com/2017/04/21/mt-leaf.html)\n","slug":"分布式全局唯一-ID-生成方案有哪些？","published":1,"updated":"2023-03-25T07:29:23.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyww002cvhfids3pb8to","content":"<h2 id=\"全局唯一ID要求\"><a href=\"#全局唯一ID要求\" class=\"headerlink\" title=\"全局唯一ID要求\"></a>全局唯一ID要求</h2><p>分布式系统中，我们会对一些数据量大的业务进行拆分，如用户表、订单表，当数据量巨大导致数据库性能下降时，通常会进行分库分表，无法利用MySQL的自增ID，那么就需要一个单独的系统来生成全局唯一ID，而且生成的ID要求具有以下特性：</p>\n<ul>\n<li>整个系统全局唯一</li>\n<li>ID趋势递增，提高数据库插入的效率（索引是递增的，避免乱序插入提高索引的维护成本）</li>\n<li>ID简单，占用空间小，查询效率高</li>\n</ul>\n<h2 id=\"常见方案\"><a href=\"#常见方案\" class=\"headerlink\" title=\"常见方案\"></a>常见方案</h2><h3 id=\"UUID\"><a href=\"#UUID\" class=\"headerlink\" title=\"UUID\"></a>UUID</h3><p>全局唯一首先可以想到使用UUID，基本各种语言都提供了UUID的库</p>\n<h5 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h5><ul>\n<li>代码实现简单</li>\n<li>本地生成，没有性能问题</li>\n<li>全球唯一的，数据迁移容易</li>\n</ul>\n<h5 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h5><ul>\n<li>每次生成的ID是无序的，不满足趋势递增</li>\n<li>UUID是字符串，而且比较长，占用空间大，查询效率低</li>\n<li>ID没有含义，可读性差</li>\n</ul>\n<h3 id=\"MySQL自增主键\"><a href=\"#MySQL自增主键\" class=\"headerlink\" title=\"MySQL自增主键\"></a>MySQL自增主键</h3><p>单表可以使用MySQL的自增ID，多表的情况下其实也可以使用自增ID，只是和单表每次+1不同，分多表的情况下每次需要加N，具体如下图：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-2a5d07950848c303.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-2a5d07950848c303.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>上图中共分成了两个库4个表，那么每个表初始值一次为1~4，之后每次自增时+4，这样保证了每个表的ID不会重复，而且是趋势递增的，解决了单表的问题。</p>\n<h4 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><p>一旦步长定好就无法扩容，数据库单机能力有限，不易于横向扩展</p>\n<h3 id=\"雪花snowflake方案\"><a href=\"#雪花snowflake方案\" class=\"headerlink\" title=\"雪花snowflake方案\"></a>雪花snowflake方案</h3><p>雪花算法生成64位二进制正整数，然后转换为10进制的数，具体方案如下图：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-73e41ba1afcd26c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-73e41ba1afcd26c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>最高的一个bit不用，接下来的41个bit表示微秒级的时间（表示范围约69年），再接下来的10个bit机器编号可以分别表示1024台机器，如果对IDC划分，可以将10-bit的高几位表示IDC，最低位的12个字节是一个自增序列，表示范围为2^12&#x3D;4096个，理论上这种方案每秒可以生成的唯一ID数约为4096*1000&#x3D;409.6w个。</p>\n<h4 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>整个ID满足趋势递增</li>\n<li>不依赖第三方系统，稳定性和性能都比较高</li>\n<li>可以根据自身业务分配bit位，比较灵活</li>\n</ul>\n<h4 id=\"缺点：-2\"><a href=\"#缺点：-2\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>强依赖系统时钟，如果系统时钟回拨，会导致ID重复或者服务不可用</li>\n</ul>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><p>利用Redis的incr原子性操作<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-00f8962cc2a1ee14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-00f8962cc2a1ee14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>一般方案为年份+月份+小时+Redis自增。</p>\n<h4 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>有序递增，可读性强</li>\n<li>性能较高</li>\n</ul>\n<h4 id=\"缺点：-3\"><a href=\"#缺点：-3\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>占用带宽，依赖Redis</li>\n</ul>\n<h2 id=\"更优的方案\"><a href=\"#更优的方案\" class=\"headerlink\" title=\"更优的方案\"></a>更优的方案</h2><h3 id=\"美团的Leaf-segment方案\"><a href=\"#美团的Leaf-segment方案\" class=\"headerlink\" title=\"美团的Leaf-segment方案\"></a>美团的Leaf-segment方案</h3><p>在之前的数据方案中，利用自增id每次从数据库只取了一个id，由于数据库的IO能力有限，不能支持高并发的场景，那么如果一次取一批id，消耗完再取一批，是不是就可以提高并发能力了？具体的方案架构如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-4747be83c08046d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-4747be83c08046d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>抽象出Proxy Server，用于从数据库批量获取，然后在Leaf内部中逐个消耗分发给用户服务。<br>如图中的数据库表结构：biz_tag用来区分业务，业务之间的id号相互隔离互不影响，每次从数据库取出step个id号，将数据操作次数减少到了1&#x2F;step。<br>对于多个Leaf抢占数据库可以利用MySQL的事务和锁机制，先更新再查询，保证多个Leaf请求的id范围不会重复复。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Begin</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> <span class=\"keyword\">table</span> <span class=\"keyword\">SET</span> max_id<span class=\"operator\">=</span>max_id<span class=\"operator\">+</span>step <span class=\"keyword\">WHERE</span> biz_tag<span class=\"operator\">=</span>xxx</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> tag, max_id, step <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> biz_tag<span class=\"operator\">=</span>xxx</span><br><span class=\"line\"><span class=\"keyword\">Commit</span></span><br></pre></td></tr></table></figure>\n<p>这样返回给业务服务的ID范围应该是[max_id-step+1, max_id]</p>\n<h4 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景</li>\n<li>ID是趋势递增的64位数字</li>\n<li>高可用：Leaf内部可以使用缓存，即使数据宕机短时间服务仍可用</li>\n<li>可以自定义max_id和step，便于业务迁移</li>\n</ul>\n<h4 id=\"缺点：-4\"><a href=\"#缺点：-4\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>ID号码不够随机，可能导致发号数量的信息</li>\n<li>TP999数据波动大，当多个Leaf同时消耗完后，还是会阻塞在数据库更新上，业务可能会出现偶尔的时延毛刺</li>\n<li>强依赖DB，DB宕机会导致系统不可用</li>\n</ul>\n<h4 id=\"双buffer优化\"><a href=\"#双buffer优化\" class=\"headerlink\" title=\"双buffer优化\"></a>双buffer优化</h4><p>对于第一个缺点，由于是这个方案设计上的问题不能优化了，但对于第二个缺点，可以作进一步的优化，具体思路如下：<br>之前的方案Leaf从数据库取号段是在号段消耗完的时候进行的，这导致了需要等待从DB取回号段的时间才能返回下一个ID号码，而数据库的操作是比较耗时的，导致Leaf服务阻塞，该次请求时延会突增。<br>为了解决这个问题，希望两次取号段能尽量做到无缝衔接，那么在号段消耗到某个点（比如100&#x2F;1000）的时候异步的就请求DB取下一个号段然后保存在内存中，而不是等到号段用完再同步请求DB，这样就可以很大程度减少因为DB阻塞带来的业务抖动，具体实现如下图：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-bad0803983eb9b35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-bad0803983eb9b35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br>Leaf服务内部采用两个segment buffer，当前号段已下发10%时，如果下一个号段未更新，则启动线程去更新下个号段，这样当buffer1消耗完时buffer2很可能已经更新好了，只需要直接切换当前segment到segment buffer2，然后就可以继续发放号码。两个buffer交替工作，平滑DB带来的I&#x2F;O阻塞。</p>\n<h4 id=\"数据库高可用容灾\"><a href=\"#数据库高可用容灾\" class=\"headerlink\" title=\"数据库高可用容灾\"></a>数据库高可用容灾</h4><p>对于第三个缺点强依赖DB的问题，需要DB高可用，可以采用一主两从的方式，分机房部署（常见的架构有“同城三机房”、“两城三中心”），Master和Slave采用半同步复制同步数据，保证至少有两个节点数据一致且不丢失，同时可以接入中间件来实现主从切换。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://blog.csdn.net/zl1zl2zl3/article/details/89509445\">一线大厂的分布式唯一ID生成方案是什么样的？</a><br>【2】<a href=\"https://tech.meituan.com/2017/04/21/mt-leaf.html\">Leaf——美团点评分布式ID生成系统</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"全局唯一ID要求\"><a href=\"#全局唯一ID要求\" class=\"headerlink\" title=\"全局唯一ID要求\"></a>全局唯一ID要求</h2><p>分布式系统中，我们会对一些数据量大的业务进行拆分，如用户表、订单表，当数据量巨大导致数据库性能下降时，通常会进行分库分表，无法利用MySQL的自增ID，那么就需要一个单独的系统来生成全局唯一ID，而且生成的ID要求具有以下特性：</p>\n<ul>\n<li>整个系统全局唯一</li>\n<li>ID趋势递增，提高数据库插入的效率（索引是递增的，避免乱序插入提高索引的维护成本）</li>\n<li>ID简单，占用空间小，查询效率高</li>\n</ul>\n<h2 id=\"常见方案\"><a href=\"#常见方案\" class=\"headerlink\" title=\"常见方案\"></a>常见方案</h2><h3 id=\"UUID\"><a href=\"#UUID\" class=\"headerlink\" title=\"UUID\"></a>UUID</h3><p>全局唯一首先可以想到使用UUID，基本各种语言都提供了UUID的库</p>\n<h5 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h5><ul>\n<li>代码实现简单</li>\n<li>本地生成，没有性能问题</li>\n<li>全球唯一的，数据迁移容易</li>\n</ul>\n<h5 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h5><ul>\n<li>每次生成的ID是无序的，不满足趋势递增</li>\n<li>UUID是字符串，而且比较长，占用空间大，查询效率低</li>\n<li>ID没有含义，可读性差</li>\n</ul>\n<h3 id=\"MySQL自增主键\"><a href=\"#MySQL自增主键\" class=\"headerlink\" title=\"MySQL自增主键\"></a>MySQL自增主键</h3><p>单表可以使用MySQL的自增ID，多表的情况下其实也可以使用自增ID，只是和单表每次+1不同，分多表的情况下每次需要加N，具体如下图：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-2a5d07950848c303.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>上图中共分成了两个库4个表，那么每个表初始值一次为1~4，之后每次自增时+4，这样保证了每个表的ID不会重复，而且是趋势递增的，解决了单表的问题。</p>\n<h4 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><p>一旦步长定好就无法扩容，数据库单机能力有限，不易于横向扩展</p>\n<h3 id=\"雪花snowflake方案\"><a href=\"#雪花snowflake方案\" class=\"headerlink\" title=\"雪花snowflake方案\"></a>雪花snowflake方案</h3><p>雪花算法生成64位二进制正整数，然后转换为10进制的数，具体方案如下图：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-73e41ba1afcd26c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>最高的一个bit不用，接下来的41个bit表示微秒级的时间（表示范围约69年），再接下来的10个bit机器编号可以分别表示1024台机器，如果对IDC划分，可以将10-bit的高几位表示IDC，最低位的12个字节是一个自增序列，表示范围为2^12&#x3D;4096个，理论上这种方案每秒可以生成的唯一ID数约为4096*1000&#x3D;409.6w个。</p>\n<h4 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>整个ID满足趋势递增</li>\n<li>不依赖第三方系统，稳定性和性能都比较高</li>\n<li>可以根据自身业务分配bit位，比较灵活</li>\n</ul>\n<h4 id=\"缺点：-2\"><a href=\"#缺点：-2\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>强依赖系统时钟，如果系统时钟回拨，会导致ID重复或者服务不可用</li>\n</ul>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><p>利用Redis的incr原子性操作<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-00f8962cc2a1ee14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>一般方案为年份+月份+小时+Redis自增。</p>\n<h4 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>有序递增，可读性强</li>\n<li>性能较高</li>\n</ul>\n<h4 id=\"缺点：-3\"><a href=\"#缺点：-3\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>占用带宽，依赖Redis</li>\n</ul>\n<h2 id=\"更优的方案\"><a href=\"#更优的方案\" class=\"headerlink\" title=\"更优的方案\"></a>更优的方案</h2><h3 id=\"美团的Leaf-segment方案\"><a href=\"#美团的Leaf-segment方案\" class=\"headerlink\" title=\"美团的Leaf-segment方案\"></a>美团的Leaf-segment方案</h3><p>在之前的数据方案中，利用自增id每次从数据库只取了一个id，由于数据库的IO能力有限，不能支持高并发的场景，那么如果一次取一批id，消耗完再取一批，是不是就可以提高并发能力了？具体的方案架构如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-4747be83c08046d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>抽象出Proxy Server，用于从数据库批量获取，然后在Leaf内部中逐个消耗分发给用户服务。<br>如图中的数据库表结构：biz_tag用来区分业务，业务之间的id号相互隔离互不影响，每次从数据库取出step个id号，将数据操作次数减少到了1&#x2F;step。<br>对于多个Leaf抢占数据库可以利用MySQL的事务和锁机制，先更新再查询，保证多个Leaf请求的id范围不会重复复。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Begin</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> <span class=\"keyword\">table</span> <span class=\"keyword\">SET</span> max_id<span class=\"operator\">=</span>max_id<span class=\"operator\">+</span>step <span class=\"keyword\">WHERE</span> biz_tag<span class=\"operator\">=</span>xxx</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> tag, max_id, step <span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> <span class=\"keyword\">WHERE</span> biz_tag<span class=\"operator\">=</span>xxx</span><br><span class=\"line\"><span class=\"keyword\">Commit</span></span><br></pre></td></tr></table></figure>\n<p>这样返回给业务服务的ID范围应该是[max_id-step+1, max_id]</p>\n<h4 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景</li>\n<li>ID是趋势递增的64位数字</li>\n<li>高可用：Leaf内部可以使用缓存，即使数据宕机短时间服务仍可用</li>\n<li>可以自定义max_id和step，便于业务迁移</li>\n</ul>\n<h4 id=\"缺点：-4\"><a href=\"#缺点：-4\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>ID号码不够随机，可能导致发号数量的信息</li>\n<li>TP999数据波动大，当多个Leaf同时消耗完后，还是会阻塞在数据库更新上，业务可能会出现偶尔的时延毛刺</li>\n<li>强依赖DB，DB宕机会导致系统不可用</li>\n</ul>\n<h4 id=\"双buffer优化\"><a href=\"#双buffer优化\" class=\"headerlink\" title=\"双buffer优化\"></a>双buffer优化</h4><p>对于第一个缺点，由于是这个方案设计上的问题不能优化了，但对于第二个缺点，可以作进一步的优化，具体思路如下：<br>之前的方案Leaf从数据库取号段是在号段消耗完的时候进行的，这导致了需要等待从DB取回号段的时间才能返回下一个ID号码，而数据库的操作是比较耗时的，导致Leaf服务阻塞，该次请求时延会突增。<br>为了解决这个问题，希望两次取号段能尽量做到无缝衔接，那么在号段消耗到某个点（比如100&#x2F;1000）的时候异步的就请求DB取下一个号段然后保存在内存中，而不是等到号段用完再同步请求DB，这样就可以很大程度减少因为DB阻塞带来的业务抖动，具体实现如下图：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-bad0803983eb9b35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br>Leaf服务内部采用两个segment buffer，当前号段已下发10%时，如果下一个号段未更新，则启动线程去更新下个号段，这样当buffer1消耗完时buffer2很可能已经更新好了，只需要直接切换当前segment到segment buffer2，然后就可以继续发放号码。两个buffer交替工作，平滑DB带来的I&#x2F;O阻塞。</p>\n<h4 id=\"数据库高可用容灾\"><a href=\"#数据库高可用容灾\" class=\"headerlink\" title=\"数据库高可用容灾\"></a>数据库高可用容灾</h4><p>对于第三个缺点强依赖DB的问题，需要DB高可用，可以采用一主两从的方式，分机房部署（常见的架构有“同城三机房”、“两城三中心”），Master和Slave采用半同步复制同步数据，保证至少有两个节点数据一致且不丢失，同时可以接入中间件来实现主从切换。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://blog.csdn.net/zl1zl2zl3/article/details/89509445\">一线大厂的分布式唯一ID生成方案是什么样的？</a><br>【2】<a href=\"https://tech.meituan.com/2017/04/21/mt-leaf.html\">Leaf——美团点评分布式ID生成系统</a></p>\n"},{"title":"分布式系统基础知识概述","date":"2023-03-25T07:21:46.000Z","_content":"## 基础\n\n### 性能\n\n- 性能指标\n\n\t- 响应时间\n\t- 吞吐量（QPS、TPS）\n\t- 并发用户数：不是越高越好，如果系统来不及处理就会阻塞，响应时间会大大提高\n\n- 性能优化\n\n\t- 集群\n\t- 缓存（Redis、CDN）\n\t- 异步\n\n### 伸缩性\n\n- 扩容\n- \b无状态的\b应用服务器可以通过负载均衡器想集群中添加新的节点\n- 关系型数据库可以用过Sharding实现\n- 非关系型数据库对伸缩性支持很好\n\n### 扩展性\n\n- 添加新的功能对现有系统的其他应用无影响\n- 使用消息队列进行解耦\n- 分布式服务奖业务可复用的部分\b模块化\n\n### 可用性\n\n- 冗余（多点备份，异地双活）\n- 故障切换\n- 服务降级\n- 监控\n\n### 安全性\n\n- 应对各种攻击手段\n\n\t- SQL注入\n\t- XSS攻击\n\n## 分布式\n\n### 分布式锁\n\n- 数据库唯一索引\n\n\t- 没有失效时间，解锁失败会造成死锁\n\t- 只能是非阻塞，插入失败无法重试\n\t- 不可重入，已获得锁的进程也必须重新获取锁\n\n- Redis的SETNX指令\n\n\t- 节点挂了就不可用，造成死锁\n\n- RedLock\n\n\t- \b高可用\n\n- Zookeeper的有序节点\n\n### 分布式事务\n\n- 两阶段提交（2PC）\n\n\t- 准备阶段\n\n\t\t- 协调者询问所有参与者事务执行的结果\n\n\t- 提交阶段\n\n\t\t- \b协调者根\b据所有参与者返回的结果判断最终是提交还是回滚\n\n\t- \b存在问题\n\n\t\t- 同步阻塞\n\t\t- 单点故障\n\t\t- 数据不一致\n\n- 本地消息表\n\n\t- 1.\b 分布式事务操作方完成写业务数据后向本地消息表发送一个消息，\b确保这个消息一定会写入本地消息表\n\t- 2. 之后将本地消息表中的消息转发到消息队列，转发成功则从本地消息表删除，否则继续重发\n\t- 3. 分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作\n\n### CAP\n\n- 分布式系统不可能同时满足\b\n\n\t- 一致性（Consistency）\n\t- 分区容忍性（Partition Tolerance）\n\t- 可用性（Availability）\n\n- 权衡\n\n\t- 分区容忍性必不可少，可用性和一致性的权衡\n\t- 为了保证一致性，不能访问未同步完成的节点，就失去了部分可用性\n\t- 为了保证可用性，允许读取所有节点的数据，但是数据可能不一致\n\n### BASE\n\n- 概念\n\n\t- 基本可用（Basically Available）\n\n\t\t- \b分布式系统在\b故障的时候保证核心可用，允许\b损失部分可用性\n\n\t- 软状态（Soft State）\n\n\t\t- 允许\b系统中的数据存在中间状态，并认为\b该中间状态不会影响整体可用性\n\n\t- 最终一致性（Eventually Consistent）\n\n\t\t- 系统中的所有数据副本在经过一段时间的同步后，最终能达到一致性的状态\n\n### 竞选协议\n\n- Paxos\n\n\t- 执行过程\n\n\t\t- 1. Prepare\n\t\t- 2. Accept\n\t\t- 3. Learn\n\n\t- 约束条件\n\n\t\t- 正确性\n\t\t- 可终止性\n\n- Raft\n\n## 集群\n\n### 负载均衡\n\n- 算法\n\n\t- 轮询\n\n\t\t- 服务器性能均衡的场景\n\n\t- 加权轮询\n\n\t\t- 轮询的基础上根据权重分配\n\n\t- 最少连接\n\n\t\t- 将请求发送给当前最少连接的服务器上\n\n\t- 加权最少连接\n\n\t\t- 根据权重结算最少连接\n\n\t- 随机算法\n\t- 源地址哈希\n\n\t\t- 对\b客户端IP计算哈希值取模\n\n- 转发实现\n\n\t- HTTP重定向\n\n\t\t- 返回302重新发起请求\n\t\t- 延迟高，处理能力有限\n\n\t- \bDNS域名解析\n\n\t\t- 解析域名同时使用负载均衡\b算法计算服务器IP\n\t\t- 优点：能根据地理位置进行域名解析，可以返回最近的服务器\n\t\t- 缺点：DNS多级缓存，当\b下线机器需要修改DNS记录，生效时间慢\n\n\t- 反向代理\n\n\t\t- \bOpenresty/Nginx\n\t\t- 缺点：所有请求和响应都要经过反向代理服务器，容易成为瓶颈\n\n\t- 网络层\n\t- 链路层\n\n\t\t- LVS\n\n### Session管理\n\n- Sticky Session\n- Session Replication\n- Session Server\n\n\t- Redis、MySQL\n\n## 攻击技术\n\n### 跨站脚本攻击：XSS（Cross-Site Scripting）\n\n### 跨站请求伪造：CSRF（Cross-Site request forgery）\n\n- 检查Referer头\n- 添加token校验\n- 验证码\n\n### SQL注入\n\n- sql quote预处理\n\n### 拒绝服务攻击（DoS、DDoS）\n\n## 一致性哈希\n\n### 基本原理\n\n- 将哈希空间看做一个环，每个节点都配置在环上，每个数据对象通过哈希取模得到哈希值后，顺时针向前走，存放在碰到第一个节点上\n\n### 分布不均问题\n\n- 虚拟节点解决\n\n## LRU\n\n## 消息队列\n\n### 消息模型\n\n- 点对点\n\n\t- 生产者向MQ中发送了一个消息后，只能被一个消费者消费一次\n\n- 发布/订阅\n\n\t- 生产者向频道发送了一个消息后，多个消费者可以从该频道订阅这条消息并消费\n\n### 使用场景\n\n- 异步处理\n- 流量削峰\n- 应用解耦\n\n### 可靠性\n\n- 发送端可靠性\n\n\t- 本地消息表\n\n- 接收端可靠性\n\n\t- 幂等性\n\t- 唯一消息ID\n\n[【参考文章】GitHub-CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes)\n","source":"_posts/2023/03-25-分布式系统基础知识概述.md","raw":"---\ntitle: 分布式系统基础知识概述\ndate: 2023-03-25 15:21:46\ncategories:\n- [分布式系统]\ntags:\n- 分布式\n- CAP\n- BASE\n---\n## 基础\n\n### 性能\n\n- 性能指标\n\n\t- 响应时间\n\t- 吞吐量（QPS、TPS）\n\t- 并发用户数：不是越高越好，如果系统来不及处理就会阻塞，响应时间会大大提高\n\n- 性能优化\n\n\t- 集群\n\t- 缓存（Redis、CDN）\n\t- 异步\n\n### 伸缩性\n\n- 扩容\n- \b无状态的\b应用服务器可以通过负载均衡器想集群中添加新的节点\n- 关系型数据库可以用过Sharding实现\n- 非关系型数据库对伸缩性支持很好\n\n### 扩展性\n\n- 添加新的功能对现有系统的其他应用无影响\n- 使用消息队列进行解耦\n- 分布式服务奖业务可复用的部分\b模块化\n\n### 可用性\n\n- 冗余（多点备份，异地双活）\n- 故障切换\n- 服务降级\n- 监控\n\n### 安全性\n\n- 应对各种攻击手段\n\n\t- SQL注入\n\t- XSS攻击\n\n## 分布式\n\n### 分布式锁\n\n- 数据库唯一索引\n\n\t- 没有失效时间，解锁失败会造成死锁\n\t- 只能是非阻塞，插入失败无法重试\n\t- 不可重入，已获得锁的进程也必须重新获取锁\n\n- Redis的SETNX指令\n\n\t- 节点挂了就不可用，造成死锁\n\n- RedLock\n\n\t- \b高可用\n\n- Zookeeper的有序节点\n\n### 分布式事务\n\n- 两阶段提交（2PC）\n\n\t- 准备阶段\n\n\t\t- 协调者询问所有参与者事务执行的结果\n\n\t- 提交阶段\n\n\t\t- \b协调者根\b据所有参与者返回的结果判断最终是提交还是回滚\n\n\t- \b存在问题\n\n\t\t- 同步阻塞\n\t\t- 单点故障\n\t\t- 数据不一致\n\n- 本地消息表\n\n\t- 1.\b 分布式事务操作方完成写业务数据后向本地消息表发送一个消息，\b确保这个消息一定会写入本地消息表\n\t- 2. 之后将本地消息表中的消息转发到消息队列，转发成功则从本地消息表删除，否则继续重发\n\t- 3. 分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作\n\n### CAP\n\n- 分布式系统不可能同时满足\b\n\n\t- 一致性（Consistency）\n\t- 分区容忍性（Partition Tolerance）\n\t- 可用性（Availability）\n\n- 权衡\n\n\t- 分区容忍性必不可少，可用性和一致性的权衡\n\t- 为了保证一致性，不能访问未同步完成的节点，就失去了部分可用性\n\t- 为了保证可用性，允许读取所有节点的数据，但是数据可能不一致\n\n### BASE\n\n- 概念\n\n\t- 基本可用（Basically Available）\n\n\t\t- \b分布式系统在\b故障的时候保证核心可用，允许\b损失部分可用性\n\n\t- 软状态（Soft State）\n\n\t\t- 允许\b系统中的数据存在中间状态，并认为\b该中间状态不会影响整体可用性\n\n\t- 最终一致性（Eventually Consistent）\n\n\t\t- 系统中的所有数据副本在经过一段时间的同步后，最终能达到一致性的状态\n\n### 竞选协议\n\n- Paxos\n\n\t- 执行过程\n\n\t\t- 1. Prepare\n\t\t- 2. Accept\n\t\t- 3. Learn\n\n\t- 约束条件\n\n\t\t- 正确性\n\t\t- 可终止性\n\n- Raft\n\n## 集群\n\n### 负载均衡\n\n- 算法\n\n\t- 轮询\n\n\t\t- 服务器性能均衡的场景\n\n\t- 加权轮询\n\n\t\t- 轮询的基础上根据权重分配\n\n\t- 最少连接\n\n\t\t- 将请求发送给当前最少连接的服务器上\n\n\t- 加权最少连接\n\n\t\t- 根据权重结算最少连接\n\n\t- 随机算法\n\t- 源地址哈希\n\n\t\t- 对\b客户端IP计算哈希值取模\n\n- 转发实现\n\n\t- HTTP重定向\n\n\t\t- 返回302重新发起请求\n\t\t- 延迟高，处理能力有限\n\n\t- \bDNS域名解析\n\n\t\t- 解析域名同时使用负载均衡\b算法计算服务器IP\n\t\t- 优点：能根据地理位置进行域名解析，可以返回最近的服务器\n\t\t- 缺点：DNS多级缓存，当\b下线机器需要修改DNS记录，生效时间慢\n\n\t- 反向代理\n\n\t\t- \bOpenresty/Nginx\n\t\t- 缺点：所有请求和响应都要经过反向代理服务器，容易成为瓶颈\n\n\t- 网络层\n\t- 链路层\n\n\t\t- LVS\n\n### Session管理\n\n- Sticky Session\n- Session Replication\n- Session Server\n\n\t- Redis、MySQL\n\n## 攻击技术\n\n### 跨站脚本攻击：XSS（Cross-Site Scripting）\n\n### 跨站请求伪造：CSRF（Cross-Site request forgery）\n\n- 检查Referer头\n- 添加token校验\n- 验证码\n\n### SQL注入\n\n- sql quote预处理\n\n### 拒绝服务攻击（DoS、DDoS）\n\n## 一致性哈希\n\n### 基本原理\n\n- 将哈希空间看做一个环，每个节点都配置在环上，每个数据对象通过哈希取模得到哈希值后，顺时针向前走，存放在碰到第一个节点上\n\n### 分布不均问题\n\n- 虚拟节点解决\n\n## LRU\n\n## 消息队列\n\n### 消息模型\n\n- 点对点\n\n\t- 生产者向MQ中发送了一个消息后，只能被一个消费者消费一次\n\n- 发布/订阅\n\n\t- 生产者向频道发送了一个消息后，多个消费者可以从该频道订阅这条消息并消费\n\n### 使用场景\n\n- 异步处理\n- 流量削峰\n- 应用解耦\n\n### 可靠性\n\n- 发送端可靠性\n\n\t- 本地消息表\n\n- 接收端可靠性\n\n\t- 幂等性\n\t- 唯一消息ID\n\n[【参考文章】GitHub-CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes)\n","slug":"分布式系统基础知识概述","published":1,"updated":"2023-03-25T07:26:36.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywx002gvhfi046odndu","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><ul>\n<li><p>性能指标</p>\n<ul>\n<li>响应时间</li>\n<li>吞吐量（QPS、TPS）</li>\n<li>并发用户数：不是越高越好，如果系统来不及处理就会阻塞，响应时间会大大提高</li>\n</ul>\n</li>\n<li><p>性能优化</p>\n<ul>\n<li>集群</li>\n<li>缓存（Redis、CDN）</li>\n<li>异步</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"伸缩性\"><a href=\"#伸缩性\" class=\"headerlink\" title=\"伸缩性\"></a>伸缩性</h3><ul>\n<li>扩容</li>\n<li>\b无状态的\b应用服务器可以通过负载均衡器想集群中添加新的节点</li>\n<li>关系型数据库可以用过Sharding实现</li>\n<li>非关系型数据库对伸缩性支持很好</li>\n</ul>\n<h3 id=\"扩展性\"><a href=\"#扩展性\" class=\"headerlink\" title=\"扩展性\"></a>扩展性</h3><ul>\n<li>添加新的功能对现有系统的其他应用无影响</li>\n<li>使用消息队列进行解耦</li>\n<li>分布式服务奖业务可复用的部分\b模块化</li>\n</ul>\n<h3 id=\"可用性\"><a href=\"#可用性\" class=\"headerlink\" title=\"可用性\"></a>可用性</h3><ul>\n<li>冗余（多点备份，异地双活）</li>\n<li>故障切换</li>\n<li>服务降级</li>\n<li>监控</li>\n</ul>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><ul>\n<li><p>应对各种攻击手段</p>\n<ul>\n<li>SQL注入</li>\n<li>XSS攻击</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h2><h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><ul>\n<li><p>数据库唯一索引</p>\n<ul>\n<li>没有失效时间，解锁失败会造成死锁</li>\n<li>只能是非阻塞，插入失败无法重试</li>\n<li>不可重入，已获得锁的进程也必须重新获取锁</li>\n</ul>\n</li>\n<li><p>Redis的SETNX指令</p>\n<ul>\n<li>节点挂了就不可用，造成死锁</li>\n</ul>\n</li>\n<li><p>RedLock</p>\n<ul>\n<li>\b高可用</li>\n</ul>\n</li>\n<li><p>Zookeeper的有序节点</p>\n</li>\n</ul>\n<h3 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h3><ul>\n<li><p>两阶段提交（2PC）</p>\n<ul>\n<li><p>准备阶段</p>\n<ul>\n<li>协调者询问所有参与者事务执行的结果</li>\n</ul>\n</li>\n<li><p>提交阶段</p>\n<ul>\n<li>\b协调者根\b据所有参与者返回的结果判断最终是提交还是回滚</li>\n</ul>\n</li>\n<li><p>\b存在问题</p>\n<ul>\n<li>同步阻塞</li>\n<li>单点故障</li>\n<li>数据不一致</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>本地消息表</p>\n<ul>\n<li>1.\b 分布式事务操作方完成写业务数据后向本地消息表发送一个消息，\b确保这个消息一定会写入本地消息表</li>\n<li><ol start=\"2\">\n<li>之后将本地消息表中的消息转发到消息队列，转发成功则从本地消息表删除，否则继续重发</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CAP\"><a href=\"#CAP\" class=\"headerlink\" title=\"CAP\"></a>CAP</h3><ul>\n<li><p>分布式系统不可能同时满足\b</p>\n<ul>\n<li>一致性（Consistency）</li>\n<li>分区容忍性（Partition Tolerance）</li>\n<li>可用性（Availability）</li>\n</ul>\n</li>\n<li><p>权衡</p>\n<ul>\n<li>分区容忍性必不可少，可用性和一致性的权衡</li>\n<li>为了保证一致性，不能访问未同步完成的节点，就失去了部分可用性</li>\n<li>为了保证可用性，允许读取所有节点的数据，但是数据可能不一致</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"BASE\"><a href=\"#BASE\" class=\"headerlink\" title=\"BASE\"></a>BASE</h3><ul>\n<li><p>概念</p>\n<ul>\n<li><p>基本可用（Basically Available）</p>\n<ul>\n<li>\b分布式系统在\b故障的时候保证核心可用，允许\b损失部分可用性</li>\n</ul>\n</li>\n<li><p>软状态（Soft State）</p>\n<ul>\n<li>允许\b系统中的数据存在中间状态，并认为\b该中间状态不会影响整体可用性</li>\n</ul>\n</li>\n<li><p>最终一致性（Eventually Consistent）</p>\n<ul>\n<li>系统中的所有数据副本在经过一段时间的同步后，最终能达到一致性的状态</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"竞选协议\"><a href=\"#竞选协议\" class=\"headerlink\" title=\"竞选协议\"></a>竞选协议</h3><ul>\n<li><p>Paxos</p>\n<ul>\n<li><p>执行过程</p>\n<ul>\n<li><ol>\n<li>Prepare</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>Accept</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>Learn</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>约束条件</p>\n<ul>\n<li>正确性</li>\n<li>可终止性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Raft</p>\n</li>\n</ul>\n<h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><ul>\n<li><p>算法</p>\n<ul>\n<li><p>轮询</p>\n<ul>\n<li>服务器性能均衡的场景</li>\n</ul>\n</li>\n<li><p>加权轮询</p>\n<ul>\n<li>轮询的基础上根据权重分配</li>\n</ul>\n</li>\n<li><p>最少连接</p>\n<ul>\n<li>将请求发送给当前最少连接的服务器上</li>\n</ul>\n</li>\n<li><p>加权最少连接</p>\n<ul>\n<li>根据权重结算最少连接</li>\n</ul>\n</li>\n<li><p>随机算法</p>\n</li>\n<li><p>源地址哈希</p>\n<ul>\n<li>对\b客户端IP计算哈希值取模</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>转发实现</p>\n<ul>\n<li><p>HTTP重定向</p>\n<ul>\n<li>返回302重新发起请求</li>\n<li>延迟高，处理能力有限</li>\n</ul>\n</li>\n<li><p>\bDNS域名解析</p>\n<ul>\n<li>解析域名同时使用负载均衡\b算法计算服务器IP</li>\n<li>优点：能根据地理位置进行域名解析，可以返回最近的服务器</li>\n<li>缺点：DNS多级缓存，当\b下线机器需要修改DNS记录，生效时间慢</li>\n</ul>\n</li>\n<li><p>反向代理</p>\n<ul>\n<li>\bOpenresty&#x2F;Nginx</li>\n<li>缺点：所有请求和响应都要经过反向代理服务器，容易成为瓶颈</li>\n</ul>\n</li>\n<li><p>网络层</p>\n</li>\n<li><p>链路层</p>\n<ul>\n<li>LVS</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Session管理\"><a href=\"#Session管理\" class=\"headerlink\" title=\"Session管理\"></a>Session管理</h3><ul>\n<li><p>Sticky Session</p>\n</li>\n<li><p>Session Replication</p>\n</li>\n<li><p>Session Server</p>\n<ul>\n<li>Redis、MySQL</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"攻击技术\"><a href=\"#攻击技术\" class=\"headerlink\" title=\"攻击技术\"></a>攻击技术</h2><h3 id=\"跨站脚本攻击：XSS（Cross-Site-Scripting）\"><a href=\"#跨站脚本攻击：XSS（Cross-Site-Scripting）\" class=\"headerlink\" title=\"跨站脚本攻击：XSS（Cross-Site Scripting）\"></a>跨站脚本攻击：XSS（Cross-Site Scripting）</h3><h3 id=\"跨站请求伪造：CSRF（Cross-Site-request-forgery）\"><a href=\"#跨站请求伪造：CSRF（Cross-Site-request-forgery）\" class=\"headerlink\" title=\"跨站请求伪造：CSRF（Cross-Site request forgery）\"></a>跨站请求伪造：CSRF（Cross-Site request forgery）</h3><ul>\n<li>检查Referer头</li>\n<li>添加token校验</li>\n<li>验证码</li>\n</ul>\n<h3 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h3><ul>\n<li>sql quote预处理</li>\n</ul>\n<h3 id=\"拒绝服务攻击（DoS、DDoS）\"><a href=\"#拒绝服务攻击（DoS、DDoS）\" class=\"headerlink\" title=\"拒绝服务攻击（DoS、DDoS）\"></a>拒绝服务攻击（DoS、DDoS）</h3><h2 id=\"一致性哈希\"><a href=\"#一致性哈希\" class=\"headerlink\" title=\"一致性哈希\"></a>一致性哈希</h2><h3 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h3><ul>\n<li>将哈希空间看做一个环，每个节点都配置在环上，每个数据对象通过哈希取模得到哈希值后，顺时针向前走，存放在碰到第一个节点上</li>\n</ul>\n<h3 id=\"分布不均问题\"><a href=\"#分布不均问题\" class=\"headerlink\" title=\"分布不均问题\"></a>分布不均问题</h3><ul>\n<li>虚拟节点解决</li>\n</ul>\n<h2 id=\"LRU\"><a href=\"#LRU\" class=\"headerlink\" title=\"LRU\"></a>LRU</h2><h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><h3 id=\"消息模型\"><a href=\"#消息模型\" class=\"headerlink\" title=\"消息模型\"></a>消息模型</h3><ul>\n<li><p>点对点</p>\n<ul>\n<li>生产者向MQ中发送了一个消息后，只能被一个消费者消费一次</li>\n</ul>\n</li>\n<li><p>发布&#x2F;订阅</p>\n<ul>\n<li>生产者向频道发送了一个消息后，多个消费者可以从该频道订阅这条消息并消费</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ul>\n<li>异步处理</li>\n<li>流量削峰</li>\n<li>应用解耦</li>\n</ul>\n<h3 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h3><ul>\n<li><p>发送端可靠性</p>\n<ul>\n<li>本地消息表</li>\n</ul>\n</li>\n<li><p>接收端可靠性</p>\n<ul>\n<li>幂等性</li>\n<li>唯一消息ID</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">【参考文章】GitHub-CyC2018&#x2F;CS-Notes</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><ul>\n<li><p>性能指标</p>\n<ul>\n<li>响应时间</li>\n<li>吞吐量（QPS、TPS）</li>\n<li>并发用户数：不是越高越好，如果系统来不及处理就会阻塞，响应时间会大大提高</li>\n</ul>\n</li>\n<li><p>性能优化</p>\n<ul>\n<li>集群</li>\n<li>缓存（Redis、CDN）</li>\n<li>异步</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"伸缩性\"><a href=\"#伸缩性\" class=\"headerlink\" title=\"伸缩性\"></a>伸缩性</h3><ul>\n<li>扩容</li>\n<li>\b无状态的\b应用服务器可以通过负载均衡器想集群中添加新的节点</li>\n<li>关系型数据库可以用过Sharding实现</li>\n<li>非关系型数据库对伸缩性支持很好</li>\n</ul>\n<h3 id=\"扩展性\"><a href=\"#扩展性\" class=\"headerlink\" title=\"扩展性\"></a>扩展性</h3><ul>\n<li>添加新的功能对现有系统的其他应用无影响</li>\n<li>使用消息队列进行解耦</li>\n<li>分布式服务奖业务可复用的部分\b模块化</li>\n</ul>\n<h3 id=\"可用性\"><a href=\"#可用性\" class=\"headerlink\" title=\"可用性\"></a>可用性</h3><ul>\n<li>冗余（多点备份，异地双活）</li>\n<li>故障切换</li>\n<li>服务降级</li>\n<li>监控</li>\n</ul>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><ul>\n<li><p>应对各种攻击手段</p>\n<ul>\n<li>SQL注入</li>\n<li>XSS攻击</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h2><h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><ul>\n<li><p>数据库唯一索引</p>\n<ul>\n<li>没有失效时间，解锁失败会造成死锁</li>\n<li>只能是非阻塞，插入失败无法重试</li>\n<li>不可重入，已获得锁的进程也必须重新获取锁</li>\n</ul>\n</li>\n<li><p>Redis的SETNX指令</p>\n<ul>\n<li>节点挂了就不可用，造成死锁</li>\n</ul>\n</li>\n<li><p>RedLock</p>\n<ul>\n<li>\b高可用</li>\n</ul>\n</li>\n<li><p>Zookeeper的有序节点</p>\n</li>\n</ul>\n<h3 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h3><ul>\n<li><p>两阶段提交（2PC）</p>\n<ul>\n<li><p>准备阶段</p>\n<ul>\n<li>协调者询问所有参与者事务执行的结果</li>\n</ul>\n</li>\n<li><p>提交阶段</p>\n<ul>\n<li>\b协调者根\b据所有参与者返回的结果判断最终是提交还是回滚</li>\n</ul>\n</li>\n<li><p>\b存在问题</p>\n<ul>\n<li>同步阻塞</li>\n<li>单点故障</li>\n<li>数据不一致</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>本地消息表</p>\n<ul>\n<li>1.\b 分布式事务操作方完成写业务数据后向本地消息表发送一个消息，\b确保这个消息一定会写入本地消息表</li>\n<li><ol start=\"2\">\n<li>之后将本地消息表中的消息转发到消息队列，转发成功则从本地消息表删除，否则继续重发</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CAP\"><a href=\"#CAP\" class=\"headerlink\" title=\"CAP\"></a>CAP</h3><ul>\n<li><p>分布式系统不可能同时满足\b</p>\n<ul>\n<li>一致性（Consistency）</li>\n<li>分区容忍性（Partition Tolerance）</li>\n<li>可用性（Availability）</li>\n</ul>\n</li>\n<li><p>权衡</p>\n<ul>\n<li>分区容忍性必不可少，可用性和一致性的权衡</li>\n<li>为了保证一致性，不能访问未同步完成的节点，就失去了部分可用性</li>\n<li>为了保证可用性，允许读取所有节点的数据，但是数据可能不一致</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"BASE\"><a href=\"#BASE\" class=\"headerlink\" title=\"BASE\"></a>BASE</h3><ul>\n<li><p>概念</p>\n<ul>\n<li><p>基本可用（Basically Available）</p>\n<ul>\n<li>\b分布式系统在\b故障的时候保证核心可用，允许\b损失部分可用性</li>\n</ul>\n</li>\n<li><p>软状态（Soft State）</p>\n<ul>\n<li>允许\b系统中的数据存在中间状态，并认为\b该中间状态不会影响整体可用性</li>\n</ul>\n</li>\n<li><p>最终一致性（Eventually Consistent）</p>\n<ul>\n<li>系统中的所有数据副本在经过一段时间的同步后，最终能达到一致性的状态</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"竞选协议\"><a href=\"#竞选协议\" class=\"headerlink\" title=\"竞选协议\"></a>竞选协议</h3><ul>\n<li><p>Paxos</p>\n<ul>\n<li><p>执行过程</p>\n<ul>\n<li><ol>\n<li>Prepare</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>Accept</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>Learn</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>约束条件</p>\n<ul>\n<li>正确性</li>\n<li>可终止性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Raft</p>\n</li>\n</ul>\n<h2 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h2><h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><ul>\n<li><p>算法</p>\n<ul>\n<li><p>轮询</p>\n<ul>\n<li>服务器性能均衡的场景</li>\n</ul>\n</li>\n<li><p>加权轮询</p>\n<ul>\n<li>轮询的基础上根据权重分配</li>\n</ul>\n</li>\n<li><p>最少连接</p>\n<ul>\n<li>将请求发送给当前最少连接的服务器上</li>\n</ul>\n</li>\n<li><p>加权最少连接</p>\n<ul>\n<li>根据权重结算最少连接</li>\n</ul>\n</li>\n<li><p>随机算法</p>\n</li>\n<li><p>源地址哈希</p>\n<ul>\n<li>对\b客户端IP计算哈希值取模</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>转发实现</p>\n<ul>\n<li><p>HTTP重定向</p>\n<ul>\n<li>返回302重新发起请求</li>\n<li>延迟高，处理能力有限</li>\n</ul>\n</li>\n<li><p>\bDNS域名解析</p>\n<ul>\n<li>解析域名同时使用负载均衡\b算法计算服务器IP</li>\n<li>优点：能根据地理位置进行域名解析，可以返回最近的服务器</li>\n<li>缺点：DNS多级缓存，当\b下线机器需要修改DNS记录，生效时间慢</li>\n</ul>\n</li>\n<li><p>反向代理</p>\n<ul>\n<li>\bOpenresty&#x2F;Nginx</li>\n<li>缺点：所有请求和响应都要经过反向代理服务器，容易成为瓶颈</li>\n</ul>\n</li>\n<li><p>网络层</p>\n</li>\n<li><p>链路层</p>\n<ul>\n<li>LVS</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Session管理\"><a href=\"#Session管理\" class=\"headerlink\" title=\"Session管理\"></a>Session管理</h3><ul>\n<li><p>Sticky Session</p>\n</li>\n<li><p>Session Replication</p>\n</li>\n<li><p>Session Server</p>\n<ul>\n<li>Redis、MySQL</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"攻击技术\"><a href=\"#攻击技术\" class=\"headerlink\" title=\"攻击技术\"></a>攻击技术</h2><h3 id=\"跨站脚本攻击：XSS（Cross-Site-Scripting）\"><a href=\"#跨站脚本攻击：XSS（Cross-Site-Scripting）\" class=\"headerlink\" title=\"跨站脚本攻击：XSS（Cross-Site Scripting）\"></a>跨站脚本攻击：XSS（Cross-Site Scripting）</h3><h3 id=\"跨站请求伪造：CSRF（Cross-Site-request-forgery）\"><a href=\"#跨站请求伪造：CSRF（Cross-Site-request-forgery）\" class=\"headerlink\" title=\"跨站请求伪造：CSRF（Cross-Site request forgery）\"></a>跨站请求伪造：CSRF（Cross-Site request forgery）</h3><ul>\n<li>检查Referer头</li>\n<li>添加token校验</li>\n<li>验证码</li>\n</ul>\n<h3 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h3><ul>\n<li>sql quote预处理</li>\n</ul>\n<h3 id=\"拒绝服务攻击（DoS、DDoS）\"><a href=\"#拒绝服务攻击（DoS、DDoS）\" class=\"headerlink\" title=\"拒绝服务攻击（DoS、DDoS）\"></a>拒绝服务攻击（DoS、DDoS）</h3><h2 id=\"一致性哈希\"><a href=\"#一致性哈希\" class=\"headerlink\" title=\"一致性哈希\"></a>一致性哈希</h2><h3 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h3><ul>\n<li>将哈希空间看做一个环，每个节点都配置在环上，每个数据对象通过哈希取模得到哈希值后，顺时针向前走，存放在碰到第一个节点上</li>\n</ul>\n<h3 id=\"分布不均问题\"><a href=\"#分布不均问题\" class=\"headerlink\" title=\"分布不均问题\"></a>分布不均问题</h3><ul>\n<li>虚拟节点解决</li>\n</ul>\n<h2 id=\"LRU\"><a href=\"#LRU\" class=\"headerlink\" title=\"LRU\"></a>LRU</h2><h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><h3 id=\"消息模型\"><a href=\"#消息模型\" class=\"headerlink\" title=\"消息模型\"></a>消息模型</h3><ul>\n<li><p>点对点</p>\n<ul>\n<li>生产者向MQ中发送了一个消息后，只能被一个消费者消费一次</li>\n</ul>\n</li>\n<li><p>发布&#x2F;订阅</p>\n<ul>\n<li>生产者向频道发送了一个消息后，多个消费者可以从该频道订阅这条消息并消费</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ul>\n<li>异步处理</li>\n<li>流量削峰</li>\n<li>应用解耦</li>\n</ul>\n<h3 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h3><ul>\n<li><p>发送端可靠性</p>\n<ul>\n<li>本地消息表</li>\n</ul>\n</li>\n<li><p>接收端可靠性</p>\n<ul>\n<li>幂等性</li>\n<li>唯一消息ID</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">【参考文章】GitHub-CyC2018&#x2F;CS-Notes</a></p>\n"},{"title":"数据库和缓存数据一致性问题如何解决?","date":"2023-03-25T07:24:43.000Z","_content":"业务使用Redis做缓存，当有数据更新时，如何保证缓存及时更新\n\n## 读数据流程\n请求到来，业务代码会先查Redis，查不到再去查DB，并将结果写入Redis\n\n## 写数据方案\n\n### 1. 先删除缓存，再更新DB\n\n#### 可行性\n先删除缓存，再更新DB，下次读请求到来会从数据库查到新的数据更新到缓存中。如果先更新缓存，在更新DB，更新DB失败会导致数据不一致。\n\n#### 问题\n##### 容灾不足\n如果删除缓存失败的情况，如果业务继续进行，更新DB，那么在缓存过期之前仍然查到的是旧数据。如果业务返回失败，则对Redis变成了强依赖。\n\n##### 并发不安全\n考虑如下场景：\n1. A请求删除缓存，A请求更新DB\n2. B请求查询缓存，不存在\n3. B请求查询DB，查到旧数据（更新未完成），写入缓存\n4. A请求更新DB完成\n\n这就导致缓存中仍存的旧数据，数据不一致。\n\n### 2. 先更新DB，再删除缓存\n\n这种策略解决了方法1中的并发问题，但是还是有极小可能存在并发问题，考虑如下情况：\n1. 请求A查询缓存，缓存刚好失效\n2. 请求A查询DB，得到一个旧值\n3. 请求B更新数据库\n4. 请求B删除缓存\n5. 请求A将查到的旧值写入缓存\n\n这种情况确实会产生数据不一致，但是考虑到DB的读操作总是比写操作快的多，这种场景基本不可能出现。\n\n#### 如何杜绝并发问题\n延迟异步删，保证读操作完成后再删除缓存。\n\n#### 如何容灾\n上述方案中如果删除缓存失败了怎么办？\n\n##### 引入消息队列\n1. 更新DB\n2. 删除缓存，如果失败将要删除的key发送至消息队列\n3. 消费消息，获得需要删除的key，删除key缓存直到成功\n\n##### 订阅binlog\n上述方法对业务代码的侵入性比较大，为此可以启动一个程序订阅MySQL的binlog用来发现数据更新，流程如下：\n1. 业务代码更新数据库，MySQL将更新操作写入binlog\n2. 订阅程序提取中更新的数据以及key，尝试删除key的缓存\n3. 如果删除缓存失败，将key发送至消息队列\n4. 消费者程序从消息队列中获取待删除的key，重试删除直到成功。\n\n## 参考\n【1】[Redis与Mysql双写一致性方案解析](https://zhuanlan.zhihu.com/p/59167071)\n","source":"_posts/2023/03-25-数据库和缓存数据一致性问题如何解决.md","raw":"---\ntitle: 数据库和缓存数据一致性问题如何解决?\ndate: 2023-03-25 15:24:43\ncategories:\n- [分布式系统]\ntags:\n- 一致性\n- Cache-Aside\n---\n业务使用Redis做缓存，当有数据更新时，如何保证缓存及时更新\n\n## 读数据流程\n请求到来，业务代码会先查Redis，查不到再去查DB，并将结果写入Redis\n\n## 写数据方案\n\n### 1. 先删除缓存，再更新DB\n\n#### 可行性\n先删除缓存，再更新DB，下次读请求到来会从数据库查到新的数据更新到缓存中。如果先更新缓存，在更新DB，更新DB失败会导致数据不一致。\n\n#### 问题\n##### 容灾不足\n如果删除缓存失败的情况，如果业务继续进行，更新DB，那么在缓存过期之前仍然查到的是旧数据。如果业务返回失败，则对Redis变成了强依赖。\n\n##### 并发不安全\n考虑如下场景：\n1. A请求删除缓存，A请求更新DB\n2. B请求查询缓存，不存在\n3. B请求查询DB，查到旧数据（更新未完成），写入缓存\n4. A请求更新DB完成\n\n这就导致缓存中仍存的旧数据，数据不一致。\n\n### 2. 先更新DB，再删除缓存\n\n这种策略解决了方法1中的并发问题，但是还是有极小可能存在并发问题，考虑如下情况：\n1. 请求A查询缓存，缓存刚好失效\n2. 请求A查询DB，得到一个旧值\n3. 请求B更新数据库\n4. 请求B删除缓存\n5. 请求A将查到的旧值写入缓存\n\n这种情况确实会产生数据不一致，但是考虑到DB的读操作总是比写操作快的多，这种场景基本不可能出现。\n\n#### 如何杜绝并发问题\n延迟异步删，保证读操作完成后再删除缓存。\n\n#### 如何容灾\n上述方案中如果删除缓存失败了怎么办？\n\n##### 引入消息队列\n1. 更新DB\n2. 删除缓存，如果失败将要删除的key发送至消息队列\n3. 消费消息，获得需要删除的key，删除key缓存直到成功\n\n##### 订阅binlog\n上述方法对业务代码的侵入性比较大，为此可以启动一个程序订阅MySQL的binlog用来发现数据更新，流程如下：\n1. 业务代码更新数据库，MySQL将更新操作写入binlog\n2. 订阅程序提取中更新的数据以及key，尝试删除key的缓存\n3. 如果删除缓存失败，将key发送至消息队列\n4. 消费者程序从消息队列中获取待删除的key，重试删除直到成功。\n\n## 参考\n【1】[Redis与Mysql双写一致性方案解析](https://zhuanlan.zhihu.com/p/59167071)\n","slug":"数据库和缓存数据一致性问题如何解决","published":1,"updated":"2023-03-25T07:31:36.643Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywy002ivhfie499e6nm","content":"<p>业务使用Redis做缓存，当有数据更新时，如何保证缓存及时更新</p>\n<h2 id=\"读数据流程\"><a href=\"#读数据流程\" class=\"headerlink\" title=\"读数据流程\"></a>读数据流程</h2><p>请求到来，业务代码会先查Redis，查不到再去查DB，并将结果写入Redis</p>\n<h2 id=\"写数据方案\"><a href=\"#写数据方案\" class=\"headerlink\" title=\"写数据方案\"></a>写数据方案</h2><h3 id=\"1-先删除缓存，再更新DB\"><a href=\"#1-先删除缓存，再更新DB\" class=\"headerlink\" title=\"1. 先删除缓存，再更新DB\"></a>1. 先删除缓存，再更新DB</h3><h4 id=\"可行性\"><a href=\"#可行性\" class=\"headerlink\" title=\"可行性\"></a>可行性</h4><p>先删除缓存，再更新DB，下次读请求到来会从数据库查到新的数据更新到缓存中。如果先更新缓存，在更新DB，更新DB失败会导致数据不一致。</p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><h5 id=\"容灾不足\"><a href=\"#容灾不足\" class=\"headerlink\" title=\"容灾不足\"></a>容灾不足</h5><p>如果删除缓存失败的情况，如果业务继续进行，更新DB，那么在缓存过期之前仍然查到的是旧数据。如果业务返回失败，则对Redis变成了强依赖。</p>\n<h5 id=\"并发不安全\"><a href=\"#并发不安全\" class=\"headerlink\" title=\"并发不安全\"></a>并发不安全</h5><p>考虑如下场景：</p>\n<ol>\n<li>A请求删除缓存，A请求更新DB</li>\n<li>B请求查询缓存，不存在</li>\n<li>B请求查询DB，查到旧数据（更新未完成），写入缓存</li>\n<li>A请求更新DB完成</li>\n</ol>\n<p>这就导致缓存中仍存的旧数据，数据不一致。</p>\n<h3 id=\"2-先更新DB，再删除缓存\"><a href=\"#2-先更新DB，再删除缓存\" class=\"headerlink\" title=\"2. 先更新DB，再删除缓存\"></a>2. 先更新DB，再删除缓存</h3><p>这种策略解决了方法1中的并发问题，但是还是有极小可能存在并发问题，考虑如下情况：</p>\n<ol>\n<li>请求A查询缓存，缓存刚好失效</li>\n<li>请求A查询DB，得到一个旧值</li>\n<li>请求B更新数据库</li>\n<li>请求B删除缓存</li>\n<li>请求A将查到的旧值写入缓存</li>\n</ol>\n<p>这种情况确实会产生数据不一致，但是考虑到DB的读操作总是比写操作快的多，这种场景基本不可能出现。</p>\n<h4 id=\"如何杜绝并发问题\"><a href=\"#如何杜绝并发问题\" class=\"headerlink\" title=\"如何杜绝并发问题\"></a>如何杜绝并发问题</h4><p>延迟异步删，保证读操作完成后再删除缓存。</p>\n<h4 id=\"如何容灾\"><a href=\"#如何容灾\" class=\"headerlink\" title=\"如何容灾\"></a>如何容灾</h4><p>上述方案中如果删除缓存失败了怎么办？</p>\n<h5 id=\"引入消息队列\"><a href=\"#引入消息队列\" class=\"headerlink\" title=\"引入消息队列\"></a>引入消息队列</h5><ol>\n<li>更新DB</li>\n<li>删除缓存，如果失败将要删除的key发送至消息队列</li>\n<li>消费消息，获得需要删除的key，删除key缓存直到成功</li>\n</ol>\n<h5 id=\"订阅binlog\"><a href=\"#订阅binlog\" class=\"headerlink\" title=\"订阅binlog\"></a>订阅binlog</h5><p>上述方法对业务代码的侵入性比较大，为此可以启动一个程序订阅MySQL的binlog用来发现数据更新，流程如下：</p>\n<ol>\n<li>业务代码更新数据库，MySQL将更新操作写入binlog</li>\n<li>订阅程序提取中更新的数据以及key，尝试删除key的缓存</li>\n<li>如果删除缓存失败，将key发送至消息队列</li>\n<li>消费者程序从消息队列中获取待删除的key，重试删除直到成功。</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://zhuanlan.zhihu.com/p/59167071\">Redis与Mysql双写一致性方案解析</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>业务使用Redis做缓存，当有数据更新时，如何保证缓存及时更新</p>\n<h2 id=\"读数据流程\"><a href=\"#读数据流程\" class=\"headerlink\" title=\"读数据流程\"></a>读数据流程</h2><p>请求到来，业务代码会先查Redis，查不到再去查DB，并将结果写入Redis</p>\n<h2 id=\"写数据方案\"><a href=\"#写数据方案\" class=\"headerlink\" title=\"写数据方案\"></a>写数据方案</h2><h3 id=\"1-先删除缓存，再更新DB\"><a href=\"#1-先删除缓存，再更新DB\" class=\"headerlink\" title=\"1. 先删除缓存，再更新DB\"></a>1. 先删除缓存，再更新DB</h3><h4 id=\"可行性\"><a href=\"#可行性\" class=\"headerlink\" title=\"可行性\"></a>可行性</h4><p>先删除缓存，再更新DB，下次读请求到来会从数据库查到新的数据更新到缓存中。如果先更新缓存，在更新DB，更新DB失败会导致数据不一致。</p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><h5 id=\"容灾不足\"><a href=\"#容灾不足\" class=\"headerlink\" title=\"容灾不足\"></a>容灾不足</h5><p>如果删除缓存失败的情况，如果业务继续进行，更新DB，那么在缓存过期之前仍然查到的是旧数据。如果业务返回失败，则对Redis变成了强依赖。</p>\n<h5 id=\"并发不安全\"><a href=\"#并发不安全\" class=\"headerlink\" title=\"并发不安全\"></a>并发不安全</h5><p>考虑如下场景：</p>\n<ol>\n<li>A请求删除缓存，A请求更新DB</li>\n<li>B请求查询缓存，不存在</li>\n<li>B请求查询DB，查到旧数据（更新未完成），写入缓存</li>\n<li>A请求更新DB完成</li>\n</ol>\n<p>这就导致缓存中仍存的旧数据，数据不一致。</p>\n<h3 id=\"2-先更新DB，再删除缓存\"><a href=\"#2-先更新DB，再删除缓存\" class=\"headerlink\" title=\"2. 先更新DB，再删除缓存\"></a>2. 先更新DB，再删除缓存</h3><p>这种策略解决了方法1中的并发问题，但是还是有极小可能存在并发问题，考虑如下情况：</p>\n<ol>\n<li>请求A查询缓存，缓存刚好失效</li>\n<li>请求A查询DB，得到一个旧值</li>\n<li>请求B更新数据库</li>\n<li>请求B删除缓存</li>\n<li>请求A将查到的旧值写入缓存</li>\n</ol>\n<p>这种情况确实会产生数据不一致，但是考虑到DB的读操作总是比写操作快的多，这种场景基本不可能出现。</p>\n<h4 id=\"如何杜绝并发问题\"><a href=\"#如何杜绝并发问题\" class=\"headerlink\" title=\"如何杜绝并发问题\"></a>如何杜绝并发问题</h4><p>延迟异步删，保证读操作完成后再删除缓存。</p>\n<h4 id=\"如何容灾\"><a href=\"#如何容灾\" class=\"headerlink\" title=\"如何容灾\"></a>如何容灾</h4><p>上述方案中如果删除缓存失败了怎么办？</p>\n<h5 id=\"引入消息队列\"><a href=\"#引入消息队列\" class=\"headerlink\" title=\"引入消息队列\"></a>引入消息队列</h5><ol>\n<li>更新DB</li>\n<li>删除缓存，如果失败将要删除的key发送至消息队列</li>\n<li>消费消息，获得需要删除的key，删除key缓存直到成功</li>\n</ol>\n<h5 id=\"订阅binlog\"><a href=\"#订阅binlog\" class=\"headerlink\" title=\"订阅binlog\"></a>订阅binlog</h5><p>上述方法对业务代码的侵入性比较大，为此可以启动一个程序订阅MySQL的binlog用来发现数据更新，流程如下：</p>\n<ol>\n<li>业务代码更新数据库，MySQL将更新操作写入binlog</li>\n<li>订阅程序提取中更新的数据以及key，尝试删除key的缓存</li>\n<li>如果删除缓存失败，将key发送至消息队列</li>\n<li>消费者程序从消息队列中获取待删除的key，重试删除直到成功。</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://zhuanlan.zhihu.com/p/59167071\">Redis与Mysql双写一致性方案解析</a></p>\n"},{"title":"数据库基础知识概述","date":"2023-03-25T07:10:28.000Z","_content":"### 事务\n\n- ACID\n\n\t- 原子性\n\t- 隔离性\n\t- 一致性\n\t- 持久性\n\n\t\t- 应对系统崩溃，可以用Redo Log恢复\n\n- AUTOCOMMIT：MySQL默认采用自动提交，不显示start transaction，每个查询都会被当成一个事务执行并自动提交\n\n### 并发一致性问题\n\n- 丢失修改\n- 脏读\n- 不可重复读\n- 幻读\n\n\t- insert操作引起\n\n### 锁\n\n- 锁粒度\n\n\t- 行锁\n\t- 表锁\n\n- 锁类型\n\n\t- 读写锁\n\n\t\t- 互斥锁（X锁、写锁）\n\t\t- 共享锁（S锁、读锁）\n\t\t- 一个事务对数据A加了X锁，期间其他事务不能对A加任何锁\n一个事务对数据A加了S锁，其他事务可以对A加S锁，但是不能加X锁\n\n\t- 意向锁\n\n\t\t- 可以更容易支持多粒度加锁\n\t\t- IX/IS锁，表示一个事务想要再表中的某个数据行上加X/S锁\n\n\t\t\t- 一个事务再获得某个数据行的S锁之前，必须先获得表的IS锁或更强的锁\n\t\t\t- 一个事务在获得某个数据行的X锁之前，必须先获得表的IX锁\n\t\t\t- 任意IS/IX锁之间都是兼容的\n\n- 封锁协议\n\n\t- 一级：事务T要修改A时必须加X锁，直到T结束才释放（解决丢失修改问题）\n\t- 二级：在一级基础上事务T要读取A时必须加S锁，读取完立即释放锁（解决脏读问题）\n\t- 三级：在二级的基础上，要求读取A时必须加S锁，直到事务结束才释放（解决不可重复读问题）\n\t- 两段锁协议：加锁和解锁分两个阶段进行，保证可串行化调度\n\n### 事务隔离级别\n\n- 读未提交（RU）\n- 读提交（RC）\n- 可重复度（RR）\n- 可串行化（Serializable）\n\n### 多版本并发控制（MVCC）\n\n- 版本号\n\n\t- 系统版本号SYS_ID:每开启一个新事务时递增\n\t- 事务版本号TRX_ID:事务开启时的系统版本号\n\n- ReadView\n\n\t- 当前系统未提交的事务列表，以及最大ID和最小ID\n\n- 快照读：SELECT，不需要进行加锁\n- 当前读：INSERT、UPDATE、DELETE，需要加锁\n- SELECT时可以显式指定加锁\n\n\t- select * from table where ? lock in share mode;(S锁)\n\t- select * from table where ? for update;(X锁)\n\n### Next-Key Locks\n\n- 可重复读级别下，使用MVCC+Next-Key Lock可以解决幻读\n- Record Locks: 锁定一个记录上的索引\n- Gap Locks：锁定索引之间的间隙，但是不包括索引本身\n\n### 关系数据库\n\n- 异常\n\n\t- 冗余数据、修改异常、删除异常、插入异常\n\n- 范式\n\n\t- 为了解决异常\n\t- 第一范式：属性不可分割\n\t- 第二范式：非主属性完全依赖于键码\n\t- 第三范式：非主属性不传递函数依赖于键码\n\n[【参考文章】GitHub-CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes)\n","source":"_posts/2023/03-25-数据库基础知识概述.md","raw":"---\ntitle: 数据库基础知识概述\ndate: 2023-03-25 15:10:28\ncategories:\n- [数据库]\ntags:\n- MySQL\n---\n### 事务\n\n- ACID\n\n\t- 原子性\n\t- 隔离性\n\t- 一致性\n\t- 持久性\n\n\t\t- 应对系统崩溃，可以用Redo Log恢复\n\n- AUTOCOMMIT：MySQL默认采用自动提交，不显示start transaction，每个查询都会被当成一个事务执行并自动提交\n\n### 并发一致性问题\n\n- 丢失修改\n- 脏读\n- 不可重复读\n- 幻读\n\n\t- insert操作引起\n\n### 锁\n\n- 锁粒度\n\n\t- 行锁\n\t- 表锁\n\n- 锁类型\n\n\t- 读写锁\n\n\t\t- 互斥锁（X锁、写锁）\n\t\t- 共享锁（S锁、读锁）\n\t\t- 一个事务对数据A加了X锁，期间其他事务不能对A加任何锁\n一个事务对数据A加了S锁，其他事务可以对A加S锁，但是不能加X锁\n\n\t- 意向锁\n\n\t\t- 可以更容易支持多粒度加锁\n\t\t- IX/IS锁，表示一个事务想要再表中的某个数据行上加X/S锁\n\n\t\t\t- 一个事务再获得某个数据行的S锁之前，必须先获得表的IS锁或更强的锁\n\t\t\t- 一个事务在获得某个数据行的X锁之前，必须先获得表的IX锁\n\t\t\t- 任意IS/IX锁之间都是兼容的\n\n- 封锁协议\n\n\t- 一级：事务T要修改A时必须加X锁，直到T结束才释放（解决丢失修改问题）\n\t- 二级：在一级基础上事务T要读取A时必须加S锁，读取完立即释放锁（解决脏读问题）\n\t- 三级：在二级的基础上，要求读取A时必须加S锁，直到事务结束才释放（解决不可重复读问题）\n\t- 两段锁协议：加锁和解锁分两个阶段进行，保证可串行化调度\n\n### 事务隔离级别\n\n- 读未提交（RU）\n- 读提交（RC）\n- 可重复度（RR）\n- 可串行化（Serializable）\n\n### 多版本并发控制（MVCC）\n\n- 版本号\n\n\t- 系统版本号SYS_ID:每开启一个新事务时递增\n\t- 事务版本号TRX_ID:事务开启时的系统版本号\n\n- ReadView\n\n\t- 当前系统未提交的事务列表，以及最大ID和最小ID\n\n- 快照读：SELECT，不需要进行加锁\n- 当前读：INSERT、UPDATE、DELETE，需要加锁\n- SELECT时可以显式指定加锁\n\n\t- select * from table where ? lock in share mode;(S锁)\n\t- select * from table where ? for update;(X锁)\n\n### Next-Key Locks\n\n- 可重复读级别下，使用MVCC+Next-Key Lock可以解决幻读\n- Record Locks: 锁定一个记录上的索引\n- Gap Locks：锁定索引之间的间隙，但是不包括索引本身\n\n### 关系数据库\n\n- 异常\n\n\t- 冗余数据、修改异常、删除异常、插入异常\n\n- 范式\n\n\t- 为了解决异常\n\t- 第一范式：属性不可分割\n\t- 第二范式：非主属性完全依赖于键码\n\t- 第三范式：非主属性不传递函数依赖于键码\n\n[【参考文章】GitHub-CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes)\n","slug":"数据库基础知识概述","published":1,"updated":"2023-03-25T07:25:00.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpywz002lvhfi6dc1e20n","content":"<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><ul>\n<li><p>ACID</p>\n<ul>\n<li><p>原子性</p>\n</li>\n<li><p>隔离性</p>\n</li>\n<li><p>一致性</p>\n</li>\n<li><p>持久性</p>\n<ul>\n<li>应对系统崩溃，可以用Redo Log恢复</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AUTOCOMMIT：MySQL默认采用自动提交，不显示start transaction，每个查询都会被当成一个事务执行并自动提交</p>\n</li>\n</ul>\n<h3 id=\"并发一致性问题\"><a href=\"#并发一致性问题\" class=\"headerlink\" title=\"并发一致性问题\"></a>并发一致性问题</h3><ul>\n<li><p>丢失修改</p>\n</li>\n<li><p>脏读</p>\n</li>\n<li><p>不可重复读</p>\n</li>\n<li><p>幻读</p>\n<ul>\n<li>insert操作引起</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h3><ul>\n<li><p>锁粒度</p>\n<ul>\n<li>行锁</li>\n<li>表锁</li>\n</ul>\n</li>\n<li><p>锁类型</p>\n<ul>\n<li><p>读写锁</p>\n<ul>\n<li>互斥锁（X锁、写锁）</li>\n<li>共享锁（S锁、读锁）</li>\n<li>一个事务对数据A加了X锁，期间其他事务不能对A加任何锁</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>一个事务对数据A加了S锁，其他事务可以对A加S锁，但是不能加X锁</p>\n<pre><code>- 意向锁\n\n    - 可以更容易支持多粒度加锁\n    - IX/IS锁，表示一个事务想要再表中的某个数据行上加X/S锁\n\n        - 一个事务再获得某个数据行的S锁之前，必须先获得表的IS锁或更强的锁\n        - 一个事务在获得某个数据行的X锁之前，必须先获得表的IX锁\n        - 任意IS/IX锁之间都是兼容的\n</code></pre>\n<ul>\n<li><p>封锁协议</p>\n<ul>\n<li>一级：事务T要修改A时必须加X锁，直到T结束才释放（解决丢失修改问题）</li>\n<li>二级：在一级基础上事务T要读取A时必须加S锁，读取完立即释放锁（解决脏读问题）</li>\n<li>三级：在二级的基础上，要求读取A时必须加S锁，直到事务结束才释放（解决不可重复读问题）</li>\n<li>两段锁协议：加锁和解锁分两个阶段进行，保证可串行化调度</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h3><ul>\n<li>读未提交（RU）</li>\n<li>读提交（RC）</li>\n<li>可重复度（RR）</li>\n<li>可串行化（Serializable）</li>\n</ul>\n<h3 id=\"多版本并发控制（MVCC）\"><a href=\"#多版本并发控制（MVCC）\" class=\"headerlink\" title=\"多版本并发控制（MVCC）\"></a>多版本并发控制（MVCC）</h3><ul>\n<li><p>版本号</p>\n<ul>\n<li>系统版本号SYS_ID:每开启一个新事务时递增</li>\n<li>事务版本号TRX_ID:事务开启时的系统版本号</li>\n</ul>\n</li>\n<li><p>ReadView</p>\n<ul>\n<li>当前系统未提交的事务列表，以及最大ID和最小ID</li>\n</ul>\n</li>\n<li><p>快照读：SELECT，不需要进行加锁</p>\n</li>\n<li><p>当前读：INSERT、UPDATE、DELETE，需要加锁</p>\n</li>\n<li><p>SELECT时可以显式指定加锁</p>\n<ul>\n<li>select * from table where ? lock in share mode;(S锁)</li>\n<li>select * from table where ? for update;(X锁)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Next-Key-Locks\"><a href=\"#Next-Key-Locks\" class=\"headerlink\" title=\"Next-Key Locks\"></a>Next-Key Locks</h3><ul>\n<li>可重复读级别下，使用MVCC+Next-Key Lock可以解决幻读</li>\n<li>Record Locks: 锁定一个记录上的索引</li>\n<li>Gap Locks：锁定索引之间的间隙，但是不包括索引本身</li>\n</ul>\n<h3 id=\"关系数据库\"><a href=\"#关系数据库\" class=\"headerlink\" title=\"关系数据库\"></a>关系数据库</h3><ul>\n<li><p>异常</p>\n<ul>\n<li>冗余数据、修改异常、删除异常、插入异常</li>\n</ul>\n</li>\n<li><p>范式</p>\n<ul>\n<li>为了解决异常</li>\n<li>第一范式：属性不可分割</li>\n<li>第二范式：非主属性完全依赖于键码</li>\n<li>第三范式：非主属性不传递函数依赖于键码</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">【参考文章】GitHub-CyC2018&#x2F;CS-Notes</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><ul>\n<li><p>ACID</p>\n<ul>\n<li><p>原子性</p>\n</li>\n<li><p>隔离性</p>\n</li>\n<li><p>一致性</p>\n</li>\n<li><p>持久性</p>\n<ul>\n<li>应对系统崩溃，可以用Redo Log恢复</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AUTOCOMMIT：MySQL默认采用自动提交，不显示start transaction，每个查询都会被当成一个事务执行并自动提交</p>\n</li>\n</ul>\n<h3 id=\"并发一致性问题\"><a href=\"#并发一致性问题\" class=\"headerlink\" title=\"并发一致性问题\"></a>并发一致性问题</h3><ul>\n<li><p>丢失修改</p>\n</li>\n<li><p>脏读</p>\n</li>\n<li><p>不可重复读</p>\n</li>\n<li><p>幻读</p>\n<ul>\n<li>insert操作引起</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h3><ul>\n<li><p>锁粒度</p>\n<ul>\n<li>行锁</li>\n<li>表锁</li>\n</ul>\n</li>\n<li><p>锁类型</p>\n<ul>\n<li><p>读写锁</p>\n<ul>\n<li>互斥锁（X锁、写锁）</li>\n<li>共享锁（S锁、读锁）</li>\n<li>一个事务对数据A加了X锁，期间其他事务不能对A加任何锁</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>一个事务对数据A加了S锁，其他事务可以对A加S锁，但是不能加X锁</p>\n<pre><code>- 意向锁\n\n    - 可以更容易支持多粒度加锁\n    - IX/IS锁，表示一个事务想要再表中的某个数据行上加X/S锁\n\n        - 一个事务再获得某个数据行的S锁之前，必须先获得表的IS锁或更强的锁\n        - 一个事务在获得某个数据行的X锁之前，必须先获得表的IX锁\n        - 任意IS/IX锁之间都是兼容的\n</code></pre>\n<ul>\n<li><p>封锁协议</p>\n<ul>\n<li>一级：事务T要修改A时必须加X锁，直到T结束才释放（解决丢失修改问题）</li>\n<li>二级：在一级基础上事务T要读取A时必须加S锁，读取完立即释放锁（解决脏读问题）</li>\n<li>三级：在二级的基础上，要求读取A时必须加S锁，直到事务结束才释放（解决不可重复读问题）</li>\n<li>两段锁协议：加锁和解锁分两个阶段进行，保证可串行化调度</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h3><ul>\n<li>读未提交（RU）</li>\n<li>读提交（RC）</li>\n<li>可重复度（RR）</li>\n<li>可串行化（Serializable）</li>\n</ul>\n<h3 id=\"多版本并发控制（MVCC）\"><a href=\"#多版本并发控制（MVCC）\" class=\"headerlink\" title=\"多版本并发控制（MVCC）\"></a>多版本并发控制（MVCC）</h3><ul>\n<li><p>版本号</p>\n<ul>\n<li>系统版本号SYS_ID:每开启一个新事务时递增</li>\n<li>事务版本号TRX_ID:事务开启时的系统版本号</li>\n</ul>\n</li>\n<li><p>ReadView</p>\n<ul>\n<li>当前系统未提交的事务列表，以及最大ID和最小ID</li>\n</ul>\n</li>\n<li><p>快照读：SELECT，不需要进行加锁</p>\n</li>\n<li><p>当前读：INSERT、UPDATE、DELETE，需要加锁</p>\n</li>\n<li><p>SELECT时可以显式指定加锁</p>\n<ul>\n<li>select * from table where ? lock in share mode;(S锁)</li>\n<li>select * from table where ? for update;(X锁)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Next-Key-Locks\"><a href=\"#Next-Key-Locks\" class=\"headerlink\" title=\"Next-Key Locks\"></a>Next-Key Locks</h3><ul>\n<li>可重复读级别下，使用MVCC+Next-Key Lock可以解决幻读</li>\n<li>Record Locks: 锁定一个记录上的索引</li>\n<li>Gap Locks：锁定索引之间的间隙，但是不包括索引本身</li>\n</ul>\n<h3 id=\"关系数据库\"><a href=\"#关系数据库\" class=\"headerlink\" title=\"关系数据库\"></a>关系数据库</h3><ul>\n<li><p>异常</p>\n<ul>\n<li>冗余数据、修改异常、删除异常、插入异常</li>\n</ul>\n</li>\n<li><p>范式</p>\n<ul>\n<li>为了解决异常</li>\n<li>第一范式：属性不可分割</li>\n<li>第二范式：非主属性完全依赖于键码</li>\n<li>第三范式：非主属性不传递函数依赖于键码</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">【参考文章】GitHub-CyC2018&#x2F;CS-Notes</a></p>\n"},{"title":"无处不在的微服务","date":"2023-03-25T07:23:00.000Z","_content":"## 概念\n\n### 基本定义\n\n- 微服务就是一些协同工作的小而自治的服务\n\n### 服务注册与发现\n\n- 微服务之间互相调用，服务发现需要管理各个服务的服务器地址，当进行扩容或摘除时能及时更新\n\n### 服务监控\n\n- 监控、日志、调用链、告警通知、健康检查\n\n### 服务容错\n\n- 熔断\n- 切换\n- 限流和降级\n- 重试\n\n### 服务安全\n\n- 敏感服务进行身份验证和授权\n\n\t- HTTPS传输\n\t- 隐私数据加密存储\n\n### 服务治理\n\n- 引入微服务框架\n\n## 相比单体架构\n\n### 优点\n\n- 技术异构性\n\n\t- 不同服务内部可以选择不同的语言开发，也可以选择适合各自服务的数据库（MySQL、Redis）\n\n- 隔离性\n\n\t- 一个服务不可用不会导致整个系统或其他服务不可用，各个服务相互独立的\n\n- 可扩展性\n\n\t- 可以只对影响性能的瓶颈资源进行扩展升级\n\n- 简化部署\n\n\t- 单个服务的修改迭代只需要发步自己的改动\n\n- 易优化\n\n\t- 代码量不会很大，重构相对容易且改动带来的影响可控\n\n### 缺点\n\n- 管理复杂\n- 难定位问题\n\n## 微服务框架\n\n### Dubbo\n\n- 阿里\n- 仅支持Java语言\n\n### Tars\n\n- 腾讯\n- 仅支持C++语言\n\n### Motan\n\n- 微博\n- 仅支持Java\n\n### gRPC\n\n- 谷歌\n- 支持多种语言\n\n### thrift\n\n- Facebook\n- 支持多种语言\n\n## 微服务框架和RPC\n\n### RPC（Remote Procedure Call）\n\n- 允许像调用本地函数一样调用另一个程序的函数（C/S模式）\n\n### 微服务框架\n\n- 微服务框架一般都包含了RPC的实现和一系列的服务治理能力，是一套软件开发框架，可以基于这个框架实现自己的服务，方便的利用框架提供的服务治理和RPC能力，微服务框架也被某些人称为RPC框架\n\n## 下一代微服务架构\n\n### 服务网格（Service Mesh）\n\n- 特点\n\n\t- 应用程序间通讯中间层\n\t- 轻量级网络代理\n\t- 应用程序无感知\n\t- 解耦应用程序的重试/超时、监控、追踪和服务发现\n\n- Service Mesh之于微服务，类似TCP/IP之于网络通信\n\n[【参考资料】知乎：微服务架构是什么？](https://www.zhihu.com/question/65502802)\n","source":"_posts/2023/03-25-无处不在的微服务.md","raw":"---\ntitle: 无处不在的微服务\ndate: 2023-03-25 15:23:00\ncategories:\n- [分布式系统]\n- [微服务]\ntags:\n- 微服务\n---\n## 概念\n\n### 基本定义\n\n- 微服务就是一些协同工作的小而自治的服务\n\n### 服务注册与发现\n\n- 微服务之间互相调用，服务发现需要管理各个服务的服务器地址，当进行扩容或摘除时能及时更新\n\n### 服务监控\n\n- 监控、日志、调用链、告警通知、健康检查\n\n### 服务容错\n\n- 熔断\n- 切换\n- 限流和降级\n- 重试\n\n### 服务安全\n\n- 敏感服务进行身份验证和授权\n\n\t- HTTPS传输\n\t- 隐私数据加密存储\n\n### 服务治理\n\n- 引入微服务框架\n\n## 相比单体架构\n\n### 优点\n\n- 技术异构性\n\n\t- 不同服务内部可以选择不同的语言开发，也可以选择适合各自服务的数据库（MySQL、Redis）\n\n- 隔离性\n\n\t- 一个服务不可用不会导致整个系统或其他服务不可用，各个服务相互独立的\n\n- 可扩展性\n\n\t- 可以只对影响性能的瓶颈资源进行扩展升级\n\n- 简化部署\n\n\t- 单个服务的修改迭代只需要发步自己的改动\n\n- 易优化\n\n\t- 代码量不会很大，重构相对容易且改动带来的影响可控\n\n### 缺点\n\n- 管理复杂\n- 难定位问题\n\n## 微服务框架\n\n### Dubbo\n\n- 阿里\n- 仅支持Java语言\n\n### Tars\n\n- 腾讯\n- 仅支持C++语言\n\n### Motan\n\n- 微博\n- 仅支持Java\n\n### gRPC\n\n- 谷歌\n- 支持多种语言\n\n### thrift\n\n- Facebook\n- 支持多种语言\n\n## 微服务框架和RPC\n\n### RPC（Remote Procedure Call）\n\n- 允许像调用本地函数一样调用另一个程序的函数（C/S模式）\n\n### 微服务框架\n\n- 微服务框架一般都包含了RPC的实现和一系列的服务治理能力，是一套软件开发框架，可以基于这个框架实现自己的服务，方便的利用框架提供的服务治理和RPC能力，微服务框架也被某些人称为RPC框架\n\n## 下一代微服务架构\n\n### 服务网格（Service Mesh）\n\n- 特点\n\n\t- 应用程序间通讯中间层\n\t- 轻量级网络代理\n\t- 应用程序无感知\n\t- 解耦应用程序的重试/超时、监控、追踪和服务发现\n\n- Service Mesh之于微服务，类似TCP/IP之于网络通信\n\n[【参考资料】知乎：微服务架构是什么？](https://www.zhihu.com/question/65502802)\n","slug":"无处不在的微服务","published":1,"updated":"2023-03-25T07:35:40.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyx0002nvhfi74rp1t2d","content":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h3><ul>\n<li>微服务就是一些协同工作的小而自治的服务</li>\n</ul>\n<h3 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h3><ul>\n<li>微服务之间互相调用，服务发现需要管理各个服务的服务器地址，当进行扩容或摘除时能及时更新</li>\n</ul>\n<h3 id=\"服务监控\"><a href=\"#服务监控\" class=\"headerlink\" title=\"服务监控\"></a>服务监控</h3><ul>\n<li>监控、日志、调用链、告警通知、健康检查</li>\n</ul>\n<h3 id=\"服务容错\"><a href=\"#服务容错\" class=\"headerlink\" title=\"服务容错\"></a>服务容错</h3><ul>\n<li>熔断</li>\n<li>切换</li>\n<li>限流和降级</li>\n<li>重试</li>\n</ul>\n<h3 id=\"服务安全\"><a href=\"#服务安全\" class=\"headerlink\" title=\"服务安全\"></a>服务安全</h3><ul>\n<li><p>敏感服务进行身份验证和授权</p>\n<ul>\n<li>HTTPS传输</li>\n<li>隐私数据加密存储</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h3><ul>\n<li>引入微服务框架</li>\n</ul>\n<h2 id=\"相比单体架构\"><a href=\"#相比单体架构\" class=\"headerlink\" title=\"相比单体架构\"></a>相比单体架构</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li><p>技术异构性</p>\n<ul>\n<li>不同服务内部可以选择不同的语言开发，也可以选择适合各自服务的数据库（MySQL、Redis）</li>\n</ul>\n</li>\n<li><p>隔离性</p>\n<ul>\n<li>一个服务不可用不会导致整个系统或其他服务不可用，各个服务相互独立的</li>\n</ul>\n</li>\n<li><p>可扩展性</p>\n<ul>\n<li>可以只对影响性能的瓶颈资源进行扩展升级</li>\n</ul>\n</li>\n<li><p>简化部署</p>\n<ul>\n<li>单个服务的修改迭代只需要发步自己的改动</li>\n</ul>\n</li>\n<li><p>易优化</p>\n<ul>\n<li>代码量不会很大，重构相对容易且改动带来的影响可控</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>管理复杂</li>\n<li>难定位问题</li>\n</ul>\n<h2 id=\"微服务框架\"><a href=\"#微服务框架\" class=\"headerlink\" title=\"微服务框架\"></a>微服务框架</h2><h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><ul>\n<li>阿里</li>\n<li>仅支持Java语言</li>\n</ul>\n<h3 id=\"Tars\"><a href=\"#Tars\" class=\"headerlink\" title=\"Tars\"></a>Tars</h3><ul>\n<li>腾讯</li>\n<li>仅支持C++语言</li>\n</ul>\n<h3 id=\"Motan\"><a href=\"#Motan\" class=\"headerlink\" title=\"Motan\"></a>Motan</h3><ul>\n<li>微博</li>\n<li>仅支持Java</li>\n</ul>\n<h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><ul>\n<li>谷歌</li>\n<li>支持多种语言</li>\n</ul>\n<h3 id=\"thrift\"><a href=\"#thrift\" class=\"headerlink\" title=\"thrift\"></a>thrift</h3><ul>\n<li>Facebook</li>\n<li>支持多种语言</li>\n</ul>\n<h2 id=\"微服务框架和RPC\"><a href=\"#微服务框架和RPC\" class=\"headerlink\" title=\"微服务框架和RPC\"></a>微服务框架和RPC</h2><h3 id=\"RPC（Remote-Procedure-Call）\"><a href=\"#RPC（Remote-Procedure-Call）\" class=\"headerlink\" title=\"RPC（Remote Procedure Call）\"></a>RPC（Remote Procedure Call）</h3><ul>\n<li>允许像调用本地函数一样调用另一个程序的函数（C&#x2F;S模式）</li>\n</ul>\n<h3 id=\"微服务框架-1\"><a href=\"#微服务框架-1\" class=\"headerlink\" title=\"微服务框架\"></a>微服务框架</h3><ul>\n<li>微服务框架一般都包含了RPC的实现和一系列的服务治理能力，是一套软件开发框架，可以基于这个框架实现自己的服务，方便的利用框架提供的服务治理和RPC能力，微服务框架也被某些人称为RPC框架</li>\n</ul>\n<h2 id=\"下一代微服务架构\"><a href=\"#下一代微服务架构\" class=\"headerlink\" title=\"下一代微服务架构\"></a>下一代微服务架构</h2><h3 id=\"服务网格（Service-Mesh）\"><a href=\"#服务网格（Service-Mesh）\" class=\"headerlink\" title=\"服务网格（Service Mesh）\"></a>服务网格（Service Mesh）</h3><ul>\n<li><p>特点</p>\n<ul>\n<li>应用程序间通讯中间层</li>\n<li>轻量级网络代理</li>\n<li>应用程序无感知</li>\n<li>解耦应用程序的重试&#x2F;超时、监控、追踪和服务发现</li>\n</ul>\n</li>\n<li><p>Service Mesh之于微服务，类似TCP&#x2F;IP之于网络通信</p>\n</li>\n</ul>\n<p><a href=\"https://www.zhihu.com/question/65502802\">【参考资料】知乎：微服务架构是什么？</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h3><ul>\n<li>微服务就是一些协同工作的小而自治的服务</li>\n</ul>\n<h3 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h3><ul>\n<li>微服务之间互相调用，服务发现需要管理各个服务的服务器地址，当进行扩容或摘除时能及时更新</li>\n</ul>\n<h3 id=\"服务监控\"><a href=\"#服务监控\" class=\"headerlink\" title=\"服务监控\"></a>服务监控</h3><ul>\n<li>监控、日志、调用链、告警通知、健康检查</li>\n</ul>\n<h3 id=\"服务容错\"><a href=\"#服务容错\" class=\"headerlink\" title=\"服务容错\"></a>服务容错</h3><ul>\n<li>熔断</li>\n<li>切换</li>\n<li>限流和降级</li>\n<li>重试</li>\n</ul>\n<h3 id=\"服务安全\"><a href=\"#服务安全\" class=\"headerlink\" title=\"服务安全\"></a>服务安全</h3><ul>\n<li><p>敏感服务进行身份验证和授权</p>\n<ul>\n<li>HTTPS传输</li>\n<li>隐私数据加密存储</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h3><ul>\n<li>引入微服务框架</li>\n</ul>\n<h2 id=\"相比单体架构\"><a href=\"#相比单体架构\" class=\"headerlink\" title=\"相比单体架构\"></a>相比单体架构</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li><p>技术异构性</p>\n<ul>\n<li>不同服务内部可以选择不同的语言开发，也可以选择适合各自服务的数据库（MySQL、Redis）</li>\n</ul>\n</li>\n<li><p>隔离性</p>\n<ul>\n<li>一个服务不可用不会导致整个系统或其他服务不可用，各个服务相互独立的</li>\n</ul>\n</li>\n<li><p>可扩展性</p>\n<ul>\n<li>可以只对影响性能的瓶颈资源进行扩展升级</li>\n</ul>\n</li>\n<li><p>简化部署</p>\n<ul>\n<li>单个服务的修改迭代只需要发步自己的改动</li>\n</ul>\n</li>\n<li><p>易优化</p>\n<ul>\n<li>代码量不会很大，重构相对容易且改动带来的影响可控</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>管理复杂</li>\n<li>难定位问题</li>\n</ul>\n<h2 id=\"微服务框架\"><a href=\"#微服务框架\" class=\"headerlink\" title=\"微服务框架\"></a>微服务框架</h2><h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><ul>\n<li>阿里</li>\n<li>仅支持Java语言</li>\n</ul>\n<h3 id=\"Tars\"><a href=\"#Tars\" class=\"headerlink\" title=\"Tars\"></a>Tars</h3><ul>\n<li>腾讯</li>\n<li>仅支持C++语言</li>\n</ul>\n<h3 id=\"Motan\"><a href=\"#Motan\" class=\"headerlink\" title=\"Motan\"></a>Motan</h3><ul>\n<li>微博</li>\n<li>仅支持Java</li>\n</ul>\n<h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><ul>\n<li>谷歌</li>\n<li>支持多种语言</li>\n</ul>\n<h3 id=\"thrift\"><a href=\"#thrift\" class=\"headerlink\" title=\"thrift\"></a>thrift</h3><ul>\n<li>Facebook</li>\n<li>支持多种语言</li>\n</ul>\n<h2 id=\"微服务框架和RPC\"><a href=\"#微服务框架和RPC\" class=\"headerlink\" title=\"微服务框架和RPC\"></a>微服务框架和RPC</h2><h3 id=\"RPC（Remote-Procedure-Call）\"><a href=\"#RPC（Remote-Procedure-Call）\" class=\"headerlink\" title=\"RPC（Remote Procedure Call）\"></a>RPC（Remote Procedure Call）</h3><ul>\n<li>允许像调用本地函数一样调用另一个程序的函数（C&#x2F;S模式）</li>\n</ul>\n<h3 id=\"微服务框架-1\"><a href=\"#微服务框架-1\" class=\"headerlink\" title=\"微服务框架\"></a>微服务框架</h3><ul>\n<li>微服务框架一般都包含了RPC的实现和一系列的服务治理能力，是一套软件开发框架，可以基于这个框架实现自己的服务，方便的利用框架提供的服务治理和RPC能力，微服务框架也被某些人称为RPC框架</li>\n</ul>\n<h2 id=\"下一代微服务架构\"><a href=\"#下一代微服务架构\" class=\"headerlink\" title=\"下一代微服务架构\"></a>下一代微服务架构</h2><h3 id=\"服务网格（Service-Mesh）\"><a href=\"#服务网格（Service-Mesh）\" class=\"headerlink\" title=\"服务网格（Service Mesh）\"></a>服务网格（Service Mesh）</h3><ul>\n<li><p>特点</p>\n<ul>\n<li>应用程序间通讯中间层</li>\n<li>轻量级网络代理</li>\n<li>应用程序无感知</li>\n<li>解耦应用程序的重试&#x2F;超时、监控、追踪和服务发现</li>\n</ul>\n</li>\n<li><p>Service Mesh之于微服务，类似TCP&#x2F;IP之于网络通信</p>\n</li>\n</ul>\n<p><a href=\"https://www.zhihu.com/question/65502802\">【参考资料】知乎：微服务架构是什么？</a></p>\n"},{"title":"计算机网络基础概述","date":"2023-03-25T05:58:26.000Z","_content":"\n## 网络\n\n### 网络层\n\n### 传输层\n\n- TCP、UDP\n\n\t- 特点\n\n\t\t- UDP：无连接，尽最大可能交付数据，面向报文，支持一对一、一对多、多对一、多对多的交互通信，不可靠（快、实时性好）\n\n\t\t\t- DNS、TFTP\n\n\t\t- TCP：面向连接，可靠交付，有流量控制、拥塞控制，全双工通信，面向字节流，只能点对点（一对一）\n\n\t\t\t- HTTP、FTP、TELENT、SMTP\n\n\t- TCP三次握手\n\n\t\t- 防止失效的连接请求到达服务器，导致服务器打开无用的连接\n\n\t- TCP四次挥手\n\n\t\t- TIME_WAIT=2MSL\n\n\t\t\t- 确保最后一个确认报文能到达，因为如果丢失会重传\n\t\t\t- 让本次连接产生的所有报文都从网络中消失\n\n\t- TCP可靠传输\n\n\t\t- 超时重传RTT\n\n\t- TCP滑动窗口\n\t- TCP流量控制\n\n\t\t- 控制发送方速率，保证接收方来得及接收（通过确认报文的窗口字段控制发送方窗口大小）\n\n\t- TCP拥塞控制\n\n\t\t- 慢启动、拥塞避免、快重传、快恢复\n\n### 应用层\n\n- DNS\n\n\t- UDP+TCP\n\n- DHCP\n\n\t- 动态主机配置\n\n- Web页面请求过程\n\n\t- 1. DHCP配置主机信息\n\t- 2. ARP解析MAC地址\n\t- 3. DNS解析域名\n\t- 4. HTTP请求页面\n\n\t\t- 三次握手建立连接\n\t\t- 开始通信\n\n## Socket\n\n### 阻塞式I/O\n\n- 直到数据从内核缓冲区复制到应用进程缓冲区才返回（cpu并不会阻塞，其他进程还可以执行，cpu利用率较高）\n\n### 非阻塞式I/O\n\n- 应用进程执行系统调用后内核返回一个错误码，需要轮询来获知IO操作是否完成（CPU利用率低）\n\n### I/O多路复用\n\n- select、poll等待数据，当监听的某个套接字可读，再使用recvfrom把数据从内核复制到进程中\n\n\t- select\n\n\t\t- 会修改fd，默认只能监听少于1024个，轮询\n\n\t- poll\n\n\t\t- 提供了更多的事件类型，对fd的重复利用更高\n\n\t- epoll\n\n\t\t- 比上述两种更加灵活，对多线程更友好\n\n\t\t\t- epoll_create\n\n\t\t\t\t- 创建一个epoll句柄\n\n\t\t\t- epoll_ctl\n\n\t\t\t\t- 为fd注册事件并绑定一个回调函数，当设备就绪callback把fd加入就绪队列（列表）\n\n\t\t\t- epoll_wait\n\n\t\t\t\t- 轮询就绪队列（schedule_timeout()）\n\n### 信号驱动I/O\n\n- sigaction系统调用，当数据到达时内核会向进程发送SIGIO信号，收到信号后调用recvfrom（相比轮询的非阻塞I/O模型CPU利用率更高）\n\n### 异步I/O\n\n- aio_read系统调用，内核会在数据复制完成后向应用进程发送信号（注意和信号驱动I/O的区别）\n\n## HTTP\n\n### HTTP状态码\n\n- 1xx：信息性\n- 2xx：成功\n- 3xx：重定向\n\n\t- 301：永久重定向，会缓存\n\t- 302：临时重定向，不缓存，有url劫持问题\n\n- 4xx：客户端错误，服务端无法处理的请求\n- 5xx：服务器错误\n\n### Cookie\n\n- 客户端保存状态\n\n### Session\n\n- 服务器保存状态\n\n### HTTPS\n\n- HTTP+SSL\n- 使用非对称加密协商对称加密使用的Secretkey\n- 使用Secretkey对称加密数据\n- 使用数字证书保证公钥的正确性\n\n### HTTP2.0\n\n- 二进制分帧层\n- 服务端推送\n- 首部压缩\n\n[【参考文章】GitHub-CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes)\n","source":"_posts/2023/03-25-计算机网络基础概述.md","raw":"---\ntitle: 计算机网络基础概述\ndate: 2023-03-25 13:58:26\ncategories:\n- [计算机网络]\ntags:\n---\n\n## 网络\n\n### 网络层\n\n### 传输层\n\n- TCP、UDP\n\n\t- 特点\n\n\t\t- UDP：无连接，尽最大可能交付数据，面向报文，支持一对一、一对多、多对一、多对多的交互通信，不可靠（快、实时性好）\n\n\t\t\t- DNS、TFTP\n\n\t\t- TCP：面向连接，可靠交付，有流量控制、拥塞控制，全双工通信，面向字节流，只能点对点（一对一）\n\n\t\t\t- HTTP、FTP、TELENT、SMTP\n\n\t- TCP三次握手\n\n\t\t- 防止失效的连接请求到达服务器，导致服务器打开无用的连接\n\n\t- TCP四次挥手\n\n\t\t- TIME_WAIT=2MSL\n\n\t\t\t- 确保最后一个确认报文能到达，因为如果丢失会重传\n\t\t\t- 让本次连接产生的所有报文都从网络中消失\n\n\t- TCP可靠传输\n\n\t\t- 超时重传RTT\n\n\t- TCP滑动窗口\n\t- TCP流量控制\n\n\t\t- 控制发送方速率，保证接收方来得及接收（通过确认报文的窗口字段控制发送方窗口大小）\n\n\t- TCP拥塞控制\n\n\t\t- 慢启动、拥塞避免、快重传、快恢复\n\n### 应用层\n\n- DNS\n\n\t- UDP+TCP\n\n- DHCP\n\n\t- 动态主机配置\n\n- Web页面请求过程\n\n\t- 1. DHCP配置主机信息\n\t- 2. ARP解析MAC地址\n\t- 3. DNS解析域名\n\t- 4. HTTP请求页面\n\n\t\t- 三次握手建立连接\n\t\t- 开始通信\n\n## Socket\n\n### 阻塞式I/O\n\n- 直到数据从内核缓冲区复制到应用进程缓冲区才返回（cpu并不会阻塞，其他进程还可以执行，cpu利用率较高）\n\n### 非阻塞式I/O\n\n- 应用进程执行系统调用后内核返回一个错误码，需要轮询来获知IO操作是否完成（CPU利用率低）\n\n### I/O多路复用\n\n- select、poll等待数据，当监听的某个套接字可读，再使用recvfrom把数据从内核复制到进程中\n\n\t- select\n\n\t\t- 会修改fd，默认只能监听少于1024个，轮询\n\n\t- poll\n\n\t\t- 提供了更多的事件类型，对fd的重复利用更高\n\n\t- epoll\n\n\t\t- 比上述两种更加灵活，对多线程更友好\n\n\t\t\t- epoll_create\n\n\t\t\t\t- 创建一个epoll句柄\n\n\t\t\t- epoll_ctl\n\n\t\t\t\t- 为fd注册事件并绑定一个回调函数，当设备就绪callback把fd加入就绪队列（列表）\n\n\t\t\t- epoll_wait\n\n\t\t\t\t- 轮询就绪队列（schedule_timeout()）\n\n### 信号驱动I/O\n\n- sigaction系统调用，当数据到达时内核会向进程发送SIGIO信号，收到信号后调用recvfrom（相比轮询的非阻塞I/O模型CPU利用率更高）\n\n### 异步I/O\n\n- aio_read系统调用，内核会在数据复制完成后向应用进程发送信号（注意和信号驱动I/O的区别）\n\n## HTTP\n\n### HTTP状态码\n\n- 1xx：信息性\n- 2xx：成功\n- 3xx：重定向\n\n\t- 301：永久重定向，会缓存\n\t- 302：临时重定向，不缓存，有url劫持问题\n\n- 4xx：客户端错误，服务端无法处理的请求\n- 5xx：服务器错误\n\n### Cookie\n\n- 客户端保存状态\n\n### Session\n\n- 服务器保存状态\n\n### HTTPS\n\n- HTTP+SSL\n- 使用非对称加密协商对称加密使用的Secretkey\n- 使用Secretkey对称加密数据\n- 使用数字证书保证公钥的正确性\n\n### HTTP2.0\n\n- 二进制分帧层\n- 服务端推送\n- 首部压缩\n\n[【参考文章】GitHub-CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes)\n","slug":"计算机网络基础概述","published":1,"updated":"2023-03-25T06:58:34.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyx0002qvhficfl4d2by","content":"<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h3><h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h3><ul>\n<li><p>TCP、UDP</p>\n<ul>\n<li><p>特点</p>\n<ul>\n<li><p>UDP：无连接，尽最大可能交付数据，面向报文，支持一对一、一对多、多对一、多对多的交互通信，不可靠（快、实时性好）</p>\n<ul>\n<li>DNS、TFTP</li>\n</ul>\n</li>\n<li><p>TCP：面向连接，可靠交付，有流量控制、拥塞控制，全双工通信，面向字节流，只能点对点（一对一）</p>\n<ul>\n<li>HTTP、FTP、TELENT、SMTP</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>TCP三次握手</p>\n<ul>\n<li>防止失效的连接请求到达服务器，导致服务器打开无用的连接</li>\n</ul>\n</li>\n<li><p>TCP四次挥手</p>\n<ul>\n<li><p>TIME_WAIT&#x3D;2MSL</p>\n<ul>\n<li>确保最后一个确认报文能到达，因为如果丢失会重传</li>\n<li>让本次连接产生的所有报文都从网络中消失</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>TCP可靠传输</p>\n<ul>\n<li>超时重传RTT</li>\n</ul>\n</li>\n<li><p>TCP滑动窗口</p>\n</li>\n<li><p>TCP流量控制</p>\n<ul>\n<li>控制发送方速率，保证接收方来得及接收（通过确认报文的窗口字段控制发送方窗口大小）</li>\n</ul>\n</li>\n<li><p>TCP拥塞控制</p>\n<ul>\n<li>慢启动、拥塞避免、快重传、快恢复</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h3><ul>\n<li><p>DNS</p>\n<ul>\n<li>UDP+TCP</li>\n</ul>\n</li>\n<li><p>DHCP</p>\n<ul>\n<li>动态主机配置</li>\n</ul>\n</li>\n<li><p>Web页面请求过程</p>\n<ul>\n<li><ol>\n<li>DHCP配置主机信息</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>ARP解析MAC地址</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>DNS解析域名</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>HTTP请求页面</li>\n</ol>\n<ul>\n<li>三次握手建立连接</li>\n<li>开始通信</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h2><h3 id=\"阻塞式I-x2F-O\"><a href=\"#阻塞式I-x2F-O\" class=\"headerlink\" title=\"阻塞式I&#x2F;O\"></a>阻塞式I&#x2F;O</h3><ul>\n<li>直到数据从内核缓冲区复制到应用进程缓冲区才返回（cpu并不会阻塞，其他进程还可以执行，cpu利用率较高）</li>\n</ul>\n<h3 id=\"非阻塞式I-x2F-O\"><a href=\"#非阻塞式I-x2F-O\" class=\"headerlink\" title=\"非阻塞式I&#x2F;O\"></a>非阻塞式I&#x2F;O</h3><ul>\n<li>应用进程执行系统调用后内核返回一个错误码，需要轮询来获知IO操作是否完成（CPU利用率低）</li>\n</ul>\n<h3 id=\"I-x2F-O多路复用\"><a href=\"#I-x2F-O多路复用\" class=\"headerlink\" title=\"I&#x2F;O多路复用\"></a>I&#x2F;O多路复用</h3><ul>\n<li><p>select、poll等待数据，当监听的某个套接字可读，再使用recvfrom把数据从内核复制到进程中</p>\n<ul>\n<li><p>select</p>\n<ul>\n<li>会修改fd，默认只能监听少于1024个，轮询</li>\n</ul>\n</li>\n<li><p>poll</p>\n<ul>\n<li>提供了更多的事件类型，对fd的重复利用更高</li>\n</ul>\n</li>\n<li><p>epoll</p>\n<ul>\n<li><p>比上述两种更加灵活，对多线程更友好</p>\n<ul>\n<li><p>epoll_create</p>\n<ul>\n<li>创建一个epoll句柄</li>\n</ul>\n</li>\n<li><p>epoll_ctl</p>\n<ul>\n<li>为fd注册事件并绑定一个回调函数，当设备就绪callback把fd加入就绪队列（列表）</li>\n</ul>\n</li>\n<li><p>epoll_wait</p>\n<ul>\n<li>轮询就绪队列（schedule_timeout()）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"信号驱动I-x2F-O\"><a href=\"#信号驱动I-x2F-O\" class=\"headerlink\" title=\"信号驱动I&#x2F;O\"></a>信号驱动I&#x2F;O</h3><ul>\n<li>sigaction系统调用，当数据到达时内核会向进程发送SIGIO信号，收到信号后调用recvfrom（相比轮询的非阻塞I&#x2F;O模型CPU利用率更高）</li>\n</ul>\n<h3 id=\"异步I-x2F-O\"><a href=\"#异步I-x2F-O\" class=\"headerlink\" title=\"异步I&#x2F;O\"></a>异步I&#x2F;O</h3><ul>\n<li>aio_read系统调用，内核会在数据复制完成后向应用进程发送信号（注意和信号驱动I&#x2F;O的区别）</li>\n</ul>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><ul>\n<li><p>1xx：信息性</p>\n</li>\n<li><p>2xx：成功</p>\n</li>\n<li><p>3xx：重定向</p>\n<ul>\n<li>301：永久重定向，会缓存</li>\n<li>302：临时重定向，不缓存，有url劫持问题</li>\n</ul>\n</li>\n<li><p>4xx：客户端错误，服务端无法处理的请求</p>\n</li>\n<li><p>5xx：服务器错误</p>\n</li>\n</ul>\n<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><ul>\n<li>客户端保存状态</li>\n</ul>\n<h3 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h3><ul>\n<li>服务器保存状态</li>\n</ul>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><ul>\n<li>HTTP+SSL</li>\n<li>使用非对称加密协商对称加密使用的Secretkey</li>\n<li>使用Secretkey对称加密数据</li>\n<li>使用数字证书保证公钥的正确性</li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><ul>\n<li>二进制分帧层</li>\n<li>服务端推送</li>\n<li>首部压缩</li>\n</ul>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">【参考文章】GitHub-CyC2018&#x2F;CS-Notes</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h3><h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h3><ul>\n<li><p>TCP、UDP</p>\n<ul>\n<li><p>特点</p>\n<ul>\n<li><p>UDP：无连接，尽最大可能交付数据，面向报文，支持一对一、一对多、多对一、多对多的交互通信，不可靠（快、实时性好）</p>\n<ul>\n<li>DNS、TFTP</li>\n</ul>\n</li>\n<li><p>TCP：面向连接，可靠交付，有流量控制、拥塞控制，全双工通信，面向字节流，只能点对点（一对一）</p>\n<ul>\n<li>HTTP、FTP、TELENT、SMTP</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>TCP三次握手</p>\n<ul>\n<li>防止失效的连接请求到达服务器，导致服务器打开无用的连接</li>\n</ul>\n</li>\n<li><p>TCP四次挥手</p>\n<ul>\n<li><p>TIME_WAIT&#x3D;2MSL</p>\n<ul>\n<li>确保最后一个确认报文能到达，因为如果丢失会重传</li>\n<li>让本次连接产生的所有报文都从网络中消失</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>TCP可靠传输</p>\n<ul>\n<li>超时重传RTT</li>\n</ul>\n</li>\n<li><p>TCP滑动窗口</p>\n</li>\n<li><p>TCP流量控制</p>\n<ul>\n<li>控制发送方速率，保证接收方来得及接收（通过确认报文的窗口字段控制发送方窗口大小）</li>\n</ul>\n</li>\n<li><p>TCP拥塞控制</p>\n<ul>\n<li>慢启动、拥塞避免、快重传、快恢复</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h3><ul>\n<li><p>DNS</p>\n<ul>\n<li>UDP+TCP</li>\n</ul>\n</li>\n<li><p>DHCP</p>\n<ul>\n<li>动态主机配置</li>\n</ul>\n</li>\n<li><p>Web页面请求过程</p>\n<ul>\n<li><ol>\n<li>DHCP配置主机信息</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>ARP解析MAC地址</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>DNS解析域名</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>HTTP请求页面</li>\n</ol>\n<ul>\n<li>三次握手建立连接</li>\n<li>开始通信</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h2><h3 id=\"阻塞式I-x2F-O\"><a href=\"#阻塞式I-x2F-O\" class=\"headerlink\" title=\"阻塞式I&#x2F;O\"></a>阻塞式I&#x2F;O</h3><ul>\n<li>直到数据从内核缓冲区复制到应用进程缓冲区才返回（cpu并不会阻塞，其他进程还可以执行，cpu利用率较高）</li>\n</ul>\n<h3 id=\"非阻塞式I-x2F-O\"><a href=\"#非阻塞式I-x2F-O\" class=\"headerlink\" title=\"非阻塞式I&#x2F;O\"></a>非阻塞式I&#x2F;O</h3><ul>\n<li>应用进程执行系统调用后内核返回一个错误码，需要轮询来获知IO操作是否完成（CPU利用率低）</li>\n</ul>\n<h3 id=\"I-x2F-O多路复用\"><a href=\"#I-x2F-O多路复用\" class=\"headerlink\" title=\"I&#x2F;O多路复用\"></a>I&#x2F;O多路复用</h3><ul>\n<li><p>select、poll等待数据，当监听的某个套接字可读，再使用recvfrom把数据从内核复制到进程中</p>\n<ul>\n<li><p>select</p>\n<ul>\n<li>会修改fd，默认只能监听少于1024个，轮询</li>\n</ul>\n</li>\n<li><p>poll</p>\n<ul>\n<li>提供了更多的事件类型，对fd的重复利用更高</li>\n</ul>\n</li>\n<li><p>epoll</p>\n<ul>\n<li><p>比上述两种更加灵活，对多线程更友好</p>\n<ul>\n<li><p>epoll_create</p>\n<ul>\n<li>创建一个epoll句柄</li>\n</ul>\n</li>\n<li><p>epoll_ctl</p>\n<ul>\n<li>为fd注册事件并绑定一个回调函数，当设备就绪callback把fd加入就绪队列（列表）</li>\n</ul>\n</li>\n<li><p>epoll_wait</p>\n<ul>\n<li>轮询就绪队列（schedule_timeout()）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"信号驱动I-x2F-O\"><a href=\"#信号驱动I-x2F-O\" class=\"headerlink\" title=\"信号驱动I&#x2F;O\"></a>信号驱动I&#x2F;O</h3><ul>\n<li>sigaction系统调用，当数据到达时内核会向进程发送SIGIO信号，收到信号后调用recvfrom（相比轮询的非阻塞I&#x2F;O模型CPU利用率更高）</li>\n</ul>\n<h3 id=\"异步I-x2F-O\"><a href=\"#异步I-x2F-O\" class=\"headerlink\" title=\"异步I&#x2F;O\"></a>异步I&#x2F;O</h3><ul>\n<li>aio_read系统调用，内核会在数据复制完成后向应用进程发送信号（注意和信号驱动I&#x2F;O的区别）</li>\n</ul>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><ul>\n<li><p>1xx：信息性</p>\n</li>\n<li><p>2xx：成功</p>\n</li>\n<li><p>3xx：重定向</p>\n<ul>\n<li>301：永久重定向，会缓存</li>\n<li>302：临时重定向，不缓存，有url劫持问题</li>\n</ul>\n</li>\n<li><p>4xx：客户端错误，服务端无法处理的请求</p>\n</li>\n<li><p>5xx：服务器错误</p>\n</li>\n</ul>\n<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><ul>\n<li>客户端保存状态</li>\n</ul>\n<h3 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h3><ul>\n<li>服务器保存状态</li>\n</ul>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><ul>\n<li>HTTP+SSL</li>\n<li>使用非对称加密协商对称加密使用的Secretkey</li>\n<li>使用Secretkey对称加密数据</li>\n<li>使用数字证书保证公钥的正确性</li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><ul>\n<li>二进制分帧层</li>\n<li>服务端推送</li>\n<li>首部压缩</li>\n</ul>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">【参考文章】GitHub-CyC2018&#x2F;CS-Notes</a></p>\n"},{"title":"限流算法有哪些?","date":"2023-03-25T07:24:13.000Z","_content":"## 为什么要限流？\n由于Web服务无法控制调用方的行为，当遇到请求并发量超过系统的容量阈值，会导致服务器资源耗尽从而导致服务异常或宕机，而且某个服务的请求量突增还会影响到上游的服务，如DB或者是其他的公共服务，导致整个系统瘫痪。\n可能导致流量突增的原因有以下几点：\n- 热点业务的突发请求（如大型活动）\n- 调用方bug导致的请求量倍增\n- 恶意攻击的请求\n\n为了对服务进行保护，就需要对请求进行限流。\n\n## 常见算法\n\n### 固定窗口计数器算法\n![](https://upload-images.jianshu.io/upload_images/14151453-eb82b484202a6797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**算法思路**：\n- 将时间划分为多个窗口\n- 每个窗口内每有一次请求计数器加1\n- 如果计数器超过了限制数量，则本窗口内的所有请求都被丢弃，当时间到达下一个窗口时，计数器重置。\n\n**特点**：原理和实现都比较简单，但是这种算法可能会让通过的请求量为阈值的两倍。比如当阈值是100时，第一个窗口在0-0.5秒期间没有请求，0.5-1.0秒期间有100个请求，然后到了第二个窗口计数器已经重置，在1.0-1.5秒期间有100个请求，这样看来在0.5-1.5秒的1秒内通过了200个请求。\n\n### 滑动窗口计数器算法\n该方法就是对固定窗口计数算法的窗口时间细分更多的区间，并且按照时间在区间上滑动，如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-6ffb47a5808a8296.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**算法思路**：\n- 将时间划分多个区间，维护一个包含多个区间的窗口\n- 每个区间内每有一次请求就将该区间的计数器加1\n- 每经过一个区间时间，丢弃最老的一个区间，加入最新的一个区间\n- 如果当前窗口内区间的请求计数总和超过了限制数量则本窗口内所有新的请求都被丢弃。\n\n**特点**：\n将时间划分为更小单位的区间，按时间滑动，避免了固定窗口计数器会产生双倍请求的问题，但是时间区间的精度越高，算法需要的空间容量就越大。\n\n### 漏桶算法\n![](https://upload-images.jianshu.io/upload_images/14151453-c5fa82d0ce096327.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**算法思路**：\n- 将每个请求视作“水滴”放入“漏桶”进行存储\n- 漏桶以固定的速率（通常是服务的最大容量）向外漏出请求交给服务器执行\n- 如果漏桶空了则停止漏水，如果漏桶满了则丢弃新来的请求\n\n**特点**：通常使用消息队列来实现漏桶。该算法能良好的保证瞬时请求量不会超过阈值，但是当短时间内有大量的突发请求时，即使服务器没有负载，每个请求也都需要在队列中等待一段时间才能被响应。\n\n### 令牌桶算法\n![](https://upload-images.jianshu.io/upload_images/14151453-943e3e218fb56c62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**算法思路**：\n- 令牌以固定速录添加到桶中，如果桶满了直接丢弃\n- 请求到达时从桶中取令牌，取到了令牌的请求交给服务器执行\n- 如果桶空了，尝试取令牌的请求就会被拒绝\n\n**特点**：令牌桶算法既能将流量均匀的分布，又能接受服务器承受的容量范围内的突发请求，因此是目前使用比较广泛的一种限流算法。缺点是突发流量时第一个周期会多放过一些请求。\n\n## 参考\n【1】[InfoQ：分布式服务限流实战，已经为你排好坑了](https://www.infoq.cn/article/qg2tx8fyw5vt-f3hh673)\n【2】[阿里云：限流算法介绍](https://help.aliyun.com/document_detail/149952.html)\n","source":"_posts/2023/03-25-限流算法有哪些.md","raw":"---\ntitle: 限流算法有哪些?\ndate: 2023-03-25 15:24:13\ncategories:\n- [分布式系统]\ntags:\n- 限流\n- 漏桶\n- 令牌桶\n---\n## 为什么要限流？\n由于Web服务无法控制调用方的行为，当遇到请求并发量超过系统的容量阈值，会导致服务器资源耗尽从而导致服务异常或宕机，而且某个服务的请求量突增还会影响到上游的服务，如DB或者是其他的公共服务，导致整个系统瘫痪。\n可能导致流量突增的原因有以下几点：\n- 热点业务的突发请求（如大型活动）\n- 调用方bug导致的请求量倍增\n- 恶意攻击的请求\n\n为了对服务进行保护，就需要对请求进行限流。\n\n## 常见算法\n\n### 固定窗口计数器算法\n![](https://upload-images.jianshu.io/upload_images/14151453-eb82b484202a6797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**算法思路**：\n- 将时间划分为多个窗口\n- 每个窗口内每有一次请求计数器加1\n- 如果计数器超过了限制数量，则本窗口内的所有请求都被丢弃，当时间到达下一个窗口时，计数器重置。\n\n**特点**：原理和实现都比较简单，但是这种算法可能会让通过的请求量为阈值的两倍。比如当阈值是100时，第一个窗口在0-0.5秒期间没有请求，0.5-1.0秒期间有100个请求，然后到了第二个窗口计数器已经重置，在1.0-1.5秒期间有100个请求，这样看来在0.5-1.5秒的1秒内通过了200个请求。\n\n### 滑动窗口计数器算法\n该方法就是对固定窗口计数算法的窗口时间细分更多的区间，并且按照时间在区间上滑动，如下图所示：\n![](https://upload-images.jianshu.io/upload_images/14151453-6ffb47a5808a8296.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**算法思路**：\n- 将时间划分多个区间，维护一个包含多个区间的窗口\n- 每个区间内每有一次请求就将该区间的计数器加1\n- 每经过一个区间时间，丢弃最老的一个区间，加入最新的一个区间\n- 如果当前窗口内区间的请求计数总和超过了限制数量则本窗口内所有新的请求都被丢弃。\n\n**特点**：\n将时间划分为更小单位的区间，按时间滑动，避免了固定窗口计数器会产生双倍请求的问题，但是时间区间的精度越高，算法需要的空间容量就越大。\n\n### 漏桶算法\n![](https://upload-images.jianshu.io/upload_images/14151453-c5fa82d0ce096327.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**算法思路**：\n- 将每个请求视作“水滴”放入“漏桶”进行存储\n- 漏桶以固定的速率（通常是服务的最大容量）向外漏出请求交给服务器执行\n- 如果漏桶空了则停止漏水，如果漏桶满了则丢弃新来的请求\n\n**特点**：通常使用消息队列来实现漏桶。该算法能良好的保证瞬时请求量不会超过阈值，但是当短时间内有大量的突发请求时，即使服务器没有负载，每个请求也都需要在队列中等待一段时间才能被响应。\n\n### 令牌桶算法\n![](https://upload-images.jianshu.io/upload_images/14151453-943e3e218fb56c62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**算法思路**：\n- 令牌以固定速录添加到桶中，如果桶满了直接丢弃\n- 请求到达时从桶中取令牌，取到了令牌的请求交给服务器执行\n- 如果桶空了，尝试取令牌的请求就会被拒绝\n\n**特点**：令牌桶算法既能将流量均匀的分布，又能接受服务器承受的容量范围内的突发请求，因此是目前使用比较广泛的一种限流算法。缺点是突发流量时第一个周期会多放过一些请求。\n\n## 参考\n【1】[InfoQ：分布式服务限流实战，已经为你排好坑了](https://www.infoq.cn/article/qg2tx8fyw5vt-f3hh673)\n【2】[阿里云：限流算法介绍](https://help.aliyun.com/document_detail/149952.html)\n","slug":"限流算法有哪些","published":1,"updated":"2023-03-25T07:30:08.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfnnpyx1002svhfifszk6ici","content":"<h2 id=\"为什么要限流？\"><a href=\"#为什么要限流？\" class=\"headerlink\" title=\"为什么要限流？\"></a>为什么要限流？</h2><p>由于Web服务无法控制调用方的行为，当遇到请求并发量超过系统的容量阈值，会导致服务器资源耗尽从而导致服务异常或宕机，而且某个服务的请求量突增还会影响到上游的服务，如DB或者是其他的公共服务，导致整个系统瘫痪。<br>可能导致流量突增的原因有以下几点：</p>\n<ul>\n<li>热点业务的突发请求（如大型活动）</li>\n<li>调用方bug导致的请求量倍增</li>\n<li>恶意攻击的请求</li>\n</ul>\n<p>为了对服务进行保护，就需要对请求进行限流。</p>\n<h2 id=\"常见算法\"><a href=\"#常见算法\" class=\"headerlink\" title=\"常见算法\"></a>常见算法</h2><h3 id=\"固定窗口计数器算法\"><a href=\"#固定窗口计数器算法\" class=\"headerlink\" title=\"固定窗口计数器算法\"></a>固定窗口计数器算法</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-eb82b484202a6797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-eb82b484202a6797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br><strong>算法思路</strong>：</p>\n<ul>\n<li>将时间划分为多个窗口</li>\n<li>每个窗口内每有一次请求计数器加1</li>\n<li>如果计数器超过了限制数量，则本窗口内的所有请求都被丢弃，当时间到达下一个窗口时，计数器重置。</li>\n</ul>\n<p><strong>特点</strong>：原理和实现都比较简单，但是这种算法可能会让通过的请求量为阈值的两倍。比如当阈值是100时，第一个窗口在0-0.5秒期间没有请求，0.5-1.0秒期间有100个请求，然后到了第二个窗口计数器已经重置，在1.0-1.5秒期间有100个请求，这样看来在0.5-1.5秒的1秒内通过了200个请求。</p>\n<h3 id=\"滑动窗口计数器算法\"><a href=\"#滑动窗口计数器算法\" class=\"headerlink\" title=\"滑动窗口计数器算法\"></a>滑动窗口计数器算法</h3><p>该方法就是对固定窗口计数算法的窗口时间细分更多的区间，并且按照时间在区间上滑动，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-6ffb47a5808a8296.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-6ffb47a5808a8296.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br><strong>算法思路</strong>：</p>\n<ul>\n<li>将时间划分多个区间，维护一个包含多个区间的窗口</li>\n<li>每个区间内每有一次请求就将该区间的计数器加1</li>\n<li>每经过一个区间时间，丢弃最老的一个区间，加入最新的一个区间</li>\n<li>如果当前窗口内区间的请求计数总和超过了限制数量则本窗口内所有新的请求都被丢弃。</li>\n</ul>\n<p><strong>特点</strong>：<br>将时间划分为更小单位的区间，按时间滑动，避免了固定窗口计数器会产生双倍请求的问题，但是时间区间的精度越高，算法需要的空间容量就越大。</p>\n<h3 id=\"漏桶算法\"><a href=\"#漏桶算法\" class=\"headerlink\" title=\"漏桶算法\"></a>漏桶算法</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-c5fa82d0ce096327.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-c5fa82d0ce096327.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p><strong>算法思路</strong>：</p>\n<ul>\n<li>将每个请求视作“水滴”放入“漏桶”进行存储</li>\n<li>漏桶以固定的速率（通常是服务的最大容量）向外漏出请求交给服务器执行</li>\n<li>如果漏桶空了则停止漏水，如果漏桶满了则丢弃新来的请求</li>\n</ul>\n<p><strong>特点</strong>：通常使用消息队列来实现漏桶。该算法能良好的保证瞬时请求量不会超过阈值，但是当短时间内有大量的突发请求时，即使服务器没有负载，每个请求也都需要在队列中等待一段时间才能被响应。</p>\n<h3 id=\"令牌桶算法\"><a href=\"#令牌桶算法\" class=\"headerlink\" title=\"令牌桶算法\"></a>令牌桶算法</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-943e3e218fb56c62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" class=\"lazyload\" data-srcset=\"https://upload-images.jianshu.io/upload_images/14151453-943e3e218fb56c62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"><br><strong>算法思路</strong>：</p>\n<ul>\n<li>令牌以固定速录添加到桶中，如果桶满了直接丢弃</li>\n<li>请求到达时从桶中取令牌，取到了令牌的请求交给服务器执行</li>\n<li>如果桶空了，尝试取令牌的请求就会被拒绝</li>\n</ul>\n<p><strong>特点</strong>：令牌桶算法既能将流量均匀的分布，又能接受服务器承受的容量范围内的突发请求，因此是目前使用比较广泛的一种限流算法。缺点是突发流量时第一个周期会多放过一些请求。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://www.infoq.cn/article/qg2tx8fyw5vt-f3hh673\">InfoQ：分布式服务限流实战，已经为你排好坑了</a><br>【2】<a href=\"https://help.aliyun.com/document_detail/149952.html\">阿里云：限流算法介绍</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么要限流？\"><a href=\"#为什么要限流？\" class=\"headerlink\" title=\"为什么要限流？\"></a>为什么要限流？</h2><p>由于Web服务无法控制调用方的行为，当遇到请求并发量超过系统的容量阈值，会导致服务器资源耗尽从而导致服务异常或宕机，而且某个服务的请求量突增还会影响到上游的服务，如DB或者是其他的公共服务，导致整个系统瘫痪。<br>可能导致流量突增的原因有以下几点：</p>\n<ul>\n<li>热点业务的突发请求（如大型活动）</li>\n<li>调用方bug导致的请求量倍增</li>\n<li>恶意攻击的请求</li>\n</ul>\n<p>为了对服务进行保护，就需要对请求进行限流。</p>\n<h2 id=\"常见算法\"><a href=\"#常见算法\" class=\"headerlink\" title=\"常见算法\"></a>常见算法</h2><h3 id=\"固定窗口计数器算法\"><a href=\"#固定窗口计数器算法\" class=\"headerlink\" title=\"固定窗口计数器算法\"></a>固定窗口计数器算法</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-eb82b484202a6797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br><strong>算法思路</strong>：</p>\n<ul>\n<li>将时间划分为多个窗口</li>\n<li>每个窗口内每有一次请求计数器加1</li>\n<li>如果计数器超过了限制数量，则本窗口内的所有请求都被丢弃，当时间到达下一个窗口时，计数器重置。</li>\n</ul>\n<p><strong>特点</strong>：原理和实现都比较简单，但是这种算法可能会让通过的请求量为阈值的两倍。比如当阈值是100时，第一个窗口在0-0.5秒期间没有请求，0.5-1.0秒期间有100个请求，然后到了第二个窗口计数器已经重置，在1.0-1.5秒期间有100个请求，这样看来在0.5-1.5秒的1秒内通过了200个请求。</p>\n<h3 id=\"滑动窗口计数器算法\"><a href=\"#滑动窗口计数器算法\" class=\"headerlink\" title=\"滑动窗口计数器算法\"></a>滑动窗口计数器算法</h3><p>该方法就是对固定窗口计数算法的窗口时间细分更多的区间，并且按照时间在区间上滑动，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/14151453-6ffb47a5808a8296.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br><strong>算法思路</strong>：</p>\n<ul>\n<li>将时间划分多个区间，维护一个包含多个区间的窗口</li>\n<li>每个区间内每有一次请求就将该区间的计数器加1</li>\n<li>每经过一个区间时间，丢弃最老的一个区间，加入最新的一个区间</li>\n<li>如果当前窗口内区间的请求计数总和超过了限制数量则本窗口内所有新的请求都被丢弃。</li>\n</ul>\n<p><strong>特点</strong>：<br>将时间划分为更小单位的区间，按时间滑动，避免了固定窗口计数器会产生双倍请求的问题，但是时间区间的精度越高，算法需要的空间容量就越大。</p>\n<h3 id=\"漏桶算法\"><a href=\"#漏桶算法\" class=\"headerlink\" title=\"漏桶算法\"></a>漏桶算法</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-c5fa82d0ce096327.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p><strong>算法思路</strong>：</p>\n<ul>\n<li>将每个请求视作“水滴”放入“漏桶”进行存储</li>\n<li>漏桶以固定的速率（通常是服务的最大容量）向外漏出请求交给服务器执行</li>\n<li>如果漏桶空了则停止漏水，如果漏桶满了则丢弃新来的请求</li>\n</ul>\n<p><strong>特点</strong>：通常使用消息队列来实现漏桶。该算法能良好的保证瞬时请求量不会超过阈值，但是当短时间内有大量的突发请求时，即使服务器没有负载，每个请求也都需要在队列中等待一段时间才能被响应。</p>\n<h3 id=\"令牌桶算法\"><a href=\"#令牌桶算法\" class=\"headerlink\" title=\"令牌桶算法\"></a>令牌桶算法</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/14151453-943e3e218fb56c62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"><br><strong>算法思路</strong>：</p>\n<ul>\n<li>令牌以固定速录添加到桶中，如果桶满了直接丢弃</li>\n<li>请求到达时从桶中取令牌，取到了令牌的请求交给服务器执行</li>\n<li>如果桶空了，尝试取令牌的请求就会被拒绝</li>\n</ul>\n<p><strong>特点</strong>：令牌桶算法既能将流量均匀的分布，又能接受服务器承受的容量范围内的突发请求，因此是目前使用比较广泛的一种限流算法。缺点是突发流量时第一个周期会多放过一些请求。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>【1】<a href=\"https://www.infoq.cn/article/qg2tx8fyw5vt-f3hh673\">InfoQ：分布式服务限流实战，已经为你排好坑了</a><br>【2】<a href=\"https://help.aliyun.com/document_detail/149952.html\">阿里云：限流算法介绍</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clfnnpyvu0001vhficq2e6e04","category_id":"clfnnpyvz0004vhfiap898yu3","_id":"clfnnpyw7000gvhfif37g5r3t"},{"post_id":"clfnnpyvy0003vhfibywc7045","category_id":"clfnnpyvz0004vhfiap898yu3","_id":"clfnnpyw9000lvhfi03cj1dx2"},{"post_id":"clfnnpyw10007vhfiep8mgw3s","category_id":"clfnnpyw7000fvhfi2grt5bng","_id":"clfnnpywd000uvhfi8vr1hd49"},{"post_id":"clfnnpyw20009vhfigsjb5xyh","category_id":"clfnnpyw7000fvhfi2grt5bng","_id":"clfnnpywf000zvhfif78yaftg"},{"post_id":"clfnnpyw3000avhfi6jf35wo8","category_id":"clfnnpyw7000fvhfi2grt5bng","_id":"clfnnpywg0015vhfieod17loo"},{"post_id":"clfnnpyw5000dvhfi3o1p9czu","category_id":"clfnnpyw7000fvhfi2grt5bng","_id":"clfnnpywh001bvhfi18ux64z0"},{"post_id":"clfnnpyw6000evhfic6jv0khl","category_id":"clfnnpyw7000fvhfi2grt5bng","_id":"clfnnpywj001hvhfic8zn6i9o"},{"post_id":"clfnnpyw8000ivhfi7vqmeols","category_id":"clfnnpywh0019vhfi8opr83m8","_id":"clfnnpywq001nvhfi22gz97qy"},{"post_id":"clfnnpyw9000kvhfi4cq44j7x","category_id":"clfnnpywh0019vhfi8opr83m8","_id":"clfnnpywr001tvhfi16muhifb"},{"post_id":"clfnnpywa000pvhfia9hy8b2m","category_id":"clfnnpywh0019vhfi8opr83m8","_id":"clfnnpywt001zvhfig1yadg9x"},{"post_id":"clfnnpywb000qvhfibo0327vj","category_id":"clfnnpywh0019vhfi8opr83m8","_id":"clfnnpywv0024vhfi2c4b0kyc"},{"post_id":"clfnnpywc000tvhfi59jc5isn","category_id":"clfnnpywh0019vhfi8opr83m8","_id":"clfnnpyww002avhfi1r2l11uc"},{"post_id":"clfnnpywd000vvhfi02xw3aze","category_id":"clfnnpywh0019vhfi8opr83m8","_id":"clfnnpywy002hvhfigif9a2dd"},{"post_id":"clfnnpywf000yvhfi26l0a044","category_id":"clfnnpywh0019vhfi8opr83m8","_id":"clfnnpywz002mvhfi2oxx3amt"},{"post_id":"clfnnpywf0011vhfigddah650","category_id":"clfnnpywh0019vhfi8opr83m8","_id":"clfnnpyx1002rvhfi5trf1qj0"},{"post_id":"clfnnpywg0014vhfi388t5ulg","category_id":"clfnnpywy002jvhfihuyfdckc","_id":"clfnnpyx2002vvhfi2eas0uns"},{"post_id":"clfnnpyx0002qvhficfl4d2by","category_id":"clfnnpywy002jvhfihuyfdckc","_id":"clfnnpyx2002yvhfi9wtc42tu"},{"post_id":"clfnnpywh0018vhfi498673fj","category_id":"clfnnpyx0002ovhfif1guc9g5","_id":"clfnnpyx30032vhfihif41z6g"},{"post_id":"clfnnpywh001avhfidh9sebuk","category_id":"clfnnpyx0002ovhfif1guc9g5","_id":"clfnnpyx40036vhfi3bv11myx"},{"post_id":"clfnnpywi001dvhfibuy6dcwc","category_id":"clfnnpyx0002ovhfif1guc9g5","_id":"clfnnpyx5003bvhfifcfb2cfn"},{"post_id":"clfnnpywj001gvhfidz8l31n9","category_id":"clfnnpyx0002ovhfif1guc9g5","_id":"clfnnpyx5003fvhfie77p9a5z"},{"post_id":"clfnnpywk001kvhfie4s4ftj2","category_id":"clfnnpyx0002ovhfif1guc9g5","_id":"clfnnpyx6003jvhfi4uj18quc"},{"post_id":"clfnnpywl001mvhfictidbahw","category_id":"clfnnpyx0002ovhfif1guc9g5","_id":"clfnnpyx6003mvhfi0hurhcoq"},{"post_id":"clfnnpywq001pvhfialim1ziq","category_id":"clfnnpyx6003hvhficnm9eu7y","_id":"clfnnpyx7003rvhfiewz4g9t5"},{"post_id":"clfnnpywr001svhfi2tqsaaqn","category_id":"clfnnpyx6003hvhficnm9eu7y","_id":"clfnnpyx7003uvhfi3b7k6xgh"},{"post_id":"clfnnpywr001wvhfihes0frke","category_id":"clfnnpyx6003hvhficnm9eu7y","_id":"clfnnpyx7003wvhficzipf1ie"},{"post_id":"clfnnpywt001yvhfic0jag0wy","category_id":"clfnnpywy002jvhfihuyfdckc","_id":"clfnnpyx80041vhfifrztgyod"},{"post_id":"clfnnpywt0020vhfi9f61glb4","category_id":"clfnnpywy002jvhfihuyfdckc","_id":"clfnnpyx90045vhfi1gxk55rn"},{"post_id":"clfnnpywv0023vhfigsehdgp1","category_id":"clfnnpyx8003zvhfias1ddhb2","_id":"clfnnpyxa004avhfi3xms4ldx"},{"post_id":"clfnnpywv0025vhficq272x04","category_id":"clfnnpywy002jvhfihuyfdckc","_id":"clfnnpyxa004dvhfi6co15qu4"},{"post_id":"clfnnpyww0029vhfi6avm4brp","category_id":"clfnnpyx8003zvhfias1ddhb2","_id":"clfnnpyxb004hvhfi2cxe7u6e"},{"post_id":"clfnnpyww002cvhfids3pb8to","category_id":"clfnnpyx8003zvhfias1ddhb2","_id":"clfnnpyxb004lvhfi3jzx31go"},{"post_id":"clfnnpywx002gvhfi046odndu","category_id":"clfnnpyx8003zvhfias1ddhb2","_id":"clfnnpyxc004pvhfig2709gul"},{"post_id":"clfnnpywy002ivhfie499e6nm","category_id":"clfnnpyx8003zvhfias1ddhb2","_id":"clfnnpyxc004tvhfiekpf3jqj"},{"post_id":"clfnnpywz002lvhfi6dc1e20n","category_id":"clfnnpyx0002ovhfif1guc9g5","_id":"clfnnpyxd004wvhfi4lv1eolr"},{"post_id":"clfnnpyx1002svhfifszk6ici","category_id":"clfnnpyx8003zvhfias1ddhb2","_id":"clfnnpyxe0053vhfi8y9ih9f2"},{"post_id":"clfnnpyx0002nvhfi74rp1t2d","category_id":"clfnnpyx8003zvhfias1ddhb2","_id":"clfnnpyxe0056vhfib71q9v6j"},{"post_id":"clfnnpyx0002nvhfi74rp1t2d","category_id":"clfnnpyxd004yvhfi8zv70r48","_id":"clfnnpyxe0057vhfi2drr3tx7"}],"PostTag":[{"post_id":"clfnnpyvu0001vhficq2e6e04","tag_id":"clfnnpyw00005vhfiaszxhcg1","_id":"clfnnpyw9000jvhficybv2hc6"},{"post_id":"clfnnpyvu0001vhficq2e6e04","tag_id":"clfnnpyw4000cvhfibh4nfqk3","_id":"clfnnpyw9000mvhfigco8d3vw"},{"post_id":"clfnnpyvy0003vhfibywc7045","tag_id":"clfnnpyw00005vhfiaszxhcg1","_id":"clfnnpywf0010vhfi9q8677yt"},{"post_id":"clfnnpyvy0003vhfibywc7045","tag_id":"clfnnpywa000ovhfi0sizblw4","_id":"clfnnpywg0013vhfi5b0iclog"},{"post_id":"clfnnpyvy0003vhfibywc7045","tag_id":"clfnnpywc000svhfihcht3u6q","_id":"clfnnpywh0017vhfi35xndi4n"},{"post_id":"clfnnpyw10007vhfiep8mgw3s","tag_id":"clfnnpywe000xvhfi5a7ea3ac","_id":"clfnnpywi001evhfi3jlxb4mj"},{"post_id":"clfnnpyw10007vhfiep8mgw3s","tag_id":"clfnnpywg0016vhfi3lc29kww","_id":"clfnnpywj001ivhfi363i352z"},{"post_id":"clfnnpyw20009vhfigsjb5xyh","tag_id":"clfnnpywi001cvhfihpjj52m9","_id":"clfnnpywq001qvhfi3ohy8f38"},{"post_id":"clfnnpyw20009vhfigsjb5xyh","tag_id":"clfnnpywg0016vhfi3lc29kww","_id":"clfnnpywr001uvhfibha6ffzs"},{"post_id":"clfnnpyw3000avhfi6jf35wo8","tag_id":"clfnnpywq001ovhfi59s95h3g","_id":"clfnnpyww0028vhfi4e300yks"},{"post_id":"clfnnpyw3000avhfi6jf35wo8","tag_id":"clfnnpywr001vvhfi80hwdvci","_id":"clfnnpyww002bvhfi9bya00f3"},{"post_id":"clfnnpyw3000avhfi6jf35wo8","tag_id":"clfnnpywg0016vhfi3lc29kww","_id":"clfnnpywx002fvhfi8aoh47uh"},{"post_id":"clfnnpyw5000dvhfi3o1p9czu","tag_id":"clfnnpywv0026vhfi988w9i4q","_id":"clfnnpyx2002wvhfiflpf51wp"},{"post_id":"clfnnpyw5000dvhfi3o1p9czu","tag_id":"clfnnpywx002dvhfidheg9gph","_id":"clfnnpyx2002xvhfi0k413tp0"},{"post_id":"clfnnpyw5000dvhfi3o1p9czu","tag_id":"clfnnpywy002kvhfi4xeca7jf","_id":"clfnnpyx30031vhfi6ibwcjgs"},{"post_id":"clfnnpyw5000dvhfi3o1p9czu","tag_id":"clfnnpywg0016vhfi3lc29kww","_id":"clfnnpyx30033vhfi8s1jekuq"},{"post_id":"clfnnpyw6000evhfic6jv0khl","tag_id":"clfnnpyx2002tvhfi8nxk4lhx","_id":"clfnnpyx40037vhfias040a4q"},{"post_id":"clfnnpyw6000evhfic6jv0khl","tag_id":"clfnnpywg0016vhfi3lc29kww","_id":"clfnnpyx40038vhfih9vves3l"},{"post_id":"clfnnpyw8000ivhfi7vqmeols","tag_id":"clfnnpywg0016vhfi3lc29kww","_id":"clfnnpyx5003cvhfi6l0kfn84"},{"post_id":"clfnnpyw9000kvhfi4cq44j7x","tag_id":"clfnnpyx4003avhfid4i11e9d","_id":"clfnnpyx5003gvhfigukk204c"},{"post_id":"clfnnpywa000pvhfia9hy8b2m","tag_id":"clfnnpyx5003evhfi0itx0f5x","_id":"clfnnpyx6003nvhfidpwndf1i"},{"post_id":"clfnnpywa000pvhfia9hy8b2m","tag_id":"clfnnpywg0016vhfi3lc29kww","_id":"clfnnpyx6003pvhfi1s2fhnsa"},{"post_id":"clfnnpywb000qvhfibo0327vj","tag_id":"clfnnpywg0016vhfi3lc29kww","_id":"clfnnpyx8003yvhfi27vc7gpz"},{"post_id":"clfnnpywb000qvhfibo0327vj","tag_id":"clfnnpyx7003qvhfi1iwl3u4f","_id":"clfnnpyx80040vhfi0hqxd8vw"},{"post_id":"clfnnpywb000qvhfibo0327vj","tag_id":"clfnnpyx7003tvhfib8ipb2uc","_id":"clfnnpyx80043vhfifxh85jhl"},{"post_id":"clfnnpywc000tvhfi59jc5isn","tag_id":"clfnnpywg0016vhfi3lc29kww","_id":"clfnnpyx90047vhfi06e95jem"},{"post_id":"clfnnpywc000tvhfi59jc5isn","tag_id":"clfnnpyx80042vhfi2qt9fd19","_id":"clfnnpyxa0049vhfihvvjh1xr"},{"post_id":"clfnnpywd000vvhfi02xw3aze","tag_id":"clfnnpyx90046vhfi7krg974z","_id":"clfnnpyxb004fvhfif8pob5t6"},{"post_id":"clfnnpywd000vvhfi02xw3aze","tag_id":"clfnnpywg0016vhfi3lc29kww","_id":"clfnnpyxb004ivhfigsrrh69c"},{"post_id":"clfnnpywf000yvhfi26l0a044","tag_id":"clfnnpywg0016vhfi3lc29kww","_id":"clfnnpyxc004ovhfi1kuk00qb"},{"post_id":"clfnnpywf000yvhfi26l0a044","tag_id":"clfnnpyxb004jvhfiews71oyf","_id":"clfnnpyxc004qvhficj3s1b63"},{"post_id":"clfnnpywf0011vhfigddah650","tag_id":"clfnnpywg0016vhfi3lc29kww","_id":"clfnnpyxd004zvhfi5pi8eucv"},{"post_id":"clfnnpywf0011vhfigddah650","tag_id":"clfnnpyxc004rvhfih7p525mw","_id":"clfnnpyxd0050vhfi5cb3f4pu"},{"post_id":"clfnnpywf0011vhfigddah650","tag_id":"clfnnpyxc004uvhficf8ec82s","_id":"clfnnpyxe0052vhfiaz3hfyy9"},{"post_id":"clfnnpywg0014vhfi388t5ulg","tag_id":"clfnnpyxd004xvhfidcdj1enr","_id":"clfnnpyxe0054vhfi70u65aed"},{"post_id":"clfnnpywh0018vhfi498673fj","tag_id":"clfnnpyxd0051vhfi13hwgjla","_id":"clfnnpyxe0059vhfia5ey403i"},{"post_id":"clfnnpywh0018vhfi498673fj","tag_id":"clfnnpyxe0055vhfid2d439ov","_id":"clfnnpyxe005avhfi5w40ekbq"},{"post_id":"clfnnpywh001avhfidh9sebuk","tag_id":"clfnnpyxd0051vhfi13hwgjla","_id":"clfnnpyxf005dvhfi5zve1drx"},{"post_id":"clfnnpywh001avhfidh9sebuk","tag_id":"clfnnpyxe005bvhfi8me24o00","_id":"clfnnpyxf005evhfi30ir9gtc"},{"post_id":"clfnnpywi001dvhfibuy6dcwc","tag_id":"clfnnpyxd0051vhfi13hwgjla","_id":"clfnnpyxf005hvhfiglay8mhv"},{"post_id":"clfnnpywi001dvhfibuy6dcwc","tag_id":"clfnnpyxf005fvhfi8laseltr","_id":"clfnnpyxf005ivhfi1v5i0pi6"},{"post_id":"clfnnpywj001gvhfidz8l31n9","tag_id":"clfnnpyxd0051vhfi13hwgjla","_id":"clfnnpyxf005lvhfi1mz681jn"},{"post_id":"clfnnpywj001gvhfidz8l31n9","tag_id":"clfnnpyxf005jvhfi3uqpbxpi","_id":"clfnnpyxf005mvhfihj3rc4ws"},{"post_id":"clfnnpywk001kvhfie4s4ftj2","tag_id":"clfnnpyxd0051vhfi13hwgjla","_id":"clfnnpyxg005pvhfi6nr96oiz"},{"post_id":"clfnnpywk001kvhfie4s4ftj2","tag_id":"clfnnpyxf005nvhfibu30htsg","_id":"clfnnpyxg005qvhfi47qa06dv"},{"post_id":"clfnnpywl001mvhfictidbahw","tag_id":"clfnnpyxd0051vhfi13hwgjla","_id":"clfnnpyxh005svhfidktp7pab"},{"post_id":"clfnnpywq001pvhfialim1ziq","tag_id":"clfnnpyxg005rvhficzy06804","_id":"clfnnpyxh005uvhfifoty8qvn"},{"post_id":"clfnnpywr001svhfi2tqsaaqn","tag_id":"clfnnpyxg005rvhficzy06804","_id":"clfnnpyxi005xvhfibtzt5vg2"},{"post_id":"clfnnpywr001svhfi2tqsaaqn","tag_id":"clfnnpyxh005vvhfid06w0lkv","_id":"clfnnpyxi005yvhfigu574t3o"},{"post_id":"clfnnpywr001wvhfihes0frke","tag_id":"clfnnpyxg005rvhficzy06804","_id":"clfnnpyxi0061vhfih32s49qg"},{"post_id":"clfnnpywr001wvhfihes0frke","tag_id":"clfnnpyxi005zvhfi7w5rfefz","_id":"clfnnpyxi0062vhfi311ybv0v"},{"post_id":"clfnnpywt001yvhfic0jag0wy","tag_id":"clfnnpyxi0060vhfi9eeifoei","_id":"clfnnpyxj0065vhfi3eb9hpnt"},{"post_id":"clfnnpywt001yvhfic0jag0wy","tag_id":"clfnnpyxi0063vhfi2lnv6dz1","_id":"clfnnpyxj0066vhfi6p14aqzj"},{"post_id":"clfnnpywt0020vhfi9f61glb4","tag_id":"clfnnpyxi0064vhfi3qale1tf","_id":"clfnnpyxj0068vhfi7faog6e4"},{"post_id":"clfnnpywv0023vhfigsehdgp1","tag_id":"clfnnpyxj0067vhfi50n5380g","_id":"clfnnpyxj006avhfif8cyges5"},{"post_id":"clfnnpywv0025vhficq272x04","tag_id":"clfnnpyxj0069vhfi4619cjbz","_id":"clfnnpyxj006cvhfi50tq1oin"},{"post_id":"clfnnpyww0029vhfi6avm4brp","tag_id":"clfnnpyxj006bvhfi7uq61g8t","_id":"clfnnpyxk006ivhfih5e3f4xa"},{"post_id":"clfnnpyww0029vhfi6avm4brp","tag_id":"clfnnpyxj006dvhfi773b47hu","_id":"clfnnpyxk006jvhfihz1k40rm"},{"post_id":"clfnnpyww0029vhfi6avm4brp","tag_id":"clfnnpyxj006evhfi8nt18oiz","_id":"clfnnpyxl006lvhfiaf0f1fmn"},{"post_id":"clfnnpyww0029vhfi6avm4brp","tag_id":"clfnnpyxj006fvhfigqk8b7j6","_id":"clfnnpyxl006mvhfi8qs94xjq"},{"post_id":"clfnnpyww0029vhfi6avm4brp","tag_id":"clfnnpyxk006gvhfi15579h7c","_id":"clfnnpyxl006ovhfi931z4r3e"},{"post_id":"clfnnpyww002cvhfids3pb8to","tag_id":"clfnnpyxk006hvhfif4un295w","_id":"clfnnpyxm006qvhfib99nb1dh"},{"post_id":"clfnnpyww002cvhfids3pb8to","tag_id":"clfnnpyxk006kvhfihlq2ajie","_id":"clfnnpyxm006rvhfi77gfbhmg"},{"post_id":"clfnnpyww002cvhfids3pb8to","tag_id":"clfnnpyxl006nvhfigxfxe89b","_id":"clfnnpyxm006tvhfi3fr564ch"},{"post_id":"clfnnpywx002gvhfi046odndu","tag_id":"clfnnpyxl006pvhfi06ykb0vm","_id":"clfnnpyxm006wvhfi4e6sa283"},{"post_id":"clfnnpywx002gvhfi046odndu","tag_id":"clfnnpyxm006svhfi1dyk9ryc","_id":"clfnnpyxm006xvhfidy8ner1g"},{"post_id":"clfnnpywx002gvhfi046odndu","tag_id":"clfnnpyxm006uvhfi7v7d33lo","_id":"clfnnpyxm006zvhfi87yv0ibp"},{"post_id":"clfnnpywy002ivhfie499e6nm","tag_id":"clfnnpyxm006vvhfic8po5ocp","_id":"clfnnpyxn0071vhfiexss5c97"},{"post_id":"clfnnpywy002ivhfie499e6nm","tag_id":"clfnnpyxm006yvhfia0u7cp37","_id":"clfnnpyxn0072vhfigw3m9nxw"},{"post_id":"clfnnpywz002lvhfi6dc1e20n","tag_id":"clfnnpyxd0051vhfi13hwgjla","_id":"clfnnpyxn0074vhfia20lgn8w"},{"post_id":"clfnnpyx0002nvhfi74rp1t2d","tag_id":"clfnnpyxn0073vhfib0n79eji","_id":"clfnnpyxn0076vhfifbeefl3m"},{"post_id":"clfnnpyx1002svhfifszk6ici","tag_id":"clfnnpyxn0075vhfibbnj2rpl","_id":"clfnnpyxo0079vhfifll8cfi3"},{"post_id":"clfnnpyx1002svhfifszk6ici","tag_id":"clfnnpyxn0077vhfiah3rebja","_id":"clfnnpyxo007avhfieyzpgqg0"},{"post_id":"clfnnpyx1002svhfifszk6ici","tag_id":"clfnnpyxo0078vhfi5vykeuoi","_id":"clfnnpyxo007bvhfi08527lxe"}],"Tag":[{"name":"Linux","_id":"clfnnpyw00005vhfiaszxhcg1"},{"name":"守护进程","_id":"clfnnpyw4000cvhfibh4nfqk3"},{"name":"I/O模型","_id":"clfnnpywa000ovhfi0sizblw4"},{"name":"select/poll/epoll","_id":"clfnnpywc000svhfihcht3u6q"},{"name":"字符串","_id":"clfnnpywe000xvhfi5a7ea3ac"},{"name":"leetcode","_id":"clfnnpywg0016vhfi3lc29kww"},{"name":"数组","_id":"clfnnpywi001cvhfihpjj52m9"},{"name":"树","_id":"clfnnpywq001ovhfi59s95h3g"},{"name":"二叉树","_id":"clfnnpywr001vvhfi80hwdvci"},{"name":"栈","_id":"clfnnpywv0026vhfi988w9i4q"},{"name":"队列","_id":"clfnnpywx002dvhfidheg9gph"},{"name":"堆","_id":"clfnnpywy002kvhfi4xeca7jf"},{"name":"链表","_id":"clfnnpyx2002tvhfi8nxk4lhx"},{"name":"快速排序","_id":"clfnnpyx4003avhfid4i11e9d"},{"name":"二分查找","_id":"clfnnpyx5003evhfi0itx0f5x"},{"name":"深度优先搜索","_id":"clfnnpyx7003qvhfi1iwl3u4f"},{"name":"广度优先搜索","_id":"clfnnpyx7003tvhfib8ipb2uc"},{"name":"二叉搜索树","_id":"clfnnpyx80042vhfi2qt9fd19"},{"name":"贪心","_id":"clfnnpyx90046vhfi7krg974z"},{"name":"动态规划","_id":"clfnnpyxb004jvhfiews71oyf"},{"name":"LRU","_id":"clfnnpyxc004rvhfih7p525mw"},{"name":"缓存","_id":"clfnnpyxc004uvhficf8ec82s"},{"name":"HTTPS","_id":"clfnnpyxd004xvhfidcdj1enr"},{"name":"MySQL","_id":"clfnnpyxd0051vhfi13hwgjla"},{"name":"排序","_id":"clfnnpyxe0055vhfid2d439ov"},{"name":"SQL语句","_id":"clfnnpyxe005bvhfi8me24o00"},{"name":"NoSQL","_id":"clfnnpyxf005fvhfi8laseltr"},{"name":"索引","_id":"clfnnpyxf005jvhfi3uqpbxpi"},{"name":"脏页","_id":"clfnnpyxf005nvhfibu30htsg"},{"name":"Redis","_id":"clfnnpyxg005rvhficzy06804"},{"name":"热点 key","_id":"clfnnpyxh005vvhfid06w0lkv"},{"name":"Redis 集群","_id":"clfnnpyxi005zvhfi7w5rfefz"},{"name":"Session","_id":"clfnnpyxi0060vhfi9eeifoei"},{"name":"Cookie","_id":"clfnnpyxi0063vhfi2lnv6dz1"},{"name":"TCP","_id":"clfnnpyxi0064vhfi3qale1tf"},{"name":"一致性哈希","_id":"clfnnpyxj0067vhfi50n5380g"},{"name":"WebSocket","_id":"clfnnpyxj0069vhfi4619cjbz"},{"name":"消息队列","_id":"clfnnpyxj006bvhfi7uq61g8t"},{"name":"MQ","_id":"clfnnpyxj006dvhfi773b47hu"},{"name":"RabbitMQ","_id":"clfnnpyxj006evhfi8nt18oiz"},{"name":"RocketMQ","_id":"clfnnpyxj006fvhfigqk8b7j6"},{"name":"Kafka","_id":"clfnnpyxk006gvhfi15579h7c"},{"name":"唯一ID","_id":"clfnnpyxk006hvhfif4un295w"},{"name":"snowflake","_id":"clfnnpyxk006kvhfihlq2ajie"},{"name":"leaf","_id":"clfnnpyxl006nvhfigxfxe89b"},{"name":"分布式","_id":"clfnnpyxl006pvhfi06ykb0vm"},{"name":"CAP","_id":"clfnnpyxm006svhfi1dyk9ryc"},{"name":"BASE","_id":"clfnnpyxm006uvhfi7v7d33lo"},{"name":"一致性","_id":"clfnnpyxm006vvhfic8po5ocp"},{"name":"Cache-Aside","_id":"clfnnpyxm006yvhfia0u7cp37"},{"name":"微服务","_id":"clfnnpyxn0073vhfib0n79eji"},{"name":"限流","_id":"clfnnpyxn0075vhfibbnj2rpl"},{"name":"漏桶","_id":"clfnnpyxn0077vhfiah3rebja"},{"name":"令牌桶","_id":"clfnnpyxo0078vhfi5vykeuoi"}]}}